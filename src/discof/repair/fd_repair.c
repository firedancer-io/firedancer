#include "fd_repair.h"
#include "../../ballet/sha256/fd_sha256.h"

void *
fd_repair_new( void * shmem, ulong peer_max ) {

  if( FD_UNLIKELY( !shmem ) ) {
    FD_LOG_WARNING(( "NULL mem" ));
    return NULL;
  }

  if( FD_UNLIKELY( !fd_ulong_is_aligned( (ulong)shmem, fd_repair_align() ) ) ) {
    FD_LOG_WARNING(( "misaligned mem" ));
    return NULL;
  }

  int lg_peer_max = fd_ulong_find_msb( fd_ulong_pow2_up( peer_max ) );

  ulong footprint = fd_repair_footprint( peer_max );
  fd_memset( shmem, 0, footprint );

  FD_SCRATCH_ALLOC_INIT( l, shmem );
  fd_repair_t * repair   = FD_SCRATCH_ALLOC_APPEND( l, fd_repair_align(),          sizeof(fd_repair_t)                         );
  void *        peer_map = FD_SCRATCH_ALLOC_APPEND( l, fd_repair_peer_map_align(), fd_repair_peer_map_footprint( lg_peer_max ) );
  FD_TEST( FD_SCRATCH_ALLOC_FINI( l, fd_repair_align() ) == (ulong)shmem + footprint );

  repair->peer_map = fd_repair_peer_map_new( peer_map, lg_peer_max );

  return shmem;
}

fd_repair_t *
fd_repair_join( void * shrepair ) {
  fd_repair_t * repair = (fd_repair_t *)shrepair;

  if( FD_UNLIKELY( !repair ) ) {
    FD_LOG_WARNING(( "NULL repair" ));
    return NULL;
  }

  if( FD_UNLIKELY( !fd_ulong_is_aligned((ulong)repair, fd_repair_align() ) ) ) {
    FD_LOG_WARNING(( "misaligned repair" ));
    return NULL;
  }

  fd_wksp_t * wksp = fd_wksp_containing( repair );
  if( FD_UNLIKELY( !wksp ) ) {
    FD_LOG_WARNING(( "repair must be part of a workspace" ));
    return NULL;
  }

  repair->peer_map = fd_repair_peer_map_join( repair->peer_map );

  return repair;
}

void *
fd_repair_leave( fd_repair_t const * repair ) {

  if( FD_UNLIKELY( !repair ) ) {
    FD_LOG_WARNING(( "NULL repair" ));
    return NULL;
  }

  return (void *)repair;
}

void *
fd_repair_delete( void * repair ) {

  if( FD_UNLIKELY( !repair ) ) {
    FD_LOG_WARNING(( "NULL repair" ));
    return NULL;
  }

  if( FD_UNLIKELY( !fd_ulong_is_aligned((ulong)repair, fd_repair_align() ) ) ) {
    FD_LOG_WARNING(( "misaligned repair" ));
    return NULL;
  }

  // TODO: zero out mem?

  return repair;
}

fd_repair_pong_t *
fd_repair_pong( fd_repair_t * repair, fd_hash_t * ping_token ) {
  fd_repair_private_pong( &repair->identity_key, ping_token, &repair->pong );
  return &repair->pong;
}

fd_repair_req_t *
fd_repair_shred_req( fd_repair_t * repair,
                     fd_pubkey_t * to,
                     ulong         slot,
                     ulong         shred_idx,
                     uint          nonce ) {
  fd_repair_private_shred_req( &repair->identity_key, to, (ulong)fd_log_wallclock(), nonce, slot, shred_idx, &repair->req );
  return &repair->req;
}

fd_repair_req_t *
fd_repair_highest_shred_req( fd_repair_t * repair,
                             fd_pubkey_t * to,
                             ulong         slot,
                             ulong         shred_idx,
                             uint          nonce ) {
  fd_repair_private_highest_shred_req( &repair->identity_key, to, (ulong)fd_log_wallclock(), nonce, slot, shred_idx, &repair->req );
  return &repair->req;
}

fd_repair_req_t *
fd_repair_orphan_req( fd_repair_t * repair,
                      fd_pubkey_t * to,
                      ulong slot,
                      uint nonce ) {
  fd_repair_private_orphan_req( &repair->identity_key, to, (ulong)fd_log_wallclock(), nonce, slot, &repair->req );
  return &repair->req;
}

void
fd_repair_private_pong( fd_pubkey_t *      from,
                        fd_hash_t *        ping_token,
                        fd_repair_pong_t * pong_out ) {
  pong_out->kind = FD_REPAIR_KIND_PONG;
  pong_out->from = *from;

  /* The Pong hash is generated by concatenating the Ping hash together
     with a prefix and then hashing that.

    The Pong signature is also generated from that concatenation. */

  uchar preimage[ FD_REPAIR_PREIMAGE_SZ ];
  memcpy( preimage,                                FD_REPAIR_PREIMAGE_PREFIX, FD_REPAIR_PREIMAGE_PREFIX_SZ );
  memcpy( preimage + FD_REPAIR_PREIMAGE_PREFIX_SZ, ping_token,                 sizeof(fd_hash_t)            );
  fd_sha256_hash( preimage, FD_REPAIR_PREIMAGE_SZ, pong_out->hash.uc );
}

/* hdr populates the common header of {Shred,HighestShred,Orphan}
   requests. */

void hdr( fd_pubkey_t * from, fd_pubkey_t * to, ulong ts, uint nonce, fd_repair_req_t * req_out ) {
  req_out->from  = *from;
  req_out->to    = *to;
  req_out->ts    = ts;
  req_out->nonce = nonce;
}

void
fd_repair_private_shred_req( fd_pubkey_t *     from,
                             fd_pubkey_t *     to,
                             ulong             ts,
                             uint              nonce,
                             ulong             slot,
                             ulong             shred_idx,
                             fd_repair_req_t * req_out ) {
  hdr( from, to, ts, nonce, req_out );
  req_out->kind = FD_REPAIR_KIND_SHRED_REQ;
  req_out->shred.slot = slot;
  req_out->shred.shred_idx = shred_idx;
}

void
fd_repair_private_highest_shred_req( fd_pubkey_t *     from,
                                     fd_pubkey_t *     to,
                                     ulong             ts,
                                     uint              nonce,
                                     ulong             slot,
                                     ulong             shred_idx,
                                     fd_repair_req_t * req_out ) {
  hdr( from, to, ts, nonce, req_out );
  req_out->kind = FD_REPAIR_KIND_HIGHEST_SHRED_REQ;
  req_out->shred.slot = slot;
  req_out->shred.shred_idx = shred_idx;
}

void
fd_repair_private_orphan_req( fd_pubkey_t *     from,
                              fd_pubkey_t *     to,
                              ulong             ts,
                              uint              nonce,
                              ulong             slot,
                              fd_repair_req_t * req_out ) {
  hdr( from, to, ts, nonce, req_out );
  req_out->kind = FD_REPAIR_KIND_ORPHAN_REQ;
  req_out->shred.slot = slot;
}

static ulong
serialize( uchar * ser, ulong sz, uchar * buf_out ) {
   fd_repair_protocol_t protocol;
   memcpy( &protocol, ser, sz );
   fd_bincode_encode_ctx_t ctx = { .data = buf_out, .dataend = buf_out + sz };
   fd_repair_protocol_encode( &protocol, &ctx );
   return sz;
}

ulong
fd_repair_serialize_pong( fd_repair_pong_t * pong, uchar buf_out[ static sizeof(fd_repair_pong_t) ] ) {
  return serialize( (uchar *)pong, sizeof(fd_repair_pong_t), buf_out );
}

ulong
fd_repair_serialize_req( fd_repair_req_t * req, uchar buf_out[ static sizeof(fd_repair_req_t) ] ) {
  serialize( (uchar *)req, sizeof(fd_repair_req_t), buf_out );
  switch( req->kind ) {
  case FD_REPAIR_KIND_SHRED_REQ:         return sizeof(fd_repair_req_t);
  case FD_REPAIR_KIND_HIGHEST_SHRED_REQ: return sizeof(fd_repair_req_t);
  case FD_REPAIR_KIND_ORPHAN_REQ:        return sizeof(fd_repair_req_t) - sizeof(ulong);
  default: break;
  }
  FD_LOG_ERR( ( "%s: unhandled kind %u", __func__, req->kind ) );
}
