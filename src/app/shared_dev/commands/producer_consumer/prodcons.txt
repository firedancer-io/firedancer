- As a leader we shouldn’t drop too much latency (cuz of debouncing) + coalescing (not calling wake when not needed/no waiters)
- Debouncing is simple (we have a window like 10-100 micro seconds) where we don’t sleep to see if we get anything else to do
- Coalescing is harder — cuz I was thinking the producer can see if the consumer advanced/running (and thus doesn’t need a wake)
    - But they don’t store that state — j on the stack, cuz that be a lot of cache traffic moving that around
    - That’s why the credits system is designed the way it is, during house keeping
    - Can we do this in housekeeping? Might be too slow
    - try and do basically reverse of credits with timestamps or something -- whens the last time a consumer read from us?
        - can we reuse the credits system?
    
    

Producer:
for( int i=0; i<10; i++ ) {
    fd_stem_publish( frag_i );
}
wake();

int consumer() {
    sleep();

    ... frag0 ...
    ... frag1 ...
    ... 


    .....
}

int needs_wake[ out_cnt ]; - > out_cnt is number of links the producer is writing to
// publish_does_not_wake, but it sets needs_wake[ out_idx ] = 1

// debounce (more like coalesce) ... every 200 micros, check needs_wake[ out_idx ] ... if some call wake(), needs_wake[ out_idx ] = 0

// wake( memory_address )
// wait( memory_address, value ) -> if value is not expected, exit immediately

problem is we have many slots in the link dif consumers can be listening to. can we centralize this in 1 place?
