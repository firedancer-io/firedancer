#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <alloca.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include "../../disco/fd_disco.h"
#include "../../disco/tvu/fd_tvu.h"
#include "../../util/fd_util.h"
#include "../../flamenco/fd_flamenco.h"
#include "../../flamenco/nanopb/pb_decode.h"
#include "../../flamenco/runtime/fd_hashes.h"
#include "../../funk/fd_funk.h"
#include "../../flamenco/types/fd_types.h"
#include "../../flamenco/runtime/fd_runtime.h"
#include "../../flamenco/runtime/fd_account.h"
#include "../../flamenco/runtime/fd_rocksdb.h"
#include "../../ballet/base58/fd_base58.h"
#include "../../flamenco/types/fd_solana_block.pb.h"
#include "../../flamenco/runtime/context/fd_capture_ctx.h"
#include "../../flamenco/runtime/fd_snapshot_loader.h"
#include "../../flamenco/runtime/fd_blockstore.h"
#include "../../flamenco/runtime/program/fd_builtin_programs.h"
#include "../../flamenco/shredcap/fd_shredcap.h"
#include "../../flamenco/runtime/program/fd_bpf_program_util.h"

#pragma GCC diagnostic ignored "-Wformat"
#pragma GCC diagnostic ignored "-Wformat-extra-args"

extern void fd_write_builtin_bogus_account( fd_exec_slot_ctx_t * slot_ctx, uchar const pubkey[ static 32 ], char const * data, ulong sz );

static void usage( char const * progname ) {
  fprintf( stderr, "fd_ledger usage: %s\n", progname );
  fprintf( stderr, " --cmd ingest <ingest|prune|minify|replay>       \n" );
  fprintf( stderr, " --wksp-name <workspace name>               workspace name\n" );
  fprintf( stderr, " --page-cnt <page count>                    number of pages for anon wksp\n" );
  fprintf( stderr, " --reset <int>                              reset workspace\n" );
  fprintf( stderr, " --index-max <ulong>                        number of records to index in funk\n" );
  fprintf( stderr, " --txns-max <ulong>                         number of transactions to store in funk\n" );
  fprintf( stderr, " --verify-funky <int>                       verify funky account database integrity\n" );
  fprintf( stderr, " --snapshot <snapshot file>                 snapshot file\n" );
  fprintf( stderr, " --incremental <incremental snapshot file>  incremental snapshot file\n" );
  fprintf( stderr, " --genesis <genesis snapshot file>          genesis snapshot file\n" );
  fprintf( stderr, " --rocksdb <rocksdb directory>              rocksdb directory\n" );
  fprintf( stderr, " --copy-txn-status <int>                    copy transaction status from rocksdb into blockstore\n" );
  fprintf( stderr, " --slot-history <ulong>                     number of slots to keep in blockstore\n" );
  fprintf( stderr, " --shred-max <ulong>                        max shred\n" );
  fprintf( stderr, " --start-slot <ulong>                       start slot\n" );
  fprintf( stderr, " --end-slot <ulong>                         end slot\n" );
  fprintf( stderr, " --verify-hash <hash>                       verify hash\n" );
  fprintf( stderr, " --verify-acc-hash <uint>                   verify account hash against ledger\n" );
  fprintf( stderr, " --check-acc-hash <uint>                    check account hash against hash generated by data\n" );
  fprintf( stderr, " --restore <restore file>                   path to checkpoint to be restored\n" );
  fprintf( stderr, " --shred-cap <shredcap file>                path to shredcap file\n" );
  fprintf( stderr, " --trash-hash <ulong>                       trash hash for invalidation\n" );
  fprintf( stderr, " --minified-rocksdb <mini rocksdb dir>      minified rocksdb directory\n" );
  fprintf( stderr, " --funk-only <int>                          only funk to be used/checkpointed\n" );
  fprintf( stderr, " --checkpt <checkpoint file>                checkpoint wksp into file after execution\n" );
  fprintf( stderr, " --abort-on-mismatch <int>                  abort on mismatch\n" );
  fprintf( stderr, " --index-max-pruned <ulong>                 number of records to index in pruned funk\n" ); /* Prune related */
  fprintf( stderr, " --page-cnt-pruned <ulong>                  number of pages for pruned anon wksp\n" );
  fprintf( stderr, " --on-demand-block-ingest <int>             on demand block ingest\n" ); /* On demand block reading */
  fprintf( stderr, " --on-demand-block-history <ulong>          on demand block history\n" );
  fprintf( stderr, " --capture-solcap <capture file>            capture solcap\n" ); /* Capture context tool for solcaps*/
  fprintf( stderr, " --capture-txns <int>                       capture transactions\n" );
  fprintf( stderr, " --checkpt-path <checkpoint path>           path to checkpoint\n" ); /* Capture context tool for runtime checkpoints */
  fprintf( stderr, " --checkpt-slot <ulong>                     checkpoint slot\n" );
  fprintf( stderr, " --checkpt-freq <ulong>                     checkpoint frequency\n" );
  fprintf( stderr, " --allocator <allocator>                    allocator to use\n" );
  fprintf( stderr, " --dump-insn-to-pb <int>                    dump instructions to pb\n" ); /* Capture ctx tool for insn dumping*/
  fprintf( stderr, " --dump-insn-sig-filter <insn sig filter>   dump instructions signature filter\n" );
  fprintf( stderr, " --dump-insn-output-dir <insn output dir>   dump instructions output directory\n" );
}

struct fd_ledger_args {
  fd_wksp_t *       wksp;
  fd_blockstore_t * blockstore;
  fd_funk_t *       funk;
  fd_alloc_t *      alloc;
  char const *      cmd;
  ulong             start_slot;
  ulong             end_slot;
  uint              hashseed;
  char const *      rocksdb_dir;
  char const *      checkpt;
  char const *      restore;
  char const *      allocator;
  ulong             shred_max;
  ulong             slot_history_max;
  ulong             txns_max;
  ulong             index_max;
  char const *      snapshot;
  char const *      incremental;
  char const *      genesis;
  char const *      mini_db_dir;
  int               copy_txn_status;
  int               funk_only;
  char const *      shredcap;
  ulong             pages_pruned;
  ulong             index_max_pruned;
  int               abort_on_mismatch;
  int               on_demand_block_ingest;
  char const *      capture_fpath; /* solcap */
  int               capture_txns;
  char const *      checkpt_path; /* runtime checkpoints */
  ulong             checkpt_slot;
  ulong             checkpt_freq;
  ulong             on_demand_block_history;
  int               dump_insn_to_pb;
  char const *      dump_insn_sig_filter;
  char const *      dump_insn_output_dir;
  int               verify_funk;
  uint              verify_acc_hash;
  uint              check_acc_hash;
  char const *      verify_hash;
  ulong             trash_hash;
  ulong             vote_acct_max;
  #ifdef _ENABLE_LTHASH
  char const *      lthash;
  #endif

};
typedef struct fd_ledger_args fd_ledger_args_t;

int
runtime_replay( fd_runtime_ctx_t * state, fd_runtime_args_t * args ) {
  args->tcnt = fd_tile_cnt();
  uchar * tpool_scr_mem = NULL;
  fd_tpool_t * tpool = NULL;
  if( args->tcnt > 1 ) {
    tpool = fd_tpool_init( state->tpool_mem, args->tcnt );
    if( tpool == NULL ) {
      FD_LOG_ERR(( "failed to create thread pool" ));
    }
    ulong scratch_sz = fd_scratch_smem_footprint( 256UL<<20UL );
    tpool_scr_mem = fd_valloc_malloc( state->slot_ctx->valloc, FD_SCRATCH_SMEM_ALIGN, scratch_sz*(args->tcnt - 1U) );
    if( tpool_scr_mem == NULL ) {
      FD_LOG_ERR( ( "failed to allocate thread pool scratch space" ) );
    }
    for( ulong i = 1; i < args->tcnt; ++i ) {
      if( fd_tpool_worker_push( tpool, i, tpool_scr_mem + scratch_sz*(i - 1U), scratch_sz ) == NULL ) {
        FD_LOG_ERR(( "failed to launch worker" ));
      }
      else {
        FD_LOG_NOTICE(( "launched worker" ));
      }
    }
  }
  state->tpool       = tpool;
  state->max_workers = args->tcnt;

  ulong r = fd_funk_txn_cancel_all( state->slot_ctx->acc_mgr->funk, 1 );
  FD_LOG_INFO( ( "Cancelled old transactions %lu", r ) );

  fd_features_restore( state->slot_ctx );

  if( state->slot_ctx->blockstore->max < args->end_slot && !args->on_demand_block_ingest ) {
    args->end_slot = state->slot_ctx->blockstore->max;
  }

  fd_runtime_update_leaders( state->slot_ctx, state->slot_ctx->slot_bank.slot );

  fd_calculate_epoch_accounts_hash_values( state->slot_ctx );

  long              replay_time = -fd_log_wallclock();
  ulong             txn_cnt     = 0;
  ulong             slot_cnt    = 0;
  fd_blockstore_t * blockstore  = state->slot_ctx->blockstore;

  ulong prev_slot = state->slot_ctx->slot_bank.slot;

  ulong start_slot = state->slot_ctx->slot_bank.slot + 1;

  /* On demand rocksdb ingest */
  fd_rocksdb_t rocks_db = {0};
  fd_rocksdb_root_iter_t iter = {0};
  fd_slot_meta_t slot_meta = {0};
  if( args->on_demand_block_ingest ) {
    fd_rocksdb_init( &rocks_db, args->rocksdb_dir );
    fd_rocksdb_root_iter_new( &iter );
    if( fd_rocksdb_root_iter_seek( &iter, &rocks_db, start_slot, &slot_meta, state->slot_ctx->valloc ) ) {
      FD_LOG_ERR(( "unable to seek to first slot" ));
    }
  }

  if( state->capture_ctx && state->capture_ctx->pruned_funk != NULL ) {
    fd_funk_t * funk = state->slot_ctx->acc_mgr->funk;
    fd_wksp_t * wksp = fd_funk_wksp( funk );
    fd_funk_partvec_t * partvec = fd_funk_get_partvec( funk, wksp );
    fd_funk_t * pruned_funk = state->capture_ctx->pruned_funk;
    fd_funk_set_num_partitions( pruned_funk, partvec->num_part );
  }

  /* Setup trash_hash */
  uchar trash_hash_buf[32];
  memset( trash_hash_buf, 0xFE, sizeof(trash_hash_buf) );

  for( ulong slot = start_slot; slot <= args->end_slot; ++slot ) {
    state->slot_ctx->slot_bank.prev_slot = prev_slot;
    state->slot_ctx->slot_bank.slot      = slot;

    FD_LOG_DEBUG(( "reading slot %ld", slot ));

    if( state->capture_ctx && state->capture_ctx->pruned_funk != NULL ) {
      fd_runtime_collect_rent_accounts_prune( slot, state->slot_ctx, state->capture_ctx );
    }

    if( args->on_demand_block_ingest ) {
      if( fd_blockstore_block_query( blockstore, slot ) == NULL && slot_meta.slot == slot ) {
        int err = fd_rocksdb_import_block_blockstore( &rocks_db, &slot_meta, blockstore, 
                                                      args->copy_txn_status, slot == (args->trash_hash) ? trash_hash_buf : NULL );
        if( FD_UNLIKELY( err ) ) {
          FD_LOG_ERR(( "Failed to import block %lu", start_slot ));
        }
      }
      fd_blockstore_slot_remove( blockstore, slot - args->on_demand_block_history );
    }

    fd_blockstore_start_read( blockstore );
    fd_block_t * blk = fd_blockstore_block_query( blockstore, slot );
    if( blk == NULL ) {
      FD_LOG_WARNING( ( "failed to read slot %ld", slot ) );
      fd_blockstore_end_read( blockstore );
      continue;
    }

    uchar * val = fd_blockstore_block_data_laddr( blockstore, blk );
    ulong   sz  = blk->data_sz;
    fd_blockstore_end_read( blockstore );

    ulong blk_txn_cnt = 0;
    FD_TEST( fd_runtime_block_eval_tpool( state->slot_ctx,
                                          state->capture_ctx,
                                          val,
                                          sz,
                                          state->tpool,
                                          state->max_workers,
                                          1,
                                          &blk_txn_cnt ) == FD_RUNTIME_EXECUTE_SUCCESS );
    txn_cnt += blk_txn_cnt;
    slot_cnt++;

    fd_blockstore_start_read( blockstore );
    fd_hash_t const * expected = fd_blockstore_block_hash_query( blockstore, slot );
    if( FD_UNLIKELY( !expected ) ) FD_LOG_ERR( ( "slot %lu is missing its hash", slot ) );
    else if( FD_UNLIKELY( 0 != memcmp( state->slot_ctx->slot_bank.poh.hash, expected->hash, 32UL ) ) ) {
      FD_LOG_WARNING(( "PoH hash mismatch! slot=%lu expected=%32J, got=%32J",
                        slot,
                        expected->hash,
                        state->slot_ctx->slot_bank.poh.hash ));
      if( state->abort_on_mismatch ) {
        fd_blockstore_end_read( blockstore );
        return 1;
      }
    }

    expected = fd_blockstore_bank_hash_query( blockstore, slot );
    if( FD_UNLIKELY( !expected ) ) {
      FD_LOG_ERR(( "slot %lu is missing its bank hash", slot ));
    } else if( FD_UNLIKELY( 0 != memcmp( state->slot_ctx->slot_bank.banks_hash.hash,
                                         expected->hash,
                                         32UL ) ) ) {
      FD_LOG_WARNING(( "Bank hash mismatch! slot=%lu expected=%32J, got=%32J",
                        slot,
                        expected->hash,
                        state->slot_ctx->slot_bank.banks_hash.hash ));
      if( state->abort_on_mismatch ) {
        fd_blockstore_end_read( blockstore );
        return 1;
      }
    }
    fd_blockstore_end_read( blockstore );

    prev_slot = slot;

    if( args->on_demand_block_ingest && slot < args->end_slot ) {
      int ret = fd_rocksdb_root_iter_next( &iter, &slot_meta, state->slot_ctx->valloc );
      if( ret < 0 ) {
        ret = fd_rocksdb_get_meta( &rocks_db, slot + 1, &slot_meta, state->slot_ctx->valloc );
        if( ret < 0 ) {
          FD_LOG_ERR(( "Failed to get meta for slot %lu", slot + 1 ));
        }
      }
    }
  }

  if( state->tpool ) {
    fd_tpool_fini( state->tpool );
  }

  if( tpool_scr_mem ) {
    fd_valloc_free( state->slot_ctx->valloc, tpool_scr_mem );
  }

  replay_time += fd_log_wallclock();
  double replay_time_s = (double)replay_time * 1e-9;
  double tps           = (double)txn_cnt / replay_time_s;
  double sec_per_slot  = replay_time_s / (double)slot_cnt;
  FD_LOG_NOTICE((
        "replay completed - slots: %lu, elapsed: %6.6f s, txns: %lu, tps: %6.6f, sec/slot: %6.6f",
        slot_cnt,
        replay_time_s,
        txn_cnt,
        tps,
        sec_per_slot ));

  return 0;
}

void
ingest_rocksdb( fd_alloc_t *      alloc,
                char const *      file,
                ulong             start_slot,
                ulong             end_slot,
                fd_blockstore_t * blockstore,
                int txn_status,
                ulong trash_hash ) {

  fd_valloc_t valloc = fd_alloc_virtual( alloc );
  fd_rocksdb_t rocks_db;
  char *err = fd_rocksdb_init( &rocks_db, file );
  if( err != NULL ) {
    FD_LOG_ERR(( "fd_rocksdb_init returned %s", err ));
  }

  ulong last_slot = fd_rocksdb_last_slot( &rocks_db, &err );
  if( err != NULL ) {
    FD_LOG_ERR(( "fd_rocksdb_last_slot returned %s", err ));
  }

  if( last_slot < start_slot ) {
    FD_LOG_ERR(( "rocksdb blocks are older than snapshot. first=%lu last=%lu wanted=%lu",
                 fd_rocksdb_first_slot(&rocks_db, &err), last_slot, start_slot ));
  }

  FD_LOG_NOTICE(( "ingesting rocksdb from start=%lu to end=%lu", start_slot, end_slot ));

  fd_rocksdb_root_iter_t iter;
  fd_rocksdb_root_iter_new( &iter );

  fd_slot_meta_t slot_meta;
  fd_memset( &slot_meta, 0, sizeof(slot_meta) );

  int ret = fd_rocksdb_root_iter_seek( &iter, &rocks_db, start_slot, &slot_meta, valloc );
  if( ret < 0 ) {
    FD_LOG_ERR(( "fd_rocksdb_root_iter_seek returned %d", ret ));
  }

  uchar trash_hash_buf[32];
  memset( trash_hash_buf, 0xFE, sizeof(trash_hash_buf) );

  ulong blk_cnt = 0;
  do {
    ulong slot = slot_meta.slot;
    if( slot > end_slot ) {
      break;
    }

    /* Read and deshred block from RocksDB */
    if( blk_cnt % 100 == 0 ) {
      FD_LOG_WARNING(( "imported %lu blocks", blk_cnt ));
    }

    int err = fd_rocksdb_import_block_blockstore( &rocks_db, &slot_meta, blockstore, txn_status,
                                                  (slot == trash_hash) ? trash_hash_buf : NULL );
    if( FD_UNLIKELY( err ) ) {
      FD_LOG_ERR(( "fd_rocksdb_get_block failed" ));
    }

    ++blk_cnt;

    fd_bincode_destroy_ctx_t ctx = { .valloc = valloc };
    fd_slot_meta_destroy( &slot_meta, &ctx );

    ret = fd_rocksdb_root_iter_next( &iter, &slot_meta, valloc );
    if( ret < 0 ) {
      // FD_LOG_WARNING(("Failed for slot %lu", slot + 1));
      ret = fd_rocksdb_get_meta( &rocks_db, slot + 1, &slot_meta, valloc );
      if( ret < 0 ) {
        break;
      }
    }
      // FD_LOG_ERR(("fd_rocksdb_root_iter_seek returned %d", ret));
  } while (1);

  fd_rocksdb_root_iter_destroy( &iter );
  fd_rocksdb_destroy( &rocks_db );

  FD_LOG_NOTICE(( "ingested %lu blocks", blk_cnt ));
}

void
init_scratch( fd_wksp_t * wksp ) {
  #define FD_SCRATCH_TAG (421UL)
  ulong  smax   = 1024UL /*MiB*/ << 21;
  ulong  sdepth = 128;   /* 128 scratch frames */
  void * smem   = fd_wksp_alloc_laddr( wksp, fd_scratch_smem_align(), fd_scratch_smem_footprint( smax   ), FD_SCRATCH_TAG );
  void * fmem   = fd_wksp_alloc_laddr( wksp, fd_scratch_fmem_align(), fd_scratch_fmem_footprint( sdepth ), FD_SCRATCH_TAG );
  #undef FD_SCRATCH_TAG
  FD_TEST( (!!smem) & (!!fmem) );
  fd_scratch_attach( smem, fmem, smax, sdepth );
}

void
cleanup_scratch( void ) {
  void * fmem = NULL;
  void * smem = fd_scratch_detach( &fmem );
  fd_wksp_free_laddr( smem );
  fd_wksp_free_laddr( fmem );
}

void
init_funk( fd_ledger_args_t * args ) {
  fd_wksp_t * wksp = args->wksp;
  void * shmem;
  fd_wksp_tag_query_info_t info;
  ulong tag = FD_FUNK_MAGIC;
  fd_funk_t * funk;
  if( fd_wksp_tag_query( wksp, &tag, 1, &info, 1 ) > 0 ) {
    shmem = fd_wksp_laddr_fast( wksp, info.gaddr_lo );
    funk = fd_funk_join( shmem );
    if( funk == NULL ) {
      FD_LOG_ERR(( "failed to join a funky" ));
    }
    if( args->verify_funk ) {
      if ( fd_funk_verify( funk ) ) {
        FD_LOG_ERR(( "verification failed" ));
      }
    }
  } else {
    shmem = fd_wksp_alloc_laddr( wksp, fd_funk_align(), fd_funk_footprint(), FD_FUNK_MAGIC );
    if ( shmem == NULL ) {
      FD_LOG_ERR(( "failed to allocate a funky" ));
    }
    funk = fd_funk_join( fd_funk_new( shmem, 1, args->hashseed, args->txns_max, args->index_max ) );

    if ( funk == NULL ) {
      fd_wksp_free_laddr( shmem );
      FD_LOG_ERR(( "failed to allocate a funky" ));
    }
  }
  FD_LOG_NOTICE(( "funky at global address 0x%016lx", fd_wksp_gaddr_fast( wksp, shmem ) ));
  args->funk = funk;
}

void
init_blockstore( fd_ledger_args_t * args ) {
  fd_wksp_tag_query_info_t info;
  ulong blockstore_tag = FD_BLOCKSTORE_MAGIC;
  void * shmem;
  if( fd_wksp_tag_query( args->wksp, &blockstore_tag, 1, &info, 1 ) > 0 ) {
    shmem = fd_wksp_laddr_fast( args->wksp, info.gaddr_lo );
    args->blockstore = fd_blockstore_join( shmem );
    if( args->blockstore == NULL ) {
      FD_LOG_ERR(( "failed to join a blockstore" ));
    }
    FD_LOG_NOTICE(( "joined blockstore" ));
  } else {
    shmem = fd_wksp_alloc_laddr( args->wksp, fd_blockstore_align(), fd_blockstore_footprint(), blockstore_tag );
    if( shmem == NULL ) {
      FD_LOG_ERR(( "failed to allocate a blockstore" ));
    }
    int lg_txn_max = 22;
    args->blockstore = fd_blockstore_join( fd_blockstore_new( shmem, 1, args->hashseed, args->shred_max,
                                                              args->slot_history_max, lg_txn_max ) );
    if( args->blockstore == NULL ) {
      fd_wksp_free_laddr( shmem );
      FD_LOG_ERR(( "failed to allocate a blockstore" ));
    }
    FD_LOG_NOTICE(( "allocating a new blockstore" ));
  }
}

void
checkpt( fd_ledger_args_t * args, fd_exec_slot_ctx_t * slot_ctx ) {
  if( !args->checkpt ) {
    FD_LOG_WARNING(( "No backup argument specified" ));
  }
  if( args->funk ) {
    /* Copy the entire workspace into a file in the most naive way */
    fd_funk_start_write( args->funk );
    FD_TEST( FD_RUNTIME_EXECUTE_SUCCESS == fd_runtime_save_epoch_bank( slot_ctx ) );
    FD_TEST( FD_RUNTIME_EXECUTE_SUCCESS == fd_runtime_save_slot_bank( slot_ctx ) );
    fd_funk_end_write( args->funk );
  }

  /* Remove the blockstore from the workspace if no blockstore was ingested */
  if( args->funk_only ) {
    ulong blockstore_tag = FD_BLOCKSTORE_MAGIC;
    fd_wksp_tag_free( args->wksp, &blockstore_tag, 1 );
    FD_LOG_NOTICE(( "removing existing blockstore" ));
  }

  FD_LOG_NOTICE(( "writing %s", args->checkpt ));
  unlink( args->checkpt );
  int err = fd_wksp_checkpt( args->wksp, args->checkpt, 0666, 0, NULL );
  if( err ) {
    FD_LOG_ERR(( "backup failed: error %d", err ));
  }
}

void
minify( fd_ledger_args_t * args ) {
    /* Example commmand:
    fd_ledger --cmd minify --rocksdb <LARGE_ROCKSDB> --minified-rocksdb <MINI_ROCKSDB>
              --start-slot <START_SLOT> --end-slot <END_SLOT> --copy-txn-status 1
  */

  fd_rocksdb_t big_rocksdb;
  char *err = fd_rocksdb_init( &big_rocksdb, args->rocksdb_dir );
  if( err != NULL ) {
    FD_LOG_ERR(( "fd_rocksdb_init at path=%s returned error=%s", args->rocksdb_dir, err ));
  }

  /* If the directory for the minified rocksdb already exists, error out */
  struct stat statbuf;
  if( stat( args->mini_db_dir, &statbuf ) == 0 ) {
    FD_LOG_ERR(( "path for mini_db_dir=%s already exists", args->mini_db_dir ));
  }

  /* Create a new smaller rocksdb */
  fd_rocksdb_t mini_rocksdb;
  fd_rocksdb_new( &mini_rocksdb, args->mini_db_dir );

  /* Correctly bound off start and end slot */
  ulong first_slot = fd_rocksdb_first_slot( &big_rocksdb, &err );
  ulong last_slot  = fd_rocksdb_last_slot( &big_rocksdb, &err );
  if( args->start_slot < first_slot ) { args->start_slot = first_slot; }
  if( args->end_slot > last_slot )    { args->end_slot = last_slot; }

  FD_LOG_NOTICE(( "copying over rocks db for range [%lu, %lu]", args->start_slot, args->end_slot ));

  /* Copy over all slot indexed columns */
  for( ulong cf_idx = 1; cf_idx < FD_ROCKSDB_CF_CNT; ++cf_idx ) {
    fd_rocksdb_copy_over_slot_indexed_range( &big_rocksdb, &mini_rocksdb, cf_idx,
                                              args->start_slot, args->end_slot );
  }
  FD_LOG_NOTICE(("copied over all slot indexed columns"));

  /* Copy over transactions. This is more complicated because first, a temporary
      blockstore will be populated. This will be used to look up transactions
      which can be quickly queried */
  if( args->copy_txn_status ) {
    init_blockstore( args );
    /* Ingest block range into blockstore */
    ingest_rocksdb( args->alloc, args->rocksdb_dir, args->start_slot,
                    args->end_slot, args->blockstore, 0, ULONG_MAX );

    fd_rocksdb_copy_over_txn_status_range( &big_rocksdb, &mini_rocksdb, args->blockstore,
                                           args->start_slot, args->end_slot );
    FD_LOG_NOTICE(( "copied over all transaction statuses" ));
  } else {
    FD_LOG_NOTICE(( "skipping copying of transaction statuses" ));
  }

  /* TODO: Currently, the address signatures column family isn't copied as it
            is indexed on the pubkey */
}

void
ingest( fd_ledger_args_t * args ) {
  /* Setup funk, blockstore, epoch_ctx, and slot_ctx */
  init_funk( args );
  init_blockstore( args );
  fd_wksp_t * wksp = args->wksp;
  fd_funk_t * funk = args->funk;

  fd_alloc_t * alloc = fd_alloc_join( fd_wksp_laddr_fast( wksp, funk->alloc_gaddr ), 0UL );
  if( FD_UNLIKELY( !alloc ) ) FD_LOG_ERR(( "fd_alloc_join(gaddr=%#lx) failed", funk->alloc_gaddr ));

  uchar * epoch_ctx_mem = fd_wksp_alloc_laddr( wksp, fd_exec_epoch_ctx_align(), fd_exec_epoch_ctx_footprint( args->vote_acct_max ), FD_EXEC_EPOCH_CTX_MAGIC );
  fd_exec_epoch_ctx_t * epoch_ctx = fd_exec_epoch_ctx_join( fd_exec_epoch_ctx_new( epoch_ctx_mem, args->vote_acct_max ) );

  uchar slot_ctx_mem[FD_EXEC_SLOT_CTX_FOOTPRINT] __attribute__((aligned(FD_EXEC_SLOT_CTX_ALIGN)));
  fd_exec_slot_ctx_t * slot_ctx = fd_exec_slot_ctx_join( fd_exec_slot_ctx_new( slot_ctx_mem, fd_alloc_virtual( alloc ) ) );
  slot_ctx->epoch_ctx = epoch_ctx;

  fd_acc_mgr_t mgr[1];
  slot_ctx->acc_mgr = fd_acc_mgr_new( mgr, funk );
  slot_ctx->blockstore = args->blockstore;

  /* Load in snapshot(s) */
  if( args->snapshot ) {
    fd_snapshot_load( args->snapshot, slot_ctx, args->verify_acc_hash, args->check_acc_hash , FD_SNAPSHOT_TYPE_FULL );
    FD_LOG_NOTICE(( "imported %lu records from snapshot", fd_funk_rec_cnt( fd_funk_rec_map( funk, wksp ) ) ));
  }
  if( args->incremental ) {
    fd_snapshot_load( args->incremental, slot_ctx, args->verify_acc_hash, args->check_acc_hash, FD_SNAPSHOT_TYPE_INCREMENTAL );
    FD_LOG_NOTICE(( "imported %lu records from snapshot", fd_funk_rec_cnt( fd_funk_rec_map( funk, wksp ) ) ));
  }

  if( args->genesis ) {
    struct stat sbuf;
    if( FD_UNLIKELY( stat( args->genesis, &sbuf ) < 0 ) ) {
      FD_LOG_ERR(( "cannot open %s : %s", args->genesis, strerror(errno) ));
    }
    int fd = open( args->genesis, O_RDONLY );
    if( FD_UNLIKELY( fd < 0 ) ) {
      FD_LOG_ERR(( "cannot open %s : %s", args->genesis, strerror(errno) ));
    }
    uchar * buf = malloc( (ulong) sbuf.st_size );  /* TODO: Make this a scratch alloc */
    ssize_t n = read( fd, buf, (ulong) sbuf.st_size );
    close( fd );

    fd_genesis_solana_t genesis_block;
    fd_genesis_solana_new( &genesis_block );
    fd_bincode_decode_ctx_t ctx = {
      .data = buf,
      .dataend = buf + n,
      .valloc  = slot_ctx->valloc
    };
    if( fd_genesis_solana_decode( &genesis_block, &ctx ) ) {
      FD_LOG_ERR(( "fd_genesis_solana_decode failed" ));
    }

    // The hash is generated from the raw data... don't mess with this..
    fd_hash_t genesis_hash;
    fd_sha256_hash( buf, (ulong)n, genesis_hash.uc );
    FD_LOG_NOTICE(( "Genesis Hash: %32J", &genesis_hash ));
    fd_epoch_bank_t * epoch_bank = fd_exec_epoch_ctx_epoch_bank( slot_ctx->epoch_ctx );
    fd_memcpy( epoch_bank->genesis_hash.uc, genesis_hash.uc, 32U );
    epoch_bank->cluster_type = genesis_block.cluster_type;

    free( buf );

    fd_funk_start_write( funk );

    /* If we are loading from a snapshot, do not overwrite from genesis */
    if ( !args->snapshot ) {
      fd_runtime_init_bank_from_genesis( slot_ctx, &genesis_block, &genesis_hash );

      fd_runtime_init_program( slot_ctx );

      FD_LOG_DEBUG(( "start genesis accounts - count: %lu", genesis_block.accounts_len ));

      for( ulong i=0; i < genesis_block.accounts_len; i++ ) {
        fd_pubkey_account_pair_t * a = &genesis_block.accounts[i];

        FD_BORROWED_ACCOUNT_DECL(rec);

        int err = fd_acc_mgr_modify(
          slot_ctx->acc_mgr,
          slot_ctx->funk_txn,
          &a->key,
          /* do_create */ 1,
          a->account.data_len,
          rec);
        if( FD_UNLIKELY( err ) )
          FD_LOG_ERR(( "fd_acc_mgr_modify failed (%d)", err ));

        rec->meta->dlen            = a->account.data_len;
        rec->meta->info.lamports   = a->account.lamports;
        rec->meta->info.rent_epoch = a->account.rent_epoch;
        rec->meta->info.executable = !!a->account.executable;
        memcpy( rec->meta->info.owner, a->account.owner.key, 32UL );
        if( a->account.data_len ) {
          memcpy( rec->data, a->account.data, a->account.data_len );
        }
      }

      FD_LOG_DEBUG(( "end genesis accounts"));

      FD_LOG_DEBUG(( "native instruction processors - count: %lu", genesis_block.native_instruction_processors_len));

      for( ulong i=0; i < genesis_block.native_instruction_processors_len; i++ ) {
        fd_string_pubkey_pair_t * a = &genesis_block.native_instruction_processors[i];
        fd_write_builtin_bogus_account( slot_ctx, a->pubkey.uc, a->string, strlen(a->string) );
      }

      /* Sort and update bank hash */
      int result = fd_update_hash_bank( slot_ctx, NULL, &slot_ctx->slot_bank.banks_hash, slot_ctx->signature_cnt );
      if( result != FD_EXECUTOR_INSTR_SUCCESS ) {
        FD_LOG_ERR(( "unable to update hash bank" ));
      }

      slot_ctx->slot_bank.slot = 0UL;
    }

    FD_TEST( FD_RUNTIME_EXECUTE_SUCCESS == fd_runtime_save_epoch_bank( slot_ctx ) );

    FD_TEST( FD_RUNTIME_EXECUTE_SUCCESS == fd_runtime_save_slot_bank( slot_ctx ) );

    fd_funk_end_write( funk );

    fd_bincode_destroy_ctx_t ctx2 = { .valloc = slot_ctx->valloc };
    fd_genesis_solana_destroy( &genesis_block, &ctx2 );
  }

  /* At this point the account state has been ingested into funk. Intake rocksdb */
  if( args->start_slot == 0 ) {
    args->start_slot = slot_ctx->slot_bank.slot;
  }

  fd_blockstore_t * blockstore = args->blockstore;
  if( args->funk_only ) {
    FD_LOG_NOTICE(( "using funk only, skipping blockstore ingest" ));
  } else if( args->shredcap ) {
    FD_LOG_NOTICE(( "using shredcap" ));
    fd_shredcap_populate_blockstore( args->shredcap, blockstore, args->start_slot, args->end_slot );
  } else if( args->rocksdb_dir ) {
    if ( args->end_slot >= slot_ctx->slot_bank.slot + args->slot_history_max ) {
      args->end_slot = slot_ctx->slot_bank.slot + args->slot_history_max - 1;
    }
    ingest_rocksdb( args->alloc, args->rocksdb_dir, args->start_slot, args->end_slot,
                    blockstore, args->copy_txn_status, args->trash_hash );
  }

  /* Verification */
  for( fd_feature_id_t const * id = fd_feature_iter_init();
                                    !fd_feature_iter_done( id );
                                id = fd_feature_iter_next( id ) ) {
    ulong activated_at = fd_features_get( &slot_ctx->epoch_ctx->features, id );
    if( activated_at ) {
      FD_LOG_DEBUG(( "feature %32J activated at slot %lu", id->id.key, activated_at ));
    }
  }

  if( args->verify_funk ) {
    FD_LOG_NOTICE(( "verifying funky" ));
    if( fd_funk_verify( funk ) ) {
      FD_LOG_ERR(( "verification failed" ));
    }
  }

  #ifdef _ENABLE_LTHASH
    if( (NULL != args->lthash) && ( strcmp( args->lthash, "true" ) == 0) ) {
      fd_accounts_init_lthash( slot_ctx );
      fd_accounts_check_lthash( slot_ctx );
    }
  #endif

  if( args->verify_hash ) {
    fd_funk_rec_t * rec_map  = fd_funk_rec_map( funk, wksp );
    ulong num_iter_accounts = fd_funk_rec_map_key_cnt( rec_map );

    FD_LOG_NOTICE(( "verifying hash for %lu accounts", num_iter_accounts ));

    ulong zero_accounts = 0;
    ulong num_pairs = 0;
    fd_pubkey_hash_pair_t * pairs = (fd_pubkey_hash_pair_t *) malloc( num_iter_accounts*sizeof(fd_pubkey_hash_pair_t) );
    for( fd_funk_rec_map_iter_t iter = fd_funk_rec_map_iter_init( rec_map );
         !fd_funk_rec_map_iter_done( rec_map, iter );
         iter = fd_funk_rec_map_iter_next( rec_map, iter ) ) {
      fd_funk_rec_t * rec = fd_funk_rec_map_iter_ele( rec_map, iter );
      if ( !fd_funk_key_is_acc( rec->pair.key ) ) {
        continue;
      }

      if( num_pairs % 10000000 == 0 ) {
        FD_LOG_NOTICE(( "read %lu so far", num_pairs ));
      }

      fd_account_meta_t * metadata = (fd_account_meta_t *) fd_funk_val_const( rec, wksp );
      if( (metadata->magic != FD_ACCOUNT_META_MAGIC) || (metadata->hlen != sizeof(fd_account_meta_t)) ) {
        FD_LOG_ERR(( "invalid magic on metadata" ));
      }

      if( (metadata->info.lamports == 0) | ((metadata->info.executable & ~1) != 0) ) {
        zero_accounts++;
        continue;
      }

      fd_hash_t acc_hash;
      if( fd_hash_account_v0( acc_hash.uc, metadata, rec->pair.key->uc, fd_account_get_data( metadata ), metadata->slot )==NULL ) {
        FD_LOG_ERR(("error processing account hash"));
      }

      if( memcmp( acc_hash.uc, metadata->hash, 32 ) != 0 ) {
        FD_LOG_ERR(("account hash mismatch - num_pairs: %lu, slot: %lu, acc: %32J, acc_hash: %32J, snap_hash: %32J", num_pairs, slot_ctx->slot_bank.slot, rec->pair.key->uc, acc_hash.uc, metadata->hash));
      }

      pairs[num_pairs].pubkey = (const fd_pubkey_t *)rec->pair.key->uc;
      pairs[num_pairs].hash = (const fd_hash_t *)metadata->hash;
      num_pairs++;
    }
    FD_LOG_NOTICE(( "num_iter_accounts: %ld zero_accounts: %lu", num_iter_accounts, zero_accounts ));

    fd_hash_t accounts_hash;
    fd_hash_account_deltas( pairs, num_pairs, &accounts_hash, slot_ctx );

    free( pairs );

    char accounts_hash_58[FD_BASE58_ENCODED_32_SZ];
    fd_base58_encode_32( (uchar const *)accounts_hash.hash, NULL, accounts_hash_58 );

    FD_LOG_NOTICE(( "hash result %s", accounts_hash_58 ));
    if( strcmp( args->verify_hash, accounts_hash_58 ) == 0 ) {
      FD_LOG_NOTICE(( "hash verified!" ));
    } else {
      FD_LOG_ERR(( "hash does not match!" ));
    }
  }

  cleanup_scratch();
  checkpt( args, slot_ctx );
}

void
prune( fd_ledger_args_t * args ) {
  // TODO: update to have the option to take in a checkpoint
  /* Unpruned setup */
  init_funk( args );
  init_blockstore( args );
  fd_wksp_t * unpruned_wksp             = args->wksp;
  fd_funk_t * unpruned_funk             = args->funk;
  fd_blockstore_t * unpruned_blockstore = args->blockstore;

  uchar * epoch_ctx_mem_unpruned = fd_wksp_alloc_laddr( unpruned_wksp, fd_exec_epoch_ctx_align(), fd_exec_epoch_ctx_footprint( args->vote_acct_max ), FD_EXEC_EPOCH_CTX_MAGIC );
  fd_exec_epoch_ctx_t * epoch_ctx_unpruned = fd_exec_epoch_ctx_join( fd_exec_epoch_ctx_new( epoch_ctx_mem_unpruned, args->vote_acct_max ) );

  uchar slot_ctx_mem_unpruned[FD_EXEC_SLOT_CTX_FOOTPRINT] __attribute__((aligned(FD_EXEC_SLOT_CTX_ALIGN)));
  fd_exec_slot_ctx_t * slot_ctx_unpruned = fd_exec_slot_ctx_join( fd_exec_slot_ctx_new( slot_ctx_mem_unpruned, fd_alloc_virtual( args->alloc ) ) );
  slot_ctx_unpruned->epoch_ctx = epoch_ctx_unpruned;
  slot_ctx_unpruned->valloc = fd_alloc_virtual( args->alloc );

  fd_acc_mgr_t mgr_unpruned[1];
  slot_ctx_unpruned->acc_mgr = fd_acc_mgr_new( mgr_unpruned, unpruned_funk );
  slot_ctx_unpruned->blockstore = unpruned_blockstore;

  /* Setup pruned wksp */
  fd_wksp_t * pruned_wksp = fd_wksp_new_anonymous( FD_SHMEM_GIGANTIC_PAGE_SZ, args->pages_pruned, 0, "prunedwksp", 0UL );
  if( pruned_wksp == NULL ) {
    FD_LOG_ERR(( "failed to create and attach to a pruned_wksp" ));
  }

  /* Create pruned blockstore */
  fd_blockstore_t * pruned_blockstore;
  void * shmem = fd_wksp_alloc_laddr( pruned_wksp, fd_blockstore_align(), fd_blockstore_footprint(), FD_BLOCKSTORE_MAGIC );
  if( shmem == NULL ) {
    FD_LOG_ERR(( "failed to allocate a blockstore" ));
  }
  int lg_txn_max = 22;
  pruned_blockstore = fd_blockstore_join( fd_blockstore_new( shmem, 1, args->hashseed, args->shred_max,
                                                             args->slot_history_max, lg_txn_max ) );
  if( pruned_blockstore == NULL ) {
    fd_wksp_free_laddr( shmem );
    FD_LOG_ERR(( "failed to allocate a blockstore" ));
  }
  FD_LOG_NOTICE(( "pruned blockstore at global address 0x%016lx", fd_wksp_gaddr_fast( pruned_wksp, shmem ) ));

  /* Create pruned funk */
  fd_funk_t * pruned_funk;
  shmem = fd_wksp_alloc_laddr( pruned_wksp, fd_funk_align(), fd_funk_footprint(), FD_FUNK_MAGIC );
  if ( shmem == NULL ) {
    FD_LOG_ERR(( "failed to allocate a funky" ));
  }
  pruned_funk = fd_funk_join( fd_funk_new( shmem, FD_FUNK_MAGIC, args->hashseed,
                                              args->txns_max, args->index_max_pruned ) );
  if ( pruned_funk == NULL ) {
    fd_wksp_free_laddr( shmem );
    FD_LOG_ERR(( "failed to allocate a funky" ));
  }
  FD_LOG_NOTICE(( "pruned funky at global address 0x%016lx", fd_wksp_gaddr_fast( pruned_wksp, shmem ) ));

  /* Setup slot and epoch contexts for unpruned slot and epoch tonexts*/
  fd_alloc_t * alloc_unpruned = fd_alloc_join( fd_wksp_laddr_fast( unpruned_wksp, unpruned_funk->alloc_gaddr ), 0UL );
  if( FD_UNLIKELY( !alloc_unpruned ) ) {
    FD_LOG_ERR(( "fd_alloc_join(gaddr=%#lx) failed", unpruned_funk->alloc_gaddr ));
  }

  fd_alloc_t * alloc = fd_alloc_join( fd_wksp_laddr_fast( pruned_wksp, pruned_funk->alloc_gaddr ), 0UL );
  if( FD_UNLIKELY( !alloc ) ) { FD_LOG_ERR(( "fd_alloc_join(gaddr=%#lx) failed", pruned_funk->alloc_gaddr )); }

  uchar * epoch_ctx_mem = fd_wksp_alloc_laddr( pruned_wksp, fd_exec_epoch_ctx_align(), fd_exec_epoch_ctx_footprint( args->vote_acct_max ), FD_EXEC_EPOCH_CTX_MAGIC );
  fd_exec_epoch_ctx_t * epoch_ctx = fd_exec_epoch_ctx_join( fd_exec_epoch_ctx_new( epoch_ctx_mem, args->vote_acct_max ) );

  uchar slot_ctx_mem[FD_EXEC_SLOT_CTX_FOOTPRINT] __attribute__((aligned(FD_EXEC_SLOT_CTX_ALIGN)));
  fd_exec_slot_ctx_t * slot_ctx = fd_exec_slot_ctx_join( fd_exec_slot_ctx_new( slot_ctx_mem, fd_alloc_virtual( alloc ) ) );
  slot_ctx->epoch_ctx = epoch_ctx;

  fd_acc_mgr_t pruned_mgr[1];
  slot_ctx->acc_mgr = fd_acc_mgr_new( pruned_mgr, pruned_funk );
  slot_ctx->blockstore = pruned_blockstore;

  fd_funk_leave( unpruned_funk );

  /* Load in snapshot(s) into the unpruned funk */
  if( args->snapshot == NULL ) {
    FD_LOG_ERR(( "no snapshot file passed in" ));
  }
  fd_snapshot_load( args->snapshot, slot_ctx_unpruned, args->verify_acc_hash,
                    args->check_acc_hash, FD_SNAPSHOT_TYPE_FULL );
  FD_LOG_NOTICE(( "imported %lu records from snapshot",
                  fd_funk_rec_cnt( fd_funk_rec_map( unpruned_funk, unpruned_wksp ) ) ));

  if( args->incremental ) {
    fd_snapshot_load( args->incremental, slot_ctx_unpruned, args->verify_acc_hash,
                      args->check_acc_hash, FD_SNAPSHOT_TYPE_INCREMENTAL );
    FD_LOG_NOTICE(( "imported %lu records from snapshot",
                    fd_funk_rec_cnt( fd_funk_rec_map( unpruned_funk, unpruned_wksp ) ) ));
  }


  if( args->start_slot == 0 ) {
    args->start_slot = slot_ctx_unpruned->slot_bank.slot;
  }
  if( args->end_slot >= slot_ctx_unpruned->slot_bank.slot + args->slot_history_max ) {
    args->end_slot = slot_ctx->slot_bank.slot + args->slot_history_max - 1;
  }

  ingest_rocksdb( args->alloc, args->rocksdb_dir, args->start_slot, args->end_slot, unpruned_blockstore, 0, args->trash_hash );
  FD_LOG_NOTICE(( "imported unpruned rocksdb" ));

  slot_ctx->slot_bank.slot = slot_ctx_unpruned->slot_bank.slot;
  ingest_rocksdb( alloc, args->rocksdb_dir, args->start_slot, args->end_slot,
                  pruned_blockstore, args->copy_txn_status, args->trash_hash );
  FD_LOG_NOTICE(( "imported pruned rocksdb" ));

  fd_scratch_detach( NULL );

  /* Replay to get all accounts that are touched (r/w) during execution */
  fd_runtime_args_t runtime_args = {0};
  runtime_args.end_slot = args->end_slot;
  runtime_args.pruned_funk = pruned_funk;
  runtime_args.cmd = "replay";
  runtime_args.allocator = "wksp";

  fd_runtime_ctx_t state = {0};

  fd_tvu_gossip_deliver_arg_t gossip_deliver_arg[1];
  fd_replay_t * replay = NULL;
  fd_tvu_main_setup( &state, &replay, NULL, NULL, 0, unpruned_wksp, &runtime_args, gossip_deliver_arg );

  /* Junk xid for pruning transaction */ // TODO: factor out the xid nicely
  fd_funk_txn_xid_t prune_xid;
  fd_memset( &prune_xid, 0x42, sizeof(fd_funk_txn_xid_t) );
  fd_funk_txn_t * prune_txn = fd_funk_txn_prepare( pruned_funk, NULL, &prune_xid, 1 );
  FD_TEST(( !!prune_txn ));

  int err = runtime_replay( &state, &runtime_args );
  if( err != 0 ) {
    fd_tvu_main_teardown( &state, NULL );
    FD_LOG_ERR(("error in runtime replay"));
  }

  /* Reset the wksp and load in funk again. */
  /* TODO: A better implementation of this would be to just rollback the
      funk transactions. This can be done by publishing all funk transactions
      into a parent and then cancelling the parent after execution is complete. */

  fd_wksp_reset( unpruned_wksp, args->hashseed );

  shmem = fd_wksp_alloc_laddr( unpruned_wksp, fd_funk_align(), fd_funk_footprint(), FD_FUNK_MAGIC );
  if( shmem == NULL ) {
    FD_LOG_ERR(( "failed to allocate a funky" ));
  }
  unpruned_funk = fd_funk_join( fd_funk_new( shmem, FD_FUNK_MAGIC, args->hashseed,
                                             args->txns_max, args->index_max ) );
  init_scratch( unpruned_wksp );

  alloc_unpruned = fd_alloc_join( fd_wksp_laddr_fast( unpruned_wksp, unpruned_funk->alloc_gaddr ), 0UL );
  if( FD_UNLIKELY( !alloc_unpruned ) ) {
    FD_LOG_ERR(( "fd_alloc_join(gaddr=%#lx) failed", unpruned_funk->alloc_gaddr ));
  }
  epoch_ctx_unpruned = fd_exec_epoch_ctx_join( fd_exec_epoch_ctx_new( epoch_ctx_mem_unpruned, args->vote_acct_max ) );
  slot_ctx_unpruned = fd_exec_slot_ctx_join( fd_exec_slot_ctx_new( slot_ctx_mem_unpruned, fd_alloc_virtual( alloc_unpruned ) ) );
  slot_ctx_unpruned->epoch_ctx = epoch_ctx_unpruned;

  slot_ctx_unpruned->valloc = fd_alloc_virtual( alloc_unpruned );

  fd_acc_mgr_t mgr_unpruned_new[1];
  slot_ctx_unpruned->acc_mgr = fd_acc_mgr_new( mgr_unpruned_new, unpruned_funk );
  fd_snapshot_load( args->snapshot, slot_ctx_unpruned, args->verify_acc_hash,
                    args->check_acc_hash, FD_SNAPSHOT_TYPE_FULL );

  if( args->incremental ) {
    fd_snapshot_load( args->incremental, slot_ctx_unpruned, args->verify_acc_hash,
                      args->check_acc_hash, FD_SNAPSHOT_TYPE_INCREMENTAL );
  }

  FD_LOG_NOTICE(("imported %lu records from snapshot",
                  fd_funk_rec_cnt( fd_funk_rec_map( unpruned_funk, unpruned_wksp ))));

  /* After replaying, update all touched accounts to contain the data that is
     present before execution begins. Look up the corresponding account in the
     unpruned funk and copy over the contents */
  fd_funk_rec_t * rec_map = fd_funk_rec_map( pruned_funk, pruned_wksp );
  for( const fd_funk_rec_t * rec = fd_funk_txn_rec_head( prune_txn, rec_map );
        rec; rec = fd_funk_txn_next_rec( pruned_funk, rec ) ) {

    const fd_funk_rec_t * original_rec = fd_funk_rec_query_global( unpruned_funk, NULL, rec->pair.key );
    if( original_rec != NULL ) {
      fd_funk_rec_t * mod_rec = fd_funk_rec_modify( pruned_funk, rec );
      mod_rec = fd_funk_val_copy( mod_rec, fd_funk_val_const( original_rec, unpruned_wksp ),
                                  fd_funk_val_sz( original_rec ),fd_funk_val_sz( original_rec ),
                                  fd_funk_alloc( pruned_funk, pruned_wksp ), pruned_wksp, NULL );
      FD_TEST(( memcmp( fd_funk_val( original_rec, unpruned_wksp ), fd_funk_val_const( rec, pruned_wksp ),
                        fd_funk_val_sz( original_rec ) ) == 0 ));
    } else {
      fd_funk_rec_t * mod_rec = fd_funk_rec_modify( pruned_funk, rec );
      int res = fd_funk_rec_remove( pruned_funk, mod_rec, 1 );
      FD_TEST(( res == 0 ));
    }
  }
  FD_LOG_NOTICE(( "Copied over all records from transactions" ));

  /* Repeat above steps with all features */
  for( fd_feature_id_t const * id = fd_feature_iter_init();
        !fd_feature_iter_done( id ); id = fd_feature_iter_next( id ) ) {

    fd_pubkey_t const *   pubkey      = (fd_pubkey_t *) id->id.key;
    fd_funk_rec_key_t     feature_id  = fd_acc_funk_key( pubkey );
    fd_funk_rec_t const * feature_rec = fd_funk_rec_query_global( unpruned_funk, NULL, &feature_id );
    if( !feature_rec ) {
      continue;
    }
    fd_funk_rec_t * new_feature_rec = fd_funk_rec_write_prepare( pruned_funk, prune_txn, &feature_id,
                                                                 0, 1, NULL, NULL );
    FD_TEST(( !!new_feature_rec ));
    new_feature_rec = fd_funk_val_copy( new_feature_rec, fd_funk_val_const( feature_rec, unpruned_wksp ),
                                        fd_funk_val_sz( feature_rec ), fd_funk_val_sz( feature_rec ),
                                        fd_funk_alloc( pruned_funk, pruned_wksp ), pruned_wksp, NULL );
    FD_TEST(( !!new_feature_rec ));
  }
  FD_LOG_NOTICE(("Copied over all features"));

  /* Do the same with the epoch/slot bank keys and sysvars */
  fd_funk_rec_key_t id_epoch_bank       = fd_runtime_epoch_bank_key();
  fd_funk_rec_key_t id_slot_bank        = fd_runtime_slot_bank_key();
  fd_funk_rec_key_t recent_block_hashes = fd_acc_funk_key( &fd_sysvar_recent_block_hashes_id );
  fd_funk_rec_key_t clock               = fd_acc_funk_key( &fd_sysvar_clock_id );
  fd_funk_rec_key_t slot_history        = fd_acc_funk_key( &fd_sysvar_slot_history_id );
  fd_funk_rec_key_t slot_hashes         = fd_acc_funk_key( &fd_sysvar_slot_hashes_id );
  fd_funk_rec_key_t epoch_schedule      = fd_acc_funk_key( &fd_sysvar_epoch_schedule_id );
  fd_funk_rec_key_t epoch_rewards       = fd_acc_funk_key( &fd_sysvar_epoch_rewards_id );
  fd_funk_rec_key_t sysvar_fees         = fd_acc_funk_key( &fd_sysvar_fees_id );
  fd_funk_rec_key_t rent                = fd_acc_funk_key( &fd_sysvar_rent_id );
  fd_funk_rec_key_t stake_history       = fd_acc_funk_key( &fd_sysvar_stake_history_id );
  fd_funk_rec_key_t owner               = fd_acc_funk_key( &fd_sysvar_owner_id );
  fd_funk_rec_key_t last_restart_slot   = fd_acc_funk_key( &fd_sysvar_last_restart_slot_id );
  fd_funk_rec_key_t instructions        = fd_acc_funk_key( &fd_sysvar_instructions_id );
  fd_funk_rec_key_t incinerator         = fd_acc_funk_key( &fd_sysvar_incinerator_id );

  fd_funk_rec_key_t records[15] = { id_epoch_bank, id_slot_bank, recent_block_hashes, clock, slot_history,
                                    slot_hashes, epoch_schedule, epoch_rewards, sysvar_fees, rent,
                                    stake_history, owner, last_restart_slot, instructions, incinerator };
  for( uint i = 0; i < sizeof( records ) / sizeof( fd_funk_rec_key_t ); ++i ) {
    fd_funk_rec_t const * original_rec = fd_funk_rec_query_global( unpruned_funk, NULL, &records[i] );
    if( !original_rec ) {
      /* Some sysvars aren't touched during execution. Not a problem. */
      FD_LOG_DEBUG(("Record is not in account pubkey=%32J", &records[i]));
      continue;
    }
    fd_funk_rec_t * new_rec = fd_funk_rec_write_prepare( pruned_funk, prune_txn, &records[i], 0, 1, NULL, NULL );
    FD_TEST(( !!new_rec ));
    new_rec = fd_funk_val_copy( new_rec, fd_funk_val_const( original_rec, unpruned_wksp ),
                                fd_funk_val_sz( original_rec ), fd_funk_val_sz( original_rec ),
                                fd_funk_alloc( pruned_funk, pruned_wksp ), pruned_wksp, NULL );
    FD_TEST(( !!new_rec ));
  }
  FD_LOG_NOTICE(("Copied over all sysvars and bank keys"));

  /* Publish transaction with pruned records to the root of funk */
  if( fd_funk_txn_publish( pruned_funk, prune_txn, 1 ) == 0 ) {
    FD_LOG_ERR(("failed to publish transaction into pruned funk"));
  }

  /* Verify that the pruned records are in the funk */
  FD_LOG_NOTICE(("Pruned funk record count is %lu", fd_funk_rec_global_cnt( pruned_funk, pruned_wksp )));

  cleanup_scratch();
  fd_funk_leave( unpruned_funk );

  if( fd_funk_verify( pruned_funk ) ) {
    FD_LOG_ERR(( "pruned funk verification failed" ));
  }

  checkpt( args, slot_ctx );
}

int
replay( fd_ledger_args_t * args ) {
  /* Allows for ingest and direct replay. This can be done with a full checkpoint
     that contains a blockstore and funk, a checkpoint that just has funk, or directly
     using a rocksdb and snapshot.

    On demand block ingest is enabled by default and can be disabled with
    '--on-demand-block-ingest 0'. The number of blocks retained in a blockstore during
    on demand block ingest can be set with '--on-demand-block-history <N slots>'

    In order to replay from a checkpoint, use '--checkpoint <path to checkpoint>'.

    To use a checkpoint, but to consume blocks on demand use '--funkonly true'.
    This option MUST be used if the checkpoint was generated during a replay with
    on demand block ingest.

    For blocks to contain transaction status information use '--txnstatus true'

    Example command loading in from on demand checkpoint and replaying with on demand block ingest.
    It creates a checkpoint every 1000 slots.
    fd_ledger --restore <CHECKPOINT_TO_LOAD_IN> --cmd replay --page-cnt 400
              --abort-on-mismatch 1 --tile-cpus 5-21 --allocator wksp
              --rocksdb dump/rocksdb --checkpt-path dump/checkpoint_new
              --checkpt-freq 1000 --funk-only 1 --on-demand-block-ingest 1
    Note: remove --on-demand-block-ingest 1 and --funk-only 1 if you want to replay from a full checkpoint

    Example command directly loading in a rocksdb and snapshot and replaying.
    fd_ledger --reset 1 --cmd replay --rocksdb dump/mainnet-257068890/rocksdb --index-max 5000000
              --end-slot 257068895 --txn-max 100 --page-cnt 16 --verify-acc-hash 1
              --snapshot dump/mainnet-257068890/snapshot-257068890-uRVtagPzKhYorycp4CRtKdWrYPij6iBxCYYXmqRvdSp.tar.zst
              --slot-history 5000 --copy-txn-status 0 --allocator wksp --tile-cpus 5-21
              --on-demand-block-ingest 1 --on-demand-block-history 100

  */

  if( args->restore != NULL ) {
    fd_wksp_restore( args->wksp, args->restore, args->hashseed );
  }

  init_funk( args ); /* Joins or creates funk based on if one exists in the workspace */

  /* Remove the blockstore from the workspace if specified */
  if( args->funk_only ) {
    ulong blockstore_tag = FD_BLOCKSTORE_MAGIC;
    fd_wksp_tag_free( args->wksp, &blockstore_tag, 1 );
  }

  fd_funk_t * funk = args->funk;
  fd_wksp_t * wksp = args->wksp;

  /* Check number of records in funk. If rec_cnt == 0, then it can be assumed
     that you need to load in snapshot(s)  */
  ulong rec_cnt = fd_funk_rec_cnt( fd_funk_rec_map( funk, wksp ) );
  if ( rec_cnt == 0 ) {

    uchar * epoch_ctx_mem = fd_wksp_alloc_laddr( wksp, fd_exec_epoch_ctx_align(), fd_exec_epoch_ctx_footprint( args->vote_acct_max ), FD_EXEC_EPOCH_CTX_MAGIC );
    fd_exec_epoch_ctx_t * epoch_ctx = fd_exec_epoch_ctx_join( fd_exec_epoch_ctx_new( epoch_ctx_mem, args->vote_acct_max ) );

    uchar slot_ctx_mem[FD_EXEC_SLOT_CTX_FOOTPRINT] __attribute__((aligned(FD_EXEC_SLOT_CTX_ALIGN)));
    fd_exec_slot_ctx_t * slot_ctx = fd_exec_slot_ctx_join( fd_exec_slot_ctx_new( slot_ctx_mem, fd_alloc_virtual( args->alloc ) ) );
    slot_ctx->epoch_ctx = epoch_ctx;

    fd_acc_mgr_t mgr[1];
    slot_ctx->acc_mgr = fd_acc_mgr_new( mgr, funk );
    slot_ctx->blockstore = args->blockstore;

    /* Load in snapshot(s) */
    if( args->snapshot ) {
      fd_snapshot_load( args->snapshot, slot_ctx, args->verify_acc_hash, args->check_acc_hash, FD_SNAPSHOT_TYPE_FULL );
      FD_LOG_NOTICE(( "imported %lu records from snapshot", fd_funk_rec_cnt( fd_funk_rec_map( funk, wksp ) ) ));
    }
    if( args->incremental ) {
      fd_snapshot_load( args->incremental, slot_ctx, args->verify_acc_hash, args->check_acc_hash, FD_SNAPSHOT_TYPE_INCREMENTAL );
      FD_LOG_NOTICE(( "imported %lu records from snapshot", fd_funk_rec_cnt( fd_funk_rec_map( funk, wksp ) ) ));
    }
    if( args->genesis ) {
      struct stat sbuf;
      if( FD_UNLIKELY( stat( args->genesis, &sbuf ) < 0 ) ) {
        FD_LOG_ERR(( "cannot open %s : %s", args->genesis, strerror(errno) ));
      }
      int fd = open( args->genesis, O_RDONLY );
      if( FD_UNLIKELY( fd < 0 ) ) {
        FD_LOG_ERR(( "cannot open %s : %s", args->genesis, strerror(errno) ));
      }
      uchar * buf = malloc( (ulong) sbuf.st_size );  /* TODO: Make this a scratch alloc */
      ssize_t n = read( fd, buf, (ulong) sbuf.st_size );
      close( fd );

      fd_genesis_solana_t genesis_block;
      fd_genesis_solana_new( &genesis_block );
      fd_bincode_decode_ctx_t ctx = {
        .data = buf,
        .dataend = buf + n,
        .valloc  = slot_ctx->valloc
      };
      if( fd_genesis_solana_decode( &genesis_block, &ctx ) ) {
        FD_LOG_ERR(( "fd_genesis_solana_decode failed" ));
      }

      // The hash is generated from the raw data... don't mess with this..
      fd_hash_t genesis_hash;
      fd_sha256_hash( buf, (ulong)n, genesis_hash.uc );
      FD_LOG_NOTICE(( "Genesis Hash: %32J", &genesis_hash ));
      fd_epoch_bank_t * epoch_bank = fd_exec_epoch_ctx_epoch_bank( slot_ctx->epoch_ctx );
      fd_memcpy( epoch_bank->genesis_hash.uc, genesis_hash.uc, 32U );
      epoch_bank->cluster_type = genesis_block.cluster_type;

      free( buf );

      fd_funk_start_write( funk );

      /* If we are loading from a snapshot, do not overwrite from genesis */
      if ( !args->snapshot ) {
        fd_runtime_init_bank_from_genesis( slot_ctx, &genesis_block, &genesis_hash );

        fd_runtime_init_program( slot_ctx );

        FD_LOG_DEBUG(( "start genesis accounts - count: %lu", genesis_block.accounts_len ));

        for( ulong i=0; i < genesis_block.accounts_len; i++ ) {
          fd_pubkey_account_pair_t * a = &genesis_block.accounts[i];

          FD_BORROWED_ACCOUNT_DECL(rec);

          int err = fd_acc_mgr_modify(
            slot_ctx->acc_mgr,
            slot_ctx->funk_txn,
            &a->key,
            /* do_create */ 1,
            a->account.data_len,
            rec);
          if( FD_UNLIKELY( err ) )
            FD_LOG_ERR(( "fd_acc_mgr_modify failed (%d)", err ));

          rec->meta->dlen            = a->account.data_len;
          rec->meta->info.lamports   = a->account.lamports;
          rec->meta->info.rent_epoch = a->account.rent_epoch;
          rec->meta->info.executable = !!a->account.executable;
          memcpy( rec->meta->info.owner, a->account.owner.key, 32UL );
          if( a->account.data_len ) {
            memcpy( rec->data, a->account.data, a->account.data_len );
          }
        }

        FD_LOG_DEBUG(( "end genesis accounts"));

        FD_LOG_DEBUG(( "native instruction processors - count: %lu", genesis_block.native_instruction_processors_len));

        for( ulong i=0; i < genesis_block.native_instruction_processors_len; i++ ) {
          fd_string_pubkey_pair_t * a = &genesis_block.native_instruction_processors[i];
          fd_write_builtin_bogus_account( slot_ctx, a->pubkey.uc, a->string, strlen(a->string) );
        }

        /* Sort and update bank hash */
        int result = fd_update_hash_bank( slot_ctx, NULL, &slot_ctx->slot_bank.banks_hash, slot_ctx->signature_cnt );
        if( result != FD_EXECUTOR_INSTR_SUCCESS ) {
          FD_LOG_ERR(( "unable to update hash bank" ));
        }

        slot_ctx->slot_bank.slot = 0UL;
      }

      FD_TEST( FD_RUNTIME_EXECUTE_SUCCESS == fd_runtime_save_epoch_bank( slot_ctx ) );

      FD_TEST( FD_RUNTIME_EXECUTE_SUCCESS == fd_runtime_save_slot_bank( slot_ctx ) );

      fd_funk_end_write( funk );

      fd_bincode_destroy_ctx_t ctx2 = { .valloc = slot_ctx->valloc };
      fd_genesis_solana_destroy( &genesis_block, &ctx2 );
    }

  }

  fd_runtime_args_t runtime_args = {0};
  fd_runtime_ctx_t state = {0};

  /* TODO: update so that we aren't piping through every argument twice */
  runtime_args.abort_on_mismatch       = args->abort_on_mismatch;
  runtime_args.cmd                     = args->cmd;
  runtime_args.end_slot                = args->end_slot;
  runtime_args.allocator               = args->allocator;
  runtime_args.rocksdb_dir             = args->rocksdb_dir;
  runtime_args.capture_fpath           = args->capture_fpath;
  runtime_args.capture_txns            = args->capture_txns;
  runtime_args.checkpt_path            = args->checkpt_path;
  runtime_args.checkpt_slot            = args->checkpt_slot;
  runtime_args.checkpt_freq            = args->checkpt_freq;
  runtime_args.copy_txn_status         = args->copy_txn_status;
  runtime_args.on_demand_block_ingest  = args->on_demand_block_ingest;
  runtime_args.on_demand_block_history = args->on_demand_block_history;
  runtime_args.dump_insn_to_pb         = args->dump_insn_to_pb;
  runtime_args.dump_insn_sig_filter    = args->dump_insn_sig_filter;
  runtime_args.dump_insn_output_dir    = args->dump_insn_output_dir;
  runtime_args.trash_hash              = args->trash_hash;

  fd_replay_t * replay = NULL;
  fd_tvu_main_setup( &state, &replay, NULL, NULL, 0, wksp, &runtime_args, NULL );

  FD_LOG_WARNING(( "tvu main setup done" ));

  int ret = runtime_replay( &state, &runtime_args );
  fd_tvu_main_teardown( &state, NULL );
  return ret;
}

/* Parse user arguments and setup shared data structures used across commands */
int
initial_setup( int argc, char ** argv, fd_ledger_args_t * args ) {
  if( FD_UNLIKELY( argc==1 ) ) {
    usage( argv[0] );
    return 1;
  }

  fd_boot( &argc, &argv );
  fd_flamenco_boot( &argc, &argv );

  char const * wksp_name               = fd_env_strip_cmdline_cstr ( &argc, &argv, "--wksp-name",               NULL, NULL      );
  ulong        page_cnt                = fd_env_strip_cmdline_ulong( &argc, &argv, "--page-cnt",                NULL, 5         );
  int          reset                   = fd_env_strip_cmdline_int  ( &argc, &argv, "--reset",                   NULL, 0         );
  char const * cmd                     = fd_env_strip_cmdline_cstr ( &argc, &argv, "--cmd",                     NULL, NULL      );
  ulong        index_max               = fd_env_strip_cmdline_ulong( &argc, &argv, "--index-max",               NULL, 450000000 );
  ulong        txns_max                = fd_env_strip_cmdline_ulong( &argc, &argv, "--txn-max",                 NULL,      1000 );
  int          verify_funk             = fd_env_strip_cmdline_int  ( &argc, &argv, "--verify-funky",            NULL, 0         );
  char const * snapshot                = fd_env_strip_cmdline_cstr ( &argc, &argv, "--snapshot",                NULL, NULL      );
  char const * incremental             = fd_env_strip_cmdline_cstr ( &argc, &argv, "--incremental",             NULL, NULL      );
  char const * genesis                 = fd_env_strip_cmdline_cstr ( &argc, &argv, "--genesis",                 NULL, NULL      );
  char const * rocksdb_dir             = fd_env_strip_cmdline_cstr ( &argc, &argv, "--rocksdb",                 NULL, NULL      );
  int          copy_txn_status         = fd_env_strip_cmdline_int  ( &argc, &argv, "--copy-txn-status",         NULL, 0         );
  ulong        slot_history_max        = fd_env_strip_cmdline_ulong( &argc, &argv, "--slot-history",            NULL, FD_BLOCKSTORE_SLOT_HISTORY_MAX );
  ulong        shred_max               = fd_env_strip_cmdline_ulong( &argc, &argv, "--shred-max",               NULL, 1UL << 17 );
  ulong        start_slot              = fd_env_strip_cmdline_ulong( &argc, &argv, "--start-slot",              NULL, 0UL       );
  ulong        end_slot                = fd_env_strip_cmdline_ulong( &argc, &argv, "--end-slot",                NULL, ULONG_MAX );
  char const * verify_hash             = fd_env_strip_cmdline_cstr ( &argc, &argv, "--verify-hash",             NULL, NULL      );
  uint         verify_acc_hash         = fd_env_strip_cmdline_uint ( &argc, &argv, "--verify-acc-hash",         NULL, 0         );
  uint         check_acc_hash          = fd_env_strip_cmdline_uint ( &argc, &argv, "--check-acc-hash",          NULL, 0         );
  char const * restore                 = fd_env_strip_cmdline_cstr ( &argc, &argv, "--restore",                 NULL, NULL      );
  char const * shredcap                = fd_env_strip_cmdline_cstr ( &argc, &argv, "--shred-cap",               NULL, NULL      );
  ulong        trash_hash              = fd_env_strip_cmdline_ulong( &argc, &argv, "--trash-hash",              NULL, ULONG_MAX );
  char const * mini_db_dir             = fd_env_strip_cmdline_cstr ( &argc, &argv, "--minified-rocksdb",        NULL, NULL      );
  ulong        index_max_pruned        = fd_env_strip_cmdline_ulong( &argc, &argv, "--index-max-pruned",        NULL, 450000000 );
  ulong        pages_pruned            = fd_env_strip_cmdline_ulong( &argc, &argv, "--page-cnt-pruned",         NULL, ULONG_MAX );
  int          funk_only               = fd_env_strip_cmdline_int  ( &argc, &argv, "--funk-only",               NULL, 0         );
  char const * checkpt                 = fd_env_strip_cmdline_cstr ( &argc, &argv, "--checkpt",                 NULL, NULL      );
  char const * capture_fpath           = fd_env_strip_cmdline_cstr ( &argc, &argv, "--capture-solcap",          NULL, NULL      );
  int          capture_txns            = fd_env_strip_cmdline_int  ( &argc, &argv, "--capture-txns",            NULL, 1         );
  char const * checkpt_path            = fd_env_strip_cmdline_cstr ( &argc, &argv, "--checkpt-path",            NULL, NULL      );
  ulong        checkpt_slot            = fd_env_strip_cmdline_ulong( &argc, &argv, "--checkpt-slot",            NULL, 0         );
  ulong        checkpt_freq            = fd_env_strip_cmdline_ulong( &argc, &argv, "--checkpt-freq",            NULL, ULONG_MAX );
  char const * allocator               = fd_env_strip_cmdline_cstr ( &argc, &argv, "--allocator",               NULL, "wksp"    );
  int          abort_on_mismatch       = fd_env_strip_cmdline_int  ( &argc, &argv, "--abort-on-mismatch",       NULL, 1         );
  int          on_demand_block_ingest  = fd_env_strip_cmdline_int  ( &argc, &argv, "--on-demand-block-ingest",  NULL, 0         );
  ulong        on_demand_block_history = fd_env_strip_cmdline_ulong( &argc, &argv, "--on-demand-block-history", NULL, 100       );
  int          dump_insn_to_pb         = fd_env_strip_cmdline_int  ( &argc, &argv, "--dump-insn-to-pb",         NULL, 0         );
  char const * dump_insn_sig_filter    = fd_env_strip_cmdline_cstr ( &argc, &argv, "--dump-insn-sig-filter",    NULL, NULL      );
  char const * dump_insn_output_dir    = fd_env_strip_cmdline_cstr ( &argc, &argv, "--dump-insn-output-dir",    NULL, NULL      );
  ulong        vote_acct_max           = fd_env_strip_cmdline_ulong( &argc, &argv, "--vote_acct_max",           NULL, 2000000UL  );

  #ifdef _ENABLE_LTHASH
  char const * lthash             = fd_env_strip_cmdline_cstr ( &argc, &argv, "--lthash",           NULL, "false"   );
  #endif

  // TODO: Add argument validation. Make sure that we aren't including any arguments that aren't parsed for

  char hostname[64];
  gethostname( hostname, sizeof(hostname) );
  ulong hashseed = fd_hash( 0, hostname, strnlen( hostname, sizeof(hostname) ) );
  args->hashseed = (uint)hashseed;

  /* Setup workspace */
  fd_wksp_t * wksp;
  if( wksp_name == NULL ) {
    FD_LOG_NOTICE(( "--wksp not specified, using an anonymous local workspace" ));
    wksp = fd_wksp_new_anonymous( FD_SHMEM_GIGANTIC_PAGE_SZ, page_cnt, 0, "wksp", 0UL );
  } else {
    fd_shmem_info_t shmem_info[1];
    if ( FD_UNLIKELY( fd_shmem_info( wksp_name, 0UL, shmem_info ) ) )
      FD_LOG_ERR(( "unable to query region \"%s\"\n\tprobably does not exist or bad permissions", wksp_name ));
    wksp = fd_wksp_attach( wksp_name );
  }

  if( wksp == NULL ) {
    FD_LOG_ERR(( "failed to attach to workspace %s", wksp_name ));
  }
  if( reset ) {
    fd_wksp_reset( wksp, args->hashseed );
  }
  args->wksp = wksp;

  init_scratch( wksp );

  /* Setup alloc and valloc */
  #define FD_ALLOC_TAG (422UL)
  void * alloc_shmem = fd_wksp_alloc_laddr( wksp, fd_alloc_align(), fd_alloc_footprint(), FD_ALLOC_TAG );
  if( FD_UNLIKELY( !alloc_shmem ) ) { FD_LOG_ERR( ( "fd_alloc too large for workspace" ) ); }
  void * alloc_shalloc = fd_alloc_new( alloc_shmem, FD_ALLOC_TAG );
  if( FD_UNLIKELY( !alloc_shalloc ) ) { FD_LOG_ERR( ( "fd_allow_new failed" ) ); }
  fd_alloc_t * alloc = fd_alloc_join( alloc_shalloc, FD_ALLOC_TAG );
  args->alloc = alloc;
  #undef FD_ALLOC_TAG

  /* Copy over arguments */
  args->cmd                     = cmd;
  args->start_slot              = start_slot;
  args->end_slot                = end_slot;
  args->rocksdb_dir             = rocksdb_dir;
  args->checkpt                 = checkpt;
  args->shred_max               = shred_max;
  args->slot_history_max        = slot_history_max;
  args->txns_max                = txns_max;
  args->index_max               = index_max;
  args->restore                 = restore;
  args->mini_db_dir             = mini_db_dir;
  args->funk_only               = funk_only;
  args->copy_txn_status         = copy_txn_status;
  args->snapshot                = snapshot;
  args->incremental             = incremental;
  args->genesis                 = genesis;
  args->shredcap                = shredcap;
  args->verify_funk             = verify_funk;
  args->check_acc_hash          = check_acc_hash;
  args->verify_acc_hash         = verify_acc_hash;
  args->trash_hash              = trash_hash;
  args->verify_hash             = verify_hash;
  args->index_max_pruned        = index_max_pruned;
  args->pages_pruned            = pages_pruned;
  args->capture_fpath           = capture_fpath;
  args->capture_txns            = capture_txns;
  args->checkpt_path            = checkpt_path;
  args->checkpt_slot            = checkpt_slot;
  args->checkpt_freq            = checkpt_freq;
  args->allocator               = allocator;
  args->abort_on_mismatch       = abort_on_mismatch;
  args->on_demand_block_ingest  = on_demand_block_ingest;
  args->on_demand_block_history = on_demand_block_history;
  args->dump_insn_to_pb         = dump_insn_to_pb;
  args->dump_insn_sig_filter    = dump_insn_sig_filter;
  args->dump_insn_output_dir    = dump_insn_output_dir;
  args->vote_acct_max           = vote_acct_max;

  /* TODO: add argument validation */

  #ifdef _ENABLE_LTHASH
  args->lthash           = lthash;
  #endif

  return 0;
}

int main ( int argc, char ** argv ) {
  fd_ledger_args_t args = {0};
  initial_setup( argc, argv, &args );

  if( args.cmd == NULL ) {
    FD_LOG_ERR(( "no command specified" ));
  } else if( strcmp( args.cmd, "replay" ) == 0 ) {
    return replay( &args );
  } else if( strcmp( args.cmd, "ingest" ) == 0 ) {
    ingest( &args );
  } else if( strcmp( args.cmd, "minify" ) == 0 ) {
    minify( &args );
  } else if( strcmp( args.cmd, "prune" ) == 0 ) {
    prune( &args );

  } else {
    FD_LOG_ERR(( "unknown command=%s", args.cmd ));
  }
  return 0;
}
