#ifndef HEADER_fd_src_util_sandbox_net_seccomp.h_h
#define HEADER_fd_src_util_sandbox_net_seccomp.h_h

#include <linux/filter.h>

/* THIS FILE WAS GENERATED BY generate_filters.py. */
/* DO NOT EDIT BY HAND!                            */

static const unsigned int sock_filter_policy_net_instr_cnt = 42;

static void populate_sock_filter_policy_net(struct sock_filter (*out) [static 42], unsigned int xsk_fd, unsigned int lo_xsk_fd) {
  *out = {
    /* Check: Jump to RET_KILL_PROCESS if the script's arch != the runtime arch */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, arch ) ) ),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, ARCH_NR, 0, /* RET_KILL_PROCESS */ 38 ),
    /* loading syscall number in accumulator as it might have been evicted by the previous evaluation */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, nr ) ) ),
    /* begin write: (Symbol(or), (Symbol(eq), (Symbol(arg), 0), 2), (Symbol(eq), (Symbol(arg), 0), 3)) */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, __NR_write, 0, /* lbl_1 */ 4 ),
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 2, /* RET_ALLOW */ 35, /* lbl_2 */ 0 ),
    /* lbl_2: */
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 3, /* RET_ALLOW */ 33, /* RET_KILL_PROCESS */ 32 ),
    /* lbl_1: */
    /* loading syscall number in accumulator as it might have been evicted by the previous evaluation */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, nr ) ) ),
    /* begin fsync: (Symbol(eq), (Symbol(arg), 0), 3) */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, __NR_fsync, 0, /* lbl_3 */ 2 ),
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 3, /* RET_ALLOW */ 29, /* RET_KILL_PROCESS */ 28 ),
    /* lbl_3: */
    /* loading syscall number in accumulator as it might have been evicted by the previous evaluation */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, nr ) ) ),
    /* begin sendto: (Symbol(and), (Symbol(or), (Symbol(eq), (Symbol(arg), 0), Symbol(xsk_fd)), (Symbol(eq), (Symbol(arg), 0), Symbol(lo_xsk_fd))), (Symbol(eq), (Symbol(arg), 1), 0), (Symbol(eq), (Symbol(arg), 2), 0), (Symbol(eq), (Symbol(arg), 3), Symbol(MSG_DONTWAIT)), (Symbol(eq), (Symbol(arg), 4), 0), (Symbol(eq), (Symbol(arg), 5), 0)) */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, __NR_sendto, 0, /* lbl_4 */ 14 ),
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, xsk_fd, /* lbl_5 */ 2, /* lbl_6 */ 0 ),
    /* lbl_6: */
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, lo_xsk_fd, /* lbl_5 */ 0, /* RET_KILL_PROCESS */ 22 ),
    /* lbl_5: */
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 0, /* lbl_7 */ 0, /* RET_KILL_PROCESS */ 20 ),
    /* lbl_7: */
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 0, /* lbl_8 */ 0, /* RET_KILL_PROCESS */ 18 ),
    /* lbl_8: */
    /* load syscall argument 3 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[3])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, MSG_DONTWAIT, /* lbl_9 */ 0, /* RET_KILL_PROCESS */ 16 ),
    /* lbl_9: */
    /* load syscall argument 4 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[4])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 0, /* lbl_10 */ 0, /* RET_KILL_PROCESS */ 14 ),
    /* lbl_10: */
    /* load syscall argument 5 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[5])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 0, /* RET_ALLOW */ 13, /* RET_KILL_PROCESS */ 12 ),
    /* lbl_4: */
    /* loading syscall number in accumulator as it might have been evicted by the previous evaluation */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, ( offsetof( struct seccomp_data, nr ) ) ),
    /* begin recvmsg: (Symbol(and), (Symbol(or), (Symbol(eq), (Symbol(arg), 0), Symbol(xsk_fd)), (Symbol(eq), (Symbol(arg), 0), Symbol(lo_xsk_fd))), (Symbol(eq), (Symbol(arg), 1), 0), (Symbol(eq), (Symbol(arg), 2), 0), (Symbol(eq), (Symbol(arg), 3), Symbol(MSG_DONTWAIT))) */
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, __NR_recvmsg, 0, /* lbl_11 */ 10 ),
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, xsk_fd, /* lbl_12 */ 2, /* lbl_13 */ 0 ),
    /* lbl_13: */
    /* load syscall argument 0 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[0])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, lo_xsk_fd, /* lbl_12 */ 0, /* RET_KILL_PROCESS */ 6 ),
    /* lbl_12: */
    /* load syscall argument 1 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[1])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 0, /* lbl_14 */ 0, /* RET_KILL_PROCESS */ 4 ),
    /* lbl_14: */
    /* load syscall argument 2 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[2])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, 0, /* lbl_15 */ 0, /* RET_KILL_PROCESS */ 2 ),
    /* lbl_15: */
    /* load syscall argument 3 in accumulator */
    BPF_STMT( BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, args[3])),
    BPF_JUMP( BPF_JMP | BPF_JEQ | BPF_K, MSG_DONTWAIT, /* RET_ALLOW */ 1, /* RET_KILL_PROCESS */ 0 ),
    /* lbl_11: */
    /* RET_KILL_PROCESS: */
    /* KILL_PROCESS is placed before ALLOW since it's the fallthrough case. */
    BPF_STMT( BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS ),
    /* RET_ALLOW: */
    /* ALLOW has to be reached by jumping */
    BPF_STMT( BPF_RET | BPF_K, SECCOMP_RET_ALLOW ),
  };
}

#endif
