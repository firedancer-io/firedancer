#ifndef HEADER_fd_src_disco_dedup_fd_dedup_h
#define HEADER_fd_src_disco_dedup_fd_dedup_h

/* fd_dedup provides services to deduplicate multiple streams of input
   fragments and present them to a mix of reliable and unreliable
   consumers as though they were generated by a single multi-stream
   producer.  The entire process is zero copy for the actual fragment
   payloads and thus has extremely high throughput and extremely high
   scalability. */

#include "../fd_disco_base.h"

/* Beyond the standard FD_CNC_SIGNAL_HALT, FD_DEDUP_CNC_SIGNAL_ACK can
   be raised by a cnc thread with an open command session while the
   dedup is in the RUN state.  The dedup will transition from ACK->RUN
   the next time it processes cnc signals to indicate it is running
   normally.  If a signal other than ACK, HALT, or RUN is raised, it
   will be logged as unexpected and transitioned by back to RUN. */

#define FD_DEDUP_CNC_SIGNAL_ACK (4UL)

/* FD_DEDUP_TILE_IN_MAX and FD_DEDUP_TILE_OUT_MAX are the maximum number
   of inputs and outputs respectively that a dedup tile can have.  These
   limits are more or less arbitrary from a functional correctness POV.
   They mostly exist to set some practical upper bounds for things like
   scratch footprint.  The current value for IN_MAX is large enough to
   have every possible frag meta origin be handled by a single thread.
   (And out_max is set arbitrarily to match.) */

#define FD_DEDUP_TILE_IN_MAX  FD_FRAG_META_ORIG_MAX
#define FD_DEDUP_TILE_OUT_MAX FD_FRAG_META_ORIG_MAX

/* FD_DEDUP_TILE_SCRATCH_{ALIGN,FOOTPRINT} specify the alignment and
   footprint needed for a dedup tile scratch region that can support
   in_cnt mcaches and out_cnt reliable outputs.  ALIGN is an integer
   power of 2 of at least double cache line to mitigate various kinds of
   false sharing.  FOOTPRINT will be an integer multiple of ALIGN.
   {in,out}_cnt are assumed to be valid (i.e. at most
   FD_DEDUP_TILE_{IN,OUT}_MAX).  in_cnt and out_cnt are assumed to be
   valid and safe against multiple evaluation.  These are provided to
   facilitate compile time declarations. */

#define FD_DEDUP_TILE_SCRATCH_ALIGN (128UL)
#define FD_DEDUP_TILE_SCRATCH_FOOTPRINT( in_cnt, out_cnt )              \
  FD_LAYOUT_FINI( FD_LAYOUT_APPEND( FD_LAYOUT_APPEND( FD_LAYOUT_APPEND( \
  FD_LAYOUT_APPEND( FD_LAYOUT_APPEND( FD_LAYOUT_INIT,                   \
    64UL,             (in_cnt)*64UL                           ),        \
    alignof(ulong *), (out_cnt)*sizeof(ulong *)               ),        \
    alignof(ulong *), (out_cnt)*sizeof(ulong *)               ),        \
    alignof(ulong),   (out_cnt)*sizeof(ulong)                 ),        \
    alignof(ushort),  ((in_cnt)+(out_cnt)+1UL)*sizeof(ushort) ),        \
    FD_DEDUP_TILE_SCRATCH_ALIGN )

FD_PROTOTYPES_BEGIN

/* fd_dedup_tile deduplicates multiple fragment streams described by the
   in_mcaches into a single out_mcache that can be consumed by out_cnt
   reliable consumers and an arbitrary number of unreliable consumers.
   (While reliable consumers are simple to reason about, they have
   especially high demands on their implementation as a single slow
   reliable consumer can backpressure _all_ producers and _all_ other
   consumers using the dedup.)

   The dedup tile uses the tag cache tcache and the frag metadata
   signature field (sig) to do the deduplication.  A frag is considered
   a duplicate of another frag if its signature is found in the tcache.
   When the dedup tile encounters a frag that is not a duplicate by this
   definition, it will insert that frag's signature into the tcache
   (evicting the oldest signature in the tcache when, as is typically
   the case, the tcache is full).  That is, after startup (i.e. the
   tcache has seen at least depth unique frag signatures), this will
   discard frags that whose signatures match any of the most recent
   tcache depth unique signatures observed by the dedup tile.

   IMPORTANT!  Strictly speaking, the dedup tile does not care about the
   specifics of the tagging scheme other than signature method should
   not produce a sig of FD_TCACHE_TAG_NULL.  At the same time, this
   implementation is strongly optimized for the case where sigs for
   distinct frags are temporally uncorrelated (e.g. a quality hash of
   the frag payload).

   DEDUP TILE THROUGHPUT CAN BE SIGNIFICANTLY DEGRADED IF SIGS FOR
   DISTINCT FRAGS ARE TEMPORALLY CORRELATED.

   For example, using a raw payload sequence number for the sig is
   extremely ill advised.  But a quality integer-to-integer
   non-cryptographic full-avalanche hash of a raw payload sequence
   number can be useful especially in non-adversial cases and/or if the
   hash function used is picked randomly from a large parameterized
   family of such hashes.  Likewise, a cryptographically secure hash
   based signature is also useful here (and might already be available
   in many common use cases) as it will provides strong guarantees in
   adversarial cases.

   The order of frags among a group of streams covered by a single
   in_mcache will be preserved.  Frags from different groups of streams
   can be arbitrarily interleaved (but this makes an extreme best effort
   to avoid starvation and minimize slip between different groups of
   streams).

   The sig, chunk, sz, ctl and tsorig input fragment metadata will be
   unchanged by this tile.

   For seq, the dedup tile will resequence the unique frags from the
   in_mcaches into a new total order consistent with the above ordering
   guarantees.

   For ctl, it is up to the application to specify ctl for all streams
   covered by the in_mcaches in a non-conflicting way.  Specifically, at
   any given time, ctl.orig field should uniquely identify an active
   logical publisher such that a conusmer can correctly reassemble
   multiple fragment messages from that ctl.orig.  (As such, ctl.orig
   could be used more flexibly if an application never does multiple
   fragment messages.)

   For chunk, a consumer needs to be able to map a (ctl.orig,chunk) pair
   to an address in that consumer's local address space.  The simplest
   and most performant way to do this (especially in simple NUMA
   topologies) is to have all dcache's use the same workspace and have
   each producer reference chunks relative to the containing workspace.

   For tsorig and tspub, the dedup tile will recompute tspub for
   deduplicated fragments.  Assuming the original publisher of the frag
   set tsorig of the the fragment to when it started producing the
   message to which the frag belongs and set tspub to the timestamp to
   when it first published the frag, and that the producer, dedup and
   consumer all have access to the same clock, a downstream consumer can
   tell when a message started arriving, when it was first available to
   for consumption and (by locally reading the clock) the time when it
   actually started consuming.  And the logic for doing so on the
   consumer will be the same on the consumer regardless it is consuming
   directly or through one or more rounds of deduping.

   When this is called, the cnc should be in the BOOT state.  Returns 0
   on a successful run of the dedup tile.  That is, the tile booted
   successfully (transitioning the cnc from BOOT->RUN), ran (handling
   any application specific cnc signals while running), and (after
   receiving a HALT signal) halted successfully (transitioning the cnc
   from HALT->BOOT before return).  Returns a non-zero error code if the
   tile fails to boot up (logs details ... the cnc will not be
   transitioned from its original state and thus is likely bootable
   again if its original state was BOOT).  For maximally robust
   operation in the current implementation, all reliable consumers
   should be halted and/or caught up before this tile is halted.

   There are no theoretical restrictions on the fragment stream
   in_mcache depths.  Practically, it is recommend these be as large as
   possible, especially for bursty streams and/or a large number of
   reliable consumers.  Similarly, there is no advantage from the
   dedup's POV to using variable in_mcache depths.  But there can be
   unrelated reasons for variable mcache depths (e.g.  hardware
   requirements for a frag stream produced by custom hardware, needs for
   non-dedup consumers of individual frag streams, etc).  There might be
   some marginal theoetical memory footprint benefits to using an
   out_mcache depth smaller than in_depth when there are high levels of
   duplication but since memory footprint is relatively cheap and worst
   case usage patterns should cover the range from no duplication to
   100% duplication, this is unlikely practically to matter.  There is
   similarly no benefit from the dedup's POV to using a mcache depth
   larger than the smallest input mcache (larger cannot be fully
   utilized by the downstream outs due to the worst case scenarios with
   the smallest in mcache).

   Note that a number of tricks can be done to facilitate making this
   work with completely unreliable / non-backpressuring communications
   from producer to dedup and dedup to consumer.  The most efficient
   trick being that producers tag their payloads uniquely with the
   metadata sig.  When an unreliable consumer reads the metadata from
   the mcache, it learns the tag and then can read the payload from
   direct from the in dcache (no communication links need to be reliable
   in this regime and no verification read of the metadata is required
   either ... does require some payload formatting requirements).  This
   is currently not done in the interest of generality (more
   pedantically, this more about how applications handle fragment
   streams and less about how the dedup tile functions).

   cr_max is the maximum number of flow control credits the dedup tile
   is allowed for publishing frags to outs.  It represents the maximum
   number of frags a reliable out can lag behind the deduped stream and
   the maximum number of frags from any in mcache that might be exposed
   to the outs (because of deduplication, the _range_ of exposed frags
   might be _larger_ than cr_max).  Assuming all unique frags, in the
   general case, the optimal value is usually
   min(in[*].cr_max,out[*].lag_max).  Noting that in[*].cr_max is in
   [1,in_mcache[*].depth] and out[*].lag_max is in [1,mcache.depth],
   cr_max must be in, at a minimum,
   [1,min(in_mcache[*].depth,mcache.depth)].  If cr_max is zero, this
   use a default cr_max of min(in_mcache[*].depth,mcache.depth).  This
   is equivalent to assuming, as is typically the case, outs are allowed
   to lag the dedup by up to mcache.depth frags and in[*].cr_max is the
   same as in_mcache[*].depth.

   lazy is the ballpark interval in ns for how often to receive credits
   from an out (and, equivalently, how often to return credits to an
   in).  Too small a lazy will drown the system in cache coherence
   traffic.  Too large a lazy will kill system throughput because of
   producers stalled waiting for credits.  lazy should be roughly
   proportional to cr_max and the constant of proportionality should be
   less than the smaller of how fast a producer can generate frags / how
   fast a consumer can process frags typically.  <=0 indicates to pick a
   conservative default.

   scratch points to tile scratch memory.  fd_dedup_tile_scratch_align
   and fd_dedup_tile_scratch_footprint return the required alignment and
   footprint needed for this region.  This memory region is exclusively
   owned by the dedup tile while the tile is running and is ideally near
   the core running the dedup tile.  fd_dedup_tile_scratch_align will
   return the same value as FD_DEDUP_TILE_SCRATCH_ALIGN.  If
   (in_cnt,out_cnt) is not valid, fd_dedup_tile_scratch_footprint
   silently returns 0 so callers can diagnose configuration issues.
   Otherwise, fd_dedup_tile_scratch_footprint will return the same value
   as FD_DEDUP_TILE_SCRATCH_FOOTPRINT.

   A fd_dedup_tile will use the application regions of the fseqs and
   cncs for accumulating standard diagnostics in the standard ways.
   Except for FD_CNC_DIAG_IN_BACKP, none of the diagnostics are cleared
   at boot (as such that they can be accumulated over multiple runs).
   Clearing is up to monitoring scripts.  It is recommend that inputs
   and outputs also use their cnc and fseq application regions similarly
   for monitoring simplicity / consistency.

   The lifetime of the cnc, mcaches, fseqs, tcache, rng and scratch used
   by this tile should be a superset of this tile's lifetime.  While
   this tile is running, no other tile should use cnc for its command
   and control, modify the tcache, publish into mcache, use the rng for
   anything (and the rng should be be seeded distinctly from all other
   rngs in the system), or use scratch for anything.  This tile will act
   as a reliable consumer of in_mcache metadata.  This tile uses the
   in_fseqs passed to it in the usual consumer ways (e.g. publishing
   recent locations in the producers sequence space and updating
   consumer oriented diagnostics) and the out_fseqs passed to it in the
   usual producer ways (i.e. discovering the location of reliable
   consumers in sequence space and updating producer oriented
   diagnostics).  The in_mcache, in_fseq and out_fseq arrays will not be
   used the after the tile has successfully booted (transitioned the cnc
   from BOOT to RUN) or returned (e.g. failed to boot), whichever comes
   first. */

FD_FN_CONST ulong
fd_dedup_tile_scratch_align( void );

FD_FN_CONST ulong
fd_dedup_tile_scratch_footprint( ulong in_cnt,
                                 ulong out_cnt );

int
fd_dedup_tile( fd_cnc_t *              cnc,       /* Local join to the dedup's command-and-control */
               ulong                   in_cnt,    /* Number of input mcaches to dedup, inputs are indexed [0,in_cnt) */
               fd_frag_meta_t const ** in_mcache, /* in_mcache[in_idx] is the local join to input in_idx's mcache */
               ulong **                in_fseq,   /* in_fseq  [in_idx] is the local join to input in_idx's fseq */
               fd_tcache_t *           tcache,    /* Local join to the dedup's unique signature cache */
               fd_frag_meta_t *        mcache,    /* Local join to the dedup's frag stream output mcache */
               ulong                   out_cnt,   /* Number of reliable consumers, reliable consumers are indexed [0,out_cnt) */
               ulong **                out_fseq,  /* out_fseq[out_idx] is the local join to reliable consumer out_idx's fseq */
               ulong                   cr_max,    /* Maximum number of flow control credits, 0 means use a reasonable default */
               long                    lazy,      /* Lazyiness, <=0 means use a reasonable default */
               fd_rng_t *              rng,       /* Local join to the rng this dedup should use */
               void *                  scratch ); /* Tile scratch memory */

FD_PROTOTYPES_END

#endif /* HEADER_fd_src_disco_dedup_fd_dedup_h */

