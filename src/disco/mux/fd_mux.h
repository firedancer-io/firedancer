#ifndef HEADER_fd_src_disco_mux_fd_mux_h
#define HEADER_fd_src_disco_mux_fd_mux_h

/* fd_mux provides services to multiplex multiple streams of input
   fragments and present them to a mix of reliable and unreliable
   consumers as though they were generated by a single multi-stream
   producer.  The entire process is zero copy for the actual fragment
   payloads and thus has extremely high throughput and extremely high
   scalability. */

#include "../fd_disco_base.h"

/* Beyond the standard FD_CNC_SIGNAL_HALT, FD_MUX_CNC_SIGNAL_ACK can be
   raised by a cnc thread with an open command session while the mux is
   in the RUN state.  The mux will transition from ACK->RUN the next
   time it processes cnc signals to indicate it is running normally.  If
   a signal other than ACK, HALT, or RUN is raised, it will be logged as
   unexpected and transitioned by back to RUN. */

#define FD_MUX_CNC_SIGNAL_ACK (4UL)

/* FD_MUX_TILE_IN_MAX and FD_MUX_TILE_OUT_MAX are the maximum number of
   inputs and outputs respectively that a mux tile can have.  These
   limits are more or less arbitrary from a functional correctness POV.
   They mostly exist to set some practical upper bounds for things like
   scratch footprint.  The current value for IN_MAX is large enough to
   have every possible frag meta origin be handled by a single thread.
   (And out_max is set arbitrarily to match.) */

#define FD_MUX_TILE_IN_MAX  FD_FRAG_META_ORIG_MAX
#define FD_MUX_TILE_OUT_MAX FD_FRAG_META_ORIG_MAX

/* FD_MUX_TILE_SCRATCH_{ALIGN,FOOTPRINT} specify the alignment and
   footprint needed for a mux tile scratch region that can support
   in_cnt inputs and out_cnt outputs.  ALIGN is an integer power of 2 of
   at least be at least double cache line to mitigate various kinds of
   false sharing.  FOOTPRINT will be an integer multiple of ALIGN.
   {in,out}_cnt are assumed to be valid (i.e. at most
   FD_MUX_TILE_{IN,OUT}_MAX).  in_cnt and out_cnt are assumed to be
   valid and safe against multiple evaluation.  These are provided to
   facilitate compile time declarations. */

#define FD_MUX_TILE_SCRATCH_ALIGN (128UL)
#define FD_MUX_TILE_SCRATCH_FOOTPRINT( in_cnt, out_cnt )                \
  FD_LAYOUT_FINI( FD_LAYOUT_APPEND( FD_LAYOUT_APPEND( FD_LAYOUT_APPEND( \
  FD_LAYOUT_APPEND( FD_LAYOUT_APPEND( FD_LAYOUT_INIT,                   \
    64UL,             (in_cnt)*64UL                           ),        \
    alignof(ulong *), (out_cnt)*sizeof(ulong *)               ),        \
    alignof(ulong *), (out_cnt)*sizeof(ulong *)               ),        \
    alignof(ulong),   (out_cnt)*sizeof(ulong)                 ),        \
    alignof(ushort),  ((in_cnt)+(out_cnt)+1UL)*sizeof(ushort) ),        \
    FD_MUX_TILE_SCRATCH_ALIGN )

FD_PROTOTYPES_BEGIN

/* fd_mux_tile multiplex fragment streams provided through in_cnt
   in_mcache's that has to out_cnt reliable consumers and an arbitrary
   number of unreliable consumers.  (While reliable consumers are simple
   to reason about, they have especially high demands on their
   implementation as a single slow reliable consumer can backpressure
   _all_ producers and _all_ other consumers using the mux.)

   No frags will be filtered by the multiplexer currently.  The order of
   frags among a group of streams covered by a single in_mcache will be
   preserved.  Frags from different groups of streams can be arbitrarily
   interleaved (but this makes an extreme best effort to avoid
   starvation and minimize slip between different groups of streams).

   The signature, chunk, sz, ctl and tsorig input fragment metadata will
   be unchanged by this tile.

   For seq, the mux tile will resequence the frags from all the mcache's
   into a new total order consistent with the above.

   For ctl, it is up to the application to specify ctl.orig for all
   streams covered by the in_mcache's in a non-conflicting way.
   Specifically, at any given time, ctl.orig field should unique
   identify an active logical publisher such that a conusmer can
   correctly reassemble multiple fragment messages from that ctl.orig.
   (As such, ctl.orig could be used more flexible if an application
   never does multiple fragment messages.)

   For chunk, a consumer needs to be able to map a (ctl.orig,chunk) pair
   to an address in that consumer's local address space.  The simplest
   and most performant way to do this (especially in simple NUMA
   topologies) is to have all dcache's use the same workspace and have
   each producer reference chunks relative to the containing workspace.

   For tsorig and tspub, the mux tile will recompute tspub for
   multiplexed fragments.  Assuming the original publisher of the frag
   set tsorig of the the fragment to when it started producing the
   message to which the frag belongs and set tspub to the timestamp to
   when it first published the frag, and that the producer, mux and
   consumer all have access to the same clock, a downstream consumer can
   tell when a message started arriving, when it was first available to
   for consumption and (by locally reading the clock) the time when it
   actually started consuming.  And the logic for doing so on the
   consumer will be the same on the consumer regardless it is consuming
   directly or through one or more rounds of multiplexing.

   When this is called, the cnc should be in the BOOT state.  Returns 0
   on a successful run of the mux tile.  That is, the tile booted
   successfully (transitioning the cnc from BOOT->RUN), ran (handling
   any application specific cnc signals while running), and (after
   receiving a HALT signal) halted successfully (transitioning the cnc
   from HALT->BOOT before return).  Returns a non-zero error code if the
   tile fails to boot up (logs details ... the cnc will not be
   transitioned from its original state and thus is likely bootable
   again if its original state was BOOT).  For maximally robust
   operation in the current implementation, all reliable consumers
   should be halted and/or caught up before this tile is halted.

   There are no theoretical restrictions on the fragment stream mcache
   depths.  Practically, it is recommend these be as large as possible,
   especially for bursty streams and/or a large number of reliable
   consumers.  Likewise, there is no benefit from the mux's POV to using
   a mcache depth different from the smallest input mcache depth
   (smaller can underutilize the input mcaches and larger cannot be
   fully utilized by the downstream outs due to the worst case scenarios
   with the smallest in mcache).  Similarly, there is no advantage from
   the mux's POV to using variable in_mcache depths.  But there can be
   unrelated reasons for variable mcache depths (e.g. hardware
   requirements for a frag stream produced by custom hardware, needs for
   non-mux consumers of individual frag streams, etc).

   Note that a number of tricks can be done to facilitate making this
   work with completely unreliable / non-backpressuring communications
   from producer to mux and mux to consumer.  The most efficient trick
   being that producers tag their payloads uniquely and include that tag
   in metadata (e.g.  use the signature).  When an unreliable consumer
   reads the metadata from the mcache, it learns the tag and then can
   read the payload from direct from the in dcache (no communication
   links need to be reliable in this regime and no verification read of
   the metadata is required either ... does require a tagging method,
   payload formatting requirements and using up some metadata signature
   bits).  This is currently not done in the interest of generality
   (more pedantically, this more about how applications handle fragment
   streams and less about how the mux tile functions).

   cr_max is the maximum number of flow control credits the mux tile is
   allowed for publishing frags to outs.  It represents the maximum
   number of frags a reliable out can lag behind the multiplexed stream
   and the maximum number of frags from any in mcache that might be
   exposed to the outs.  In the general case, the optimal value is
   usually min(in[*].cr_max,out[*].lag_max).  Noting that in[*].cr_max
   is in [1,in_mcache[*].depth] and out[*].lag_max is in
   [1,mcache.depth], cr_max must be in, at a minimum,
   [1,min(in_mcache[*].depth,mcache.depth)].  If cr_max is zero, this
   use a default cr_max of min(in_mcache[*].depth,mcache.depth).  This
   is equivalent to assuming, as is typically the case, outs are allowed
   to lag the mux by up to mcache.depth frags and in[*].cr_max is the
   same as in_mcache[*].depth.

   lazy is the ballpark interval in ns for how often to receive credits
   from an out (and, equivalently, how often to return credits to an
   in).  Too small a lazy will drown the system in cache coherence
   traffic.  Too large a lazy will kill system throughput because of
   producers stalled waiting for credits.  lazy should be roughly
   proportional to cr_max and the constant of proportionality should be
   less than the smaller of how fast a producer can generate frags / how
   fast a consumer can process frags typically.  <=0 indicates to pick a
   conservative default.

   scratch points to tile scratch memory.  fd_mux_tile_scratch_align and
   fd_mux_tile_scratch_footprint return the required alignment and
   footprint needed for this region.  This memory region is exclusively
   owned by the mux tile while the tile is running and is ideally near
   the core running the mux tile.  fd_mux_tile_scratch_align will return
   the same value as FD_MUX_TILE_SCRATCH_ALIGN.  If (in_cnt,out_cnt) is
   not valid, fd_mux_tile_scratch_footprint silently returns 0 so
   callers can diagnose configuration issues.  Otherwise,
   fd_mux_tile_scratch_footprint will return the same value as
   FD_MUX_TILE_SCRATCH_FOOTPRINT.

   A fd_mux_tile will use the application regions of the fseqs and cncs
   for accumulating standard diagnostics in the standard ways.  Except
   for FD_CNC_DIAG_IN_BACKP, none of the diagnostics are cleared at (as
   such that they can be accumulated over multiple runs).  Clearing is
   up to monitoring scripts.  It is recommend that inputs and outputs
   also use their cnc and fseq application regions similarly for
   monitoring simplicity / consistency.
   
   The lifetime of the cnc, mcaches, fseqs, rng and scratch used by this
   tile should be a superset of this tile's lifetime.  While this tile
   is running, no other tile should use cnc for its command and control,
   publish into mcache, use the rng for anything (and the rng should be
   be seeded distinctly from all other rngs in the system), or use
   scratch for anything.  This tile will act as a reliable consumer of
   in_mcache metadata.  This tile uses the in_fseqs passed to it in the
   usual consumer ways (e.g. publishing recent locations in the
   producers sequence space and updating consumer oriented diagnostics)
   and the out_fseqs passed to it in the usual producer ways (i.e.
   discovering the location of reliable consumers in sequence space and
   updating producer oriented diagnostics).  The in_mcache, in_fseq and
   out_fseq arrays will not be used the after the tile has successfully
   booted (transitioned the cnc from BOOT to RUN) or returned (e.g.
   failed to boot), whichever comes first. */

FD_FN_CONST ulong
fd_mux_tile_scratch_align( void );

FD_FN_CONST ulong
fd_mux_tile_scratch_footprint( ulong in_cnt,
                               ulong out_cnt );

int
fd_mux_tile( fd_cnc_t *              cnc,       /* Local join to the mux's command-and-control */
             ulong                   in_cnt,    /* Number of input mcaches to multiplex, inputs are indexed [0,in_cnt) */
             fd_frag_meta_t const ** in_mcache, /* in_mcache[in_idx] is the local join to input in_idx's mcache */
             ulong **                in_fseq,   /* in_fseq  [in_idx] is the local join to input in_idx's fseq */
             fd_frag_meta_t *        mcache,    /* Local join to the mux's frag stream output mcache */
             ulong                   out_cnt,   /* Number of reliable consumers, reliable consumers are indexed [0,out_cnt) */
             ulong **                out_fseq,  /* out_fseq[out_idx] is the local join to reliable consumer out_idx's fseq */
             ulong                   cr_max,    /* Maximum number of flow control credits, 0 means use a reasonable default */
             long                    lazy,      /* Lazyiness, <=0 means use a reasonable default */
             fd_rng_t *              rng,       /* Local join to the rng this mux should use */
             void *                  scratch ); /* Tile scratch memory */

FD_PROTOTYPES_END

#endif /* HEADER_fd_src_disco_mux_fd_mux_h */

