import xml.etree.ElementTree as ET
from collections import defaultdict
import re
import os

def parse_metrics(xml_data):
    root = ET.fromstring(xml_data)
    groups = []  # List to hold all groups
    for group_element in root.findall('group'):
        group_name = group_element.attrib['name']
        group_tile = group_element.attrib['tile']
        metrics = []  # List to hold all metrics within a group
        for metric_element in group_element:
            metric = {
                'type': metric_element.tag,
                'name': metric_element.attrib['name'],  # No longer prepending group_name
                'units': metric_element.attrib['units'],
                'summary': metric_element.find('summary').text if metric_element.find('summary') is not None else None,
                'variants': None
            }
            variants_element = metric_element.find('variants')
            if variants_element is not None:
                metric['variants'] = {
                    'name': variants_element.attrib['name'],
                    'variant_names': [variant.attrib['name'] for variant in variants_element.findall('variant')]
                }
            metrics.append(metric)  # Append each metric to the metrics list
        # Create a dictionary for each group, containing its name, tiles, and metrics
        group_dict = {
            'name': group_name,
            'tile': group_tile,
            'metrics': metrics
        }
        groups.append(group_dict)  # Append each group dictionary to the groups list
    return groups  # Return the list of groups

OFFSETS = {
    'counter': 1,
    'gauge': 1,
    'histogram': 17, # 16 buckets + 1 for the sum
}

if __name__ == '__main__':
    with open('metrics.xml', 'r') as f:
        xml_data = f.read()

    groups = parse_metrics(xml_data)
    print(groups)

    os.makedirs('generated', exist_ok=True)  # Ensure the directory exists

    all_offset = 0
    max_offset = 0
    for tile in ['all', 'quic']:
        with open(f'generated/fd_metrics_{tile}.h', 'w') as f:
            f.write('/* THIS FILE IS GENERATED BY gen_metrics.py. DO NOT HAND EDIT. */\n')
            if tile != 'all':
                f.write('#include "fd_metrics_all.h"\n')

            offset = all_offset
            for group in groups:
                if tile==group['tile']:
                    f.write(f'\n#define FD_METRICS_GROUP_{group["name"].upper()}_OFF ({offset}UL)\n\n')
                    for metric in group['metrics']:
                        if metric['variants'] is not None:
                            for variant in metric['variants']['variant_names']:
                                name = metric['name'].replace(f"{{{metric['variants']['name']}}}", variant)
                                name = re.sub(r'(?<!^)(?=[A-Z])', '_', name).upper()
                                f.write(f'#define FD_METRICS_{group["name"].upper()}_{name}_OFF ({offset}UL)\n')
                                offset += OFFSETS[metric['type']]
                        else:
                            name = re.sub(r'(?<!^)(?=[A-Z])', '_', metric['name']).upper()
                            f.write(f'#define FD_METRICS_{group["name"].upper()}_{name}_OFF ({offset}UL)\n')
                            offset += OFFSETS[metric['type']]
            if tile == 'all':
                all_offset = offset
            max_offset = max(max_offset, offset)

    with open('generated/fd_metrics_all.h', 'a') as f:
        # Kind of a hack for now.  Different tiles should get a different size.
        f.write(f'\n#define FD_METRICS_TOTAL_SZ (8UL*{max_offset}UL)\n')
