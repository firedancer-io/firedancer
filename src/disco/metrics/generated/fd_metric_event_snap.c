/* THIS FILE IS GENERATED BY gen_metrics.py. DO NOT HAND EDIT. */
#include "fd_metric_event_snap.h"

#include "../fd_metrics.h"
static inline ulong
find_producer_out_idx( fd_topo_t *      topo,
                       fd_topo_tile_t * producer,
                       fd_topo_tile_t * consumer,
                       ulong            consumer_in_idx ) {
  ulong reliable_cons_cnt = 0UL;
  for( ulong i=0UL; i<topo->tile_cnt; i++ ) {
    fd_topo_tile_t * consumer_tile = &topo->tiles[ i ];
    for( ulong j=0UL; j<consumer_tile->in_cnt; j++ ) {
      for( ulong k=0UL; k<producer->out_cnt; k++ ) {
        if( FD_UNLIKELY( consumer_tile->in_link_id[ j ]==producer->out_link_id[ k ] && consumer_tile->in_link_reliable[ j ] ) ) {
          if( FD_UNLIKELY( consumer==consumer_tile && consumer_in_idx==j ) ) return reliable_cons_cnt;
          reliable_cons_cnt++;
        }
      }
    }
  }

  return ULONG_MAX;
}
void
fd_metric_event_snap( fd_topo_t *                 topo,
                      fd_event_metrics_sample_t * event ) {
  uchar * buffer = (uchar *)event;

  for( ulong i=0UL; i<event->tile_len; i++ ) {
    fd_event_metrics_sample_tile_t * event_tile = ((fd_event_metrics_sample_tile_t *)(buffer+event->tile_off))+i;
    fd_topo_tile_t const * tile = &topo->tiles[ i ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
    event_tile->context_switch_involuntary_count = metrics[ MIDX( COUNTER, TILE, CONTEXT_SWITCH_INVOLUNTARY_COUNT ) ];
    event_tile->context_switch_voluntary_count = metrics[ MIDX( COUNTER, TILE, CONTEXT_SWITCH_VOLUNTARY_COUNT ) ];
    event_tile->status = metrics[ MIDX( GAUGE, TILE, STATUS ) ];
    event_tile->heartbeat = metrics[ MIDX( GAUGE, TILE, HEARTBEAT ) ];
    event_tile->in_backpressure = metrics[ MIDX( GAUGE, TILE, IN_BACKPRESSURE ) ];
    event_tile->backpressure_count = metrics[ MIDX( COUNTER, TILE, BACKPRESSURE_COUNT ) ];
    event_tile->regime_duration_nanos.caught_up_housekeeping = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_CAUGHT_UP_HOUSEKEEPING ) ];
    event_tile->regime_duration_nanos.processing_housekeeping = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_PROCESSING_HOUSEKEEPING ) ];
    event_tile->regime_duration_nanos.backpressure_housekeeping = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_BACKPRESSURE_HOUSEKEEPING ) ];
    event_tile->regime_duration_nanos.caught_up_prefrag = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_CAUGHT_UP_PREFRAG ) ];
    event_tile->regime_duration_nanos.processing_prefrag = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_PROCESSING_PREFRAG ) ];
    event_tile->regime_duration_nanos.backpressure_prefrag = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_BACKPRESSURE_PREFRAG ) ];
    event_tile->regime_duration_nanos.caught_up_postfrag = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_CAUGHT_UP_POSTFRAG ) ];
    event_tile->regime_duration_nanos.processing_postfrag = metrics[ MIDX( COUNTER, TILE, REGIME_DURATION_NANOS_PROCESSING_POSTFRAG ) ];
  }

  ulong link_idx = 0UL;
  for( ulong i=0UL; i<topo->tile_cnt; i++ ) {
    fd_topo_tile_t * tile = &topo->tiles[ i ];
    ulong in_idx = 0UL;
    for( ulong j=0UL; j<tile->in_cnt; j++ ) {
      if( FD_UNLIKELY( !tile->in_link_poll[ j ] ) ) continue;

      fd_event_metrics_sample_link_t * link = ((fd_event_metrics_sample_link_t *)(buffer+event->link_off))+link_idx;
      volatile ulong const * metrics = fd_metrics_link_in( tile->metrics, in_idx );

      link->consumed_count = metrics[ MIDX( COUNTER, LINK, CONSUMED_COUNT ) ];
      link->consumed_size_bytes = metrics[ MIDX( COUNTER, LINK, CONSUMED_SIZE_BYTES ) ];
      link->filtered_count = metrics[ MIDX( COUNTER, LINK, FILTERED_COUNT ) ];
      link->filtered_size_bytes = metrics[ MIDX( COUNTER, LINK, FILTERED_SIZE_BYTES ) ];
      link->overrun_polling_count = metrics[ MIDX( COUNTER, LINK, OVERRUN_POLLING_COUNT ) ];
      link->overrun_polling_frag_count = metrics[ MIDX( COUNTER, LINK, OVERRUN_POLLING_FRAG_COUNT ) ];
      link->overrun_reading_count = metrics[ MIDX( COUNTER, LINK, OVERRUN_READING_COUNT ) ];
      link->overrun_reading_frag_count = metrics[ MIDX( COUNTER, LINK, OVERRUN_READING_FRAG_COUNT ) ];

      fd_topo_tile_t * producer = &topo->tiles[ fd_topo_find_link_producer( topo, &topo->links[ tile->in_link_id[ j ] ] ) ];
      ulong producer_out_idx = find_producer_out_idx( topo, producer, tile, j );
      metrics = fd_metrics_link_out( producer->metrics, producer_out_idx );
      link->slow_count = metrics[ MIDX( COUNTER, LINK, SLOW_COUNT ) ];

      in_idx++;
      link_idx++;
    }
  }

  for( ulong i=0UL; i<event->net_len; i++ ) {
    fd_event_metrics_sample_net_t * net = ((fd_event_metrics_sample_net_t *)(buffer+event->net_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "net", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)net; (void)metrics;

    net->received_packets = metrics[ MIDX( COUNTER, NET, RECEIVED_PACKETS ) ];
    net->received_bytes = metrics[ MIDX( COUNTER, NET, RECEIVED_BYTES ) ];
    net->sent_packets = metrics[ MIDX( COUNTER, NET, SENT_PACKETS ) ];
    net->sent_bytes = metrics[ MIDX( COUNTER, NET, SENT_BYTES ) ];
    net->xdp_rx_dropped_ring_full = metrics[ MIDX( COUNTER, NET, XDP_RX_DROPPED_RING_FULL ) ];
    net->xdp_rx_dropped_other = metrics[ MIDX( COUNTER, NET, XDP_RX_DROPPED_OTHER ) ];
    net->tx_dropped = metrics[ MIDX( COUNTER, NET, TX_DROPPED ) ];
  }

  for( ulong i=0UL; i<event->quic_len; i++ ) {
    fd_event_metrics_sample_quic_t * quic = ((fd_event_metrics_sample_quic_t *)(buffer+event->quic_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "quic", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)quic; (void)metrics;

    quic->txns_overrun = metrics[ MIDX( COUNTER, QUIC, TXNS_OVERRUN ) ];
    quic->txn_reasms_started = metrics[ MIDX( COUNTER, QUIC, TXN_REASMS_STARTED ) ];
    quic->txn_reasms_active = metrics[ MIDX( GAUGE, QUIC, TXN_REASMS_ACTIVE ) ];
    quic->frags_ok = metrics[ MIDX( COUNTER, QUIC, FRAGS_OK ) ];
    quic->frags_gap = metrics[ MIDX( COUNTER, QUIC, FRAGS_GAP ) ];
    quic->frags_dup = metrics[ MIDX( COUNTER, QUIC, FRAGS_DUP ) ];
    quic->txns_received.udp = metrics[ MIDX( COUNTER, QUIC, TXNS_RECEIVED_UDP ) ];
    quic->txns_received.quic_fast = metrics[ MIDX( COUNTER, QUIC, TXNS_RECEIVED_QUIC_FAST ) ];
    quic->txns_received.quic_frag = metrics[ MIDX( COUNTER, QUIC, TXNS_RECEIVED_QUIC_FRAG ) ];
    quic->txns_abandoned = metrics[ MIDX( COUNTER, QUIC, TXNS_ABANDONED ) ];
    quic->quic_packet_too_small = metrics[ MIDX( COUNTER, QUIC, QUIC_PACKET_TOO_SMALL ) ];
    quic->quic_txn_too_small = metrics[ MIDX( COUNTER, QUIC, QUIC_TXN_TOO_SMALL ) ];
    quic->quic_txn_too_large = metrics[ MIDX( COUNTER, QUIC, QUIC_TXN_TOO_LARGE ) ];
    quic->non_quic_packet_too_small = metrics[ MIDX( COUNTER, QUIC, NON_QUIC_PACKET_TOO_SMALL ) ];
    quic->non_quic_packet_too_large = metrics[ MIDX( COUNTER, QUIC, NON_QUIC_PACKET_TOO_LARGE ) ];
    quic->received_packets = metrics[ MIDX( COUNTER, QUIC, RECEIVED_PACKETS ) ];
    quic->received_bytes = metrics[ MIDX( COUNTER, QUIC, RECEIVED_BYTES ) ];
    quic->sent_packets = metrics[ MIDX( COUNTER, QUIC, SENT_PACKETS ) ];
    quic->sent_bytes = metrics[ MIDX( COUNTER, QUIC, SENT_BYTES ) ];
    quic->connections_active = metrics[ MIDX( GAUGE, QUIC, CONNECTIONS_ACTIVE ) ];
    quic->connections_created = metrics[ MIDX( COUNTER, QUIC, CONNECTIONS_CREATED ) ];
    quic->connections_closed = metrics[ MIDX( COUNTER, QUIC, CONNECTIONS_CLOSED ) ];
    quic->connections_aborted = metrics[ MIDX( COUNTER, QUIC, CONNECTIONS_ABORTED ) ];
    quic->connections_timed_out = metrics[ MIDX( COUNTER, QUIC, CONNECTIONS_TIMED_OUT ) ];
    quic->connections_retried = metrics[ MIDX( COUNTER, QUIC, CONNECTIONS_RETRIED ) ];
    quic->connection_error_no_slots = metrics[ MIDX( COUNTER, QUIC, CONNECTION_ERROR_NO_SLOTS ) ];
    quic->connection_error_retry_fail = metrics[ MIDX( COUNTER, QUIC, CONNECTION_ERROR_RETRY_FAIL ) ];
    quic->pkt_crypto_failed = metrics[ MIDX( COUNTER, QUIC, PKT_CRYPTO_FAILED ) ];
    quic->pkt_no_conn = metrics[ MIDX( COUNTER, QUIC, PKT_NO_CONN ) ];
    quic->pkt_tx_alloc_fail = metrics[ MIDX( COUNTER, QUIC, PKT_TX_ALLOC_FAIL ) ];
    quic->handshakes_created = metrics[ MIDX( COUNTER, QUIC, HANDSHAKES_CREATED ) ];
    quic->handshake_error_alloc_fail = metrics[ MIDX( COUNTER, QUIC, HANDSHAKE_ERROR_ALLOC_FAIL ) ];
    quic->stream_received_events = metrics[ MIDX( COUNTER, QUIC, STREAM_RECEIVED_EVENTS ) ];
    quic->stream_received_bytes = metrics[ MIDX( COUNTER, QUIC, STREAM_RECEIVED_BYTES ) ];
    quic->received_frames.unknown = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_UNKNOWN ) ];
    quic->received_frames.ack = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_ACK ) ];
    quic->received_frames.reset_stream = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_RESET_STREAM ) ];
    quic->received_frames.stop_sending = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_STOP_SENDING ) ];
    quic->received_frames.crypto = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_CRYPTO ) ];
    quic->received_frames.new_token = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_NEW_TOKEN ) ];
    quic->received_frames.stream = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_STREAM ) ];
    quic->received_frames.max_data = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_MAX_DATA ) ];
    quic->received_frames.max_stream_data = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_MAX_STREAM_DATA ) ];
    quic->received_frames.max_streams = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_MAX_STREAMS ) ];
    quic->received_frames.data_blocked = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_DATA_BLOCKED ) ];
    quic->received_frames.stream_data_blocked = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_STREAM_DATA_BLOCKED ) ];
    quic->received_frames.streams_blocked = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_STREAMS_BLOCKED ) ];
    quic->received_frames.new_conn_id = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_NEW_CONN_ID ) ];
    quic->received_frames.retire_conn_id = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_RETIRE_CONN_ID ) ];
    quic->received_frames.path_challenge = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_PATH_CHALLENGE ) ];
    quic->received_frames.path_response = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_PATH_RESPONSE ) ];
    quic->received_frames.conn_close_quic = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_CONN_CLOSE_QUIC ) ];
    quic->received_frames.conn_close_app = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_CONN_CLOSE_APP ) ];
    quic->received_frames.handshake_done = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_HANDSHAKE_DONE ) ];
    quic->received_frames.ping = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_PING ) ];
    quic->received_frames.padding = metrics[ MIDX( COUNTER, QUIC, RECEIVED_FRAMES_PADDING ) ];
    quic->ack_tx.noop = metrics[ MIDX( COUNTER, QUIC, ACK_TX_NOOP ) ];
    quic->ack_tx.new = metrics[ MIDX( COUNTER, QUIC, ACK_TX_NEW ) ];
    quic->ack_tx.merged = metrics[ MIDX( COUNTER, QUIC, ACK_TX_MERGED ) ];
    quic->ack_tx.drop = metrics[ MIDX( COUNTER, QUIC, ACK_TX_DROP ) ];
    quic->ack_tx.cancel = metrics[ MIDX( COUNTER, QUIC, ACK_TX_CANCEL ) ];
    quic->frame_fail_parse = metrics[ MIDX( COUNTER, QUIC, FRAME_FAIL_PARSE ) ];
  }

  for( ulong i=0UL; i<event->verify_len; i++ ) {
    fd_event_metrics_sample_verify_t * verify = ((fd_event_metrics_sample_verify_t *)(buffer+event->verify_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "verify", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)verify; (void)metrics;

    verify->transaction_parse_failure = metrics[ MIDX( COUNTER, VERIFY, TRANSACTION_PARSE_FAILURE ) ];
    verify->transaction_dedup_failure = metrics[ MIDX( COUNTER, VERIFY, TRANSACTION_DEDUP_FAILURE ) ];
    verify->transaction_verify_failure = metrics[ MIDX( COUNTER, VERIFY, TRANSACTION_VERIFY_FAILURE ) ];
  }

  for( ulong i=0UL; i<event->dedup_len; i++ ) {
    fd_event_metrics_sample_dedup_t * dedup = ((fd_event_metrics_sample_dedup_t *)(buffer+event->dedup_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "dedup", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)dedup; (void)metrics;

    dedup->transaction_dedup_failure = metrics[ MIDX( COUNTER, DEDUP, TRANSACTION_DEDUP_FAILURE ) ];
    dedup->gossiped_votes_received = metrics[ MIDX( COUNTER, DEDUP, GOSSIPED_VOTES_RECEIVED ) ];
  }

  for( ulong i=0UL; i<event->resolv_len; i++ ) {
    fd_event_metrics_sample_resolv_t * resolv = ((fd_event_metrics_sample_resolv_t *)(buffer+event->resolv_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "resolv", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)resolv; (void)metrics;

    resolv->no_bank_drop = metrics[ MIDX( COUNTER, RESOLV, NO_BANK_DROP ) ];
    resolv->lut_resolved.invalid_lookup_index = metrics[ MIDX( COUNTER, RESOLV, LUT_RESOLVED_INVALID_LOOKUP_INDEX ) ];
    resolv->lut_resolved.account_uninitialized = metrics[ MIDX( COUNTER, RESOLV, LUT_RESOLVED_ACCOUNT_UNINITIALIZED ) ];
    resolv->lut_resolved.invalid_account_data = metrics[ MIDX( COUNTER, RESOLV, LUT_RESOLVED_INVALID_ACCOUNT_DATA ) ];
    resolv->lut_resolved.invalid_account_owner = metrics[ MIDX( COUNTER, RESOLV, LUT_RESOLVED_INVALID_ACCOUNT_OWNER ) ];
    resolv->lut_resolved.account_not_found = metrics[ MIDX( COUNTER, RESOLV, LUT_RESOLVED_ACCOUNT_NOT_FOUND ) ];
    resolv->lut_resolved.success = metrics[ MIDX( COUNTER, RESOLV, LUT_RESOLVED_SUCCESS ) ];
    resolv->blockhash_expired = metrics[ MIDX( COUNTER, RESOLV, BLOCKHASH_EXPIRED ) ];
    resolv->blockhash_unknown = metrics[ MIDX( COUNTER, RESOLV, BLOCKHASH_UNKNOWN ) ];
  }

  for( ulong i=0UL; i<event->pack_len; i++ ) {
    fd_event_metrics_sample_pack_t * pack = ((fd_event_metrics_sample_pack_t *)(buffer+event->pack_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "pack", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)pack; (void)metrics;

    pack->normal_transaction_received = metrics[ MIDX( COUNTER, PACK, NORMAL_TRANSACTION_RECEIVED ) ];
    pack->transaction_inserted.bundle_blacklist = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_BUNDLE_BLACKLIST ) ];
    pack->transaction_inserted.write_sysvar = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_WRITE_SYSVAR ) ];
    pack->transaction_inserted.estimation_fail = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_ESTIMATION_FAIL ) ];
    pack->transaction_inserted.duplicate_account = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_DUPLICATE_ACCOUNT ) ];
    pack->transaction_inserted.too_many_accounts = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_TOO_MANY_ACCOUNTS ) ];
    pack->transaction_inserted.too_large = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_TOO_LARGE ) ];
    pack->transaction_inserted.expired = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_EXPIRED ) ];
    pack->transaction_inserted.addr_lut = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_ADDR_LUT ) ];
    pack->transaction_inserted.unaffordable = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_UNAFFORDABLE ) ];
    pack->transaction_inserted.duplicate = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_DUPLICATE ) ];
    pack->transaction_inserted.priority = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_PRIORITY ) ];
    pack->transaction_inserted.nonvote_add = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_NONVOTE_ADD ) ];
    pack->transaction_inserted.vote_add = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_VOTE_ADD ) ];
    pack->transaction_inserted.nonvote_replace = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_NONVOTE_REPLACE ) ];
    pack->transaction_inserted.vote_replace = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_VOTE_REPLACE ) ];
    pack->metric_timing.no_txn_no_bank_no_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_NO_BANK_NO_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.txn_no_bank_no_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_NO_BANK_NO_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.no_txn_bank_no_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_BANK_NO_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.txn_bank_no_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_BANK_NO_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.no_txn_no_bank_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_NO_BANK_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.txn_no_bank_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_NO_BANK_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.no_txn_bank_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_BANK_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.txn_bank_leader_no_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_BANK_LEADER_NO_MICROBLOCK ) ];
    pack->metric_timing.no_txn_no_bank_no_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_NO_BANK_NO_LEADER_MICROBLOCK ) ];
    pack->metric_timing.txn_no_bank_no_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_NO_BANK_NO_LEADER_MICROBLOCK ) ];
    pack->metric_timing.no_txn_bank_no_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_BANK_NO_LEADER_MICROBLOCK ) ];
    pack->metric_timing.txn_bank_no_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_BANK_NO_LEADER_MICROBLOCK ) ];
    pack->metric_timing.no_txn_no_bank_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_NO_BANK_LEADER_MICROBLOCK ) ];
    pack->metric_timing.txn_no_bank_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_NO_BANK_LEADER_MICROBLOCK ) ];
    pack->metric_timing.no_txn_bank_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_NO_TXN_BANK_LEADER_MICROBLOCK ) ];
    pack->metric_timing.txn_bank_leader_microblock = metrics[ MIDX( COUNTER, PACK, METRIC_TIMING_TXN_BANK_LEADER_MICROBLOCK ) ];
    pack->transaction_dropped_from_extra = metrics[ MIDX( COUNTER, PACK, TRANSACTION_DROPPED_FROM_EXTRA ) ];
    pack->transaction_inserted_to_extra = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_TO_EXTRA ) ];
    pack->transaction_inserted_from_extra = metrics[ MIDX( COUNTER, PACK, TRANSACTION_INSERTED_FROM_EXTRA ) ];
    pack->transaction_expired = metrics[ MIDX( COUNTER, PACK, TRANSACTION_EXPIRED ) ];
    pack->available_transactions = metrics[ MIDX( GAUGE, PACK, AVAILABLE_TRANSACTIONS ) ];
    pack->available_vote_transactions = metrics[ MIDX( GAUGE, PACK, AVAILABLE_VOTE_TRANSACTIONS ) ];
    pack->pending_transactions_heap_size = metrics[ MIDX( GAUGE, PACK, PENDING_TRANSACTIONS_HEAP_SIZE ) ];
    pack->conflicting_transactions = metrics[ MIDX( GAUGE, PACK, CONFLICTING_TRANSACTIONS ) ];
    pack->smallest_pending_transaction = metrics[ MIDX( GAUGE, PACK, SMALLEST_PENDING_TRANSACTION ) ];
    pack->microblock_per_block_limit = metrics[ MIDX( COUNTER, PACK, MICROBLOCK_PER_BLOCK_LIMIT ) ];
    pack->data_per_block_limit = metrics[ MIDX( COUNTER, PACK, DATA_PER_BLOCK_LIMIT ) ];
    pack->transaction_schedule.taken = metrics[ MIDX( COUNTER, PACK, TRANSACTION_SCHEDULE_TAKEN ) ];
    pack->transaction_schedule.cu_limit = metrics[ MIDX( COUNTER, PACK, TRANSACTION_SCHEDULE_CU_LIMIT ) ];
    pack->transaction_schedule.fast_path = metrics[ MIDX( COUNTER, PACK, TRANSACTION_SCHEDULE_FAST_PATH ) ];
    pack->transaction_schedule.byte_limit = metrics[ MIDX( COUNTER, PACK, TRANSACTION_SCHEDULE_BYTE_LIMIT ) ];
    pack->transaction_schedule.write_cost = metrics[ MIDX( COUNTER, PACK, TRANSACTION_SCHEDULE_WRITE_COST ) ];
    pack->transaction_schedule.slow_path = metrics[ MIDX( COUNTER, PACK, TRANSACTION_SCHEDULE_SLOW_PATH ) ];
    pack->cus_consumed_in_block = metrics[ MIDX( GAUGE, PACK, CUS_CONSUMED_IN_BLOCK ) ];
    pack->delete_missed = metrics[ MIDX( COUNTER, PACK, DELETE_MISSED ) ];
    pack->delete_hit = metrics[ MIDX( COUNTER, PACK, DELETE_HIT ) ];
  }

  for( ulong i=0UL; i<event->bank_len; i++ ) {
    fd_event_metrics_sample_bank_t * bank = ((fd_event_metrics_sample_bank_t *)(buffer+event->bank_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "bank", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)bank; (void)metrics;

    bank->transaction_sanitize_failure = metrics[ MIDX( COUNTER, BANK, TRANSACTION_SANITIZE_FAILURE ) ];
    bank->transaction_not_executed_failure = metrics[ MIDX( COUNTER, BANK, TRANSACTION_NOT_EXECUTED_FAILURE ) ];
    bank->precompile_verify_failure = metrics[ MIDX( COUNTER, BANK, PRECOMPILE_VERIFY_FAILURE ) ];
    bank->slot_acquire.success = metrics[ MIDX( COUNTER, BANK, SLOT_ACQUIRE_SUCCESS ) ];
    bank->slot_acquire.too_high = metrics[ MIDX( COUNTER, BANK, SLOT_ACQUIRE_TOO_HIGH ) ];
    bank->slot_acquire.too_low = metrics[ MIDX( COUNTER, BANK, SLOT_ACQUIRE_TOO_LOW ) ];
    bank->transaction_load_address_tables.success = metrics[ MIDX( COUNTER, BANK, TRANSACTION_LOAD_ADDRESS_TABLES_SUCCESS ) ];
    bank->transaction_load_address_tables.slot_hashes_sysvar_not_found = metrics[ MIDX( COUNTER, BANK, TRANSACTION_LOAD_ADDRESS_TABLES_SLOT_HASHES_SYSVAR_NOT_FOUND ) ];
    bank->transaction_load_address_tables.account_not_found = metrics[ MIDX( COUNTER, BANK, TRANSACTION_LOAD_ADDRESS_TABLES_ACCOUNT_NOT_FOUND ) ];
    bank->transaction_load_address_tables.invalid_account_owner = metrics[ MIDX( COUNTER, BANK, TRANSACTION_LOAD_ADDRESS_TABLES_INVALID_ACCOUNT_OWNER ) ];
    bank->transaction_load_address_tables.invalid_account_data = metrics[ MIDX( COUNTER, BANK, TRANSACTION_LOAD_ADDRESS_TABLES_INVALID_ACCOUNT_DATA ) ];
    bank->transaction_load_address_tables.invalid_index = metrics[ MIDX( COUNTER, BANK, TRANSACTION_LOAD_ADDRESS_TABLES_INVALID_INDEX ) ];
    bank->transaction_result.success = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_SUCCESS ) ];
    bank->transaction_result.account_in_use = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_ACCOUNT_IN_USE ) ];
    bank->transaction_result.account_loaded_twice = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_ACCOUNT_LOADED_TWICE ) ];
    bank->transaction_result.account_not_found = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_ACCOUNT_NOT_FOUND ) ];
    bank->transaction_result.program_account_not_found = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_PROGRAM_ACCOUNT_NOT_FOUND ) ];
    bank->transaction_result.insufficient_funds_for_fee = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INSUFFICIENT_FUNDS_FOR_FEE ) ];
    bank->transaction_result.invalid_account_for_fee = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_ACCOUNT_FOR_FEE ) ];
    bank->transaction_result.already_processed = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_ALREADY_PROCESSED ) ];
    bank->transaction_result.blockhash_not_found = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_BLOCKHASH_NOT_FOUND ) ];
    bank->transaction_result.instruction_error = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INSTRUCTION_ERROR ) ];
    bank->transaction_result.call_chain_too_deep = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_CALL_CHAIN_TOO_DEEP ) ];
    bank->transaction_result.missing_signature_for_fee = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_MISSING_SIGNATURE_FOR_FEE ) ];
    bank->transaction_result.invalid_account_index = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_ACCOUNT_INDEX ) ];
    bank->transaction_result.signature_failure = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_SIGNATURE_FAILURE ) ];
    bank->transaction_result.invalid_program_for_execution = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_PROGRAM_FOR_EXECUTION ) ];
    bank->transaction_result.sanitize_failure = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_SANITIZE_FAILURE ) ];
    bank->transaction_result.cluster_maintenance = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_CLUSTER_MAINTENANCE ) ];
    bank->transaction_result.account_borrow_outstanding = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_ACCOUNT_BORROW_OUTSTANDING ) ];
    bank->transaction_result.would_exceed_max_block_cost_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_WOULD_EXCEED_MAX_BLOCK_COST_LIMIT ) ];
    bank->transaction_result.unsupported_version = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_UNSUPPORTED_VERSION ) ];
    bank->transaction_result.invalid_writable_account = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_WRITABLE_ACCOUNT ) ];
    bank->transaction_result.would_exceed_max_account_cost_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT ) ];
    bank->transaction_result.would_exceed_account_data_block_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT ) ];
    bank->transaction_result.too_many_account_locks = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_TOO_MANY_ACCOUNT_LOCKS ) ];
    bank->transaction_result.address_lookup_table_not_found = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_ADDRESS_LOOKUP_TABLE_NOT_FOUND ) ];
    bank->transaction_result.invalid_address_lookup_table_owner = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_ADDRESS_LOOKUP_TABLE_OWNER ) ];
    bank->transaction_result.invalid_address_lookup_table_data = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_ADDRESS_LOOKUP_TABLE_DATA ) ];
    bank->transaction_result.invalid_address_lookup_table_index = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_ADDRESS_LOOKUP_TABLE_INDEX ) ];
    bank->transaction_result.invalid_rent_paying_account = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_RENT_PAYING_ACCOUNT ) ];
    bank->transaction_result.would_exceed_max_vote_cost_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_WOULD_EXCEED_MAX_VOTE_COST_LIMIT ) ];
    bank->transaction_result.would_exceed_account_data_total_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT ) ];
    bank->transaction_result.duplicate_instruction = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_DUPLICATE_INSTRUCTION ) ];
    bank->transaction_result.insufficient_funds_for_rent = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INSUFFICIENT_FUNDS_FOR_RENT ) ];
    bank->transaction_result.max_loaded_accounts_data_size_exceeded = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED ) ];
    bank->transaction_result.invalid_loaded_accounts_data_size_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT ) ];
    bank->transaction_result.resanitization_needed = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_RESANITIZATION_NEEDED ) ];
    bank->transaction_result.program_execution_temporarily_restricted = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED ) ];
    bank->transaction_result.unbalanced_transaction = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_UNBALANCED_TRANSACTION ) ];
    bank->transaction_result.program_cache_hit_max_limit = metrics[ MIDX( COUNTER, BANK, TRANSACTION_RESULT_PROGRAM_CACHE_HIT_MAX_LIMIT ) ];
    bank->processing_failed = metrics[ MIDX( COUNTER, BANK, PROCESSING_FAILED ) ];
    bank->fee_only_transactions = metrics[ MIDX( COUNTER, BANK, FEE_ONLY_TRANSACTIONS ) ];
    bank->executed_failed_transactions = metrics[ MIDX( COUNTER, BANK, EXECUTED_FAILED_TRANSACTIONS ) ];
    bank->successful_transactions = metrics[ MIDX( COUNTER, BANK, SUCCESSFUL_TRANSACTIONS ) ];
    bank->cost_model_undercount = metrics[ MIDX( COUNTER, BANK, COST_MODEL_UNDERCOUNT ) ];
  }

  for( ulong i=0UL; i<event->shred_len; i++ ) {
    fd_event_metrics_sample_shred_t * shred = ((fd_event_metrics_sample_shred_t *)(buffer+event->shred_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "shred", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)shred; (void)metrics;

    shred->microblocks_abandoned = metrics[ MIDX( COUNTER, SHRED, MICROBLOCKS_ABANDONED ) ];
    shred->shred_processed.bad_slot = metrics[ MIDX( COUNTER, SHRED, SHRED_PROCESSED_BAD_SLOT ) ];
    shred->shred_processed.parse_failed = metrics[ MIDX( COUNTER, SHRED, SHRED_PROCESSED_PARSE_FAILED ) ];
    shred->shred_processed.rejected = metrics[ MIDX( COUNTER, SHRED, SHRED_PROCESSED_REJECTED ) ];
    shred->shred_processed.ignored = metrics[ MIDX( COUNTER, SHRED, SHRED_PROCESSED_IGNORED ) ];
    shred->shred_processed.okay = metrics[ MIDX( COUNTER, SHRED, SHRED_PROCESSED_OKAY ) ];
    shred->shred_processed.completes = metrics[ MIDX( COUNTER, SHRED, SHRED_PROCESSED_COMPLETES ) ];
    shred->fec_set_spilled = metrics[ MIDX( COUNTER, SHRED, FEC_SET_SPILLED ) ];
    shred->shred_rejected_initial = metrics[ MIDX( COUNTER, SHRED, SHRED_REJECTED_INITIAL ) ];
    shred->fec_rejected_fatal = metrics[ MIDX( COUNTER, SHRED, FEC_REJECTED_FATAL ) ];
  }

  for( ulong i=0UL; i<event->store_len; i++ ) {
    fd_event_metrics_sample_store_t * store = ((fd_event_metrics_sample_store_t *)(buffer+event->store_off))+i;

    fd_topo_tile_t const * tile = &topo->tiles[ fd_topo_find_tile( topo, "store", i ) ];
    volatile ulong const * metrics = fd_metrics_tile( tile->metrics );
   (void)store; (void)metrics;

    store->transactions_inserted = metrics[ MIDX( COUNTER, STORE, TRANSACTIONS_INSERTED ) ];
  }

}

