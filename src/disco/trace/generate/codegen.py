from .types import *
from pathlib import Path


def _render_arg_list(args: list[Arg]) -> str:
    if len(args) == 0:
        return "void"
    return ", ".join(f"{arg.type.c_type()} {arg.name}" for arg in args)


def _render_arg(arg: Arg, strtab: StringTable):
    yield f"/* Argument '{arg.type.c_type()} {arg.name}' */"
    arg_size = arg.size()
    name_ref = strtab[arg.name]
    base_expr = f"({arg.type.c_enum()}) | ({arg_size<<3}<<4) | ({name_ref}<<16)"
    if arg.type == ArgType.S32:
        base_expr += f" | (((ulong)(uint){arg.name})<<32)"
    elif arg.type == ArgType.U32 or arg.type == ArgType.BOOL:
        base_expr += f" | (((ulong){arg.name})<<32)"
    yield base_expr + ","
    if (
        arg.type == ArgType.S64
        or arg.type == ArgType.F64
        or arg.type == ArgType.POINTER
    ):
        yield f"(ulong){arg.name},"
    elif arg.type == ArgType.U64 or arg.type == ArgType.KOI:
        yield f"{arg.name},"
    else:
        raise ValueError(f"Unsupported arg type {arg.type}")


def _write_rec_publish(rec_size: int, f):
    if rec_size == 8:
        print("  fd_fxt_pub_rec1( fd_fxt_pub_cur, words[0] );", file=f)
    elif rec_size == 16:
        print("  fd_fxt_pub_rec2( fd_fxt_pub_cur, words[0], words[1] );", file=f)
    else:
        print(
            f"  memcpy( fd_fxt_pub_rec_prepare( fd_fxt_pub_cur ), words, sizeof(words) );",
            file=f,
        )
        print(f"  fd_fxt_pub_rec_publish( fd_fxt_pub_cur, sizeof(words) );", file=f)


def _write_instant(event: Event, f):
    print(f"static inline void fd_trace_{event.name}( void ) {{", file=f)
    print("}", file=f)


def _write_duration(event: Event, cat: str, strtab: StringTable, f):
    cat_ref = strtab[cat]
    name_ref = strtab[event.name]
    arg_list = _render_arg_list(event.args)

    fixed_size = EventType.DURATION.min_size()

    enter_size = fixed_size + sum(arg.type.size() for arg in event.args)
    print(f"static inline void", file=f)
    print(f"fd_trace_{event.name}_enter( {arg_list} ) {{", file=f)
    print(f"  ulong const words[] = {{", file=f)
    print(f"    fd_fxt_rec_event_hdr(", file=f)
    print(f"      /* rec_sz     */ {enter_size}UL,", file=f)
    print(f"      /* event_type */ FD_FXT_EVENT_DURATION_BEGIN,", file=f)
    print(f"      /* arg_cnt    */ {len(event.args)}UL,", file=f)
    print(f"      /* thread_ref */ fd_fxt_pub_cur->thread_id,", file=f)
    print(f"      /* cat_ref    */ {cat_ref}UL,", file=f)
    print(f"      /* name_ref   */ {name_ref}UL ),", file=f)
    print(f"    (ulong)fd_tickcount(),", file=f)
    for arg in event.args:
        for line in _render_arg(arg, strtab):
            print(f"    {line}", file=f)
    print("  };", file=f)
    _write_rec_publish(enter_size, f)
    print("}\n", file=f)

    exit_size = fixed_size
    print(f"static inline void", file=f)
    print(f"fd_trace_{event.name}_exit( void ) {{", file=f)
    print(f"  ulong const words[] = {{", file=f)
    print(f"    fd_fxt_rec_event_hdr(", file=f)
    print(f"      /* rec_sz     */ {exit_size}UL,", file=f)
    print(f"      /* event_type */ FD_FXT_EVENT_DURATION_END,", file=f)
    print(f"      /* arg_cnt    */ 0UL,", file=f)
    print(f"      /* thread_ref */ fd_fxt_pub_cur->thread_id,", file=f)
    print(f"      /* cat_ref    */ {cat_ref}UL,", file=f)
    print(f"      /* name_ref   */ {name_ref}UL ),", file=f)
    print(f"    (ulong)fd_tickcount(),", file=f)
    print("  };", file=f)
    _write_rec_publish(exit_size, f)
    print("}\n", file=f)


def _write_event(event: Event, cat: str, strtab: StringTable, f):
    if event.type == EventType.INSTANT:
        _write_instant(event, f)
    elif event.type == EventType.DURATION:
        _write_duration(event, cat, strtab, f)


def _write_category(category: Category, strtab: StringTable, out_dir: Path):
    header_path = out_dir / f"fd_trace_{category.name}.h"
    with open(header_path, "w") as f:
        f.write("/* THIS FILE IS GENERATED BY gen_tracing.py. DO NOT HAND EDIT. */\n\n")
        f.write('#include "../../../tango/fxt/fd_fxt_proto.h"\n')
        f.write('#include "../fd_trace_target.h"\n\n')
        for event in category.events.values():
            _write_event(event, category.name, strtab, f)


def write_codegen(traces: Traces, strtab: StringTable, out_dir: Path):
    for category in traces.categories.values():
        _write_category(category, strtab, out_dir)
