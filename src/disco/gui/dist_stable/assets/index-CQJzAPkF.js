var _a2;
import { r as p, R as D, a as yr, b as bl, u as Pl, p as El, j as Vi, g as Dl, c as Ml, d as xl } from "./index-ay792E1i.js";
var Ut = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = false, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, i) {
    const s = t ? this.allAsyncListeners : this.allSyncListeners;
    let o = s.get(e);
    return !o && i && (o = /* @__PURE__ */ new Set(), s.set(e, o)), o;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, i = false) {
    this.getListeners(e, i, true).add(t);
  }
  removeEventListener(e, t, i = false) {
    const s = this.getListeners(e, i, false);
    s && (s.delete(t), s.size === 0 && (i ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = false) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = false) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    const t = e;
    this.dispatchToListeners(t, true), this.dispatchToListeners(t, false), this.firedEvents[t.type] = true;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const i = e.type;
    if (t && "event" in e) {
      const l = e.event;
      l instanceof Event && (e.eventPath = l.composedPath());
    }
    const s = (l, a) => l.forEach((c) => {
      if (!a.has(c)) return;
      const u = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => c(e)) : () => c(e);
      t ? this.dispatchAsync(u) : u();
    }), o = this.getListeners(i, t, false) ?? /* @__PURE__ */ new Set(), r = new Set(o);
    r.size > 0 && s(r, o), new Set(t ? this.globalAsyncListeners : this.globalSyncListeners).forEach((l) => {
      const a = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => l(i, e)) : () => l(i, e);
      t ? this.dispatchAsync(a) : a();
    });
  }
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = true;
    }
  }
  flushAsyncQueue() {
    this.scheduled = false;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
}, ht = ((e) => (e.CommunityCoreModule = "@ag-grid-community/core", e.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", e.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", e.CsvExportModule = "@ag-grid-community/csv-export", e.EnterpriseCoreModule = "@ag-grid-enterprise/core", e.RowGroupingModule = "@ag-grid-enterprise/row-grouping", e.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", e.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", e.MenuModule = "@ag-grid-enterprise/menu", e.SetFilterModule = "@ag-grid-enterprise/set-filter", e.MultiFilterModule = "@ag-grid-enterprise/multi-filter", e.StatusBarModule = "@ag-grid-enterprise/status-bar", e.SideBarModule = "@ag-grid-enterprise/side-bar", e.RangeSelectionModule = "@ag-grid-enterprise/range-selection", e.MasterDetailModule = "@ag-grid-enterprise/master-detail", e.RichSelectModule = "@ag-grid-enterprise/rich-select", e.GridChartsModule = "@ag-grid-enterprise/charts", e.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", e.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", e.ExcelExportModule = "@ag-grid-enterprise/excel-export", e.ClipboardModule = "@ag-grid-enterprise/clipboard", e.SparklinesModule = "@ag-grid-enterprise/sparklines", e.AdvancedFilterModule = "@ag-grid-enterprise/advanced-filter", e.AngularModule = "@ag-grid-community/angular", e.ReactModule = "@ag-grid-community/react", e.VueModule = "@ag-grid-community/vue", e))(ht || {}), Vo = {};
function Xs(e, t) {
  Vo[t] || (e(), Vo[t] = true);
}
function at(e, ...t) {
  console.log("AG Grid: " + e, ...t);
}
function F(e, ...t) {
  Xs(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function z(e, ...t) {
  Xs(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function Js(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function Al(e) {
  Tl(e, 400);
}
var hs = [], gs = false;
function Bo(e) {
  hs.push(e), !gs && (gs = true, window.setTimeout(() => {
    const t = hs.slice();
    hs.length = 0, gs = false, t.forEach((i) => i());
  }, 0));
}
function Tl(e, t = 0) {
  e.length > 0 && window.setTimeout(() => e.forEach((i) => i()), t);
}
function Re(e, t) {
  let i;
  return function(...s) {
    const o = this;
    window.clearTimeout(i), i = window.setTimeout(function() {
      e.apply(o, s);
    }, t);
  };
}
function Wo(e, t) {
  let i = 0;
  return function(...s) {
    const o = this, r = (/* @__PURE__ */ new Date()).getTime();
    r - i < t || (i = r, e.apply(o, s));
  };
}
function Il(e, t, i = 100, s) {
  const o = (/* @__PURE__ */ new Date()).getTime();
  let r = null, n = false;
  const l = () => {
    const a = (/* @__PURE__ */ new Date()).getTime() - o > i;
    (e() || a) && (t(), n = true, r != null && (window.clearInterval(r), r = null));
  };
  l(), n || (r = window.setInterval(l, 10));
}
function Ll(...e) {
  return (t) => e.reduce((i, s) => s(i), t);
}
function Je(e) {
  return e == null || e === "" ? null : e;
}
function E(e, t = false) {
  return e != null && (e !== "" || t);
}
function V(e) {
  return !E(e);
}
function Me(e) {
  return e == null || e.length === 0;
}
function xs(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function yt(e) {
  if (e === void 0) return;
  if (e === null || e === "") return null;
  if (typeof e == "number") return isNaN(e) ? void 0 : e;
  const t = parseInt(e, 10);
  return isNaN(t) ? void 0 : t;
}
function As(e) {
  if (e !== void 0) return e === null || e === "" ? false : Ts(e);
}
function Ts(e) {
  return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : false;
}
function Bi(e, t) {
  const i = e ? JSON.stringify(e) : null, s = t ? JSON.stringify(t) : null;
  return i === s;
}
function Ol(e, t, i = false) {
  const s = e == null, o = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), s && o) return 0;
  if (s) return -1;
  if (o) return 1;
  function r(n, l) {
    return n > l ? 1 : n < l ? -1 : 0;
  }
  if (typeof e != "string" || !i) return r(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return r(e, t);
  }
}
function Li(e) {
  if (e instanceof Set || e instanceof Map) {
    const t = [];
    return e.forEach((i) => t.push(i)), t;
  }
  return Object.values(e);
}
function Rr(e, t) {
  return e.get("rowModelType") === t;
}
function Q(e) {
  return Rr(e, "clientSide");
}
function it(e) {
  return Rr(e, "serverSide");
}
function he(e, t) {
  return e.get("domLayout") === t;
}
function Wi(e) {
  return Ui(e) !== void 0;
}
function zi(e) {
  return !e.get("suppressAsyncEvents");
}
function Fr(e) {
  return typeof e.get("getRowHeight") == "function";
}
function Gl(e, t) {
  return t ? !e.get("enableStrictPivotColumnOrder") : e.get("maintainColumnOrder");
}
function ut(e, t, i = false, s) {
  if (s == null && (s = e.environment.getDefaultRowHeight()), Fr(e)) {
    if (i) return { height: s, estimated: true };
    const n = { node: t, data: t.data }, l = e.getCallback("getRowHeight")(n);
    if (Is(l)) return l === 0 && F("The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."), { height: Math.max(1, l), estimated: false };
  }
  if (t.detail && e.get("masterDetail")) return kl(e);
  const o = e.get("rowHeight");
  return { height: o && Is(o) ? o : s, estimated: false };
}
function kl(e) {
  if (e.get("detailRowAutoHeight")) return { height: 1, estimated: false };
  const t = e.get("detailRowHeight");
  return Is(t) ? { height: t, estimated: false } : { height: 300, estimated: false };
}
function ts(e) {
  const { environment: t } = e, i = e.get("rowHeight");
  if (!i || V(i)) return t.getDefaultRowHeight();
  const s = t.refreshRowHeightVariable();
  return s !== -1 ? s : (F("row height must be a number if not using standard row model"), t.getDefaultRowHeight());
}
function Is(e) {
  return !isNaN(e) && typeof e == "number" && isFinite(e);
}
function ui(e, t, i) {
  const s = t[e.getDomDataKey()];
  return s ? s[i] : void 0;
}
function Et(e, t, i, s) {
  const o = e.getDomDataKey();
  let r = t[o];
  V(r) && (r = {}, t[o] = r), r[i] = s;
}
function re(e) {
  let t = null;
  const i = e.get("getDocument");
  return i && E(i) ? t = i() : e.eGridDiv && (t = e.eGridDiv.ownerDocument), t && E(t) ? t : document;
}
function br(e) {
  return re(e).defaultView || window;
}
function di(e) {
  return e.eGridDiv.getRootNode();
}
function te(e) {
  return di(e).activeElement;
}
function Pr(e) {
  const t = re(e), i = te(e);
  return i === null || i === t.body;
}
function Nt(e) {
  return e.get("ensureDomOrder") ? false : e.get("animateRows");
}
function is(e) {
  return !(e.get("paginateChildRows") || e.get("groupHideOpenParents") || he(e, "print"));
}
function _e(e) {
  var _a3;
  return !((_a3 = e.get("autoGroupColumnDef")) == null ? void 0 : _a3.comparator) && !e.get("treeData");
}
function Ls(e) {
  const t = e.get("groupAggFiltering");
  if (typeof t == "function") return e.getCallback("groupAggFiltering");
  if (t === true) return () => true;
}
function Er(e) {
  const t = e.get("grandTotalRow");
  if (t) return t;
  if (e.get("groupIncludeTotalFooter")) return "bottom";
}
function Dr(e) {
  const t = e.get("groupTotalRow");
  if (typeof t == "function") return e.getCallback("groupTotalRow");
  if (t) return () => t;
  const i = e.get("groupIncludeFooter");
  if (typeof i == "function") {
    const s = e.getCallback("groupIncludeFooter");
    return (o) => s(o) ? "bottom" : void 0;
  }
  return () => i ? "bottom" : void 0;
}
function Mr(e) {
  return e.exists("groupDisplayType") ? e.get("groupDisplayType") === "multipleColumns" : e.get("groupHideOpenParents");
}
function ss(e, t) {
  return t ? false : e.get("groupDisplayType") === "groupRows";
}
function Ci(e) {
  const t = e.getCallback("getRowId");
  return t === void 0 ? t : (i) => {
    let s = t(i);
    return typeof s != "string" && (F("The getRowId callback must return a string. The ID ", s, " is being cast to a string."), s = String(s)), s;
  };
}
function Wt(e) {
  return (e == null ? void 0 : e.checkboxes) ?? true;
}
function _i(e) {
  return (e == null ? void 0 : e.mode) === "multiRow" && (e.headerCheckbox ?? true);
}
function Hl(e) {
  return (e == null ? void 0 : e.hideDisabledCheckboxes) ?? false;
}
function Nl(e) {
  return typeof e.get("rowSelection") != "string";
}
function Vl(e) {
  return e.get("cellSelection") !== void 0;
}
function Bl(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? (t == null ? void 0 : t.suppressMultiRanges) ?? false : false : e.get("suppressMultiRangeSelection");
}
function et(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? !!t : e.get("enableRangeSelection");
}
function Wl(e) {
  var _a3;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? ((_a3 = t.handle) == null ? void 0 : _a3.mode) === "range" : false : e.get("enableRangeHandle");
}
function zo(e) {
  var _a3;
  const t = e.get("cellSelection");
  return t !== void 0 ? typeof t != "boolean" ? ((_a3 = t.handle) == null ? void 0 : _a3.mode) === "fill" : false : e.get("enableFillHandle");
}
function xr(e) {
  const t = e.get("rowSelection") ?? "single";
  if (typeof t == "string") {
    const i = e.get("suppressRowClickSelection"), s = e.get("suppressRowDeselection");
    return i && s ? false : i ? "enableDeselection" : s ? "enableSelection" : true;
  }
  return t.mode === "singleRow" || t.mode === "multiRow" ? t.enableClickSelection ?? false : false;
}
function zl(e) {
  const t = xr(e);
  return t === true || t === "enableSelection";
}
function _o(e) {
  const t = xr(e);
  return t === true || t === "enableDeselection";
}
function Zs(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("isRowSelectable") : t == null ? void 0 : t.isRowSelectable;
}
function Ui(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string") switch (t) {
    case "multiple":
      return "multiRow";
    case "single":
      return "singleRow";
    default:
      return;
  }
  return t == null ? void 0 : t.mode;
}
function Ar(e) {
  return Ui(e) === "multiRow";
}
function _l(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("rowMultiSelectWithClick") : (t == null ? void 0 : t.enableSelectionWithoutKeys) ?? false;
}
function eo(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string") {
    const i = e.get("groupSelectsChildren"), s = e.get("groupSelectsFiltered");
    return i && s ? "filteredDescendants" : i ? "descendants" : "self";
  }
  return (t == null ? void 0 : t.mode) === "multiRow" ? t.groupSelects : void 0;
}
function Dt(e) {
  const t = eo(e);
  return t === "descendants" || t === "filteredDescendants";
}
function ps(e) {
  return e.isModuleRegistered("@ag-grid-enterprise/set-filter") && !e.get("suppressSetFilterByDefault");
}
function N(e) {
  if (!(!e || !e.length)) return e[e.length - 1];
}
function gt(e, t, i) {
  return e == null && t == null ? true : e != null && t != null && e.length === t.length && e.every((s, o) => i ? i(s, t[o]) : t[o] === s);
}
function Ul(e) {
  return e.sort((t, i) => t - i);
}
function Tr(e, t) {
  const i = e.indexOf(t);
  i >= 0 && (e[i] = e[e.length - 1], e.pop());
}
function Fe(e, t) {
  const i = e.indexOf(t);
  i >= 0 && e.splice(i, 1);
}
function Kl(e, t) {
  for (let i = 0; i < t.length; i++) Tr(e, t[i]);
}
function $l(e, t) {
  for (let i = 0; i < t.length; i++) Fe(e, t[i]);
}
function Ki(e, t, i) {
  e.splice(i, 0, t);
}
function Ir(e, t, i) {
  $l(e, t), t.slice().reverse().forEach((s) => Ki(e, s, i));
}
function Rt(e, t) {
  return e.indexOf(t) > -1;
}
function jl(e) {
  return (e == null ? void 0 : e.flatMap((t) => t)) ?? [];
}
function Uo(e, t) {
  t == null || e == null || t.forEach((i) => e.push(i));
}
var Lr = "__ag_Grid_Stop_Propagation", ql = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], fs = {};
function zt(e) {
  e[Lr] = true;
}
function Ze(e) {
  return e[Lr] === true;
}
var Or = /* @__PURE__ */ (() => {
  const e = { select: "input", change: "input", submit: "form", reset: "form", error: "img", load: "img", abort: "img" };
  return (i) => {
    if (typeof fs[i] == "boolean") return fs[i];
    const s = document.createElement(e[i] || "div");
    return i = "on" + i, fs[i] = i in s;
  };
})();
function Os(e, t, i) {
  let s = t;
  for (; s; ) {
    const o = ui(e, s, i);
    if (o) return o;
    s = s.parentElement;
  }
  return null;
}
function Yl(e, t) {
  return !t || !e ? false : Xl(t).indexOf(e) >= 0;
}
function Ql(e) {
  const t = [];
  let i = e.target;
  for (; i; ) t.push(i), i = i.parentElement;
  return t;
}
function Xl(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : Ql(t);
}
function Jl(e, t, i, s) {
  const r = Rt(ql, i) ? { passive: true } : void 0;
  e && e.addEventListener && e.addEventListener(t, i, s, r);
}
var R = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = false, this.__v_skip = true, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.frameworkOverrides = e.frameworkOverrides, this.stubContext = e.context, this.eventService = e.eventService, this.gos = e.gos, this.localeService = e.localeService;
  }
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  destroy() {
    for (let e = 0; e < this.destroyFunctions.length; e++) this.destroyFunctions[e]();
    this.destroyFunctions.length = 0, this.destroyed = true, this.dispatchLocalEvent({ type: "destroyed" });
  }
  addEventListener(e, t, i) {
    this.localEventService || (this.localEventService = new Ut()), this.localEventService.addEventListener(e, t, i);
  }
  removeEventListener(e, t, i) {
    this.localEventService && this.localEventService.removeEventListener(e, t, i);
  }
  dispatchLocalEvent(e) {
    this.localEventService && this.localEventService.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventService, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const i = [];
    for (const s in t) {
      const o = t[s];
      o && i.push(this._setupListener(e, s, o));
    }
    return i;
  }
  _setupListener(e, t, i) {
    if (this.destroyed) return () => null;
    e instanceof HTMLElement ? Jl(this.getFrameworkOverrides(), e, t, i) : e.addEventListener(t, i);
    const s = () => (e.removeEventListener(t, i), null);
    return this.destroyFunctions.push(s), () => (s(), this.destroyFunctions = this.destroyFunctions.filter((o) => o !== s), null);
  }
  setupGridOptionListener(e, t) {
    this.gos.addPropertyEventListener(e, t);
    const i = () => (this.gos.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter((s) => s !== i), null);
  }
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t);
  }
  addManagedPropertyListeners(e, t) {
    if (this.destroyed) return;
    const i = e.join("-") + this.propertyListenerId++, s = (o) => {
      if (o.changeSet) {
        if (o.changeSet && o.changeSet.id === this.lastChangeSetIdLookup[i]) return;
        this.lastChangeSetIdLookup[i] = o.changeSet.id;
      }
      const r = { type: "gridPropertyChanged", changeSet: o.changeSet, source: o.source };
      t(r);
    };
    e.forEach((o) => this.setupGridOptionListener(o, s));
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  createManagedBean(e, t) {
    const i = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i;
  }
  createBean(e, t, i) {
    return (t || this.stubContext).createBean(e, i);
  }
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
};
function Se(e) {
  return e instanceof Oi;
}
var Oi = class extends R {
  constructor(e, t, i, s) {
    super(), this.isColumn = false, this.expandable = false, this.instanceId = Hr(), this.expandableListenerRemoveCallback = null, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = i, this.level = s;
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : false;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? false : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      dt(t) ? e.push(t) : Se(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e) return e.columnGroupShow;
  }
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding()) return;
    let e = false, t = false, i = false;
    const s = this.findChildrenRemovingPadding();
    for (let r = 0, n = s.length; r < n; r++) {
      const l = s[r];
      if (!l.isVisible()) continue;
      const a = l.getColumnGroupShow();
      a === "open" ? (e = true, i = true) : a === "closed" ? (t = true, i = true) : (e = true, t = true);
    }
    const o = e && t && i;
    this.expandable !== o && (this.expandable = o, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (i) => {
      i.forEach((s) => {
        Se(s) && s.isPadding() ? t(s.children) : e.push(s);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, Gr = "ag-Grid-ControlsColumn", Zl = class extends R {
  constructor() {
    super(...arguments), this.beanName = "controlsColService";
  }
  createControlsCols() {
    const { gos: e } = this, t = e.get("rowSelection");
    if (!t || typeof t != "object") return [];
    const i = Wt(t), s = _i(t);
    if (i || s) {
      const o = e.get("selectionColumnDef"), n = { maxWidth: 50, resizable: false, suppressHeaderMenuButton: true, sortable: false, suppressMovable: true, lockPosition: e.get("enableRtl") ? "right" : "left", comparator(a, c, u, d) {
        const h = u.isSelected(), g = d.isSelected();
        return h && g ? 0 : h ? 1 : -1;
      }, editable: false, suppressFillHandle: true, ...o, colId: `${Gr}` }, l = new oo(n, null, n.colId, false);
      return this.createBean(l), [l];
    }
    return [];
  }
}, os = "ag-Grid-AutoColumn";
function to(e) {
  const t = [], i = (s) => {
    for (let o = 0; o < s.length; o++) {
      const r = s[o];
      dt(r) ? t.push(r) : Se(r) && i(r.getChildren());
    }
  };
  return i(e), t;
}
function Xe(e) {
  return e.reduce((t, i) => t + i.getActualWidth(), 0);
}
function lt(e, t, i) {
  const s = {};
  if (!t) return;
  tt(null, t, (r) => {
    s[r.getInstanceId()] = r;
  }), i && tt(null, i, (r) => {
    s[r.getInstanceId()] = null;
  });
  const o = Object.values(s).filter((r) => r != null);
  e.destroyBeans(o);
}
function Gs(e) {
  return e.getId().startsWith(os);
}
function vi(e) {
  return e.getColId().startsWith(Gr);
}
function Gi(e) {
  let t = [];
  return e instanceof Array ? e.some((s) => typeof s != "string") ? F("if colDef.type is supplied an array it should be of type 'string[]'") : t = e : typeof e == "string" ? t = e.split(",") : F("colDef.type should be of type 'string' | 'string[]'"), t;
}
var io = class {
  constructor(e) {
    this.frameworkOverrides = e, this.wrappedListeners = /* @__PURE__ */ new Map(), this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
  }
  wrap(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (i) => {
      this.frameworkOverrides.wrapOutgoing(() => e(i));
    }, this.wrappedListeners.set(e, t)), t;
  }
  wrapGlobal(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (i, s) => {
      this.frameworkOverrides.wrapOutgoing(() => e(i, s));
    }, this.wrappedGlobalListeners.set(e, t)), t;
  }
  unwrap(e) {
    return this.wrappedListeners.get(e) ?? e;
  }
  unwrapGlobal(e) {
    return this.wrappedGlobalListeners.get(e) ?? e;
  }
}, so = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function He(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let i = 0; i < e.length; i++) t(i.toString(), e[i]);
      return;
    }
    for (const [i, s] of Object.entries(e)) t(i, s);
  }
}
function kr(e) {
  const t = {}, i = Object.keys(e);
  for (let s = 0; s < i.length; s++) {
    if (so.has(i[s])) continue;
    const o = i[s], r = e[o];
    t[o] = r;
  }
  return t;
}
function ks(e, t) {
  if (!e) return;
  const i = e, s = {};
  return Object.keys(i).forEach((o) => {
    if (t && t.indexOf(o) >= 0 || so.has(o)) return;
    const r = i[o];
    Hs(r) && r.constructor === Object ? s[o] = ks(r) : s[o] = r;
  }), s;
}
function Ko(e) {
  if (!e) return [];
  const t = Object;
  if (typeof t.values == "function") return t.values(e);
  const i = [];
  for (const s in e) e.hasOwnProperty(s) && e.propertyIsEnumerable(s) && i.push(e[s]);
  return i;
}
function we(e, t, i = true, s = false) {
  E(t) && He(t, (o, r) => {
    if (so.has(o)) return;
    let n = e[o];
    n !== r && (s && n == null && r != null && typeof r == "object" && r.constructor === Object && (n = {}, e[o] = n), Hs(r) && Hs(n) && !Array.isArray(n) ? we(n, r, i, s) : (i || r !== void 0) && (e[o] = r));
  });
}
function ri(e, t, i) {
  if (!t || !e) return;
  if (!i) return e[t];
  const s = t.split(".");
  let o = e;
  for (let r = 0; r < s.length; r++) {
    if (o == null) return;
    o = o[s[r]];
  }
  return o;
}
function Hs(e) {
  return typeof e == "object" && e !== null;
}
var ea = { resizable: true, sortable: true }, ta = 0;
function Hr() {
  return ta++;
}
function dt(e) {
  return e instanceof oo;
}
var oo = class extends R {
  constructor(e, t, i, s) {
    super(), this.isColumn = true, this.instanceId = Hr(), this.autoHeaderHeight = null, this.moving = false, this.menuVisible = false, this.lastLeftPinned = false, this.firstRightPinned = false, this.filterActive = false, this.columnEventService = new Ut(), this.tooltipEnabled = false, this.rowGroupActive = false, this.pivotActive = false, this.aggregationActive = false, this.colDef = e, this.userProvidedColDef = t, this.colId = i, this.primary = s, this.setState(e);
  }
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(e) {
    e.sort !== void 0 ? (e.sort === "asc" || e.sort === "desc") && (this.sort = e.sort) : (e.initialSort === "asc" || e.initialSort === "desc") && (this.sort = e.initialSort);
    const t = e.sortIndex, i = e.initialSortIndex;
    t !== void 0 ? t !== null && (this.sortIndex = t) : i !== null && (this.sortIndex = i);
    const s = e.hide, o = e.initialHide;
    s !== void 0 ? this.visible = !s : this.visible = !o, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
    const r = e.flex, n = e.initialFlex;
    r !== void 0 ? this.flex = r : n !== void 0 && (this.flex = n);
  }
  setColDef(e, t, i) {
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.columnEventService.dispatchEvent(this.createColumnEvent("colDefChanged", i));
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(e) {
    this.parent = e;
  }
  getParent() {
    return this.parent;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  postConstruct() {
    this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip();
  }
  initDotNotation() {
    const e = this.gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = E(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = E(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? this.gos.environment.getDefaultColumnMinWidth(), this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    this.tooltipEnabled = E(this.colDef.tooltipField) || E(this.colDef.tooltipValueGetter) || E(this.colDef.tooltipComponent);
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, true);
  }
  calculateColInitialWidth(e) {
    let t;
    const i = yt(e.width), s = yt(e.initialWidth);
    return i != null ? t = i : s != null ? t = s : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return false;
  }
  isRowGroupDisplayed(e) {
    if (V(this.colDef) || V(this.colDef.showRowGroup)) return false;
    const t = this.colDef.showRowGroup === true, i = this.colDef.showRowGroup === e;
    return t || i;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  addEventListener(e, t) {
    var _a3;
    this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.columnEventService.setFrameworkOverrides(this.frameworkOverrides), this.frameworkEventListenerService = new io(this.frameworkOverrides));
    const i = ((_a3 = this.frameworkEventListenerService) == null ? void 0 : _a3.wrap(t)) ?? t;
    this.columnEventService.addEventListener(e, i);
  }
  removeEventListener(e, t) {
    var _a3;
    const i = ((_a3 = this.frameworkEventListenerService) == null ? void 0 : _a3.unwrap(t)) ?? t;
    this.columnEventService.removeEventListener(e, i);
  }
  createColumnFunctionCallbackParams(e) {
    return this.gos.addGridCommonParams({ node: e, data: e.data, column: this, colDef: this.colDef });
  }
  isSuppressNavigable(e) {
    if (typeof this.colDef.suppressNavigable == "boolean") return this.colDef.suppressNavigable;
    if (typeof this.colDef.suppressNavigable == "function") {
      const t = this.createColumnFunctionCallbackParams(e), i = this.colDef.suppressNavigable;
      return i(t);
    }
    return false;
  }
  isCellEditable(e) {
    if (e.group) {
      if (this.gos.get("treeData")) {
        if (!e.data && !this.gos.get("enableGroupEdit")) return false;
      } else if (!this.gos.get("enableGroupEdit")) return false;
    }
    return this.isColumnFunc(e, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    const t = this.gos.get("rowSelection");
    if (t && typeof t != "string") {
      const i = vi(this) && Wt(t);
      return this.isColumnFunc(e, i);
    } else return this.isColumnFunc(e, this.colDef.checkboxSelection);
  }
  isSuppressPaste(e) {
    return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  getColDefValue(e) {
    return this.colDef[e] ?? ea[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean") return t;
    if (typeof t == "function") {
      const i = this.createColumnFunctionCallbackParams(e);
      return t(i);
    }
    return false;
  }
  setHighlighted(e) {
    this.highlighted !== e && (this.highlighted = e, this.columnEventService.dispatchEvent(this.createColumnEvent("headerHighlightChanged", "uiColumnMoved")));
  }
  setMoving(e, t) {
    this.moving = e, this.columnEventService.dispatchEvent(this.createColumnEvent("movingChanged", t));
  }
  createColumnEvent(e, t) {
    return this.gos.addGridCommonParams({ type: e, column: this, columns: [this], source: t });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  setSort(e, t) {
    this.sort !== e && (this.sort = e, this.columnEventService.dispatchEvent(this.createColumnEvent("sortChanged", t))), this.dispatchStateUpdatedEvent("sort");
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  isSortAscending() {
    return this.sort === "asc";
  }
  isSortDescending() {
    return this.sort === "desc";
  }
  isSortNone() {
    return V(this.sort);
  }
  isSorting() {
    return E(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(e) {
    this.sortIndex = e, this.dispatchStateUpdatedEvent("sortIndex");
  }
  setMenuVisible(e, t) {
    this.menuVisible !== e && (this.menuVisible = e, this.columnEventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", t)));
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  setAggFunc(e) {
    this.aggFunc = e, this.dispatchStateUpdatedEvent("aggFunc");
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.columnEventService.dispatchEvent(this.createColumnEvent("leftChanged", t)));
  }
  isFilterActive() {
    return this.filterActive;
  }
  setFilterActive(e, t, i) {
    this.filterActive !== e && (this.filterActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", t)));
    const s = this.createColumnEvent("filterChanged", t);
    i && we(s, i), this.columnEventService.dispatchEvent(s);
  }
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(e) {
    e === true || e === "left" ? this.pinned = "left" : e === "right" ? this.pinned = "right" : this.pinned = null, this.dispatchStateUpdatedEvent("pinned");
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", t)));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", t)));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const i = e === true;
    this.visible !== i && (this.visible = i, this.columnEventService.dispatchEvent(this.createColumnEvent("visibleChanged", t))), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    return !this.getColDef().suppressSpanHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding()) return { numberOfParents: 0, isSpanningTotal: false };
    const t = e.getPaddingLevel() + 1;
    let i = true;
    for (; e; ) {
      if (!e.isPadding()) {
        i = false;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: i };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return this.gos.addGridCommonParams({ node: e, data: e.data, colDef: this.colDef, column: this });
  }
  getColSpan(e) {
    if (V(this.colDef.colSpan)) return 1;
    const t = this.createBaseColDefParams(e), i = this.colDef.colSpan(t);
    return Math.max(i, 1);
  }
  getRowSpan(e) {
    if (V(this.colDef.rowSpan)) return 1;
    const t = this.createBaseColDefParams(e), i = this.colDef.rowSpan(t);
    return Math.max(i, 1);
  }
  setActualWidth(e, t, i = false) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), i || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.columnEventService.dispatchEvent(this.createColumnEvent("widthChanged", e));
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  setFlex(e) {
    this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent("flex");
  }
  setMinimum(e) {
    this.setActualWidth(this.minWidth, e);
  }
  setRowGroupActive(e, t) {
    this.rowGroupActive !== e && (this.rowGroupActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", t))), this.dispatchStateUpdatedEvent("rowGroup");
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(e, t) {
    this.pivotActive !== e && (this.pivotActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", t))), this.dispatchStateUpdatedEvent("pivot");
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(e, t) {
    this.aggregationActive !== e && (this.aggregationActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnValueChanged", t)));
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === true;
  }
  isAllowValue() {
    return this.colDef.enableValue === true;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === true;
  }
  dispatchStateUpdatedEvent(e) {
    this.columnEventService.dispatchEvent({ type: "columnStateUpdated", key: e });
  }
}, ia = { numericColumn: { headerClass: "ag-right-aligned-header", cellClass: "ag-right-aligned-cell" }, rightAligned: { headerClass: "ag-right-aligned-header", cellClass: "ag-right-aligned-cell" } }, sa = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++) this.existingKeys[e[t]] = true;
  }
  getUniqueKey(e, t) {
    e = xs(e);
    let i = 0;
    for (; ; ) {
      let s;
      if (e ? (s = e, i !== 0 && (s += "_" + i)) : t ? (s = t, i !== 0 && (s += "_" + i)) : s = i, !this.existingKeys[s]) return this.existingKeys[s] = true, String(s);
      i++;
    }
  }
}, oa = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnFactory";
  }
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  createColumnTree(e, t, i, s) {
    const o = new sa(), { existingCols: r, existingGroups: n, existingColKeys: l } = this.extractExistingTreeData(i);
    o.addExistingKeys(l);
    const a = this.recursivelyCreateColumns(e, 0, t, r, o, n, s), c = this.findMaxDept(a, 0), u = this.balanceColumnTree(a, 0, c, o);
    return tt(null, u, (h, g) => {
      Se(h) && h.setupExpandable(), h.setOriginalParent(g);
    }), { columnTree: u, treeDept: c };
  }
  extractExistingTreeData(e) {
    const t = [], i = [], s = [];
    return e && tt(null, e, (o) => {
      if (Se(o)) {
        const r = o;
        i.push(r);
      } else {
        const r = o;
        s.push(r.getId()), t.push(r);
      }
    }), { existingCols: t, existingGroups: i, existingColKeys: s };
  }
  balanceTreeForAutoCols(e, t) {
    const i = [], s = this.findDepth(t);
    return e.forEach((o) => {
      let r = o;
      for (let n = s - 1; n >= 0; n--) {
        const l = new Oi(null, `FAKE_PATH_${o.getId()}}_${n}`, true, n);
        this.createBean(l), l.setChildren([r]), r.setOriginalParent(l), r = l;
      }
      s === 0 && o.setOriginalParent(null), i.push(r);
    }), [i, s];
  }
  findDepth(e) {
    let t = 0, i = e;
    for (; i && i[0] && Se(i[0]); ) t++, i = i[0].getChildren();
    return t;
  }
  balanceColumnTree(e, t, i, s) {
    const o = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (Se(n)) {
        const l = n, a = this.balanceColumnTree(l.getChildren(), t + 1, i, s);
        l.setChildren(a), o.push(l);
      } else {
        let l, a;
        for (let c = i - 1; c >= t; c--) {
          const u = s.getUniqueKey(null, null), d = this.createMergedColGroupDef(null), h = new Oi(d, u, true, t);
          this.createBean(h), a && a.setChildren([h]), a = h, l || (l = a);
        }
        if (l && a) if (o.push(l), e.some((u) => Se(u))) {
          a.setChildren([n]);
          continue;
        } else {
          a.setChildren(e);
          break;
        }
        o.push(n);
      }
    }
    return o;
  }
  findMaxDept(e, t) {
    let i = t;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (Se(o)) {
        const r = o, n = this.findMaxDept(r.getChildren(), t + 1);
        i < n && (i = n);
      }
    }
    return i;
  }
  recursivelyCreateColumns(e, t, i, s, o, r, n) {
    if (!e) return [];
    const l = new Array(e.length);
    for (let a = 0; a < l.length; a++) {
      const c = e[a];
      this.isColumnGroup(c) ? l[a] = this.createColumnGroup(i, c, t, s, o, r, n) : l[a] = this.createColumn(i, c, s, o, n);
    }
    return l;
  }
  createColumnGroup(e, t, i, s, o, r, n) {
    const l = this.createMergedColGroupDef(t), a = o.getUniqueKey(l.groupId || null, null), c = new Oi(l, a, false, i);
    this.createBean(c);
    const u = this.findExistingGroup(t, r);
    u && r.splice(u.idx, 1);
    const d = u == null ? void 0 : u.group;
    d && c.setExpanded(d.isExpanded());
    const h = this.recursivelyCreateColumns(l.children, i + 1, e, s, o, r, n);
    return c.setChildren(h), c;
  }
  createMergedColGroupDef(e) {
    const t = {};
    return Object.assign(t, this.gos.get("defaultColGroupDef")), Object.assign(t, e), t;
  }
  createColumn(e, t, i, s, o) {
    var _a3;
    const r = this.findExistingColumn(t, i);
    r && (i == null ? void 0 : i.splice(r.idx, 1));
    let n = r == null ? void 0 : r.column;
    if (n) {
      const l = this.addColumnDefaultAndTypes(t, n.getColId());
      n.setColDef(l, t, o), this.applyColumnState(n, l, o);
    } else {
      const l = s.getUniqueKey(t.colId, t.field), a = this.addColumnDefaultAndTypes(t, l);
      n = new oo(a, t, l, e), this.createBean(n);
    }
    return (_a3 = this.dataTypeService) == null ? void 0 : _a3.addColumnListeners(n), n;
  }
  applyColumnState(e, t, i) {
    const s = yt(t.flex);
    if (s !== void 0 && e.setFlex(s), e.getFlex() <= 0) {
      const l = yt(t.width);
      if (l != null) e.setActualWidth(l, i);
      else {
        const a = e.getActualWidth();
        e.setActualWidth(a, i);
      }
    }
    t.sort !== void 0 && (t.sort == "asc" || t.sort == "desc" ? e.setSort(t.sort, i) : e.setSort(void 0, i));
    const r = yt(t.sortIndex);
    r !== void 0 && e.setSortIndex(r);
    const n = As(t.hide);
    n !== void 0 && e.setVisible(!n, i), t.pinned !== void 0 && e.setPinned(t.pinned);
  }
  findExistingColumn(e, t) {
    if (t) for (let i = 0; i < t.length; i++) {
      const s = t[i].getUserProvidedColDef();
      if (!s) continue;
      if (e.colId != null) {
        if (t[i].getId() === e.colId) return { idx: i, column: t[i] };
        continue;
      }
      if (e.field != null) {
        if (s.field === e.field) return { idx: i, column: t[i] };
        continue;
      }
      if (s === e) return { idx: i, column: t[i] };
    }
  }
  findExistingGroup(e, t) {
    if (e.groupId != null) for (let s = 0; s < t.length; s++) {
      const o = t[s];
      if (o.getColGroupDef() && o.getId() === e.groupId) return { idx: s, group: o };
    }
  }
  addColumnDefaultAndTypes(e, t) {
    var _a3;
    const i = {}, s = this.gos.get("defaultColDef");
    we(i, s, false, true);
    const o = this.updateColDefAndGetColumnType(i, e, t);
    o && this.assignColumnTypes(o, i), we(i, e, false, true);
    const r = this.gos.get("autoGroupColumnDef"), n = _e(this.gos);
    return e.rowGroup && r && n && we(i, { sort: r.sort, initialSort: r.initialSort }, false, true), (_a3 = this.dataTypeService) == null ? void 0 : _a3.validateColDef(i), i;
  }
  updateColDefAndGetColumnType(e, t, i) {
    var _a3;
    const s = (_a3 = this.dataTypeService) == null ? void 0 : _a3.updateColDefAndGetColumnType(e, t, i), o = t.type ?? s ?? e.type;
    return e.type = o, o ? Gi(o) : void 0;
  }
  assignColumnTypes(e, t) {
    if (!e.length) return;
    const i = Object.assign({}, ia), s = this.gos.get("columnTypes") || {};
    He(s, (o, r) => {
      o in i ? F(`the column type '${o}' is a default column type and cannot be overridden.`) : (r.type && F("Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type."), i[o] = r);
    }), e.forEach((o) => {
      const r = i[o.trim()];
      r ? we(t, r, false, true) : F("colDef.type '" + o + "' does not correspond to defined gridOptions.columnTypes");
    });
  }
  isColumnGroup(e) {
    return e.children !== void 0;
  }
};
function tt(e, t, i) {
  if (t) for (let s = 0; s < t.length; s++) {
    const o = t[s];
    Se(o) && tt(o, o.getChildren(), i), i(o, e);
  }
}
var ra = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnModel", this.pivotMode = false, this.autoHeightActiveAtLeastOnce = false, this.ready = false, this.changeEventsDispatching = false, this.shouldQueueResizeOperations = false, this.resizeOperationQueue = [];
  }
  wireBeans(e) {
    this.context = e.context, this.ctrlsService = e.ctrlsService, this.columnFactory = e.columnFactory, this.columnSizeService = e.columnSizeService, this.visibleColsService = e.visibleColsService, this.columnViewportService = e.columnViewportService, this.pivotResultColsService = e.pivotResultColsService, this.columnAnimationService = e.columnAnimationService, this.autoColService = e.autoColService, this.controlsColService = e.controlsColService, this.valueCache = e.valueCache, this.columnDefFactory = e.columnDefFactory, this.columnApplyStateService = e.columnApplyStateService, this.columnGroupStateService = e.columnGroupStateService, this.eventDispatcher = e.columnEventDispatcher, this.columnMoveService = e.columnMoveService, this.columnAutosizeService = e.columnAutosizeService, this.funcColsService = e.funcColsService, this.quickFilterService = e.quickFilterService, this.showRowGroupColsService = e.showRowGroupColsService, this.environment = e.environment;
  }
  postConstruct() {
    const e = this.gos.get("pivotMode");
    this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.addManagedPropertyListeners(["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"], (t) => this.refreshAll(Ct(t.source))), this.addManagedPropertyListener("rowSelection", (t) => {
      this.onSelectionOptionsChanged(t.currentValue, t.previousValue, Ct(t.source));
    }), this.addManagedPropertyListener("autoGroupColumnDef", (t) => this.onAutoGroupColumnDefChanged(Ct(t.source))), this.addManagedPropertyListeners(["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"], (t) => this.recreateColumnDefs(Ct(t.source))), this.addManagedPropertyListener("pivotMode", (t) => this.setPivotMode(this.gos.get("pivotMode"), Ct(t.source))), this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
  }
  createColsFromColDefs(e) {
    var _a3, _b, _c2;
    const t = this.colDefs ? this.columnApplyStateService.compareColumnStatesAndDispatchEvents(e) : void 0;
    this.valueCache.expire();
    const i = (_a3 = this.colDefCols) == null ? void 0 : _a3.list, s = (_b = this.colDefCols) == null ? void 0 : _b.tree, o = this.columnFactory.createColumnTree(this.colDefs, true, s, e);
    lt(this.context, (_c2 = this.colDefCols) == null ? void 0 : _c2.tree, o.columnTree);
    const r = o.columnTree, n = o.treeDept, l = to(r), a = {};
    l.forEach((c) => a[c.getId()] = c), this.colDefCols = { tree: r, treeDepth: n, list: l, map: a }, this.funcColsService.extractCols(e, i), this.ready = true, this.refreshCols(true), this.visibleColsService.refresh(e), this.columnViewportService.checkViewportColumns(), this.eventDispatcher.everythingChanged(e), t && (this.changeEventsDispatching = true, t(), this.changeEventsDispatching = false), this.eventDispatcher.newColumnsLoaded(e), e === "gridInitializing" && this.columnSizeService.applyAutosizeStrategy();
  }
  refreshCols(e) {
    var _a3, _b, _c2;
    if (!this.colDefCols) return;
    const t = (_a3 = this.cols) == null ? void 0 : _a3.tree;
    this.saveColOrder(), this.selectCols(), this.createAutoCols(), this.addAutoCols(), this.createControlsCols(), this.addControlsCols();
    const i = Gl(this.gos, this.showingPivotResult);
    (!e || i) && this.restoreColOrder(), this.positionLockedCols(), (_b = this.showRowGroupColsService) == null ? void 0 : _b.refresh(), (_c2 = this.quickFilterService) == null ? void 0 : _c2.refreshQuickFilterCols(), this.setColSpanActive(), this.setAutoHeightActive(), this.visibleColsService.clear(), this.columnViewportService.clear(), !gt(t, this.cols.tree) && this.eventDispatcher.gridColumns();
  }
  selectCols() {
    const e = this.pivotResultColsService.getPivotResultCols();
    if (this.showingPivotResult = e != null, e) {
      const { map: t, list: i, tree: s, treeDepth: o } = e;
      this.cols = { list: i.slice(), map: { ...t }, tree: s.slice(), treeDepth: o }, e.list.some((n) => {
        var _a3;
        return ((_a3 = this.cols) == null ? void 0 : _a3.map[n.getColId()]) !== void 0;
      }) || (this.lastPivotOrder = null);
    } else {
      const { map: t, list: i, tree: s, treeDepth: o } = this.colDefCols;
      this.cols = { list: i.slice(), map: { ...t }, tree: s.slice(), treeDepth: o };
    }
  }
  getColsToShow() {
    const e = this.isPivotMode() && !this.isShowingPivotResult(), t = this.funcColsService.getValueColumns();
    return this.cols.list.filter((s) => {
      const o = Gs(s);
      if (e) {
        const r = t && Rt(t, s);
        return o || r;
      } else return o || s.isVisible();
    });
  }
  addAutoCols() {
    this.autoCols != null && (this.cols.list = this.autoCols.list.concat(this.cols.list), this.cols.tree = this.autoCols.tree.concat(this.cols.tree), $o(this.cols));
  }
  createAutoCols() {
    var _a3;
    const e = ss(this.gos, this.pivotMode), t = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol(), i = this.funcColsService.getRowGroupColumns(), o = !(i.length > 0 || this.gos.get("treeData")) || t || e, r = () => {
      this.autoCols && (lt(this.context, this.autoCols.tree), this.autoCols = null);
    };
    if (o || !this.autoColService) {
      r();
      return;
    }
    const n = this.autoColService.createAutoCols(i) ?? [], l = qo(n, ((_a3 = this.autoCols) == null ? void 0 : _a3.list) || null), a = this.cols.treeDepth, u = (this.autoCols ? this.autoCols.treeDepth : -1) == a;
    if (l && u) return;
    r();
    const [d, h] = this.columnFactory.balanceTreeForAutoCols(n, this.cols.tree);
    this.autoCols = { list: n, tree: d, treeDepth: h, map: {} };
    const g = (m) => {
      if (!m) return null;
      const C = m.filter((f) => !Gs(f));
      return [...n, ...C];
    };
    this.lastOrder = g(this.lastOrder), this.lastPivotOrder = g(this.lastPivotOrder);
  }
  createControlsCols() {
    var _a3, _b, _c2;
    const e = () => {
      var _a4;
      lt(this.context, (_a4 = this.controlsCols) == null ? void 0 : _a4.tree), this.controlsCols = null;
    };
    this.controlsColService || e();
    const t = this.cols.treeDepth, s = (((_a3 = this.controlsCols) == null ? void 0 : _a3.treeDepth) ?? -1) == t, o = ((_b = this.controlsColService) == null ? void 0 : _b.createControlsCols()) ?? [];
    if (qo(o, ((_c2 = this.controlsCols) == null ? void 0 : _c2.list) ?? []) && s) return;
    e();
    const [n, l] = this.columnFactory.balanceTreeForAutoCols(o, this.cols.tree);
    this.controlsCols = { list: o, tree: n, treeDepth: l, map: {} };
    const a = (c) => {
      if (!c) return null;
      const u = c.filter((d) => !vi(d));
      return [...o, ...u];
    };
    this.lastOrder = a(this.lastOrder), this.lastPivotOrder = a(this.lastPivotOrder);
  }
  addControlsCols() {
    this.controlsCols != null && (this.cols.list = this.controlsCols.list.concat(this.cols.list), this.cols.tree = this.controlsCols.tree.concat(this.cols.tree), $o(this.cols));
  }
  refreshAll(e) {
    this.isReady() && (this.refreshCols(false), this.visibleColsService.refresh(e));
  }
  setColsVisible(e, t = false, i) {
    this.columnApplyStateService.applyColumnState({ state: e.map((s) => ({ colId: typeof s == "string" ? s : s.getColId(), hide: !t })) }, i);
  }
  setColsPinned(e, t, i) {
    if (!this.cols || Me(e)) return;
    if (he(this.gos, "print")) {
      F("Changing the column pinning status is not allowed with domLayout='print'");
      return;
    }
    this.columnAnimationService.start();
    let s;
    t === true || t === "left" ? s = "left" : t === "right" ? s = "right" : s = null;
    const o = [];
    e.forEach((r) => {
      if (!r) return;
      const n = this.getCol(r);
      n && n.getPinned() !== s && (n.setPinned(s), o.push(n));
    }), o.length && (this.visibleColsService.refresh(i), this.eventDispatcher.columnPinned(o, i)), this.columnAnimationService.finish();
  }
  setColumnGroupOpened(e, t, i) {
    let s;
    Se(e) ? s = e.getId() : s = e || "", this.columnGroupStateService.setColumnGroupState([{ groupId: s, open: t }], i);
  }
  getProvidedColGroup(e) {
    var _a3;
    let t = null;
    return tt(null, (_a3 = this.cols) == null ? void 0 : _a3.tree, (i) => {
      Se(i) && i.getId() === e && (t = i);
    }), t;
  }
  isColGroupLocked(e) {
    const t = this.gos.get("groupLockGroupColumns");
    if (!e.isRowGroupActive() || t === 0) return false;
    if (t === -1) return true;
    const s = this.funcColsService.getRowGroupColumns().findIndex((o) => o.getColId() === e.getColId());
    return t > s;
  }
  isSuppressAutoCol() {
    return this.gos.get("groupDisplayType") === "custom" ? true : this.gos.get("treeDataDisplayType") === "custom";
  }
  setAutoHeightActive() {
    this.autoHeightActive = this.cols.list.some((e) => e.isVisible() && e.isAutoHeight()), this.autoHeightActive && (this.autoHeightActiveAtLeastOnce = true, Q(this.gos) || it(this.gos) || F("autoHeight columns only work with Client Side Row Model and Server Side Row Model."));
  }
  restoreColOrder() {
    const e = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!e) return;
    const t = new Map(e.map((a, c) => [a, c]));
    if (!this.cols.list.some((a) => t.has(a))) return;
    const s = new Map(this.cols.list.map((a) => [a, true])), o = e.filter((a) => s.has(a)), r = new Map(o.map((a) => [a, true])), n = this.cols.list.filter((a) => !r.has(a)), l = o.slice();
    n.forEach((a) => {
      let c = a.getOriginalParent();
      if (!c) {
        l.push(a);
        return;
      }
      const u = [];
      for (; !u.length && c; ) c.getLeafColumns().forEach((m) => {
        const C = l.indexOf(m) >= 0, f = u.indexOf(m) < 0;
        C && f && u.push(m);
      }), c = c.getOriginalParent();
      if (!u.length) {
        l.push(a);
        return;
      }
      const d = u.map((g) => l.indexOf(g)), h = Math.max(...d);
      Ki(l, a, h + 1);
    }), this.cols.list = l;
  }
  sortColsLikeKeys(e) {
    if (this.cols == null) return;
    let t = [];
    const i = {};
    e.forEach((o) => {
      if (i[o]) return;
      const r = this.cols.map[o];
      r && (t.push(r), i[o] = true);
    });
    let s = 0;
    if (this.cols.list.forEach((o) => {
      const r = o.getColId();
      if (i[r] != null) return;
      r.startsWith(os) ? Ki(t, o, s++) : t.push(o);
    }), t = this.columnMoveService.placeLockedColumns(t), !this.columnMoveService.doesMovePassMarryChildren(t)) {
      F("Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
      return;
    }
    this.cols.list = t;
  }
  sortColsLikeCols(e) {
    !e || e.length <= 1 || e.filter((i) => this.cols.list.indexOf(i) < 0).length > 0 || e.sort((i, s) => {
      const o = this.cols.list.indexOf(i), r = this.cols.list.indexOf(s);
      return o - r;
    });
  }
  resetColDefIntoCol(e, t) {
    const i = e.getUserProvidedColDef();
    if (!i) return false;
    const s = this.columnFactory.addColumnDefaultAndTypes(i, e.getColId());
    return e.setColDef(s, i, t), true;
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = true;
  }
  isShouldQueueResizeOperations() {
    return this.shouldQueueResizeOperations;
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = false, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e);
  }
  moveInCols(e, t, i) {
    var _a3;
    Ir((_a3 = this.cols) == null ? void 0 : _a3.list, e, t), this.visibleColsService.refresh(i);
  }
  positionLockedCols() {
    this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
  }
  saveColOrder() {
    var _a3, _b;
    this.showingPivotResult ? this.lastPivotOrder = (_a3 = this.cols) == null ? void 0 : _a3.list : this.lastOrder = (_b = this.cols) == null ? void 0 : _b.list;
  }
  getColumnDefs() {
    if (!this.colDefCols) return;
    const e = this.colDefCols.list.slice();
    this.showingPivotResult ? e.sort((s, o) => this.lastOrder.indexOf(s) - this.lastOrder.indexOf(o)) : this.lastOrder && e.sort((s, o) => this.cols.list.indexOf(s) - this.cols.list.indexOf(o));
    const t = this.funcColsService.getRowGroupColumns(), i = this.funcColsService.getPivotColumns();
    return this.columnDefFactory.buildColumnDefs(e, t, i);
  }
  isShowingPivotResult() {
    return this.showingPivotResult;
  }
  isChangeEventsDispatching() {
    return this.changeEventsDispatching;
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  isProvidedColGroupsPresent() {
    var _a3;
    return ((_a3 = this.colDefCols) == null ? void 0 : _a3.treeDepth) > 0;
  }
  setColSpanActive() {
    this.colSpanActive = this.cols.list.some((e) => e.getColDef().colSpan != null);
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  getHeaderRowCount() {
    return this.cols ? this.cols.treeDepth + 1 : -1;
  }
  isReady() {
    return this.ready;
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode) || (this.pivotMode = e, this.ready && (this.refreshCols(false), this.visibleColsService.refresh(t), this.eventDispatcher.pivotModeChanged()));
  }
  isPivotSettingAllowed(e) {
    return e && this.gos.get("treeData") ? (F("Pivot mode not available with treeData."), false) : true;
  }
  isPivotActive() {
    const e = this.funcColsService.getPivotColumns();
    return this.pivotMode && !Me(e);
  }
  recreateColumnDefs(e) {
    this.cols && (this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e), this.createColsFromColDefs(e));
  }
  setColumnDefs(e, t) {
    this.colDefs = e, this.createColsFromColDefs(t);
  }
  destroy() {
    var _a3, _b, _c2;
    lt(this.context, (_a3 = this.colDefCols) == null ? void 0 : _a3.tree), lt(this.context, (_b = this.autoCols) == null ? void 0 : _b.tree), lt(this.context, (_c2 = this.controlsCols) == null ? void 0 : _c2.tree), super.destroy();
  }
  getColTree() {
    return this.cols.tree;
  }
  getColDefColTree() {
    return this.colDefCols.tree;
  }
  getColDefCols() {
    var _a3;
    return ((_a3 = this.colDefCols) == null ? void 0 : _a3.list) ? this.colDefCols.list : null;
  }
  getCols() {
    var _a3;
    return ((_a3 = this.cols) == null ? void 0 : _a3.list) ?? [];
  }
  getAllCols() {
    var _a3, _b, _c2, _d2;
    const t = (_a3 = this.pivotResultColsService.getPivotResultCols()) == null ? void 0 : _a3.list;
    return [((_b = this.colDefCols) == null ? void 0 : _b.list) ?? [], ((_c2 = this.autoCols) == null ? void 0 : _c2.list) ?? [], ((_d2 = this.controlsCols) == null ? void 0 : _d2.list) ?? [], t ?? []].flat();
  }
  getColsForKeys(e) {
    return e ? e.map((t) => this.getCol(t)).filter((t) => t != null) : [];
  }
  getColDefCol(e) {
    var _a3;
    return ((_a3 = this.colDefCols) == null ? void 0 : _a3.list) ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  getColFromCollection(e, t) {
    if (t == null) return null;
    const { map: i, list: s } = t;
    if (typeof e == "string" && i[e]) return i[e];
    for (let o = 0; o < s.length; o++) if (jo(s[o], e)) return s[o];
    return this.getAutoCol(e);
  }
  getAutoCol(e) {
    var _a3;
    return ((_a3 = this.autoCols) == null ? void 0 : _a3.list.find((t) => jo(t, e))) ?? null;
  }
  getAutoCols() {
    var _a3;
    return ((_a3 = this.autoCols) == null ? void 0 : _a3.list) ?? null;
  }
  setColHeaderHeight(e, t) {
    e.setAutoHeaderHeight(t) && (e.isColumn ? this.eventDispatcher.headerHeight(e) : this.eventDispatcher.groupHeaderHeight(e));
  }
  getGroupRowsHeight() {
    const e = [], t = this.ctrlsService.getHeaderRowContainerCtrls();
    for (const i of t) {
      if (!i) continue;
      const s = i.getGroupRowCount() || 0;
      for (let o = 0; o < s; o++) {
        const r = i.getGroupRowCtrlAtIndex(o), n = e[o];
        if (r) {
          const l = this.getColumnGroupHeaderRowHeight(r);
          (n == null || l > n) && (e[o] = l);
        }
      }
    }
    return e;
  }
  getColumnGroupHeaderRowHeight(e) {
    const t = this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight();
    let i = 0;
    const s = e.getHeaderCtrls();
    for (const o of s) {
      const r = o.getColumn();
      if (r.isAutoHeaderHeight()) {
        const n = r.getAutoHeaderHeight();
        n != null && n > i && (i = n);
      }
    }
    return Math.max(t, i);
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(), i = this.visibleColsService.getAllCols().filter((s) => s.isAutoHeaderHeight()).map((s) => s.getAutoHeaderHeight() || 0);
    return Math.max(e, ...i);
  }
  getHeaderHeight() {
    return this.gos.get("headerHeight") ?? this.environment.getDefaultHeaderHeight();
  }
  getFloatingFiltersHeight() {
    return this.gos.get("floatingFiltersHeight") ?? this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    return this.gos.get("groupHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    return this.gos.get("pivotHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    return this.gos.get("pivotGroupHeaderHeight") ?? this.getGroupHeaderHeight();
  }
  onFirstDataRendered() {
    const e = this.gos.get("autoSizeStrategy");
    if ((e == null ? void 0 : e.type) !== "fitCellContents") return;
    const { colIds: t, skipHeader: i } = e;
    setTimeout(() => {
      t ? this.columnAutosizeService.autoSizeCols({ colKeys: t, skipHeader: i, source: "autosizeColumns" }) : this.columnAutosizeService.autoSizeAllColumns("autosizeColumns", i);
    });
  }
  onAutoGroupColumnDefChanged(e) {
    this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e);
  }
  onSelectionOptionsChanged(e, t, i) {
    const s = t && typeof t != "string" ? Wt(t) : void 0, o = e && typeof e != "string" ? Wt(e) : void 0, r = s !== o, n = t && typeof t != "string" ? _i(t) : void 0, l = e && typeof e != "string" ? _i(e) : void 0;
    (r || n !== l) && this.refreshAll(i);
  }
};
function Ct(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function $o(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function jo(e, t) {
  const i = e === t, s = e.getColDef() === t, o = e.getColId() == t;
  return i || s || o;
}
function qo(e, t) {
  return gt(e, t, (i, s) => i.getColId() === s.getColId());
}
var na = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnAutosizeService", this.timesDelayed = 0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.animationFrameService = e.animationFrameService, this.autoWidthCalculator = e.autoWidthCalculator, this.eventDispatcher = e.columnEventDispatcher, this.ctrlsService = e.ctrlsService, this.renderStatusService = e.renderStatusService;
  }
  autoSizeCols(e) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeCols(e));
      return;
    }
    const { colKeys: t, skipHeader: i, skipHeaderGroups: s, stopAtGroup: o, source: r = "api" } = e;
    if (this.animationFrameService.flushAllFrames(), this.timesDelayed < 5 && this.renderStatusService && !this.renderStatusService.areHeaderCellsRendered()) {
      this.timesDelayed++, setTimeout(() => this.autoSizeCols(e));
      return;
    }
    this.timesDelayed = 0;
    const n = [];
    let l = -1;
    const a = i ?? this.gos.get("skipHeaderOnAutoSize"), c = s ?? a;
    for (; l !== 0; ) {
      l = 0;
      const u = [];
      t.forEach((d) => {
        if (!d) return;
        const h = this.columnModel.getCol(d);
        if (!h || n.indexOf(h) >= 0) return;
        const g = this.autoWidthCalculator.getPreferredWidthForColumn(h, a);
        if (g > 0) {
          const m = this.normaliseColumnWidth(h, g);
          h.setActualWidth(m, r), n.push(h), l++;
        }
        u.push(h);
      }), u.length && this.visibleColsService.refresh(r);
    }
    c || this.autoSizeColumnGroupsByColumns(t, r, o), this.eventDispatcher.columnResized(n, true, "autosizeColumns");
  }
  autoSizeColumn(e, t, i) {
    e && this.autoSizeCols({ colKeys: [e], skipHeader: i, skipHeaderGroups: true, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, i) {
    const s = /* @__PURE__ */ new Set();
    this.columnModel.getColsForKeys(e).forEach((l) => {
      let a = l.getParent();
      for (; a && a != i; ) a.isPadding() || s.add(a), a = a.getParent();
    });
    let r;
    const n = [];
    for (const l of s) {
      for (const a of this.ctrlsService.getHeaderRowContainerCtrls()) if (r = a.getHeaderCtrlForColumn(l), r) break;
      r && r.resizeLeafColumnsToFit(t);
    }
    return n;
  }
  autoSizeAllColumns(e, t) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const i = this.visibleColsService.getAllCols();
    this.autoSizeCols({ colKeys: i, skipHeader: t, source: e });
  }
  normaliseColumnWidth(e, t) {
    const i = e.getMinWidth();
    t < i && (t = i);
    const s = e.getMaxWidth();
    return e.isGreaterThanMax(t) && (t = s), t;
  }
}, la = class extends R {
  constructor() {
    super(...arguments), this.beanName = "funcColsService", this.rowGroupCols = [], this.valueCols = [], this.pivotCols = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.aggFuncService = e.aggFuncService, this.visibleColsService = e.visibleColsService;
  }
  getModifyColumnsNoEventsCallbacks() {
    return { addGroupCol: (e) => this.rowGroupCols.push(e), removeGroupCol: (e) => Fe(this.rowGroupCols, e), addPivotCol: (e) => this.pivotCols.push(e), removePivotCol: (e) => Fe(this.pivotCols, e), addValueCol: (e) => this.valueCols.push(e), removeValueCol: (e) => Fe(this.valueCols, e) };
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t) return null;
    if (t === true) return this.rowGroupCols.slice(0);
    const i = this.columnModel.getColDefCol(t);
    return i ? [i] : null;
  }
  sortRowGroupColumns(e) {
    this.rowGroupCols.sort(e);
  }
  sortPivotColumns(e) {
    this.pivotCols.sort(e);
  }
  getValueColumns() {
    return this.valueCols ? this.valueCols : [];
  }
  getPivotColumns() {
    return this.pivotCols ? this.pivotCols : [];
  }
  getRowGroupColumns() {
    return this.rowGroupCols ? this.rowGroupCols : [];
  }
  isRowGroupEmpty() {
    return Me(this.rowGroupCols);
  }
  setColumnAggFunc(e, t, i) {
    if (!e) return;
    const s = this.columnModel.getColDefCol(e);
    s && (s.setAggFunc(t), this.eventDispatcher.columnChanged("columnValueChanged", [s], i));
  }
  setRowGroupColumns(e, t) {
    this.setColList(e, this.rowGroupCols, "columnRowGroupChanged", true, true, (i, s) => this.setRowGroupActive(i, s, t), t);
  }
  setRowGroupActive(e, t, i) {
    e !== t.isRowGroupActive() && (t.setRowGroupActive(e, i), e && !this.gos.get("suppressRowGroupHidesColumns") && this.columnModel.setColsVisible([t], false, i), !e && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup") && this.columnModel.setColsVisible([t], true, i));
  }
  addRowGroupColumns(e, t) {
    this.updateColList(e, this.rowGroupCols, true, true, (i) => this.setRowGroupActive(true, i, t), "columnRowGroupChanged", t);
  }
  removeRowGroupColumns(e, t) {
    this.updateColList(e, this.rowGroupCols, false, true, (i) => this.setRowGroupActive(false, i, t), "columnRowGroupChanged", t);
  }
  addPivotColumns(e, t) {
    this.updateColList(e, this.pivotCols, true, false, (i) => i.setPivotActive(true, t), "columnPivotChanged", t);
  }
  setPivotColumns(e, t) {
    this.setColList(e, this.pivotCols, "columnPivotChanged", true, false, (i, s) => {
      s.setPivotActive(i, t);
    }, t);
  }
  removePivotColumns(e, t) {
    this.updateColList(e, this.pivotCols, false, false, (i) => i.setPivotActive(false, t), "columnPivotChanged", t);
  }
  setValueColumns(e, t) {
    this.setColList(e, this.valueCols, "columnValueChanged", false, false, (i, s) => this.setValueActive(i, s, t), t);
  }
  setValueActive(e, t, i) {
    if (e !== t.isValueActive() && (t.setValueActive(e, i), e && !t.getAggFunc() && this.aggFuncService)) {
      const s = this.aggFuncService.getDefaultAggFunc(t);
      t.setAggFunc(s);
    }
  }
  addValueColumns(e, t) {
    this.updateColList(e, this.valueCols, true, false, (i) => this.setValueActive(true, i, t), "columnValueChanged", t);
  }
  removeValueColumns(e, t) {
    this.updateColList(e, this.valueCols, false, false, (i) => this.setValueActive(false, i, t), "columnValueChanged", t);
  }
  moveRowGroupColumn(e, t, i) {
    if (this.isRowGroupEmpty()) return;
    const s = this.rowGroupCols[e], o = this.rowGroupCols.slice(e, t);
    this.rowGroupCols.splice(e, 1), this.rowGroupCols.splice(t, 0, s), this.eventDispatcher.rowGroupChanged(o, i);
  }
  setColList(e, t, i, s, o, r, n) {
    if (!this.columnModel.getCols()) return;
    const l = /* @__PURE__ */ new Map();
    t.forEach((c, u) => l.set(c, u)), t.length = 0, E(e) && e.forEach((c) => {
      const u = this.columnModel.getColDefCol(c);
      u && t.push(u);
    }), t.forEach((c, u) => {
      const d = l.get(c);
      if (d === void 0) {
        l.set(c, 0);
        return;
      }
      s && d !== u || l.delete(c);
    }), (this.columnModel.getColDefCols() || []).forEach((c) => {
      const u = t.indexOf(c) >= 0;
      r(u, c);
    }), o && this.columnModel.refreshCols(false), this.visibleColsService.refresh(n), this.eventDispatcher.columnChanged(i, [...l.keys()], n);
  }
  updateColList(e, t, i, s, o, r, n) {
    if (!e || Me(e)) return;
    let l = false;
    const a = /* @__PURE__ */ new Set();
    e.forEach((c) => {
      if (!c) return;
      const u = this.columnModel.getColDefCol(c);
      if (u) {
        if (a.add(u), i) {
          if (t.indexOf(u) >= 0) return;
          t.push(u);
        } else {
          const d = t.indexOf(u);
          if (d < 0) return;
          for (let h = d + 1; h < t.length; h++) a.add(t[h]);
          Fe(t, u);
        }
        o(u), l = true;
      }
    }), l && (s && this.columnModel.refreshCols(false), this.visibleColsService.refresh(n), this.eventDispatcher.genericColumnEvent(r, Array.from(a), n));
  }
  extractCols(e, t) {
    this.extractRowGroupCols(e, t), this.extractPivotCols(e, t), this.extractValueCols(e, t);
  }
  extractValueCols(e, t) {
    this.valueCols = this.extractColsCommon(t, this.valueCols, (i, s) => i.setValueActive(s, e), () => {
    }, () => {
    }, (i) => {
      const s = i.aggFunc;
      if (s === null || s === "") return null;
      if (s !== void 0) return !!s;
    }, (i) => i.initialAggFunc != null && i.initialAggFunc != ""), this.valueCols.forEach((i) => {
      const s = i.getColDef();
      s.aggFunc != null && s.aggFunc != "" ? i.setAggFunc(s.aggFunc) : i.getAggFunc() || i.setAggFunc(s.initialAggFunc);
    });
  }
  extractRowGroupCols(e, t) {
    this.rowGroupCols = this.extractColsCommon(t, this.rowGroupCols, (i, s) => i.setRowGroupActive(s, e), (i) => i.rowGroupIndex, (i) => i.initialRowGroupIndex, (i) => i.rowGroup, (i) => i.initialRowGroup);
  }
  extractPivotCols(e, t) {
    this.pivotCols = this.extractColsCommon(t, this.pivotCols, (i, s) => i.setPivotActive(s, e), (i) => i.pivotIndex, (i) => i.initialPivotIndex, (i) => i.pivot, (i) => i.initialPivot);
  }
  extractColsCommon(e = [], t = [], i, s, o, r, n) {
    const l = [], a = [];
    (this.columnModel.getColDefCols() || []).forEach((h) => {
      const g = e.indexOf(h) < 0, m = h.getColDef(), C = As(r(m)), f = As(n(m)), v = yt(s(m)), w = yt(o(m));
      let S;
      C !== void 0 ? S = C : v !== void 0 ? v === null ? S = false : S = v >= 0 : g ? f !== void 0 ? S = f : w !== void 0 ? S = w != null && w >= 0 : S = false : S = t.indexOf(h) >= 0, S && ((g ? v != null || w != null : v != null) ? l.push(h) : a.push(h));
    });
    const u = (h) => {
      const g = s(h.getColDef()), m = o(h.getColDef());
      return g ?? m;
    };
    l.sort((h, g) => {
      const m = u(h), C = u(g);
      return m === C ? 0 : m < C ? -1 : 1;
    });
    const d = [].concat(l);
    return t.forEach((h) => {
      a.indexOf(h) >= 0 && d.push(h);
    }), a.forEach((h) => {
      d.indexOf(h) < 0 && d.push(h);
    }), t.forEach((h) => {
      d.indexOf(h) < 0 && i(h, false);
    }), d.forEach((h) => {
      t.indexOf(h) < 0 && i(h, true);
    }), d;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const i = {}, s = (o, r, n, l, a, c) => {
      const u = this.columnModel.getColDefCols();
      if (!r.length || !u) return [];
      const d = Object.keys(o), h = new Set(d), g = new Set(d), m = new Set(r.map((M) => {
        const P = M.getColId();
        return g.delete(P), P;
      }).concat(d)), C = [], f = {};
      let v = 0;
      for (let M = 0; M < u.length; M++) {
        const P = u[M].getColId();
        m.has(P) && (C.push(P), f[P] = v++);
      }
      let w = 1e3, S = false, b = 0;
      const x = (M) => {
        const P = f[M];
        for (let A = b; A < P; A++) {
          const I = C[A];
          g.has(I) && (o[I][a] = w++, g.delete(I));
        }
        b = P;
      };
      r.forEach((M) => {
        const P = M.getColId();
        if (h.has(P)) x(P), o[P][a] = w++;
        else {
          const A = M.getColDef();
          (A[a] === null || A[a] === void 0 && A[c] == null) && (S || (A[n] || A[n] === void 0 && A[l] ? x(P) : (g.forEach((L) => {
            o[L][a] = w + f[L];
          }), w += C.length, S = true)), i[P] || (i[P] = { colId: P }), i[P][a] = w++);
        }
      });
    };
    return s(e, this.rowGroupCols, "rowGroup", "initialRowGroup", "rowGroupIndex", "initialRowGroupIndex"), s(t, this.pivotCols, "pivot", "initialPivot", "pivotIndex", "initialPivotIndex"), Object.values(i);
  }
}, aa = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnApplyStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.sortController = e.sortController, this.columnGetStateService = e.columnGetStateService, this.funcColsService = e.funcColsService, this.visibleColsService = e.visibleColsService, this.columnAnimationService = e.columnAnimationService, this.pivotResultColsService = e.pivotResultColsService;
  }
  applyColumnState(e, t) {
    var _a3;
    const i = this.columnModel.getColDefCols() || [];
    if (Me(i)) return false;
    if (e && e.state && !e.state.forEach) return F("applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."), false;
    const s = this.funcColsService.getModifyColumnsNoEventsCallbacks(), o = (l, a, c) => {
      const u = this.compareColumnStatesAndDispatchEvents(t), d = a.slice(), h = {}, g = {}, m = [], C = [];
      let f = 0;
      const v = this.funcColsService.getRowGroupColumns().slice(), w = this.funcColsService.getPivotColumns().slice();
      l.forEach((M) => {
        const P = M.colId || "";
        if (P.startsWith(os)) {
          m.push(M), C.push(M);
          return;
        }
        const I = c(P);
        I ? (this.syncColumnWithStateItem(I, M, e.defaultState, h, g, false, t, s), Fe(d, I)) : (C.push(M), f += 1);
      });
      const S = (M) => this.syncColumnWithStateItem(M, null, e.defaultState, h, g, false, t, s);
      d.forEach(S), this.funcColsService.sortRowGroupColumns(Yo.bind(this, h, v)), this.funcColsService.sortPivotColumns(Yo.bind(this, g, w)), this.columnModel.refreshCols(false);
      const x = (this.columnModel.getAutoCols() || []).slice();
      return m.forEach((M) => {
        const P = this.columnModel.getAutoCol(M.colId);
        Fe(x, P), this.syncColumnWithStateItem(P, M, e.defaultState, null, null, true, t, s);
      }), x.forEach(S), this.orderLiveColsLikeState(e), this.visibleColsService.refresh(t), this.eventDispatcher.everythingChanged(t), u(), { unmatchedAndAutoStates: C, unmatchedCount: f };
    };
    this.columnAnimationService.start();
    let { unmatchedAndAutoStates: r, unmatchedCount: n } = o(e.state || [], i, (l) => this.columnModel.getColDefCol(l));
    if (r.length > 0 || E(e.defaultState)) {
      const a = (_a3 = this.pivotResultColsService.getPivotResultCols()) == null ? void 0 : _a3.list;
      n = o(r, a || [], (c) => this.pivotResultColsService.getPivotResultCol(c)).unmatchedCount;
    }
    return this.columnAnimationService.finish(), n === 0;
  }
  resetColumnState(e) {
    const t = this.columnModel.getColDefCols();
    if (Me(t)) return;
    const i = this.columnModel.getColDefColTree(), s = to(i), o = [];
    let r = 1e3, n = 1e3, l = [];
    const a = this.columnModel.getAutoCols();
    a && (l = l.concat(a)), s && (l = l.concat(s)), l.forEach((c) => {
      const u = this.getColumnStateFromColDef(c);
      V(u.rowGroupIndex) && u.rowGroup && (u.rowGroupIndex = r++), V(u.pivotIndex) && u.pivot && (u.pivotIndex = n++), o.push(u);
    }), this.applyColumnState({ state: o, applyOrder: true }, e);
  }
  getColumnStateFromColDef(e) {
    const t = (m, C) => m ?? C ?? null, i = e.getColDef(), s = t(i.sort, i.initialSort), o = t(i.sortIndex, i.initialSortIndex), r = t(i.hide, i.initialHide), n = t(i.pinned, i.initialPinned), l = t(i.width, i.initialWidth), a = t(i.flex, i.initialFlex);
    let c = t(i.rowGroupIndex, i.initialRowGroupIndex), u = t(i.rowGroup, i.initialRowGroup);
    c == null && (u == null || u == false) && (c = null, u = null);
    let d = t(i.pivotIndex, i.initialPivotIndex), h = t(i.pivot, i.initialPivot);
    d == null && (h == null || h == false) && (d = null, h = null);
    const g = t(i.aggFunc, i.initialAggFunc);
    return { colId: e.getColId(), sort: s, sortIndex: o, hide: r, pinned: n, width: l, flex: a, rowGroup: u, rowGroupIndex: c, pivot: h, pivotIndex: d, aggFunc: g };
  }
  syncColumnWithStateItem(e, t, i, s, o, r, n, l) {
    if (!e) return;
    const a = (b, x) => {
      const M = { value1: void 0, value2: void 0 };
      let P = false;
      return t && (t[b] !== void 0 && (M.value1 = t[b], P = true), E(x) && t[x] !== void 0 && (M.value2 = t[x], P = true)), !P && i && (i[b] !== void 0 && (M.value1 = i[b]), E(x) && i[x] !== void 0 && (M.value2 = i[x])), M;
    }, c = a("hide").value1;
    c !== void 0 && e.setVisible(!c, n);
    const u = a("pinned").value1;
    u !== void 0 && e.setPinned(u);
    const d = e.getColDef().minWidth ?? this.gos.environment.getDefaultColumnMinWidth(), h = a("flex").value1;
    if (h !== void 0 && e.setFlex(h), h == null) {
      const b = a("width").value1;
      b != null && d != null && b >= d && e.setActualWidth(b, n);
    }
    const g = a("sort").value1;
    g !== void 0 && (g === "desc" || g === "asc" ? e.setSort(g, n) : e.setSort(void 0, n));
    const m = a("sortIndex").value1;
    if (m !== void 0 && e.setSortIndex(m), r || !e.isPrimary()) return;
    const C = a("aggFunc").value1;
    C !== void 0 && (typeof C == "string" ? (e.setAggFunc(C), e.isValueActive() || (e.setValueActive(true, n), l.addValueCol(e))) : (E(C) && F("stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."), e.isValueActive() && (e.setValueActive(false, n), l.removeValueCol(e))));
    const { value1: f, value2: v } = a("rowGroup", "rowGroupIndex");
    (f !== void 0 || v !== void 0) && (typeof v == "number" || f ? (e.isRowGroupActive() || (e.setRowGroupActive(true, n), l.addGroupCol(e)), s && typeof v == "number" && (s[e.getId()] = v)) : e.isRowGroupActive() && (e.setRowGroupActive(false, n), l.removeGroupCol(e)));
    const { value1: w, value2: S } = a("pivot", "pivotIndex");
    (w !== void 0 || S !== void 0) && (typeof S == "number" || w ? (e.isPivotActive() || (e.setPivotActive(true, n), l.addPivotCol(e)), o && typeof S == "number" && (o[e.getId()] = S)) : e.isPivotActive() && (e.setPivotActive(false, n), l.removePivotCol(e)));
  }
  orderLiveColsLikeState(e) {
    if (!e.applyOrder || !e.state) return;
    const t = [];
    e.state.forEach((i) => {
      i.colId != null && t.push(i.colId);
    }), this.columnModel.sortColsLikeKeys(t);
  }
  compareColumnStatesAndDispatchEvents(e) {
    const t = { rowGroupColumns: this.funcColsService.getRowGroupColumns().slice(), pivotColumns: this.funcColsService.getPivotColumns().slice(), valueColumns: this.funcColsService.getValueColumns().slice() }, i = this.columnGetStateService.getColumnState(), s = {};
    return i.forEach((o) => {
      s[o.colId] = o;
    }), () => {
      const o = this.columnModel.getAllCols(), r = (C, f, v, w) => {
        const S = f.map(w), b = v.map(w);
        if (gt(S, b)) return;
        const M = new Set(f);
        v.forEach((A) => {
          M.delete(A) || M.add(A);
        });
        const P = [...M];
        this.eventService.dispatchEvent({ type: C, columns: P, column: P.length === 1 ? P[0] : null, source: e });
      }, n = (C) => {
        const f = [];
        return o.forEach((v) => {
          const w = s[v.getColId()];
          w && C(w, v) && f.push(v);
        }), f;
      }, l = (C) => C.getColId();
      r("columnRowGroupChanged", t.rowGroupColumns, this.funcColsService.getRowGroupColumns(), l), r("columnPivotChanged", t.pivotColumns, this.funcColsService.getPivotColumns(), l);
      const c = n((C, f) => {
        const v = C.aggFunc != null, w = v != f.isValueActive(), S = v && C.aggFunc != f.getAggFunc();
        return w || S;
      });
      c.length > 0 && this.eventDispatcher.columnChanged("columnValueChanged", c, e);
      const u = (C, f) => C.width != f.getActualWidth();
      this.eventDispatcher.columnResized(n(u), true, e);
      const d = (C, f) => C.pinned != f.getPinned();
      this.eventDispatcher.columnPinned(n(d), e);
      const h = (C, f) => C.hide == f.isVisible();
      this.eventDispatcher.columnVisible(n(h), e);
      const m = n((C, f) => C.sort != f.getSort() || C.sortIndex != f.getSortIndex());
      m.length > 0 && this.sortController.dispatchSortChangedEvents(e, m), this.normaliseColumnMovedEventForColumnState(i, e);
    };
  }
  normaliseColumnMovedEventForColumnState(e, t) {
    const i = this.columnGetStateService.getColumnState(), s = {};
    i.forEach((a) => s[a.colId] = a);
    const o = {};
    e.forEach((a) => {
      s[a.colId] && (o[a.colId] = true);
    });
    const r = e.filter((a) => o[a.colId]), n = i.filter((a) => o[a.colId]), l = [];
    n.forEach((a, c) => {
      const u = r && r[c];
      if (u && u.colId !== a.colId) {
        const d = this.columnModel.getCol(u.colId);
        d && l.push(d);
      }
    }), l.length && this.eventDispatcher.columnMoved({ movedColumns: l, source: t, finished: true });
  }
}, Yo = (e, t, i, s) => {
  const o = e[i.getId()], r = e[s.getId()], n = o != null, l = r != null;
  if (n && l) return o - r;
  if (n) return -1;
  if (l) return 1;
  const a = t.indexOf(i), c = t.indexOf(s), u = a >= 0, d = c >= 0;
  return u && d ? a - c : u ? -1 : 1;
}, ca = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnMoveService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher;
  }
  moveColumnByIndex(e, t, i) {
    const s = this.columnModel.getCols();
    if (!s) return;
    const o = s[e];
    this.moveColumns([o], t, i);
  }
  moveColumns(e, t, i, s = true) {
    const o = this.columnModel.getCols();
    if (!o) return;
    if (t > o.length - e.length) {
      F("tried to insert columns in invalid location, toIndex = ", t), F("remember that you should not count the moving columns when calculating the new index");
      return;
    }
    this.columnAnimationService.start();
    const r = this.columnModel.getColsForKeys(e);
    this.doesMovePassRules(r, t) && (this.columnModel.moveInCols(r, t, i), this.eventDispatcher.columnMoved({ movedColumns: r, source: i, toIndex: t, finished: s })), this.columnAnimationService.finish();
  }
  doesMovePassRules(e, t) {
    const i = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(i);
  }
  doesOrderPassRules(e) {
    return !(!this.doesMovePassMarryChildren(e) || !this.doesMovePassLockedPositions(e));
  }
  getProposedColumnOrder(e, t) {
    const s = this.columnModel.getCols().slice();
    return Ir(s, e, t), s;
  }
  doesMovePassLockedPositions(e) {
    const t = (r) => r ? r === "left" || r === true ? -1 : 1 : 0, i = this.gos.get("enableRtl");
    let s = i ? 1 : -1, o = true;
    return e.forEach((r) => {
      const n = t(r.getColDef().lockPosition);
      i ? n > s && (o = false) : n < s && (o = false), s = n;
    }), o;
  }
  doesMovePassMarryChildren(e) {
    let t = true;
    const i = this.columnModel.getColTree();
    return tt(null, i, (s) => {
      if (!Se(s)) return;
      const o = s, r = o.getColGroupDef();
      if (!(r && r.marryChildren)) return;
      const l = [];
      o.getLeafColumns().forEach((h) => {
        const g = e.indexOf(h);
        l.push(g);
      });
      const a = Math.max.apply(Math, l), c = Math.min.apply(Math, l), u = a - c, d = o.getLeafColumns().length - 1;
      u > d && (t = false);
    }), t;
  }
  placeLockedColumns(e) {
    const t = [], i = [], s = [];
    return e.forEach((r) => {
      const n = r.getColDef().lockPosition;
      n === "right" ? s.push(r) : n === "left" || n === true ? t.push(r) : i.push(r);
    }), this.gos.get("enableRtl") ? [...s, ...i, ...t] : [...t, ...i, ...s];
  }
}, ua = /[&<>"']/g, da = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
function Ke(e, t) {
  if (e == null) return null;
  const i = e.toString().toString();
  return t ? i : i.replace(ua, (s) => da[s]);
}
function ha(e) {
  if (!e || e == null) return null;
  const t = /([a-z])([A-Z])/g, i = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(i, "$1 $2$3").replace(/\./g, " ").split(" ").map((o) => o.substring(0, 1).toUpperCase() + (o.length > 1 ? o.substring(1, o.length) : "")).join(" ");
}
var ga = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnNameService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.funcColsService = e.funcColsService, this.columnModel = e.columnModel;
  }
  getDisplayNameForColumn(e, t, i = false) {
    if (!e) return null;
    const s = this.getHeaderName(e.getColDef(), e, null, null, t);
    return i ? this.wrapHeaderNameWithAggFunc(e, s) : s;
  }
  getDisplayNameForProvidedColumnGroup(e, t, i) {
    const s = t ? t.getColGroupDef() : null;
    return s ? this.getHeaderName(s, null, e, t, i) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  getHeaderName(e, t, i, s, o) {
    const r = e.headerValueGetter;
    if (r) {
      const n = this.gos.addGridCommonParams({ colDef: e, column: t, columnGroup: i, providedColumnGroup: s, location: o });
      return typeof r == "function" ? r(n) : typeof r == "string" ? this.expressionService.evaluate(r, n) : (F("headerValueGetter must be a function or a string"), "");
    } else {
      if (e.headerName != null) return e.headerName;
      if (e.field) return ha(e.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(e, t) {
    if (this.gos.get("suppressAggFuncInHeader")) return t;
    const i = e.getColDef().pivotValueColumn, s = E(i);
    let o = null, r;
    if (s) {
      const n = this.funcColsService.getValueColumns(), l = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && n.length === 1, a = e.getColDef().pivotTotalColumnIds !== void 0;
      if (l && !a) return t;
      o = i ? i.getAggFunc() : null, r = true;
    } else {
      const n = e.isValueActive(), l = this.columnModel.isPivotMode() || !this.funcColsService.isRowGroupEmpty();
      n && l ? (o = e.getAggFunc(), r = true) : r = false;
    }
    if (r) {
      const n = typeof o == "string" ? o : "func";
      return `${this.localeService.getLocaleTextFunc()(n, n)}(${t})`;
    }
    return t;
  }
}, pa = class extends R {
  constructor() {
    super(...arguments), this.beanName = "pivotResultColsService";
  }
  wireBeans(e) {
    this.context = e.context, this.columnModel = e.columnModel, this.columnFactory = e.columnFactory, this.visibleColsService = e.visibleColsService;
  }
  destroy() {
    var _a3;
    lt(this.context, (_a3 = this.pivotResultCols) == null ? void 0 : _a3.tree), super.destroy();
  }
  isPivotResultColsPresent() {
    return this.pivotResultCols != null;
  }
  lookupPivotResultCol(e, t) {
    if (this.pivotResultCols == null) return null;
    const i = this.columnModel.getColDefCol(t);
    let s = null;
    return this.pivotResultCols.list.forEach((o) => {
      const r = o.getColDef().pivotKeys, n = o.getColDef().pivotValueColumn;
      gt(r, e) && n === i && (s = o);
    }), s;
  }
  getPivotResultCols() {
    return this.pivotResultCols;
  }
  getPivotResultCol(e) {
    return this.pivotResultCols ? this.columnModel.getColFromCollection(e, this.pivotResultCols) : null;
  }
  setPivotResultCols(e, t) {
    var _a3, _b;
    if (this.columnModel.isReady() && !(e == null && this.pivotResultCols == null)) {
      if (e) {
        this.processPivotResultColDef(e);
        const i = this.columnFactory.createColumnTree(e, false, ((_a3 = this.pivotResultCols) == null ? void 0 : _a3.tree) || this.previousPivotResultCols || void 0, t);
        lt(this.context, (_b = this.pivotResultCols) == null ? void 0 : _b.tree, i.columnTree);
        const s = i.columnTree, o = i.treeDept, r = to(s), n = {};
        this.pivotResultCols = { tree: s, treeDepth: o, list: r, map: n }, this.pivotResultCols.list.forEach((a) => this.pivotResultCols.map[a.getId()] = a);
        const l = !!this.previousPivotResultCols;
        this.previousPivotResultCols = null, this.columnModel.refreshCols(!l);
      } else this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null, this.pivotResultCols = null, this.columnModel.refreshCols(false);
      this.visibleColsService.refresh(t);
    }
  }
  processPivotResultColDef(e) {
    const t = this.gos.get("processPivotResultColDef"), i = this.gos.get("processPivotResultColGroupDef");
    if (!t && !i) return;
    const s = (o) => {
      o.forEach((r) => {
        if (E(r.children)) {
          const l = r;
          i && i(l), s(l.children);
        } else t && t(r);
      });
    };
    e && s(e);
  }
}, fa = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnSizeService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  setColumnWidths(e, t, i, s) {
    const o = [];
    e.forEach((r) => {
      const n = this.columnModel.getColDefCol(r.key) || this.columnModel.getCol(r.key);
      if (!n) return;
      if (o.push({ width: r.newWidth, ratios: [1], columns: [n] }), this.gos.get("colResizeDefault") === "shift" && (t = !t), t) {
        const a = this.visibleColsService.getColAfter(n);
        if (!a) return;
        const c = n.getActualWidth() - r.newWidth, u = a.getActualWidth() + c;
        o.push({ width: u, ratios: [1], columns: [a] });
      }
    }), o.length !== 0 && this.resizeColumnSets({ resizeSets: o, finished: i, source: s });
  }
  resizeColumnSets(e) {
    const { resizeSets: t, finished: i, source: s } = e;
    if (!(!t || t.every((u) => this.checkMinAndMaxWidthsForSet(u)))) {
      if (i) {
        const u = t && t.length > 0 ? t[0].columns : null;
        this.eventDispatcher.columnResized(u, i, s);
      }
      return;
    }
    const r = [], n = [];
    t.forEach((u) => {
      const { width: d, columns: h, ratios: g } = u, m = {}, C = {};
      h.forEach((w) => n.push(w));
      let f = true, v = 0;
      for (; f; ) {
        if (v++, v > 1e3) {
          z("infinite loop in resizeColumnSets");
          break;
        }
        f = false;
        const w = [];
        let S = 0, b = d;
        h.forEach((M, P) => {
          if (C[M.getId()]) b -= m[M.getId()];
          else {
            w.push(M);
            const I = g[P];
            S += I;
          }
        });
        const x = 1 / S;
        w.forEach((M, P) => {
          const A = P === w.length - 1;
          let I;
          A ? I = b : (I = Math.round(g[P] * d * x), b -= I);
          const T = M.getMinWidth(), L = M.getMaxWidth();
          I < T ? (I = T, C[M.getId()] = true, f = true) : L > 0 && I > L && (I = L, C[M.getId()] = true, f = true), m[M.getId()] = I;
        });
      }
      h.forEach((w) => {
        const S = m[w.getId()];
        w.getActualWidth() !== S && (w.setActualWidth(S, s), r.push(w));
      });
    });
    const l = r.length > 0;
    let a = [];
    l && (a = this.refreshFlexedColumns({ resizingCols: n, skipSetLeft: true }), this.visibleColsService.setLeftValues(s), this.visibleColsService.updateBodyWidths(), this.columnViewportService.checkViewportColumns());
    const c = n.concat(a);
    (l || i) && this.eventDispatcher.columnResized(c, i, s, a);
  }
  checkMinAndMaxWidthsForSet(e) {
    const { columns: t, width: i } = e;
    let s = 0, o = 0, r = true;
    t.forEach((a) => {
      const c = a.getMinWidth();
      s += c || 0;
      const u = a.getMaxWidth();
      u > 0 ? o += u : r = false;
    });
    const n = i >= s, l = !r || i <= o;
    return n && l;
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ? e.source : "flex";
    if (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth) return [];
    const i = this.visibleColsService.getCenterCols();
    let s = -1;
    if (e.resizingCols) {
      const h = new Set(e.resizingCols);
      for (let g = i.length - 1; g >= 0; g--) if (h.has(i[g])) {
        s = g;
        break;
      }
    }
    let o = 0, r = [], n = 0, l = 0;
    for (let h = 0; h < i.length; h++) i[h].getFlex() && h > s ? (r.push(i[h]), l += i[h].getFlex(), n += i[h].getMinWidth()) : o += i[h].getActualWidth();
    if (!r.length) return [];
    let a = [];
    o + n > this.flexViewportWidth && (r.forEach((h) => h.setActualWidth(h.getMinWidth(), t)), a = r, r = []);
    const c = [];
    let u;
    e: for (; ; ) {
      u = this.flexViewportWidth - o;
      const h = u / l;
      for (let g = 0; g < r.length; g++) {
        const m = r[g], C = h * m.getFlex();
        let f = 0;
        const v = m.getMinWidth(), w = m.getMaxWidth();
        if (C < v ? f = v : C > w && (f = w), f) {
          m.setActualWidth(f, t), Tr(r, m), l -= m.getFlex(), a.push(m), o += m.getActualWidth();
          continue e;
        }
        c[g] = Math.floor(C);
      }
      break;
    }
    let d = u;
    return r.forEach((h, g) => {
      const m = g < r.length - 1 ? Math.min(c[g], d) : Math.max(c[g], d);
      h.setActualWidth(m, t), a.push(h), d -= c[g];
    }), e.skipSetLeft || this.visibleColsService.setLeftValues(t), e.updateBodyWidths && this.visibleColsService.updateBodyWidths(), e.fireResizedEvent && this.eventDispatcher.columnResized(a, true, t, r), r;
  }
  sizeColumnsToFit(e, t = "sizeColumnsToFit", i, s) {
    var _a3;
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.sizeColumnsToFit(e, t, i, s));
      return;
    }
    const o = {};
    s && ((_a3 = s == null ? void 0 : s.columnLimits) == null ? void 0 : _a3.forEach(({ key: h, ...g }) => {
      o[typeof h == "string" ? h : h.getColId()] = g;
    }));
    const r = this.visibleColsService.getAllCols(), n = e === Xe(r);
    if (e <= 0 || !r.length || n) return;
    const l = [], a = [];
    r.forEach((h) => {
      h.getColDef().suppressSizeToFit === true ? a.push(h) : l.push(h);
    });
    const c = l.slice(0);
    let u = false;
    const d = (h) => {
      Fe(l, h), a.push(h);
    };
    for (l.forEach((h) => {
      h.resetActualWidth(t);
      const g = o == null ? void 0 : o[h.getId()], m = (g == null ? void 0 : g.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth), C = (g == null ? void 0 : g.maxWidth) ?? (s == null ? void 0 : s.defaultMaxWidth), f = h.getActualWidth();
      typeof m == "number" && f < m ? h.setActualWidth(m, t, true) : typeof C == "number" && f > C && h.setActualWidth(C, t, true);
    }); !u; ) {
      u = true;
      const h = e - Xe(a);
      if (h <= 0) l.forEach((g) => {
        var _a4;
        const m = ((_a4 = o == null ? void 0 : o[g.getId()]) == null ? void 0 : _a4.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth);
        if (typeof m == "number") {
          g.setActualWidth(m, t, true);
          return;
        }
        g.setMinimum(t);
      });
      else {
        const g = h / Xe(l);
        let m = h;
        for (let C = l.length - 1; C >= 0; C--) {
          const f = l[C], v = o == null ? void 0 : o[f.getId()], w = (v == null ? void 0 : v.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth), S = (v == null ? void 0 : v.maxWidth) ?? (s == null ? void 0 : s.defaultMaxWidth), b = f.getMinWidth(), x = f.getMaxWidth(), M = typeof w == "number" && w > b ? w : b, P = typeof S == "number" && S < x ? S : x;
          let A = Math.round(f.getActualWidth() * g);
          A < M ? (A = M, d(f), u = false) : A > P ? (A = P, d(f), u = false) : C === 0 && (A = m), f.setActualWidth(A, t, true), m -= A;
        }
      }
    }
    c.forEach((h) => {
      h.fireColumnWidthChangedEvent(t);
    }), this.visibleColsService.setLeftValues(t), this.visibleColsService.updateBodyWidths(), !i && this.eventDispatcher.columnResized(c, true, t);
  }
  applyAutosizeStrategy() {
    const e = this.gos.get("autoSizeStrategy");
    if (!e) return;
    const { type: t } = e;
    setTimeout(() => {
      if (t === "fitGridWidth") {
        const { columnLimits: i, defaultMinWidth: s, defaultMaxWidth: o } = e, r = i == null ? void 0 : i.map(({ colId: n, minWidth: l, maxWidth: a }) => ({ key: n, minWidth: l, maxWidth: a }));
        this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({ defaultMinWidth: s, defaultMaxWidth: o, columnLimits: r });
      } else t === "fitProvidedWidth" && this.sizeColumnsToFit(e.width, "sizeColumnsToFit");
    });
  }
};
function Nr(e, t) {
  return e + "_" + t;
}
function ae(e) {
  return e instanceof Vr;
}
var Vr = class extends R {
  constructor(e, t, i, s) {
    super(), this.isColumn = false, this.displayedChildren = [], this.autoHeaderHeight = null, this.parent = null, this.groupId = t, this.partId = i, this.providedColumnGroup = e, this.pinned = s;
  }
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(e) {
    this.parent = e;
  }
  getUniqueId() {
    return Nr(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? false : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      ae(e) && e.checkLeft();
    }), this.displayedChildren.length > 0) if (this.gos.get("enableRtl")) {
      const t = N(this.displayedChildren).getLeft();
      this.setLeft(t);
    } else {
      const e = this.displayedChildren[0].getLeft();
      this.setLeft(e);
    }
    else this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    let e = 0;
    return this.displayedChildren && this.displayedChildren.forEach((t) => {
      e += t.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren) return false;
    let e = false;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = true);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  isAutoHeaderHeight() {
    var _a3;
    return !!((_a3 = this.getColGroupDef()) == null ? void 0 : _a3.autoHeaderHeight);
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      dt(t) ? e.push(t) : ae(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      dt(t) ? e.push(t) : ae(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); ) e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : false)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((i) => {
      if (ae(i) && (!i.displayedChildren || !i.displayedChildren.length)) return;
      switch (i.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(i);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(i);
          break;
        default:
          this.displayedChildren.push(i);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, Br = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let i;
    return typeof t != "number" ? i = 0 : i = t + 1, this.existingIds[e] = i, i;
  }
}, ma = class extends R {
  constructor() {
    super(...arguments), this.beanName = "visibleColsService", this.colsAndGroupsMap = {}, this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = true;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher;
  }
  refresh(e, t = false) {
    t || this.buildTrees(), this.updateOpenClosedVisibilityInColumnGroups(), this.columnsLeft = ms(this.treeLeft), this.columnsCenter = ms(this.treeCenter), this.columnsRight = ms(this.treeRight), this.joinColsAriaOrder(), this.joinCols(), this.setLeftValues(e), this.autoHeightCols = this.columns.filter((i) => i.isAutoHeight()), this.columnSizeService.refreshFlexedColumns(), this.updateBodyWidths(), this.columnViewportService.checkViewportColumns(false), this.setFirstRightAndLastLeftPinned(e), this.eventDispatcher.visibleCols(e);
  }
  updateBodyWidths() {
    const e = Xe(this.columnsCenter), t = Xe(this.columnsLeft), i = Xe(this.columnsRight);
    this.bodyWidthDirty = this.bodyWidth !== e, (this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== i) && (this.bodyWidth = e, this.leftWidth = t, this.rightWidth = i, this.eventService.dispatchEvent({ type: "columnContainerWidthChanged" }), this.eventService.dispatchEvent({ type: "displayedColumnsWidthChanged" }));
  }
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e) {
    let t, i;
    this.gos.get("enableRtl") ? (t = this.columnsLeft ? this.columnsLeft[0] : null, i = this.columnsRight ? N(this.columnsRight) : null) : (t = this.columnsLeft ? N(this.columnsLeft) : null, i = this.columnsRight ? this.columnsRight[0] : null), this.columnModel.getCols().forEach((s) => {
      s.setLastLeftPinned(s === t, e), s.setFirstRightPinned(s === i, e);
    });
  }
  buildTrees() {
    const e = this.columnModel.getColsToShow(), t = e.filter((r) => r.getPinned() == "left"), i = e.filter((r) => r.getPinned() == "right"), s = e.filter((r) => r.getPinned() != "left" && r.getPinned() != "right"), o = new Br();
    this.treeLeft = this.createGroups({ columns: t, idCreator: o, pinned: "left", oldDisplayedGroups: this.treeLeft }), this.treeRight = this.createGroups({ columns: i, idCreator: o, pinned: "right", oldDisplayedGroups: this.treeRight }), this.treeCenter = this.createGroups({ columns: s, idCreator: o, pinned: null, oldDisplayedGroups: this.treeCenter }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder() {
    const e = this.columnModel.getCols(), t = [], i = [], s = [];
    for (const o of e) {
      const r = o.getPinned();
      r ? r === true || r === "left" ? t.push(o) : s.push(o) : i.push(o);
    }
    this.ariaOrderColumns = t.concat(i).concat(s);
  }
  getAriaColIndex(e) {
    let t;
    return ae(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  getAllAutoHeightCols() {
    return this.autoHeightCols;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        ae(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    if (!this.columnModel.getColDefCols()) return;
    const i = this.columnModel.getCols().slice(0), s = this.gos.get("enableRtl");
    [this.columnsLeft, this.columnsRight, this.columnsCenter].forEach((o) => {
      if (s) {
        let r = Xe(o);
        o.forEach((n) => {
          r -= n.getActualWidth(), n.setLeft(r, e);
        });
      } else {
        let r = 0;
        o.forEach((n) => {
          n.setLeft(r, e), r += n.getActualWidth();
        });
      }
      Kl(i, o);
    }), i.forEach((o) => {
      o.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.columns = this.columnsRight.concat(this.columnsCenter).concat(this.columnsLeft) : this.columns = this.columnsLeft.concat(this.columnsCenter).concat(this.columnsRight);
  }
  getColsCenter() {
    return this.columnsCenter;
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  getTreeLeft() {
    return this.treeLeft;
  }
  getTreeRight() {
    return this.treeRight;
  }
  getTreeCenter() {
    return this.treeCenter;
  }
  getAllCols() {
    return this.columns;
  }
  isColDisplayed(e) {
    return this.getAllCols().indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsLeft) : this.columnsLeft;
  }
  getRightColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsRight) : this.columnsRight;
  }
  getColsForRow(e, t, i, s) {
    const o = [];
    let r = null;
    for (let n = 0; n < t.length; n++) {
      const l = t[n], a = t.length - n, c = Math.min(l.getColSpan(e), a), u = [l];
      if (c > 1) {
        const h = c - 1;
        for (let g = 1; g <= h; g++) u.push(t[n + g]);
        n += h;
      }
      let d;
      i ? (d = false, u.forEach((h) => {
        i(h) && (d = true);
      })) : d = true, d && (o.length === 0 && r && (s && s(l)) && o.push(r), o.push(l)), r = l;
    }
    return o;
  }
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  getCenterCols() {
    return this.columnsCenter;
  }
  getLeftCols() {
    return this.columnsLeft;
  }
  getRightCols() {
    return this.columnsRight;
  }
  getColBefore(e) {
    const t = this.getAllCols(), i = t.indexOf(e);
    return i > 0 ? t[i - 1] : null;
  }
  getGroupAtDirection(e, t) {
    const i = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), s = e.getDisplayedLeafColumns(), o = t === "After" ? N(s) : s[0], r = `getCol${t}`;
    for (; ; ) {
      const n = this[r](o);
      if (!n) return null;
      const l = this.getColGroupAtLevel(n, i);
      if (l !== e) return l;
    }
  }
  getColGroupAtLevel(e, t) {
    let i = e.getParent(), s, o;
    for (; s = i.getProvidedColumnGroup().getLevel(), o = i.getPaddingLevel(), !(s + o <= t); ) i = i.getParent();
    return i;
  }
  isPinningLeft() {
    return this.columnsLeft.length > 0;
  }
  isPinningRight() {
    return this.columnsRight.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    vt(this.treeCenter, false, e), vt(this.treeLeft, false, e), vt(this.treeRight, false, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const e = this.getAllTrees();
    vt(e, false, (t) => {
      ae(t) && t.calculateDisplayedColumns();
    });
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = ["getLeftCols", "getCenterCols", "getRightCols"];
    e && t.reverse();
    for (let i = 0; i < t.length; i++) {
      const s = this[t[i]]();
      if (s.length) return e ? N(s) : s[0];
    }
    return null;
  }
  getColumnGroup(e, t) {
    if (!e) return null;
    if (ae(e)) return e;
    const i = this.getAllTrees(), s = typeof t == "number";
    let o = null;
    return vt(i, false, (r) => {
      if (ae(r)) {
        const n = r;
        let l;
        s ? l = e === n.getGroupId() && t === n.getPartId() : l = e === n.getGroupId(), l && (o = n);
      }
    }), o;
  }
  getColAfter(e) {
    const t = this.getAllCols(), i = t.indexOf(e);
    return i < t.length - 1 ? t[i + 1] : null;
  }
  isBodyWidthDirty() {
    return this.bodyWidthDirty;
  }
  setBodyWidthDirty() {
    this.bodyWidthDirty = true;
  }
  getColsLeftWidth() {
    return Xe(this.columnsLeft);
  }
  getDisplayedColumnsRightWidth() {
    return Xe(this.columnsRight);
  }
  isColAtEdge(e, t) {
    const i = this.getAllCols();
    if (!i.length) return false;
    const s = t === "first";
    let o;
    if (ae(e)) {
      const r = e.getDisplayedLeafColumns();
      if (!r.length) return false;
      o = s ? r[0] : N(r);
    } else o = e;
    return (s ? i[0] : N(i)) === o;
  }
  createGroups(e) {
    const { columns: t, idCreator: i, pinned: s, oldDisplayedGroups: o, isStandaloneStructure: r } = e, n = this.mapOldGroupsById(o), l = [];
    let a = t;
    for (; a.length; ) {
      const c = a;
      a = [];
      let u = 0;
      const d = (h) => {
        const g = u;
        u = h;
        const m = c[g], f = (ae(m) ? m.getProvidedColumnGroup() : m).getOriginalParent();
        if (f == null) {
          for (let w = g; w < h; w++) l.push(c[w]);
          return;
        }
        const v = this.createColGroup(f, i, n, s, r);
        for (let w = g; w < h; w++) v.addChild(c[w]);
        a.push(v);
      };
      for (let h = 1; h < c.length; h++) {
        const g = c[h], C = (ae(g) ? g.getProvidedColumnGroup() : g).getOriginalParent(), f = c[u], w = (ae(f) ? f.getProvidedColumnGroup() : f).getOriginalParent();
        C !== w && d(h);
      }
      u < c.length && d(c.length);
    }
    return r || this.setupParentsIntoCols(l, null), l;
  }
  createColGroup(e, t, i, s, o) {
    const r = e.getGroupId(), n = t.getInstanceIdForKey(r), l = Nr(r, n);
    let a = i[l];
    return a && a.getProvidedColumnGroup() !== e && (a = null), E(a) ? a.reset() : (a = new Vr(e, r, n, s), o || this.createBean(a)), a;
  }
  mapOldGroupsById(e) {
    const t = {}, i = (s) => {
      s.forEach((o) => {
        if (ae(o)) {
          const r = o;
          t[o.getUniqueId()] = r, i(r.getChildren());
        }
      });
    };
    return e && i(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((i) => {
      if (i.setParent(t), ae(i)) {
        const s = i;
        this.setupParentsIntoCols(s.getChildren(), s);
      }
    });
  }
};
function vt(e, t, i) {
  if (e) for (let s = 0; s < e.length; s++) {
    const o = e[s];
    if (ae(o)) {
      const r = t ? o.getDisplayedChildren() : o.getChildren();
      vt(r, t, i);
    }
    i(o);
  }
}
function ms(e) {
  const t = [];
  return vt(e, true, (i) => {
    dt(i) && t.push(i);
  }), t;
}
var Wr = ["columnEverythingChanged", "newColumnsLoaded", "columnPivotModeChanged", "pivotMaxColumnsExceeded", "columnRowGroupChanged", "expandOrCollapseAll", "columnPivotChanged", "gridColumnsChanged", "columnValueChanged", "columnMoved", "columnVisible", "columnPinned", "columnGroupOpened", "columnResized", "displayedColumnsChanged", "virtualColumnsChanged", "columnHeaderMouseOver", "columnHeaderMouseLeave", "columnHeaderClicked", "columnHeaderContextMenu", "asyncTransactionsFlushed", "rowGroupOpened", "rowDataUpdated", "pinnedRowDataChanged", "rangeSelectionChanged", "cellSelectionChanged", "chartCreated", "chartRangeSelectionChanged", "chartOptionsChanged", "chartDestroyed", "toolPanelVisibleChanged", "toolPanelSizeChanged", "modelUpdated", "cutStart", "cutEnd", "pasteStart", "pasteEnd", "fillStart", "fillEnd", "cellSelectionDeleteStart", "cellSelectionDeleteEnd", "rangeDeleteStart", "rangeDeleteEnd", "undoStarted", "undoEnded", "redoStarted", "redoEnded", "cellClicked", "cellDoubleClicked", "cellMouseDown", "cellContextMenu", "cellValueChanged", "cellEditRequest", "rowValueChanged", "headerFocused", "cellFocused", "rowSelected", "selectionChanged", "tooltipShow", "tooltipHide", "cellKeyDown", "cellMouseOver", "cellMouseOut", "filterChanged", "filterModified", "filterOpened", "advancedFilterBuilderVisibleChanged", "sortChanged", "virtualRowRemoved", "rowClicked", "rowDoubleClicked", "gridReady", "gridPreDestroyed", "gridSizeChanged", "viewportChanged", "firstDataRendered", "dragStarted", "dragStopped", "dragCancelled", "rowEditingStarted", "rowEditingStopped", "cellEditingStarted", "cellEditingStopped", "bodyScroll", "bodyScrollEnd", "paginationChanged", "componentStateChanged", "storeRefreshed", "stateUpdated", "columnMenuVisibleChanged", "contextMenuVisibleChanged", "rowDragEnter", "rowDragMove", "rowDragLeave", "rowDragEnd", "rowDragCancel"], Ca = ["scrollbarWidthChanged", "keyShortcutChangedCellStart", "keyShortcutChangedCellEnd", "pinnedHeightChanged", "cellFocusCleared", "fullWidthRowFocused", "checkboxChanged", "heightScaleChanged", "suppressMovableColumns", "suppressMenuHide", "suppressFieldDotNotation", "columnPanelItemDragStart", "columnPanelItemDragEnd", "bodyHeightChanged", "columnContainerWidthChanged", "displayedColumnsWidthChanged", "scrollVisibilityChanged", "scrollGapChanged", "columnHoverChanged", "flashCells", "paginationPixelOffsetChanged", "displayedRowsChanged", "leftPinnedWidthChanged", "rightPinnedWidthChanged", "rowContainerHeightChanged", "headerHeightChanged", "columnGroupHeaderHeightChanged", "columnHeaderHeightChanged", "gridStylesChanged", "storeUpdated", "filterDestroyed", "rowDataUpdateStarted", "rowCountReady", "advancedFilterEnabledChanged", "dataTypesInferred", "fieldValueChanged", "fieldPickerValueSelected", "richSelectListRowSelected", "sideBarUpdated", "alignedGridScroll", "alignedGridColumn", "gridOptionsChanged", "chartTitleEdit", "recalculateRowBounds", "stickyTopOffsetChanged", "overlayExclusiveChanged"], va = [...Wr, ...Ca], Sa = { enableBrowserTooltips: true, tooltipTrigger: true, tooltipMouseTrack: true, tooltipShowMode: true, tooltipInteraction: true, defaultColGroupDef: true, suppressAutoSize: true, skipHeaderOnAutoSize: true, autoSizeStrategy: true, components: true, stopEditingWhenCellsLoseFocus: true, undoRedoCellEditing: true, undoRedoCellEditingLimit: true, excelStyles: true, cacheQuickFilter: true, advancedFilterModel: true, customChartThemes: true, chartThemeOverrides: true, chartToolPanelsDef: true, loadingCellRendererSelector: true, localeText: true, keepDetailRows: true, keepDetailRowsCount: true, detailRowHeight: true, detailRowAutoHeight: true, tabIndex: true, valueCache: true, valueCacheNeverExpires: true, enableCellExpressions: true, suppressTouch: true, suppressAsyncEvents: true, suppressBrowserResizeObserver: true, suppressPropertyNamesCheck: true, debug: true, dragAndDropImageComponent: true, loadingOverlayComponent: true, suppressLoadingOverlay: true, noRowsOverlayComponent: true, paginationPageSizeSelector: true, paginateChildRows: true, pivotPanelShow: true, pivotSuppressAutoColumn: true, suppressExpandablePivotGroups: true, aggFuncs: true, suppressAggFuncInHeader: true, allowShowChangeAfterFilter: true, ensureDomOrder: true, enableRtl: true, suppressColumnVirtualisation: true, suppressMaxRenderedRowRestriction: true, suppressRowVirtualisation: true, rowDragText: true, suppressGroupMaintainValueType: true, groupLockGroupColumns: true, rowGroupPanelSuppressSort: true, suppressGroupRowsSticky: true, rowModelType: true, cacheOverflowSize: true, infiniteInitialRowCount: true, serverSideInitialRowCount: true, suppressServerSideInfiniteScroll: true, maxBlocksInCache: true, maxConcurrentDatasourceRequests: true, blockLoadDebounceMillis: true, serverSideOnlyRefreshFilteredGroups: true, serverSidePivotResultFieldSeparator: true, viewportRowModelPageSize: true, viewportRowModelBufferSize: true, debounceVerticalScrollbar: true, suppressAnimationFrame: true, suppressPreventDefaultOnMouseWheel: true, scrollbarWidth: true, icons: true, suppressRowTransform: true, gridId: true, enableGroupEdit: true, initialState: true, processUnpinnedColumns: true, createChartContainer: true, getLocaleText: true, getRowId: true, reactiveCustomComponents: true, columnMenu: true, suppressSetFilterByDefault: true }, fe = class {
};
fe.STRING_PROPERTIES = ["overlayLoadingTemplate", "overlayNoRowsTemplate", "gridId", "quickFilterText", "rowModelType", "editType", "domLayout", "clipboardDelimiter", "rowGroupPanelShow", "multiSortKey", "pivotColumnGroupTotals", "pivotRowTotals", "pivotPanelShow", "fillHandleDirection", "groupDisplayType", "treeDataDisplayType", "colResizeDefault", "tooltipTrigger", "serverSidePivotResultFieldSeparator", "columnMenu", "tooltipShowMode", "grandTotalRow"];
fe.OBJECT_PROPERTIES = ["components", "rowStyle", "context", "autoGroupColumnDef", "localeText", "icons", "datasource", "dragAndDropImageComponentParams", "serverSideDatasource", "viewportDatasource", "groupRowRendererParams", "aggFuncs", "fullWidthCellRendererParams", "defaultColGroupDef", "defaultColDef", "defaultCsvExportParams", "defaultExcelExportParams", "columnTypes", "rowClassRules", "detailCellRendererParams", "loadingCellRendererParams", "loadingOverlayComponentParams", "noRowsOverlayComponentParams", "popupParent", "statusBar", "sideBar", "theme", "chartThemeOverrides", "customChartThemes", "chartToolPanelsDef", "dataTypeDefinitions", "advancedFilterModel", "advancedFilterParent", "advancedFilterBuilderParams", "initialState", "autoSizeStrategy", "cellSelection", "selectionColumnDef"];
fe.ARRAY_PROPERTIES = ["sortingOrder", "alignedGrids", "rowData", "columnDefs", "excelStyles", "pinnedTopRowData", "pinnedBottomRowData", "chartThemes", "rowClass", "paginationPageSizeSelector"];
fe.NUMBER_PROPERTIES = ["rowHeight", "detailRowHeight", "rowBuffer", "headerHeight", "groupHeaderHeight", "groupLockGroupColumns", "floatingFiltersHeight", "pivotHeaderHeight", "pivotGroupHeaderHeight", "groupDefaultExpanded", "pivotDefaultExpanded", "viewportRowModelPageSize", "viewportRowModelBufferSize", "autoSizePadding", "maxBlocksInCache", "maxConcurrentDatasourceRequests", "tooltipShowDelay", "tooltipHideDelay", "cacheOverflowSize", "paginationPageSize", "cacheBlockSize", "infiniteInitialRowCount", "serverSideInitialRowCount", "scrollbarWidth", "asyncTransactionWaitMillis", "blockLoadDebounceMillis", "keepDetailRowsCount", "undoRedoCellEditingLimit", "cellFlashDelay", "cellFadeDelay", "cellFlashDuration", "cellFadeDuration", "tabIndex", "pivotMaxGeneratedColumns"];
fe.BOOLEAN_PROPERTIES = ["suppressMakeColumnVisibleAfterUnGroup", "suppressRowClickSelection", "suppressCellFocus", "suppressHeaderFocus", "suppressHorizontalScroll", "groupSelectsChildren", "alwaysShowHorizontalScroll", "alwaysShowVerticalScroll", "debug", "enableBrowserTooltips", "enableCellExpressions", "groupIncludeTotalFooter", "groupSuppressBlankHeader", "suppressMenuHide", "suppressRowDeselection", "unSortIcon", "suppressMultiSort", "alwaysMultiSort", "singleClickEdit", "suppressLoadingOverlay", "suppressNoRowsOverlay", "suppressAutoSize", "skipHeaderOnAutoSize", "suppressColumnMoveAnimation", "suppressMoveWhenColumnDragging", "suppressMovableColumns", "suppressFieldDotNotation", "enableRangeSelection", "enableRangeHandle", "enableFillHandle", "suppressClearOnFillReduction", "deltaSort", "suppressTouch", "suppressAsyncEvents", "allowContextMenuWithControlKey", "suppressContextMenu", "enableCellChangeFlash", "suppressDragLeaveHidesColumns", "suppressRowGroupHidesColumns", "suppressMiddleClickScrolls", "suppressPreventDefaultOnMouseWheel", "suppressCopyRowsToClipboard", "copyHeadersToClipboard", "copyGroupHeadersToClipboard", "pivotMode", "suppressAggFuncInHeader", "suppressColumnVirtualisation", "alwaysAggregateAtRootLevel", "suppressFocusAfterRefresh", "functionsReadOnly", "animateRows", "groupSelectsFiltered", "groupRemoveSingleChildren", "groupRemoveLowestSingleChildren", "enableRtl", "suppressClickEdit", "rowDragEntireRow", "rowDragManaged", "suppressRowDrag", "suppressMoveWhenRowDragging", "rowDragMultiRow", "enableGroupEdit", "embedFullWidthRows", "suppressPaginationPanel", "groupHideOpenParents", "groupAllowUnbalanced", "pagination", "paginationAutoPageSize", "suppressScrollOnNewData", "suppressScrollWhenPopupsAreOpen", "purgeClosedRowNodes", "cacheQuickFilter", "includeHiddenColumnsInQuickFilter", "ensureDomOrder", "accentedSort", "suppressChangeDetection", "valueCache", "valueCacheNeverExpires", "aggregateOnlyChangedColumns", "suppressAnimationFrame", "suppressExcelExport", "suppressCsvExport", "includeHiddenColumnsInAdvancedFilter", "suppressMultiRangeSelection", "enterNavigatesVerticallyAfterEdit", "enterNavigatesVertically", "suppressPropertyNamesCheck", "rowMultiSelectWithClick", "suppressRowHoverHighlight", "suppressRowTransform", "suppressClipboardPaste", "suppressLastEmptyLineOnPaste", "enableCharts", "suppressMaintainUnsortedOrder", "enableCellTextSelection", "suppressBrowserResizeObserver", "suppressMaxRenderedRowRestriction", "excludeChildrenWhenTreeDataFiltering", "tooltipMouseTrack", "tooltipInteraction", "keepDetailRows", "paginateChildRows", "preventDefaultOnContextMenu", "undoRedoCellEditing", "allowDragFromColumnsToolPanel", "pivotSuppressAutoColumn", "suppressExpandablePivotGroups", "debounceVerticalScrollbar", "detailRowAutoHeight", "serverSideSortAllLevels", "serverSideEnableClientSideSort", "serverSideOnlyRefreshFilteredGroups", "serverSideSortOnServer", "serverSideFilterOnServer", "suppressAggFilteredOnly", "showOpenedGroup", "suppressClipboardApi", "suppressModelUpdateAfterUpdateTransaction", "stopEditingWhenCellsLoseFocus", "groupMaintainOrder", "columnHoverHighlight", "readOnlyEdit", "suppressRowVirtualisation", "enableCellEditingOnBackspace", "resetRowDataOnUpdate", "removePivotHeaderRowWhenSingleValueColumn", "suppressCopySingleCellRanges", "suppressGroupRowsSticky", "suppressCutToClipboard", "suppressServerSideInfiniteScroll", "rowGroupPanelSuppressSort", "allowShowChangeAfterFilter", "enableAdvancedFilter", "masterDetail", "treeData", "suppressGroupMaintainValueType", "reactiveCustomComponents", "applyQuickFilterBeforePivotOrAgg", "suppressServerSideFullWidthLoadingRow", "suppressAdvancedFilterEval", "loading", "maintainColumnOrder", "enableStrictPivotColumnOrder", "suppressSetFilterByDefault"];
fe.OTHER_PROPERTIES = ["suppressStickyTotalRow", "loadThemeGoogleFonts", "rowSelection"];
fe.FUNCTION_PROPERTIES = ["doesExternalFilterPass", "processPivotResultColDef", "processPivotResultColGroupDef", "getBusinessKeyForNode", "isRowSelectable", "rowDragText", "groupRowRenderer", "dragAndDropImageComponent", "fullWidthCellRenderer", "loadingCellRenderer", "loadingOverlayComponent", "noRowsOverlayComponent", "detailCellRenderer", "quickFilterParser", "quickFilterMatcher", "getLocaleText", "isExternalFilterPresent", "getRowHeight", "getRowClass", "getRowStyle", "getContextMenuItems", "getMainMenuItems", "processRowPostCreate", "processCellForClipboard", "getGroupRowAgg", "isFullWidthRow", "sendToClipboard", "focusGridInnerElement", "navigateToNextHeader", "tabToNextHeader", "navigateToNextCell", "tabToNextCell", "processCellFromClipboard", "getDocument", "postProcessPopup", "getChildCount", "getDataPath", "isRowMaster", "postSortRows", "processHeaderForClipboard", "processUnpinnedColumns", "processGroupHeaderForClipboard", "paginationNumberFormatter", "processDataFromClipboard", "getServerSideGroupKey", "isServerSideGroup", "createChartContainer", "getChartToolbarItems", "fillOperation", "isApplyServerSideTransaction", "getServerSideGroupLevelParams", "isServerSideGroupOpenByDefault", "isGroupOpenByDefault", "initialGroupOrderComparator", "groupIncludeFooter", "loadingCellRendererSelector", "getRowId", "groupAggFiltering", "chartMenuItems", "groupTotalRow"];
fe.ALL_PROPERTIES = [...fe.ARRAY_PROPERTIES, ...fe.OBJECT_PROPERTIES, ...fe.STRING_PROPERTIES, ...fe.NUMBER_PROPERTIES, ...fe.FUNCTION_PROPERTIES, ...fe.BOOLEAN_PROPERTIES, ...fe.OTHER_PROPERTIES];
var hi = fe, Le = class {
  static getCallbackForEvent(t) {
    return !t || t.length < 2 ? t : "on" + t[0].toUpperCase() + t.substring(1);
  }
};
Le.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
Le.PUBLIC_EVENTS = Wr;
Le.EVENT_CALLBACKS = va.map((e) => Le.getCallbackForEvent(e));
Le.BOOLEAN_PROPERTIES = hi.BOOLEAN_PROPERTIES;
Le.ALL_PROPERTIES = hi.ALL_PROPERTIES;
Le.ALL_PROPERTIES_AND_CALLBACKS = [...Le.ALL_PROPERTIES, ...Le.EVENT_CALLBACKS];
Le.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Le.ALL_PROPERTIES_AND_CALLBACKS);
var gi = Le;
function wa(e, t) {
  typeof e != "object" && (e = {});
  const i = { ...e };
  return gi.ALL_PROPERTIES_AND_CALLBACKS.forEach((o) => {
    const r = t[o];
    typeof r < "u" && r !== gi.VUE_OMITTED_PROPERTY && (i[o] = r);
  }), i;
}
function ya(e, t) {
  if (!e) return;
  const i = {};
  let s = false;
  if (Object.keys(e).filter((n) => gi.ALL_PROPERTIES_AND_CALLBACKS_SET.has(n)).forEach((n) => {
    i[n] = e[n], s = true;
  }), !s) return;
  const o = { type: "gridOptionsChanged", options: i };
  t.dispatchEvent(o);
  const r = { type: "componentStateChanged" };
  He(i, (n, l) => {
    r[n] = l;
  }), t.dispatchEvent(r);
}
var Kt = class extends R {
};
function Si(e, t, i) {
  return i && e.addDestroyFunc(() => t.destroyBean(i)), i ?? e;
}
var wi = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((s) => this.addCssClass(s));
      return;
    }
    if (this.cssClassStates[e] !== true && e.length) {
      const s = this.getGui();
      s && s.classList.add(e), this.cssClassStates[e] = true;
    }
  }
  removeCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((s) => this.removeCssClass(s));
      return;
    }
    if (this.cssClassStates[e] !== false && e.length) {
      const s = this.getGui();
      s && s.classList.remove(e), this.cssClassStates[e] = false;
    }
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : false;
  }
  addOrRemoveCssClass(e, t) {
    if (!e) return;
    if (e.indexOf(" ") >= 0) {
      const s = (e || "").split(" ");
      if (s.length > 1) {
        s.forEach((o) => this.addOrRemoveCssClass(o, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const s = this.getGui();
      s && s.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
};
function st(e, t, i) {
  i == null || typeof i == "string" && i == "" ? zr(e, t) : qe(e, t, i);
}
function qe(e, t, i) {
  e.setAttribute(_r(t), i.toString());
}
function zr(e, t) {
  e.removeAttribute(_r(t));
}
function _r(e) {
  return `aria-${e}`;
}
function Ve(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function Ra(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function Fa(e) {
  return e.getAttribute("aria-label");
}
function _t(e, t) {
  st(e, "label", t);
}
function pi(e, t) {
  st(e, "labelledby", t);
}
function Ur(e, t) {
  st(e, "live", t);
}
function ba(e, t) {
  st(e, "atomic", t);
}
function Pa(e, t) {
  st(e, "relevant", t);
}
function Ea(e, t) {
  st(e, "disabled", t);
}
function Kr(e, t) {
  st(e, "hidden", t);
}
function $i(e, t) {
  qe(e, "expanded", t);
}
function Da(e, t) {
  qe(e, "setsize", t);
}
function Ma(e, t) {
  qe(e, "posinset", t);
}
function xa(e, t) {
  qe(e, "rowcount", t);
}
function Aa(e, t) {
  qe(e, "rowindex", t);
}
function Ta(e, t) {
  qe(e, "colcount", t);
}
function $r(e, t) {
  qe(e, "colindex", t);
}
function Ia(e, t) {
  qe(e, "colspan", t);
}
function La(e, t) {
  qe(e, "sort", t);
}
function Oa(e) {
  zr(e, "sort");
}
function ji(e, t) {
  st(e, "selected", t);
}
function Ga(e, t) {
  st(e, "controls", t.id), pi(t, e.id);
}
function ro(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === true ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var Cs, Pi, vs, Ss, ws, ys, Ns, Vs, Rs;
function $e() {
  return Cs === void 0 && (Cs = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), Cs;
}
function jr() {
  if (Pi === void 0) if ($e()) {
    const e = navigator.userAgent.match(/version\/(\d+)/i);
    e && (Pi = e[1] != null ? parseFloat(e[1]) : 0);
  } else Pi = 0;
  return Pi;
}
function no() {
  if (vs === void 0) {
    const e = window;
    vs = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return vs;
}
function lo() {
  return Ss === void 0 && (Ss = /(firefox)/i.test(navigator.userAgent)), Ss;
}
function qr() {
  return ws === void 0 && (ws = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), ws;
}
function pt() {
  return ys === void 0 && (ys = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), ys;
}
function Qo() {
  return !$e() || jr() >= 15;
}
function Bs(e) {
  if (!e) return null;
  const t = e.tabIndex, i = e.getAttribute("tabIndex");
  return t === -1 && (i === null || i === "" && !lo()) ? null : t.toString();
}
function ka() {
  if (Rs !== void 0) return Rs;
  if (!document.body) return -1;
  let e = 1e6;
  const t = lo() ? 6e6 : 1e9, i = document.createElement("div");
  for (document.body.appendChild(i); ; ) {
    const s = e * 2;
    if (i.style.height = s + "px", s > t || i.clientHeight !== s) break;
    e = s;
  }
  return document.body.removeChild(i), Rs = e, e;
}
function Ha() {
  var _a3, _b;
  return ((_a3 = document.body) == null ? void 0 : _a3.clientWidth) ?? (window.innerHeight || ((_b = document.documentElement) == null ? void 0 : _b.clientWidth) || -1);
}
function Na() {
  var _a3, _b;
  return ((_a3 = document.body) == null ? void 0 : _a3.clientHeight) ?? (window.innerHeight || ((_b = document.documentElement) == null ? void 0 : _b.clientHeight) || -1);
}
function Va() {
  return Vs == null && Yr(), Vs;
}
function Yr() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let i = t.offsetWidth - t.clientWidth;
  i === 0 && t.clientWidth === 0 && (i = null), t.parentNode && t.parentNode.removeChild(t), i != null && (Vs = i, Ns = i === 0);
}
function Qr() {
  return Ns == null && Yr(), Ns;
}
var Ei, Ba = "[tabindex], input, select, button, textarea, [href]", Xr = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function ao(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, s = t.call(e, "input, select, button, textarea"), o = t.call(e, Xr), r = je(e);
  return s && !o && r;
}
function ee(e, t, i = {}) {
  const { skipAriaHidden: s } = i;
  e.classList.toggle("ag-hidden", !t), s || Kr(e, !t);
}
function Wa(e, t, i = {}) {
  const { skipAriaHidden: s } = i;
  e.classList.toggle("ag-invisible", !t), s || Kr(e, !t);
}
function fi(e, t) {
  const i = "disabled", s = t ? (o) => o.setAttribute(i, "") : (o) => o.removeAttribute(i);
  s(e), tn(e.querySelectorAll("input"), (o) => s(o));
}
function Vt(e, t, i) {
  let s = 0;
  for (; e; ) {
    if (e.classList.contains(t)) return true;
    if (e = e.parentElement, typeof i == "number") {
      if (++s > i) break;
    } else if (e === i) break;
  }
  return false;
}
function xt(e) {
  const { height: t, width: i, borderTopWidth: s, borderRightWidth: o, borderBottomWidth: r, borderLeftWidth: n, paddingTop: l, paddingRight: a, paddingBottom: c, paddingLeft: u, marginTop: d, marginRight: h, marginBottom: g, marginLeft: m, boxSizing: C } = window.getComputedStyle(e);
  return { height: parseFloat(t || "0"), width: parseFloat(i || "0"), borderTopWidth: parseFloat(s || "0"), borderRightWidth: parseFloat(o || "0"), borderBottomWidth: parseFloat(r || "0"), borderLeftWidth: parseFloat(n || "0"), paddingTop: parseFloat(l || "0"), paddingRight: parseFloat(a || "0"), paddingBottom: parseFloat(c || "0"), paddingLeft: parseFloat(u || "0"), marginTop: parseFloat(d || "0"), marginRight: parseFloat(h || "0"), marginBottom: parseFloat(g || "0"), marginLeft: parseFloat(m || "0"), boxSizing: C };
}
function co(e) {
  const t = xt(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function yi(e) {
  const t = xt(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function Jr(e) {
  const { height: t, marginBottom: i, marginTop: s } = xt(e);
  return Math.floor(t + i + s);
}
function qi(e) {
  const { width: t, marginLeft: i, marginRight: s } = xt(e);
  return Math.floor(t + i + s);
}
function Zr(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: i, borderLeftWidth: s, borderRightWidth: o, borderBottomWidth: r } = xt(e);
  return { top: t.top + (i || 0), left: t.left + (s || 0), right: t.right + (o || 0), bottom: t.bottom + (r || 0) };
}
function Yi() {
  if (typeof Ei == "boolean") return Ei;
  const e = document.createElement("div");
  return e.style.direction = "rtl", e.style.width = "1px", e.style.height = "1px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(e), e.scrollLeft = 1, Ei = Math.floor(e.scrollLeft) === 0, document.body.removeChild(e), Ei;
}
function Qi(e, t) {
  let i = e.scrollLeft;
  return t && (i = Math.abs(i), no() && !Yi() && (i = e.scrollWidth - e.getBoundingClientRect().width - i)), i;
}
function Xi(e, t, i) {
  i && (Yi() ? t *= -1 : ($e() || no()) && (t = e.scrollWidth - e.getBoundingClientRect().width - t)), e.scrollLeft = t;
}
function xe(e) {
  for (; e && e.firstChild; ) e.removeChild(e.firstChild);
}
function Mt(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function en(e) {
  return !!e.offsetParent;
}
function je(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: true }) : !(!en(e) || window.getComputedStyle(e).visibility !== "visible");
}
function mi(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function za(e) {
  return e.clientWidth < e.scrollWidth;
}
function _a(e) {
  return e.clientHeight < e.scrollHeight;
}
function Ji(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : Ne(e, t);
}
function Ne(e, t) {
  t = uo(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString();
}
function ni(e, t) {
  t = uo(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString();
}
function uo(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function ho(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function Ua(e) {
  if (e == null) return [];
  const t = [];
  return tn(e, (i) => t.push(i)), t;
}
function Ka(e, t) {
  if (e) for (let i = 0; i < e.length; i++) {
    const s = e[i];
    t(s.name, s.value);
  }
}
function Oe(e, t, i) {
  i == null || i === "" ? e.removeAttribute(t) : e.setAttribute(t, i.toString());
}
function tn(e, t) {
  if (e != null) for (let i = 0; i < e.length; i++) t(e[i]);
}
var go = class {
  constructor(e = 0, t = 1) {
    this.nextValue = e, this.step = t;
  }
  next() {
    const e = this.nextValue;
    return this.nextValue += this.step, e;
  }
  peek() {
    return this.nextValue;
  }
  skip(e) {
    this.nextValue += e;
  }
}, $a = 1e3, ja = 1e3, Xo = 100, sn = class ft extends R {
  constructor(t, i, s, o) {
    super(), this.parentComp = t, this.tooltipShowDelayOverride = i, this.tooltipHideDelayOverride = s, this.shouldDisplayTooltip = o, this.interactionEnabled = false, this.isInteractingWithTooltip = false, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = false;
  }
  wireBeans(t) {
    this.popupService = t.popupService, this.userComponentFactory = t.userComponentFactory;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = true), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const t = this.parentComp.getGui();
    this.tooltipTrigger === 0 && this.addManagedListeners(t, { mouseenter: this.onMouseEnter.bind(this), mouseleave: this.onMouseLeave.bind(this) }), this.tooltipTrigger === 1 && this.addManagedListeners(t, { focusin: this.onFocusIn.bind(this), focusout: this.onFocusOut.bind(this) }), this.addManagedListeners(t, { mousemove: this.onMouseMove.bind(this) }), this.interactionEnabled || this.addManagedListeners(t, { mousedown: this.onMouseDown.bind(this), keydown: this.onKeyDown.bind(this) });
  }
  getGridOptionsTooltipDelay(t) {
    const i = this.gos.get(t);
    return i < 0 && F(`${t} should not be lower than 0`), Math.max(200, i);
  }
  getTooltipDelay(t) {
    return t === "show" ? this.tooltipShowDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipShowDelay") : this.tooltipHideDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const t = this.gos.get("tooltipTrigger");
    return !t || t === "hover" ? 0 : 1;
  }
  onMouseEnter(t) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !pt() && (ft.isLocked ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(t);
    }, Xo) : this.prepareToShowTooltip(t));
  }
  onMouseMove(t) {
    this.lastMouseEvent && (this.lastMouseEvent = t), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(t) {
    var _a3;
    const i = t.relatedTarget, s = this.parentComp.getGui(), o = (_a3 = this.tooltipComp) == null ? void 0 : _a3.getGui();
    this.isInteractingWithTooltip || s.contains(i) || this.interactionEnabled && (o == null ? void 0 : o.contains(i)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.isInteractingWithTooltip && (this.isInteractingWithTooltip = false), this.setToDoNothing();
  }
  prepareToShowTooltip(t) {
    if (this.state != 0 || ft.isLocked) return;
    let i = 0;
    t && (i = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = t || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), i), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    const t = (/* @__PURE__ */ new Date()).getTime(), i = ft.lastTooltipHideTime;
    return t - i < $a;
  }
  setToDoNothing(t) {
    !t && this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.onDocumentKeyDownCallback && (this.onDocumentKeyDownCallback(), this.onDocumentKeyDownCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    const t = { ...this.parentComp.getTooltipParams() };
    if (!E(t.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    this.state = 2, this.tooltipInstanceCount++;
    const i = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.userComponentFactory.getTooltipCompDetails(t).newAgStackInstance().then(i);
  }
  hideTooltip(t) {
    !t && this.isInteractingWithTooltip || (this.tooltipComp && (this.destroyTooltipComp(), ft.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime()), this.eventService.dispatchEvent({ type: "tooltipHide", parentGui: this.parentComp.getGui() }), t && (this.isInteractingWithTooltip = false), this.setToDoNothing(true));
  }
  newTooltipComponentCallback(t, i) {
    if (this.state !== 2 || this.tooltipInstanceCount !== t) {
      this.destroyBean(i);
      return;
    }
    const o = i.getGui();
    this.tooltipComp = i, o.classList.contains("ag-tooltip") || o.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && o.classList.add("ag-tooltip-animate"), this.interactionEnabled && o.classList.add("ag-tooltip-interactive");
    const r = this.localeService.getLocaleTextFunc(), n = this.popupService.addPopup({ eChild: o, ariaLabel: r("ariaLabelTooltip", "Tooltip") });
    if (n && (this.tooltipPopupDestroyFunc = n.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1) {
      const l = () => this.setToDoNothing();
      [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({ bodyScroll: l, columnMoved: l });
    }
    this.interactionEnabled && ([this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(o, { mouseenter: this.onTooltipMouseEnter.bind(this), mouseleave: this.onTooltipMouseLeave.bind(this) }), [this.onDocumentKeyDownCallback] = this.addManagedElementListeners(re(this.gos), { keydown: (l) => {
      o.contains(l == null ? void 0 : l.target) || this.onKeyDown();
    } }), this.tooltipTrigger === 1 && ([this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(o, { focusin: this.onTooltipFocusIn.bind(this), focusout: this.onTooltipFocusOut.bind(this) }))), this.eventService.dispatchEvent({ type: "tooltipShow", tooltipGui: o, parentGui: this.parentComp.getGui() }), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = true, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isTooltipFocused() || (this.isInteractingWithTooltip = false, this.lockService());
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = true;
  }
  isTooltipFocused() {
    var _a3;
    const t = (_a3 = this.tooltipComp) == null ? void 0 : _a3.getGui(), i = te(this.gos);
    return !!t && t.contains(i);
  }
  onTooltipFocusOut(t) {
    const i = this.parentComp.getGui();
    this.isTooltipFocused() || (this.isInteractingWithTooltip = false, i.contains(t.relatedTarget) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    const t = { type: "tooltip", ePopup: this.tooltipComp.getGui(), nudgeY: 18, skipObserver: this.tooltipMouseTrack };
    this.lastMouseEvent ? this.popupService.positionPopupUnderMouseEvent({ ...t, mouseEvent: this.lastMouseEvent }) : this.popupService.positionPopupByComponent({ ...t, eventSource: this.parentComp.getGui(), position: "under", keepWithinBounds: true, nudgeY: 5 });
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const t = this.tooltipPopupDestroyFunc, i = this.tooltipComp, s = this.tooltipTrigger === 0 ? ja : 0;
    window.setTimeout(() => {
      t(), this.destroyBean(i);
    }, s), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener, this.tooltipFocusInListener, this.tooltipFocusOutListener].forEach((t) => {
      t && t();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    ft.isLocked = true, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, Xo);
  }
  unlockService() {
    ft.isLocked = false, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
};
sn.isLocked = false;
var qa = sn, $t = class extends R {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.refreshToolTip();
  }
  setBrowserTooltip(e) {
    const t = "title", i = this.ctrl.getGui();
    i && (e != null && e != "" ? i.setAttribute(t, e) : i.removeAttribute(t));
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    var _a3, _b, _c2, _d2;
    if (this.tooltipManager != null) return;
    const e = { getTooltipParams: () => this.getTooltipParams(), getGui: () => this.ctrl.getGui() };
    this.tooltipManager = this.createBean(new qa(e, (_b = (_a3 = this.ctrl).getTooltipShowDelayOverride) == null ? void 0 : _b.call(_a3), (_d2 = (_c2 = this.ctrl).getTooltipHideDelayOverride) == null ? void 0 : _d2.call(_c2), this.ctrl.shouldDisplayTooltip), this.beans.context);
  }
  refreshToolTip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context))) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded());
  }
  getTooltipParams() {
    var _a3, _b, _c2, _d2, _e2;
    const e = this.ctrl, t = (_a3 = e.getColumn) == null ? void 0 : _a3.call(e), i = (_b = e.getColDef) == null ? void 0 : _b.call(e), s = (_c2 = e.getRowNode) == null ? void 0 : _c2.call(e);
    return { location: e.getLocation(), colDef: i, column: t, rowIndex: (_d2 = e.getRowIndex) == null ? void 0 : _d2.call(e), node: s, data: s == null ? void 0 : s.data, value: this.getTooltipText(), valueFormatted: (_e2 = e.getValueFormatted) == null ? void 0 : _e2.call(e), hideTooltipCallback: () => {
      var _a4;
      return (_a4 = this.tooltipManager) == null ? void 0 : _a4.hideTooltip(true);
    } };
  }
  getTooltipText() {
    return this.tooltip;
  }
  destroy() {
    this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)), super.destroy();
  }
}, Ya = new go(), O = null, Y = class on extends R {
  constructor(t, i) {
    super(), this.suppressDataRefValidation = false, this.displayed = true, this.visible = true, this.compId = Ya.next(), this.cssClassManager = new wi(() => this.eGui), this.componentSelectors = new Map((i ?? []).map((s) => [s.selector, s])), t && this.setTemplate(t);
  }
  preWireBeans(t) {
    super.preWireBeans(t);
  }
  preConstruct() {
    this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips"), this.wireTemplate(this.getGui());
  }
  wireTemplate(t, i) {
    t && this.gos && (this.applyElementsToComponent(t), this.createChildComponentsFromTags(t, i));
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return { value: this.tooltipText, location: "UNKNOWN" };
  }
  setTooltip(t) {
    const { newTooltipText: i, showDelayOverride: s, hideDelayOverride: o, location: r, shouldDisplayTooltip: n } = t || {};
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.tooltipText !== i && (this.tooltipText = i);
    const l = () => this.tooltipText;
    i != null && (this.tooltipFeature = this.createBean(new $t({ getTooltipValue: l, getGui: () => this.getGui(), getLocation: () => r ?? "UNKNOWN", getColDef: t == null ? void 0 : t.getColDef, getColumn: t == null ? void 0 : t.getColumn, getTooltipShowDelayOverride: s != null ? () => s : void 0, getTooltipHideDelayOverride: o != null ? () => o : void 0, shouldDisplayTooltip: n })));
  }
  getDataRefAttribute(t) {
    return t.getAttribute ? t.getAttribute("data-ref") : null;
  }
  applyElementsToComponent(t, i, s, o = null) {
    if (i === void 0 && (i = this.getDataRefAttribute(t)), i) {
      const r = this[i];
      if (r === O) this[i] = o ?? t;
      else {
        const n = s && s[i];
        !this.suppressDataRefValidation && !n && F(`Issue with data-ref: ${i} on ${this.constructor.name} with ${r}`);
      }
    }
  }
  createChildComponentsFromTags(t, i) {
    Ua(t.childNodes).forEach((o) => {
      if (!(o instanceof HTMLElement)) return;
      const r = this.createComponentFromElement(o, (n) => {
        n.getGui() && this.copyAttributesFromNode(o, n.getGui());
      }, i);
      if (r) {
        if (r.addItems && o.children.length) {
          this.createChildComponentsFromTags(o, i);
          const n = Array.prototype.slice.call(o.children);
          r.addItems(n);
        }
        this.swapComponentForNode(r, t, o);
      } else o.childNodes && this.createChildComponentsFromTags(o, i);
    });
  }
  createComponentFromElement(t, i, s) {
    const o = t.nodeName, r = this.getDataRefAttribute(t), n = o.indexOf("AG-") === 0, l = n ? this.componentSelectors.get(o) : null;
    let a = null;
    if (l) {
      on.elementGettingCreated = t;
      const c = s && r ? s[r] : void 0;
      a = new l.component(c), a.setParentComponent(this), this.createBean(a, null, i);
    } else n && F(`Missing selector: ${o}`);
    return this.applyElementsToComponent(t, r, s, a), a;
  }
  copyAttributesFromNode(t, i) {
    Ka(t.attributes, (s, o) => i.setAttribute(s, o));
  }
  swapComponentForNode(t, i, s) {
    const o = t.getGui();
    i.replaceChild(o, s), i.insertBefore(document.createComment(s.nodeName), o), this.addDestroyFunc(this.destroyBean.bind(this, t));
  }
  activateTabIndex(t) {
    const i = this.gos.get("tabIndex");
    t || (t = []), t.length || t.push(this.getGui()), t.forEach((s) => s.setAttribute("tabindex", i.toString()));
  }
  setTemplate(t, i, s) {
    const o = mi(t);
    this.setTemplateFromElement(o, i, s);
  }
  setTemplateFromElement(t, i, s, o = false) {
    if (this.eGui = t, this.suppressDataRefValidation = o, i) for (let r = 0; r < i.length; r++) {
      const n = i[r];
      this.componentSelectors.set(n.selector, n);
    }
    this.wireTemplate(t, s);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(t) {
    this.parentComponent = t;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  setGui(t) {
    this.eGui = t;
  }
  queryForHtmlElement(t) {
    return this.eGui.querySelector(t);
  }
  getContainerAndElement(t, i) {
    let s = i;
    return t == null ? null : (s || (s = this.eGui), ho(t) ? { element: t, parent: s } : { element: t.getGui(), parent: s });
  }
  prependChild(t, i) {
    const { element: s, parent: o } = this.getContainerAndElement(t, i) || {};
    !s || !o || o.insertAdjacentElement("afterbegin", s);
  }
  appendChild(t, i) {
    const { element: s, parent: o } = this.getContainerAndElement(t, i) || {};
    !s || !o || o.appendChild(s);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(t, i = {}) {
    if (t !== this.visible) {
      this.visible = t;
      const { skipAriaHidden: s } = i;
      Wa(this.eGui, t, { skipAriaHidden: s });
    }
  }
  setDisplayed(t, i = {}) {
    if (t !== this.displayed) {
      this.displayed = t;
      const { skipAriaHidden: s } = i;
      ee(this.eGui, t, { skipAriaHidden: s });
      const o = { type: "displayChanged", visible: this.displayed };
      this.dispatchLocalEvent(o);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), super.destroy();
  }
  addGuiEventListener(t, i, s) {
    this.eGui.addEventListener(t, i, s), this.addDestroyFunc(() => this.eGui.removeEventListener(t, i));
  }
  addCssClass(t) {
    this.cssClassManager.addCssClass(t);
  }
  removeCssClass(t) {
    this.cssClassManager.removeCssClass(t);
  }
  containsCssClass(t) {
    return this.cssClassManager.containsCssClass(t);
  }
  addOrRemoveCssClass(t, i) {
    this.cssClassManager.addOrRemoveCssClass(t, i);
  }
}, rn = { columnGroupOpened: "expanded", columnGroupClosed: "contracted", columnSelectClosed: "tree-closed", columnSelectOpen: "tree-open", columnSelectIndeterminate: "tree-indeterminate", columnMovePin: "pin", columnMoveHide: "eye-slash", columnMoveMove: "arrows", columnMoveLeft: "left", columnMoveRight: "right", columnMoveGroup: "group", columnMoveValue: "aggregation", columnMovePivot: "pivot", dropNotAllowed: "not-allowed", groupContracted: "tree-closed", groupExpanded: "tree-open", setFilterGroupClosed: "tree-closed", setFilterGroupOpen: "tree-open", setFilterGroupIndeterminate: "tree-indeterminate", chart: "chart", close: "cross", cancel: "cancel", check: "tick", first: "first", previous: "previous", next: "next", last: "last", linked: "linked", unlinked: "unlinked", colorPicker: "color-picker", groupLoading: "loading", menu: "menu", menuAlt: "menu-alt", filter: "filter", columns: "columns", maximize: "maximize", minimize: "minimize", menuPin: "pin", menuValue: "aggregation", menuAddRowGroup: "group", menuRemoveRowGroup: "group", clipboardCopy: "copy", clipboardCut: "cut", clipboardPaste: "paste", pivotPanel: "pivot", rowGroupPanel: "group", valuePanel: "aggregation", columnDrag: "grip", rowDrag: "grip", save: "save", csvExport: "csv", excelExport: "excel", smallDown: "small-down", smallLeft: "small-left", smallRight: "small-right", smallUp: "small-up", sortAscending: "asc", sortDescending: "desc", sortUnSort: "none", advancedFilterBuilder: "group", advancedFilterBuilderDrag: "grip", advancedFilterBuilderInvalid: "not-allowed", advancedFilterBuilderMoveUp: "up", advancedFilterBuilderMoveDown: "down", advancedFilterBuilderAdd: "plus", advancedFilterBuilderRemove: "minus", chartsMenuEdit: "chart", chartsMenuAdvancedSettings: "settings", chartsMenuAdd: "plus", checkboxChecked: "checkbox-checked", checkboxIndeterminate: "checkbox-indeterminate", checkboxUnchecked: "checkbox-unchecked", radioButtonOn: "radio-button-on", radioButtonOff: "radio-button-off" }, Qa = (() => {
  const e = new Set(Object.values(rn));
  return e.add("eye"), e;
})();
function Xa(e, t, i) {
  const s = De(e, t, i);
  if (s) {
    const { className: r } = s;
    if (typeof r == "string" && r.indexOf("ag-icon") > -1 || typeof r == "object" && r["ag-icon"]) return s;
  }
  const o = document.createElement("span");
  return o.appendChild(s), o;
}
function De(e, t, i, s) {
  let o = null;
  const r = i && i.getColDef().icons;
  if (r && (o = r[e]), t && !o) {
    const n = t.get("icons");
    n && (o = n[e]);
  }
  if (o) {
    let n;
    if (typeof o == "function") n = o();
    else if (typeof o == "string") n = o;
    else throw new Error("icon from grid options needs to be a string or a function");
    if (typeof n == "string") return mi(n);
    if (ho(n)) return n;
    F("iconRenderer should return back a string or a dom object");
  } else {
    const n = document.createElement("span");
    let l = rn[e] ?? (Qa.has(e) ? e : void 0);
    return l || (F(`Did not find icon ${e}`), l = ""), n.setAttribute("class", `ag-icon ag-icon-${l}`), n.setAttribute("unselectable", "on"), Ve(n, "presentation"), n;
  }
}
var Ja = class extends Y {
  constructor() {
    super(...arguments), this.dragSource = null, this.eIcon = O, this.eLabel = O;
  }
  postConstruct() {
    const e = (t) => Xa(t, this.gos, null);
    this.dropIconMap = { pinned: e("columnMovePin"), hide: e("columnMoveHide"), move: e("columnMoveMove"), left: e("columnMoveLeft"), right: e("columnMoveRight"), group: e("columnMoveGroup"), aggregate: e("columnMoveValue"), pivot: e("columnMovePivot"), notAllowed: e("dropNotAllowed") };
  }
  init(e) {
    this.dragSource = e.dragSource, this.setTemplate(`<div class="ag-dnd-ghost ag-unselectable">
                <span data-ref="eIcon" class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
                <div data-ref="eLabel" class="ag-dnd-ghost-label"></div>
            </div>`);
  }
  destroy() {
    this.dragSource = null, super.destroy();
  }
  setIcon(e, t = false) {
    var _a3, _b;
    xe(this.eIcon);
    let i = null;
    e || (e = ((_a3 = this.dragSource) == null ? void 0 : _a3.getDefaultIconName) ? (_b = this.dragSource) == null ? void 0 : _b.getDefaultIconName() : "notAllowed"), i = this.dropIconMap[e], this.eIcon.classList.toggle("ag-shake-left-to-right", t), !(i === this.dropIconMap.hide && this.gos.get("suppressDragLeaveHidesColumns")) && i && this.eIcon.appendChild(i);
  }
  setLabel(e) {
    this.eLabel.textContent = Ke(e);
  }
};
function nn(e, t, i) {
  if (i === 0) return false;
  const s = Math.abs(e.clientX - t.clientX), o = Math.abs(e.clientY - t.clientY);
  return Math.max(s, o) <= i;
}
var ct = class {
  constructor(e, t = false) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = false, this.localEventService = new Ut(), this.eElement = e, this.preventMouseClick = t;
    const i = this.onTouchStart.bind(this), s = this.onTouchMove.bind(this), o = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", i, { passive: true }), this.eElement.addEventListener("touchmove", s, { passive: true }), this.eElement.addEventListener("touchend", o, { passive: false }), this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", i, { passive: true }), this.eElement.removeEventListener("touchmove", s, { passive: true }), this.eElement.removeEventListener("touchend", o, { passive: false });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++) if (e[t].identifier === this.touchStart.identifier) return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching) return;
    this.touchStart = e.touches[0], this.touching = true, this.moved = false;
    const t = this.touchStart;
    window.setTimeout(() => {
      const i = this.touchStart === t;
      if (this.touching && i && !this.moved) {
        this.moved = true;
        const s = { type: "longTap", touchStart: this.touchStart, touchEvent: e };
        this.localEventService.dispatchEvent(s);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching) return;
    const t = this.getActiveTouch(e.touches);
    if (!t) return;
    !nn(t, this.touchStart, 4) && (this.moved = true);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = { type: "tap", touchStart: this.touchStart };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = false;
    }
  }
  checkForDoubleTap() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0) if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
      const i = { type: "doubleTap", touchStart: this.touchStart };
      this.localEventService.dispatchEvent(i), this.lastTapTime = null;
    } else this.lastTapTime = e;
    else this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
};
function Jt(e, t) {
  return `<span data-ref="eSort${e}" class="ag-sort-indicator-icon ag-sort-${t} ag-hidden" aria-hidden="true"></span>`;
}
var Za = `<span class="ag-sort-indicator-container">
        ${Jt("Order", "order")}
        ${Jt("Asc", "ascending-icon")}
        ${Jt("Desc", "descending-icon")}
        ${Jt("Mixed", "mixed-icon")}
        ${Jt("None", "none-icon")}
    </span>`, po = class extends Y {
  constructor(e) {
    super(), this.eSortOrder = O, this.eSortAsc = O, this.eSortDesc = O, this.eSortMixed = O, this.eSortNone = O, e || this.setTemplate(Za);
  }
  wireBeans(e) {
    this.sortController = e.sortController;
  }
  attachCustomElements(e, t, i, s, o) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = i, this.eSortMixed = s, this.eSortNone = o;
  }
  setupSort(e, t = false) {
    if (this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !this.column.isSortable() && !this.column.getColDef().showRowGroup) return;
    this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e);
    const i = this.updateIcons.bind(this), s = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", i), this.addManagedEventListeners({ newColumnsLoaded: i, sortChanged: s, columnRowGroupChanged: s }), this.onSortChanged();
  }
  addInIcon(e, t, i) {
    if (t == null) return;
    const s = De(e, this.gos, i);
    s && t.appendChild(s);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const e = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const t = e === "asc";
      ee(this.eSortAsc, t, { skipAriaHidden: true });
    }
    if (this.eSortDesc) {
      const t = e === "desc";
      ee(this.eSortDesc, t, { skipAriaHidden: true });
    }
    if (this.eSortNone) {
      const t = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon"), i = e == null;
      ee(this.eSortNone, !t && i, { skipAriaHidden: true });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const e = this.column.getColDef().showRowGroup;
    _e(this.gos) && e && (this.addManagedEventListeners({ sortChanged: this.updateMultiSortIndicator.bind(this), columnRowGroupChanged: this.updateMultiSortIndicator.bind(this) }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const e = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      ee(this.eSortMixed, e, { skipAriaHidden: true });
    }
  }
  updateSortOrder() {
    if (!this.eSortOrder) return;
    const e = this.sortController.getColumnsWithSortingOrdered(), t = this.sortController.getDisplaySortIndexForColumn(this.column) ?? -1, i = e.some((o) => this.sortController.getDisplaySortIndexForColumn(o) ?? false), s = t >= 0 && i;
    ee(this.eSortOrder, s, { skipAriaHidden: true }), t >= 0 ? this.eSortOrder.textContent = (t + 1).toString() : xe(this.eSortOrder);
  }
}, ec = { selector: "AG-SORT-INDICATOR", component: po }, tc = `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            <ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>
        </div>
    </div>`, Ws = class extends Y {
  constructor() {
    super(...arguments), this.eFilter = O, this.eFilterButton = O, this.eSortIndicator = O, this.eMenu = O, this.eLabel = O, this.eText = O, this.eSortOrder = O, this.eSortAsc = O, this.eSortDesc = O, this.eSortMixed = O, this.eSortNone = O, this.lastMovingChanged = 0;
  }
  wireBeans(e) {
    this.sortController = e.sortController, this.menuService = e.menuService, this.funcColsService = e.funcColsService;
  }
  destroy() {
    super.destroy();
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon ? false : (this.setDisplayName(e), true);
  }
  workOutTemplate() {
    let e = this.params.template ?? tc;
    return e = e && e.trim ? e.trim() : e, e;
  }
  init(e) {
    this.params = e, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate, [ec]), this.setupTap(), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.setDisplayName(e);
  }
  setDisplayName(e) {
    if (this.currentDisplayName != e.displayName) {
      this.currentDisplayName = e.displayName;
      const t = Ke(this.currentDisplayName, true);
      this.eText && (this.eText.textContent = t);
    }
  }
  addInIcon(e, t, i) {
    if (t == null) return;
    const s = De(e, this.gos, i);
    s && t.appendChild(s);
  }
  setupTap() {
    const { gos: e } = this;
    if (e.get("suppressTouch")) return;
    const t = new ct(this.getGui(), true), i = this.shouldSuppressMenuHide(), s = i && E(this.eMenu), o = s ? new ct(this.eMenu, true) : t;
    if (this.params.enableMenu) {
      const r = s ? "tap" : "longTap", n = (l) => this.params.showColumnMenuAfterMouseClick(l.touchStart);
      this.addManagedListeners(o, { [r]: n });
    }
    if (this.params.enableSorting) {
      const r = (n) => {
        var _a3, _b;
        const l = n.touchStart.target;
        i && (((_a3 = this.eMenu) == null ? void 0 : _a3.contains(l)) || ((_b = this.eFilterButton) == null ? void 0 : _b.contains(l))) || this.sortController.progressSort(this.params.column, false, "uiColumnSorted");
      };
      this.addManagedListeners(t, { tap: r });
    }
    if (this.params.enableFilterButton) {
      const r = new ct(this.eFilterButton, true);
      this.addManagedListeners(r, { tap: () => this.params.showFilter(this.eFilterButton) }), this.addDestroyFunc(() => r.destroy());
    }
    this.addDestroyFunc(() => t.destroy()), s && this.addDestroyFunc(() => o.destroy());
  }
  workOutShowMenu() {
    return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
  }
  shouldSuppressMenuHide() {
    return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
  }
  setMenu() {
    if (!this.eMenu) return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      Mt(this.eMenu), this.eMenu = void 0;
      return;
    }
    const e = this.menuService.isLegacyMenuEnabled();
    this.addInIcon(e ? "menu" : "menuAlt", this.eMenu, this.params.column), this.eMenu.classList.toggle("ag-header-menu-icon", !e), this.currentSuppressMenuHide = this.shouldSuppressMenuHide(), this.addManagedElementListeners(this.eMenu, { click: () => this.params.showColumnMenu(this.eMenu) }), this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
  }
  onMenuKeyboardShortcut(e) {
    const t = this.params.column, i = this.menuService.isLegacyMenuEnabled();
    if (e && !i) {
      if (this.menuService.isFilterMenuInHeaderEnabled(t)) return this.params.showFilter(this.eFilterButton ?? this.eMenu ?? this.getGui()), true;
    } else if (this.params.enableMenu) return this.params.showColumnMenu(this.eMenu ?? this.eFilterButton ?? this.getGui()), true;
    return false;
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.createBean(new po(true)), this.eSortIndicator.attachCustomElements(this.eSortOrder, this.eSortAsc, this.eSortDesc, this.eSortMixed, this.eSortNone)), this.eSortIndicator.setupSort(this.params.column), !this.currentSort) return;
    this.addManagedListeners(this.params.column, { movingChanged: () => {
      this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
    } }), this.eLabel && this.addManagedElementListeners(this.eLabel, { click: (t) => {
      const i = this.params.column.isMoving(), o = (/* @__PURE__ */ new Date()).getTime() - this.lastMovingChanged < 50;
      if (!(i || o)) {
        const l = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
        this.params.progressSort(l);
      }
    } });
    const e = () => {
      var _a3;
      const t = this.params.column.getSort();
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", t === "asc"), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", t === "desc"), this.addOrRemoveCssClass("ag-header-cell-sorted-none", !t), this.params.column.getColDef().showRowGroup) {
        const o = !((_a3 = this.funcColsService.getSourceColumnsForGroupColumn(this.params.column)) == null ? void 0 : _a3.every((r) => this.params.column.getSort() == r.getSort()));
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", o);
      }
    };
    this.addManagedEventListeners({ sortChanged: e, columnRowGroupChanged: e });
  }
  setupFilterIcon() {
    this.eFilter && this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
  }
  setupFilterButton() {
    if (!this.eFilterButton) return;
    this.configureFilter(this.params.enableFilterButton, this.eFilterButton, this.onFilterChangedButton.bind(this)) ? this.addManagedElementListeners(this.eFilterButton, { click: () => this.params.showFilter(this.eFilterButton) }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, i) {
    if (!e) return Mt(t), false;
    const s = this.params.column;
    return this.addInIcon("filter", t, s), this.addManagedListeners(s, { filterChanged: i }), i(), true;
  }
  onFilterChangedIcon() {
    const e = this.params.column.isFilterActive();
    ee(this.eFilter, e, { skipAriaHidden: true });
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    return e ? this.eFilterButton ?? this.eMenu ?? this.getGui() : this.eMenu ?? this.eFilterButton ?? this.getGui();
  }
}, ic = class extends Y {
  constructor() {
    super(`<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`), this.agOpened = O, this.agClosed = O, this.agLabel = O;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel;
  }
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
  }
  checkWarnings() {
    this.params.template && F("A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)");
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", this.agOpened), this.addInIcon("columnGroupClosed", this.agClosed);
    const e = (o) => {
      if (Ze(o)) return;
      const r = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), r, "uiColumnExpanded");
    };
    this.addTouchAndClickListeners(this.agClosed, e), this.addTouchAndClickListeners(this.agOpened, e);
    const t = (o) => {
      zt(o);
    };
    this.addManagedElementListeners(this.agClosed, { dblclick: t }), this.addManagedElementListeners(this.agOpened, { dblclick: t }), this.addManagedElementListeners(this.getGui(), { dblclick: e }), this.updateIconVisibility();
    const i = this.params.columnGroup.getProvidedColumnGroup(), s = this.updateIconVisibility.bind(this);
    this.addManagedListeners(i, { expandedChanged: s, expandableChanged: s });
  }
  addTouchAndClickListeners(e, t) {
    const i = new ct(e, true);
    this.addManagedListeners(i, { tap: t }), this.addDestroyFunc(() => i.destroy()), this.addManagedElementListeners(e, { click: t });
  }
  updateIconVisibility() {
    if (this.params.columnGroup.isExpandable()) {
      const t = this.params.columnGroup.isExpanded();
      ee(this.agOpened, t), ee(this.agClosed, !t);
    } else ee(this.agOpened, false), ee(this.agClosed, false);
  }
  addInIcon(e, t) {
    const i = De(e, this.gos, null);
    i && t.appendChild(i);
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      ee(this.agOpened, false), ee(this.agClosed, false);
      return;
    }
  }
  setupLabel() {
    var _a3;
    const { displayName: e, columnGroup: t } = this.params;
    if (E(e)) {
      const i = Ke(e, true);
      this.agLabel.textContent = i;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((_a3 = t.getColGroupDef()) == null ? void 0 : _a3.suppressStickyLabel));
  }
}, sc = "\u2191", oc = "\u2193", rc = class extends Y {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-change-delta");
    const i = document.createElement("span");
    i.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(i), this.setTemplateFromElement(e);
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, true);
  }
  showDelta(e, t) {
    const i = Math.abs(t), s = e.formatValue(i), o = E(s) ? s : i, r = t >= 0;
    r ? this.eDelta.textContent = sc + o : this.eDelta.textContent = oc + o, this.eDelta.classList.toggle("ag-value-change-delta-up", r), this.eDelta.classList.toggle("ag-value-change-delta-down", !r);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), xe(this.eDelta);
  }
  refresh(e, t = false) {
    var _a3;
    const i = e.value;
    if (i === this.lastValue || (E(e.valueFormatted) ? this.eValue.textContent = e.valueFormatted : E(e.value) ? this.eValue.textContent = i : xe(this.eValue), (_a3 = this.filterManager) == null ? void 0 : _a3.isSuppressFlashingCellsBecauseFiltering())) return false;
    if (typeof i == "number" && typeof this.lastValue == "number") {
      const s = i - this.lastValue;
      this.showDelta(e, s);
    }
    return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = i, true;
  }
}, nc = class extends Y {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.refresh(e, true);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = t, this.ePrevious.textContent = this.eCurrent.textContent, this.getGui().insertBefore(this.ePrevious, this.eCurrent), this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = false) {
    var _a3;
    let i = e.value;
    return V(i) && (i = ""), i === this.lastValue || ((_a3 = this.filterManager) == null ? void 0 : _a3.isSuppressFlashingCellsBecauseFiltering()) ? false : (t || this.addSlideAnimation(), this.lastValue = i, E(e.valueFormatted) ? this.eCurrent.textContent = e.valueFormatted : E(e.value) ? this.eCurrent.textContent = i : xe(this.eCurrent), true);
  }
}, y = class {
};
y.BACKSPACE = "Backspace";
y.TAB = "Tab";
y.ENTER = "Enter";
y.ESCAPE = "Escape";
y.SPACE = " ";
y.LEFT = "ArrowLeft";
y.UP = "ArrowUp";
y.RIGHT = "ArrowRight";
y.DOWN = "ArrowDown";
y.DELETE = "Delete";
y.F2 = "F2";
y.PAGE_UP = "PageUp";
y.PAGE_DOWN = "PageDown";
y.PAGE_HOME = "Home";
y.PAGE_END = "End";
y.A = "KeyA";
y.C = "KeyC";
y.D = "KeyD";
y.V = "KeyV";
y.X = "KeyX";
y.Y = "KeyY";
y.Z = "KeyZ";
var lc = class extends Y {
  constructor(e, t, i) {
    super(t, i), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = false, this.label = "", this.config = e || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: i, labelAlignment: s, disabled: o } = this.config;
    o != null && this.setDisabled(o), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), i != null && this.setLabelWidth(i), this.setLabelAlignment(s || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    xe(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (ee(this.eLabel, false), Ve(this.eLabel, "presentation")) : (ee(this.eLabel, true), Ve(this.eLabel, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const i = this.getGui().classList;
    return i.toggle("ag-label-align-left", e === "left"), i.toggle("ag-label-align-right", e === "right"), i.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (Ji(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return fi(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, ln = class extends lc {
  constructor(e, t, i, s) {
    super(e, t, i), this.className = s;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: i } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), i != null && this.onValueChange(i), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), i = this.getLabel();
    i == null || i == "" || Fa(e) !== null ? pi(e, "") : pi(e, t ?? "");
  }
  setAriaLabel(e) {
    return _t(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return Ne(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
}, wt = class extends ln {
  constructor(e, t, i = "text", s = "input") {
    super(e, (e == null ? void 0 : e.template) ?? `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${s} data-ref="eInput" class="ag-input-field-input"></${s}>
                </div>
            </div>`, [], t), this.inputType = i, this.displayFieldTag = s, this.eLabel = O, this.eWrapper = O, this.eInput = O;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName: e, inputWidth: t } = this.config;
    e != null && this.setInputName(e), t != null && this.setInputWidth(t), this.addInputListeners(), this.activateTabIndex([this.eInput]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return Ji(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return Oe(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return _t(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return fi(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === true) Oe(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      Oe(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, fo = class extends wt {
  constructor(e, t = "ag-checkbox", i = "checkbox") {
    super(e, t, i), this.labelAlignment = "right", this.selected = false, this.readOnly = false, this.passive = false;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? true : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled) return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue));
  }
  dispatchChange(e, t, i) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: i });
    const s = this.getInputElement();
    this.eventService.dispatchEvent({ type: "checkboxChanged", id: s.id, name: s.name, selected: e, previousValue: t });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled) return;
    const t = this.isSelected(), i = this.selected = e.target.checked;
    this.refreshSelectedClass(i), this.dispatchChange(i, t, e);
  }
  refreshSelectedClass(e) {
    this.eWrapper.classList.toggle("ag-checked", e === true), this.eWrapper.classList.toggle("ag-indeterminate", e == null);
  }
}, mo = { selector: "AG-CHECKBOX", component: fo }, ac = class extends Y {
  constructor() {
    super(`
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`, [mo]), this.eCheckbox = O;
  }
  init(e) {
    this.refresh(e);
    const t = this.eCheckbox.getInputElement();
    t.setAttribute("tabindex", "-1"), Ur(t, "polite"), this.addManagedListeners(t, { click: (i) => {
      if (zt(i), this.eCheckbox.isDisabled()) return;
      const s = this.eCheckbox.getValue();
      this.onCheckboxChanged(s);
    }, dblclick: (i) => {
      zt(i);
    } }), this.addManagedElementListeners(this.params.eGridCell, { keydown: (i) => {
      if (i.key === y.SPACE && !this.eCheckbox.isDisabled()) {
        this.params.eGridCell === te(this.gos) && this.eCheckbox.toggle();
        const s = this.eCheckbox.getValue();
        this.onCheckboxChanged(s), i.preventDefault();
      }
    } });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), true;
  }
  updateCheckbox(e) {
    var _a3;
    let t, i = true;
    if (e.node.group && e.column) if (typeof e.value == "boolean") t = e.value;
    else {
      const l = e.column.getColId();
      l.startsWith(os) ? t = e.value == null || e.value === "" ? void 0 : e.value === "true" : e.node.aggData && e.node.aggData[l] !== void 0 ? t = e.value ?? void 0 : i = false;
    }
    else t = e.value ?? void 0;
    if (!i) {
      this.eCheckbox.setDisplayed(false);
      return;
    }
    this.eCheckbox.setValue(t);
    const s = e.disabled != null ? e.disabled : !((_a3 = e.column) == null ? void 0 : _a3.isCellEditable(e.node));
    this.eCheckbox.setDisabled(s);
    const o = this.localeService.getLocaleTextFunc(), r = ro(o, t), n = s ? r : `${o("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${r})`;
    this.eCheckbox.setInputAriaLabel(n);
  }
  onCheckboxChanged(e) {
    const { column: t, node: i, value: s } = this.params;
    this.eventService.dispatchEvent({ type: "cellEditingStarted", column: t, colDef: t == null ? void 0 : t.getColDef(), data: i.data, node: i, rowIndex: i.rowIndex, rowPinned: i.rowPinned, value: s });
    const o = this.params.node.setDataValue(this.params.column, e, "edit");
    this.eventService.dispatchEvent({ type: "cellEditingStopped", column: t, colDef: t == null ? void 0 : t.getColDef(), data: i.data, node: i, rowIndex: i.rowIndex, rowPinned: i.rowPinned, value: s, oldValue: s, newValue: e, valueChanged: o }), o || this.updateCheckbox(this.params);
  }
}, cc = class extends Y {
  constructor() {
    super(`<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`), this.eLoadingIcon = O, this.eLoadingText = O;
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = e("loadingError", "ERR");
  }
  setupLoading() {
    const e = De("groupLoading", this.gos, null);
    e && this.eLoadingIcon.appendChild(e);
    const t = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingOoo", "Loading");
  }
  refresh(e) {
    return false;
  }
  destroy() {
    super.destroy();
  }
}, uc = class extends Y {
  constructor() {
    super('<div class="ag-skeleton-container"></div>');
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => pi(e.eParentOfValue)), pi(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.getGui().innerText = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    _t(this.getGui(), t);
  }
  setupLoading(e) {
    const i = re(this.gos).createElement("div");
    i.classList.add("ag-skeleton-effect");
    const s = e.node.rowIndex;
    if (s != null) {
      const n = 75 + 25 * (s % 2 === 0 ? Math.sin(s) : Math.cos(s));
      i.style.width = `${n}%`;
    }
    this.getGui().appendChild(i);
    const r = this.localeService.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    _t(this.getGui(), r);
  }
  refresh(e) {
    return false;
  }
  destroy() {
    super.destroy();
  }
}, an = class extends Y {
  constructor() {
    super();
  }
  destroy() {
    super.destroy();
  }
}, dc = class extends an {
  init() {
    var _a3;
    const e = Je((_a3 = this.gos.get("overlayLoadingTemplate")) == null ? void 0 : _a3.trim());
    if (this.setTemplate(e ?? '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>'), !e) {
      const t = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = t("loadingOoo", "Loading...");
      });
    }
  }
}, hc = class extends an {
  init() {
    var _a3;
    const e = Je((_a3 = this.gos.get("overlayNoRowsTemplate")) == null ? void 0 : _a3.trim());
    if (this.setTemplate(e ?? '<span class="ag-overlay-no-rows-center"></span>'), !e) {
      const t = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = t("noRowsToShow", "No Rows To Show");
      });
    }
  }
}, jt = class extends Y {
  isPopup() {
    return true;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, gc = class extends jt {
  constructor() {
    super('<div class="ag-tooltip"></div>');
  }
  init(e) {
    const { value: t } = e;
    this.getGui().textContent = Ke(t, true);
  }
};
function cn(e) {
  const { inputValue: t, allSuggestions: i, hideIrrelevant: s, filterByPercentageOfBestMatch: o, addSequentialWeight: r } = e;
  let n = i.map((c, u) => ({ value: c, relevance: fc(t.toLowerCase(), c.toLocaleLowerCase(), r), idx: u }));
  if (n.sort((c, u) => u.relevance - c.relevance), s && (n = n.filter((c) => c.relevance !== 0)), n.length > 0 && o && o > 0) {
    const u = n[0].relevance * o;
    n = n.filter((d) => u - d.relevance < 0);
  }
  const l = [], a = [];
  for (const c of n) l.push(c.value), a.push(c.idx);
  return { values: l, indices: a };
}
function pc(e) {
  const t = [], i = e.length;
  for (let s = 1; s <= i; s++) for (let o = 0; o <= i - s; o++) {
    const r = o + s - 1;
    t.push(e.slice(o, r + 1));
  }
  return t;
}
function fc(e, t, i = false) {
  const s = e.replace(/\s/g, ""), o = t.replace(/\s/g, ""), r = s.length, n = o.length, l = new Array(r + 1).fill(null).map(() => new Array(n + 1).fill(0));
  for (let d = 0; d <= r; d += 1) l[d][0] = d;
  for (let d = 0; d <= n; d += 1) l[0][d] = d;
  for (let d = 1; d <= r; d++) for (let h = 1; h <= n; h++) s[d - 1] === o[h - 1] ? l[d][h] = l[d - 1][h - 1] : l[d][h] = 1 + Math.min(l[d][h - 1], Math.min(l[d - 1][h], l[d - 1][h - 1]));
  const a = l[r][n];
  let u = Math.max(r, n) - a;
  if (i) {
    const d = pc(s);
    for (let h = 0; h < d.length; h++) {
      const g = d[h];
      o.indexOf(g) !== -1 && (u += 1, u *= g.length);
    }
  }
  return u;
}
var mc = class extends R {
  constructor() {
    super(...arguments), this.beanName = "userComponentRegistry", this.agGridDefaults = { agDragAndDropImage: Ja, agColumnHeader: Ws, agColumnGroupHeader: ic, agSortIndicator: po, agAnimateShowChangeCellRenderer: rc, agAnimateSlideCellRenderer: nc, agLoadingCellRenderer: cc, agSkeletonCellRenderer: uc, agCheckboxCellRenderer: ac, agLoadingOverlay: dc, agNoRowsOverlay: hc, agTooltipComponent: gc }, this.agGridDefaultParams = {}, this.enterpriseAgDefaultCompsModule = { agSetColumnFilter: "@ag-grid-enterprise/set-filter", agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter", agMultiColumnFilter: "@ag-grid-enterprise/multi-filter", agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter", agGroupColumnFilter: "@ag-grid-enterprise/row-grouping", agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping", agGroupCellRenderer: "@ag-grid-enterprise/row-grouping", agGroupRowRenderer: "@ag-grid-enterprise/row-grouping", agRichSelect: "@ag-grid-enterprise/rich-select", agRichSelectCellEditor: "@ag-grid-enterprise/rich-select", agDetailCellRenderer: "@ag-grid-enterprise/master-detail", agSparklineCellRenderer: "@ag-grid-enterprise/sparklines" }, this.jsComps = {};
  }
  postConstruct() {
    const e = this.gos.get("components");
    e != null && He(e, (t, i) => this.registerJsComponent(t, i));
  }
  registerDefaultComponent(e, t, i) {
    this.agGridDefaults[e] = t, i && (this.agGridDefaultParams[e] = i);
  }
  registerJsComponent(e, t) {
    this.jsComps[e] = t;
  }
  retrieve(e, t) {
    const i = (l, a, c) => ({ componentFromFramework: a, component: l, params: c }), s = this.getFrameworkOverrides().frameworkComponent(t, this.gos.get("components"));
    if (s != null) return i(s, true);
    const o = this.jsComps[t];
    if (o) {
      const l = this.getFrameworkOverrides().isFrameworkComponent(o);
      return i(o, l);
    }
    const r = this.agGridDefaults[t];
    if (r) return i(r, false, this.agGridDefaultParams[t]);
    const n = this.enterpriseAgDefaultCompsModule[t];
    return n ? this.gos.assertModuleRegistered(n, `AG Grid '${e}' component: ${t}`) : Xs(() => {
      this.warnAboutMissingComponent(e, t);
    }, "MissingComp" + t), null;
  }
  warnAboutMissingComponent(e, t) {
    const i = [...Object.keys(this.agGridDefaults).filter((o) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(o)), ...Object.keys(this.jsComps)], s = cn({ inputValue: t, allSuggestions: i, hideIrrelevant: true, filterByPercentageOfBestMatch: 0.8 }).values;
    F(`Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`), s.length > 0 && F(`         Did you mean: [${s.slice(0, 3)}]?`), F(`If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`);
  }
}, oe = class ii {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t((i) => this.onDone(i), (i) => this.onReject(i));
  }
  static all(t) {
    return t.length ? new ii((i) => {
      let s = t.length;
      const o = new Array(s);
      t.forEach((r, n) => {
        r.then((l) => {
          o[n] = l, s--, s === 0 && i(o);
        });
      });
    }) : ii.resolve();
  }
  static resolve(t = null) {
    return new ii((i) => i(t));
  }
  then(t) {
    return new ii((i) => {
      this.status === 1 ? i(t(this.resolution)) : this.waiters.push((s) => i(t(s)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((i) => i(t));
  }
  onReject(t) {
  }
}, Cc = { propertyName: "dateComponent", cellRenderer: false }, vc = { propertyName: "dragAndDropImageComponent", cellRenderer: false }, Sc = { propertyName: "headerComponent", cellRenderer: false }, wc = { propertyName: "headerGroupComponent", cellRenderer: false }, Jo = { propertyName: "cellRenderer", cellRenderer: true }, yc = { propertyName: "cellRenderer", cellRenderer: false }, Rc = { propertyName: "loadingCellRenderer", cellRenderer: true }, Fc = { propertyName: "cellEditor", cellRenderer: false }, Zo = { propertyName: "innerRenderer", cellRenderer: true }, bc = { propertyName: "loadingOverlayComponent", cellRenderer: false }, Pc = { propertyName: "noRowsOverlayComponent", cellRenderer: false }, Ec = { propertyName: "tooltipComponent", cellRenderer: false }, Co = { propertyName: "filter", cellRenderer: false }, Dc = { propertyName: "floatingFilterComponent", cellRenderer: false }, Mc = { propertyName: "toolPanel", cellRenderer: false }, xc = { propertyName: "statusPanel", cellRenderer: false }, Ac = { propertyName: "fullWidthCellRenderer", cellRenderer: true }, Tc = { propertyName: "loadingCellRenderer", cellRenderer: true }, Ic = { propertyName: "groupRowRenderer", cellRenderer: true }, Lc = { propertyName: "detailCellRenderer", cellRenderer: true }, Oc = { propertyName: "menuItem", cellRenderer: false }, un = class dn extends R {
  constructor() {
    super(...arguments), this.beanName = "userComponentFactory";
  }
  wireBeans(t) {
    this.agComponentUtils = t.agComponentUtils, this.componentMetadataProvider = t.componentMetadataProvider, this.userComponentRegistry = t.userComponentRegistry, this.frameworkComponentWrapper = t.frameworkComponentWrapper, this.gridOptions = t.gridOptions;
  }
  getDragAndDropImageCompDetails(t) {
    return this.getCompDetails(this.gridOptions, vc, "agDragAndDropImage", t, true);
  }
  getHeaderCompDetails(t, i) {
    return this.getCompDetails(t, Sc, "agColumnHeader", i);
  }
  getHeaderGroupCompDetails(t) {
    const i = t.columnGroup.getColGroupDef();
    return this.getCompDetails(i, wc, "agColumnGroupHeader", t);
  }
  getFullWidthCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, Ac, null, t, true);
  }
  getFullWidthLoadingCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, Tc, "agLoadingCellRenderer", t, true);
  }
  getFullWidthGroupCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, Ic, "agGroupRowRenderer", t, true);
  }
  getFullWidthDetailCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, Lc, "agDetailCellRenderer", t, true);
  }
  getInnerRendererDetails(t, i) {
    return this.getCompDetails(t, Zo, null, i);
  }
  getFullWidthGroupRowInnerCellRenderer(t, i) {
    return this.getCompDetails(t, Zo, null, i);
  }
  getCellRendererDetails(t, i) {
    return this.getCompDetails(t, Jo, null, i);
  }
  getEditorRendererDetails(t, i) {
    return this.getCompDetails(t, yc, null, i);
  }
  getLoadingCellRendererDetails(t, i) {
    return this.getCompDetails(t, Rc, "agSkeletonCellRenderer", i, true);
  }
  getCellEditorDetails(t, i) {
    return this.getCompDetails(t, Fc, "agCellEditor", i, true);
  }
  getFilterDetails(t, i, s) {
    return this.getCompDetails(t, Co, s, i, true);
  }
  getDateCompDetails(t) {
    return this.getCompDetails(this.gridOptions, Cc, "agDateInput", t, true);
  }
  getLoadingOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, bc, "agLoadingOverlay", t, true);
  }
  getNoRowsOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, Pc, "agNoRowsOverlay", t, true);
  }
  getTooltipCompDetails(t) {
    return this.getCompDetails(t.colDef, Ec, "agTooltipComponent", t, true);
  }
  getSetFilterCellRendererDetails(t, i) {
    return this.getCompDetails(t, Jo, null, i);
  }
  getFloatingFilterCompDetails(t, i, s) {
    return this.getCompDetails(t, Dc, s, i);
  }
  getToolPanelCompDetails(t, i) {
    return this.getCompDetails(t, Mc, null, i, true);
  }
  getStatusPanelCompDetails(t, i) {
    return this.getCompDetails(t, xc, null, i, true);
  }
  getMenuItemCompDetails(t, i) {
    return this.getCompDetails(t, Oc, "agMenuItem", i, true);
  }
  getCompDetails(t, i, s, o, r = false) {
    const { propertyName: n, cellRenderer: l } = i;
    let { compName: a, jsComp: c, fwComp: u, paramsFromSelector: d, popupFromSelector: h, popupPositionFromSelector: g } = dn.getCompKeys(this.frameworkOverrides, t, i, o), m;
    const C = (S) => {
      const b = this.userComponentRegistry.retrieve(n, S);
      b && (c = b.componentFromFramework ? void 0 : b.component, u = b.componentFromFramework ? b.component : void 0, m = b.params);
    };
    if (a != null && C(a), c == null && u == null && s != null && C(s), c && l && !this.agComponentUtils.doesImplementIComponent(c) && (c = this.agComponentUtils.adaptFunction(n, c)), !c && !u) {
      r && z(`Could not find component ${a}, did you forget to configure this component?`);
      return;
    }
    const f = this.mergeParamsWithApplicationProvidedParams(t, i, o, d, m), v = c == null, w = c || u;
    return { componentFromFramework: v, componentClass: w, params: f, type: i, popupFromSelector: h, popupPositionFromSelector: g, newAgStackInstance: () => this.newAgStackInstance(w, v, f, i) };
  }
  static getCompKeys(t, i, s, o) {
    const { propertyName: r } = s;
    let n, l, a, c, u, d;
    if (i) {
      const h = i, g = h[r + "Selector"], m = g ? g(o) : null, C = (f) => {
        typeof f == "string" ? n = f : f != null && f !== true && (t.isFrameworkComponent(f) ? a = f : l = f);
      };
      m ? (C(m.component), c = m.params, u = m.popup, d = m.popupPosition) : C(h[r]);
    }
    return { compName: n, jsComp: l, fwComp: a, paramsFromSelector: c, popupFromSelector: u, popupPositionFromSelector: d };
  }
  newAgStackInstance(t, i, s, o) {
    const r = o.propertyName, n = !i;
    let l;
    if (n) l = new t();
    else {
      const c = this.componentMetadataProvider.retrieve(r);
      l = this.frameworkComponentWrapper.wrap(t, c.mandatoryMethodList, c.optionalMethodList, o);
    }
    const a = this.initComponent(l, s);
    return a == null ? oe.resolve(l) : a.then(() => l);
  }
  mergeParamsWithApplicationProvidedParams(t, i, s, o = null, r) {
    const n = this.gos.getGridCommonParams();
    we(n, s), r && we(n, r);
    const l = t, a = l && l[i.propertyName + "Params"];
    if (typeof a == "function") {
      const c = a(s);
      we(n, c);
    } else typeof a == "object" && we(n, a);
    return we(n, o), n;
  }
  initComponent(t, i) {
    if (this.createBean(t), t.init != null) return t.init(i);
  }
};
function li(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var rs = class B {
  static register(t) {
    B.__register(t, true, void 0);
  }
  static registerModules(t) {
    B.__registerModules(t, true, void 0);
  }
  static __register(t, i, s) {
    B.runVersionChecks(t), s !== void 0 ? (B.areGridScopedModules = true, B.gridModulesMap[s] === void 0 && (B.gridModulesMap[s] = {}), B.gridModulesMap[s][t.moduleName] = t) : B.globalModulesMap[t.moduleName] = t, B.setModuleBased(i);
  }
  static __unRegisterGridModules(t) {
    delete B.gridModulesMap[t];
  }
  static __registerModules(t, i, s) {
    B.setModuleBased(i), t && t.forEach((o) => B.__register(o, i, s));
  }
  static isValidModuleVersion(t) {
    const [i, s] = t.version.split(".") || [], [o, r] = B.currentModuleVersion.split(".") || [];
    return i === o && s === r;
  }
  static runVersionChecks(t) {
    B.currentModuleVersion || (B.currentModuleVersion = t.version);
    const i = (s) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${s} Please update all modules to the same version.`;
    if (t.version ? B.isValidModuleVersion(t) || z(i(`'${t.moduleName}' is version ${t.version} but the other modules are version ${B.currentModuleVersion}.`)) : z(i(`'${t.moduleName}' is incompatible.`)), t.validate) {
      const s = t.validate();
      s.isValid || z(`${s.message}`);
    }
  }
  static setModuleBased(t) {
    B.moduleBased === void 0 ? B.moduleBased = t : B.moduleBased !== t && (z("AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."), z("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information."));
  }
  static __setIsBundled() {
    B.isBundled = true;
  }
  static __assertRegistered(t, i, s) {
    var _a3;
    if (this.__isRegistered(t, s)) return true;
    let o;
    if (B.isBundled) o = `AG Grid: unable to use ${i} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
    else if (B.moduleBased || B.moduleBased === void 0) {
      const r = (_a3 = Object.entries(ht).find(([n, l]) => l === t)) == null ? void 0 : _a3[0];
      o = `AG Grid: unable to use ${i} as the ${r} is not registered${B.areGridScopedModules ? ` for gridId: ${s}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${r} } from '${t}';
    
    ModuleRegistry.registerModules([ ${r} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else o = `AG Grid: unable to use ${i} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
    return z(o), false;
  }
  static __isRegistered(t, i) {
    var _a3;
    return !!B.globalModulesMap[t] || !!((_a3 = B.gridModulesMap[i]) == null ? void 0 : _a3[t]);
  }
  static __getRegisteredModules(t) {
    return [...Li(B.globalModulesMap), ...Li(B.gridModulesMap[t] || {})];
  }
  static __getGridRegisteredModules(t) {
    return Li(B.gridModulesMap[t] ?? {}) || [];
  }
  static __isPackageBased() {
    return !B.moduleBased;
  }
};
rs.globalModulesMap = {};
rs.gridModulesMap = {};
rs.areGridScopedModules = false;
var Ue = rs, Gc = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = false, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var _a3;
    Object.entries(e.providedBeanInstances).forEach(([t, i]) => {
      this.beans[t] = i;
    }), e.beanClasses.forEach((t) => {
      const i = new t();
      i.beanName ? this.beans[i.beanName] = i : console.error(`Bean ${t.name} is missing beanName`), this.createdBeans.push(i);
    }), (_a3 = e.derivedBeans) == null ? void 0 : _a3.forEach((t) => {
      const { beanName: i, bean: s } = t(this);
      this.beans[i] = s, this.createdBeans.push(s);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    if (!e) throw Error("Can't wire to bean since it is null");
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    e.forEach((i) => {
      var _a3, _b;
      (_a3 = i.preWireBeans) == null ? void 0 : _a3.call(i, this.beans), (_b = i.wireBeans) == null ? void 0 : _b.call(i, this.beans);
    }), e.forEach((i) => {
      var _a3;
      return (_a3 = i.preConstruct) == null ? void 0 : _a3.call(i);
    }), t && e.forEach(t), e.forEach((i) => {
      var _a3;
      return (_a3 = i.postConstruct) == null ? void 0 : _a3.call(i);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  destroy() {
    if (this.destroyed) return;
    this.destroyed = true;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [];
  }
  destroyBean(e) {
    var _a3;
    (_a3 = e == null ? void 0 : e.destroy) == null ? void 0 : _a3.call(e);
  }
  destroyBeans(e) {
    if (e) for (let t = 0; t < e.length; t++) this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, kc = class extends Gc {
  init(e) {
    this.gridId = e.gridId, this.beans.context = this, super.init(e);
  }
  destroy() {
    super.destroy(), Ue.__unRegisterGridModules(this.gridId);
  }
  getGridId() {
    return this.gridId;
  }
}, hn = ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(hn || {}), Hc = class extends R {
  constructor() {
    super(...arguments), this.beanName = "dragAndDropService", this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.dragService = e.dragService, this.mouseEventService = e.mouseEventService, this.environment = e.environment, this.userComponentFactory = e.userComponentFactory;
  }
  addDragSource(e, t = false) {
    const i = { eElement: e.eElement, dragStartPixels: e.dragStartPixels, onDragStart: this.onDragStart.bind(this, e), onDragStop: this.onDragStop.bind(this), onDragging: this.onDragging.bind(this), onDragCancel: this.onDragCancel.bind(this), includeTouch: t };
    this.dragSourceAndParamsList.push({ params: i, dragSource: e }), this.dragService.addDragSource(i);
  }
  getDragAndDropImageComponent() {
    const { dragAndDropImageComp: e } = this;
    return !e || !e.comp ? null : e.comp;
  }
  removeDragSource(e) {
    const t = this.dragSourceAndParamsList.find((i) => i.dragSource === e);
    t && (this.dragService.removeDragSource(t.params), Fe(this.dragSourceAndParamsList, t));
  }
  destroy() {
    this.dragSourceAndParamsList.forEach((e) => this.dragService.removeDragSource(e.params)), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0, this.clearDragAndDropProperties(), super.destroy();
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, true);
  }
  onDragStart(e, t) {
    var _a3, _b;
    this.dragging = true, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), (_b = (_a3 = this.dragSource).onDragStarted) == null ? void 0 : _b.call(_a3), this.createDragAndDropImageComponent();
  }
  onDragStop(e) {
    var _a3, _b, _c2;
    if ((_b = (_a3 = this.dragSource) == null ? void 0 : _a3.onDragStopped) == null ? void 0 : _b.call(_a3), (_c2 = this.lastDropTarget) == null ? void 0 : _c2.onDragStop) {
      const t = this.createDropTargetEvent(this.lastDropTarget, e, null, null, false);
      this.lastDropTarget.onDragStop(t);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    var _a3, _b, _c2;
    (_b = (_a3 = this.dragSource) == null ? void 0 : _a3.onDragCancelled) == null ? void 0 : _b.call(_a3), ((_c2 = this.lastDropTarget) == null ? void 0 : _c2.onDragCancel) && this.lastDropTarget.onDragCancel(this.createDropTargetEvent(this.lastDropTarget, this.eventLastTime, null, null, false)), this.clearDragAndDropProperties();
  }
  clearDragAndDropProperties() {
    this.eventLastTime = null, this.dragging = false, this.lastDropTarget = void 0, this.dragItem = null, this.dragSource = null, this.removeDragAndDropImageComponent();
  }
  onDragging(e, t = false) {
    var _a3, _b, _c2, _d2;
    const i = this.getHorizontalDirection(e), s = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionDragAndDropImageComp(e);
    const o = this.dropTargets.filter((n) => this.isMouseOnDropTarget(e, n)), r = this.findCurrentDropTarget(e, o);
    if (r !== this.lastDropTarget) {
      if (this.leaveLastTargetIfExists(e, i, s, t), this.lastDropTarget !== null && r === null && ((_b = (_a3 = this.dragSource) == null ? void 0 : _a3.onGridExit) == null ? void 0 : _b.call(_a3, this.dragItem)), this.lastDropTarget === null && r !== null && ((_d2 = (_c2 = this.dragSource) == null ? void 0 : _c2.onGridEnter) == null ? void 0 : _d2.call(_c2, this.dragItem)), this.enterDragTargetIfExists(r, e, i, s, t), r && this.dragAndDropImageComp) {
        const { comp: n, promise: l } = this.dragAndDropImageComp;
        n ? n.setIcon(r.getIconName ? r.getIconName() : null) : l.then((a) => {
          a && a.setIcon(r.getIconName ? r.getIconName() : null);
        });
      }
      this.lastDropTarget = r;
    } else if (r && r.onDragging) {
      const n = this.createDropTargetEvent(r, e, i, s, t);
      r.onDragging(n);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, i = [[e.getContainer()]];
    return t ? i.concat(t) : i;
  }
  allContainersIntersect(e, t) {
    for (const i of t) {
      const { width: s, height: o, left: r, right: n, top: l, bottom: a } = i.getBoundingClientRect();
      if (s === 0 || o === 0) return false;
      const c = e.clientX >= r && e.clientX < n, u = e.clientY >= l && e.clientY < a;
      if (!c || !u) return false;
    }
    return true;
  }
  isMouseOnDropTarget(e, t) {
    const i = this.getAllContainersFromDropTarget(t);
    let s = false;
    for (const n of i) if (this.allContainersIntersect(e, n)) {
      s = true;
      break;
    }
    const { eElement: o, type: r } = this.dragSource;
    return t.targetContainsSource && !t.getContainer().contains(o) ? false : s && t.isInterestedIn(r, o);
  }
  findCurrentDropTarget(e, t) {
    const i = t.length;
    if (i === 0) return null;
    if (i === 1) return t[0];
    const o = di(this.gos).elementsFromPoint(e.clientX, e.clientY);
    for (const r of o) for (const n of t) if (jl(this.getAllContainersFromDropTarget(n)).indexOf(r) !== -1) return n;
    return null;
  }
  enterDragTargetIfExists(e, t, i, s, o) {
    if (e && e.onDragEnter) {
      const r = this.createDropTargetEvent(e, t, i, s, o);
      e.onDragEnter(r);
    }
  }
  leaveLastTargetIfExists(e, t, i, s) {
    if (!this.lastDropTarget) return;
    if (this.lastDropTarget.onDragLeave) {
      const r = this.createDropTargetEvent(this.lastDropTarget, e, t, i, s);
      this.lastDropTarget.onDragLeave(r);
    }
    const o = this.getDragAndDropImageComponent();
    o && o.setIcon(null);
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((i) => i.external).find((i) => i.getContainer() === e.getContainer()) || null;
  }
  isDropZoneWithinThisGrid(e) {
    const i = this.ctrlsService.getGridBodyCtrl().getGui(), { dropZoneTarget: s } = e;
    return i.contains(s);
  }
  getHorizontalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientX, i = e.clientX;
    return t === i ? null : t > i ? 0 : 1;
  }
  getVerticalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientY, i = e.clientY;
    return t === i ? null : t > i ? 0 : 1;
  }
  createDropTargetEvent(e, t, i, s, o) {
    const r = e.getContainer(), n = r.getBoundingClientRect(), { dragItem: l, dragSource: a } = this, c = t.clientX - n.left, u = t.clientY - n.top;
    return this.gos.addGridCommonParams({ event: t, x: c, y: u, vDirection: s, hDirection: i, dragSource: a, fromNudge: o, dragItem: l, dropZoneTarget: r });
  }
  positionDragAndDropImageComp(e) {
    const t = this.getDragAndDropImageComponent();
    if (!t) return;
    const i = t.getGui(), o = i.getBoundingClientRect().height, r = Ha() - 2, n = Na() - 2;
    if (!i.offsetParent) return;
    const a = Zr(i.offsetParent), { clientY: c, clientX: u } = e;
    let d = c - a.top - o / 2, h = u - a.left - 10;
    const g = re(this.gos), m = g.defaultView || window, C = m.pageYOffset || g.documentElement.scrollTop, f = m.pageXOffset || g.documentElement.scrollLeft;
    r > 0 && h + i.clientWidth > r + f && (h = r + f - i.clientWidth), h < 0 && (h = 0), n > 0 && d + i.clientHeight > n + C && (d = n + C - i.clientHeight), d < 0 && (d = 0), i.style.left = `${h}px`, i.style.top = `${d}px`;
  }
  removeDragAndDropImageComponent() {
    if (this.dragAndDropImageComp) {
      const { comp: e } = this.dragAndDropImageComp;
      if (e) {
        const t = e.getGui();
        this.dragAndDropImageParent && this.dragAndDropImageParent.removeChild(t), this.destroyBean(e);
      }
    }
    this.dragAndDropImageComp = null;
  }
  createDragAndDropImageComponent() {
    const { dragSource: e } = this;
    if (!e) return;
    const i = this.userComponentFactory.getDragAndDropImageCompDetails({ dragSource: e }).newAgStackInstance();
    this.dragAndDropImageComp = { promise: i }, i.then((s) => {
      !s || !this.isAlive() || (this.processDragAndDropImageComponent(s), this.dragAndDropImageComp.comp = s);
    });
  }
  processDragAndDropImageComponent(e) {
    const { dragSource: t, mouseEventService: i, environment: s } = this;
    if (!t) return;
    const o = e.getGui();
    o.style.setProperty("position", "absolute"), o.style.setProperty("z-index", "9999"), i.stampTopLevelGridCompWithGridInstance(o), s.applyThemeClasses(o), e.setIcon(null);
    let { dragItemName: r } = t;
    Js(r) && (r = r()), e.setLabel(r || ""), o.style.top = "20px", o.style.left = "20px";
    const n = re(this.gos);
    let l = null, a = null;
    try {
      l = n.fullscreenElement;
    } catch {
    } finally {
      l || (l = di(this.gos));
      const c = l.querySelector("body");
      c ? a = c : l instanceof ShadowRoot ? a = l : l instanceof Document ? a = l == null ? void 0 : l.documentElement : a = l;
    }
    this.dragAndDropImageParent = a, a ? a.appendChild(o) : F("Could not find document body, it is needed for drag and drop.");
  }
}, Nc = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => false), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => false);
  }
  check(e, t = false) {
    const i = t || this.shouldSkipVerticalScroll();
    if (i && this.shouldSkipHorizontalScroll()) return;
    const s = this.scrollContainer.getBoundingClientRect(), o = this.scrollByTick;
    this.tickLeft = e.clientX < s.left + o, this.tickRight = e.clientX > s.right - o, this.tickUp = e.clientY < s.top + o && !i, this.tickDown = e.clientY > s.bottom - o && !i, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}, si = ((e) => (e[e.Above = 0] = "Above", e[e.Below = 1] = "Below", e))(si || {}), Vc = class extends R {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.sortController = e.sortController, this.filterManager = e.filterManager, this.selectionService = e.selectionService, this.mouseEventService = e.mouseEventService, this.ctrlsService = e.ctrlsService, this.funcColsService = e.funcColsService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    Q(this.gos) && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady(this, (e) => {
      const t = e.gridBodyCtrl;
      this.autoScrollService = new Nc({ scrollContainer: t.getBodyViewportElement(), scrollAxis: "y", getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top, setVerticalPosition: (i) => t.getScrollFeature().setVerticalScrollPosition(i), onScrollCallback: () => {
        this.onDragging(this.lastDraggingEvent);
      } });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName() {
    return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? "notAllowed" : "move";
  }
  shouldPreventRowMove() {
    var _a3;
    return !!(this.funcColsService.getRowGroupColumns().length || ((_a3 = this.filterManager) == null ? void 0 : _a3.isAnyFilterPresent()) || this.sortController.isSortActive());
  }
  getRowNodes(e) {
    if (!this.isFromThisGrid(e)) return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const s = [...this.selectionService.getSelectedNodes()].sort((o, r) => o.rowIndex == null || r.rowIndex == null ? 0 : this.getRowIndexNumber(o) - this.getRowIndexNumber(r));
      if (s.indexOf(t) !== -1) return s;
    }
    return [t];
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent("rowDragEnter", e), this.getRowNodes(e).forEach((t) => {
      t.setDragging(true);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gos.getDomDataKey();
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent("rowDragMove", e), this.lastDraggingEvent = e;
    const t = this.mouseEventService.getNormalisedPosition(e).y;
    this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const i = this.isFromThisGrid(e), s = this.gos.get("rowDragManaged"), o = e.dragItem.rowNodes;
    s && this.shouldPreventRowMove() || (this.gos.get("suppressMoveWhenRowDragging") || !i ? this.dragAndDropService.isDropZoneWithinThisGrid(e) && this.clientSideRowModel.highlightRowAtPixel(o[0], t) : this.moveRows(o, t));
  }
  getRowIndexNumber(e) {
    const t = e.getRowIndexString();
    return parseInt(N(t.split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel.getLastHighlightedRowNode(), i = t && t.highlighted === 1, s = this.mouseEventService.getNormalisedPosition(e).y, o = e.dragItem.rowNodes;
    let r = i ? 1 : 0;
    if (this.isFromThisGrid(e)) o.forEach((n) => {
      n.rowTop < s && (r -= 1);
    }), this.moveRows(o, s, r);
    else {
      const n = Ci(this.gos);
      let l = this.clientSideRowModel.getRowIndexAtPixel(s) + 1;
      this.clientSideRowModel.getHighlightPosition(s) === 0 && l--, this.clientSideRowModel.updateRowData({ add: o.filter((a) => !this.clientSideRowModel.getRowNode((n == null ? void 0 : n({ data: a.data, level: 0, rowPinned: a.rowPinned })) ?? a.data.id)).map((a) => a.data), addIndex: l });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, i = 0) {
    var _a3;
    this.clientSideRowModel.ensureRowsAtPixel(e, t, i) && (this.focusService.clearFocusedCell(), (_a3 = this.rangeService) == null ? void 0 : _a3.removeAllCellRanges());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      F("addRowDropZone - A container target needs to be provided");
      return;
    }
    if (this.dragAndDropService.findExternalZone(e)) {
      F("addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
      return;
    }
    let t = { getContainer: e.getContainer };
    e.fromGrid ? t = e : (e.onDragEnter && (t.onDragEnter = (s) => {
      e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", s));
    }), e.onDragLeave && (t.onDragLeave = (s) => {
      e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", s));
    }), e.onDragging && (t.onDragging = (s) => {
      e.onDragging(this.draggingToRowDragEvent("rowDragMove", s));
    }), e.onDragStop && (t.onDragStop = (s) => {
      e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", s));
    }), e.onDragCancel && (t.onDragCancel = (s) => {
      e.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", s));
    }));
    const i = { isInterestedIn: (s) => s === 2, getIconName: () => "move", external: true, ...t };
    this.dragAndDropService.addDropTarget(i), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(i));
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), i = this.onDragEnter.bind(this), s = this.onDragLeave.bind(this), o = this.onDragging.bind(this), r = this.onDragStop.bind(this), n = this.onDragCancel.bind(this);
    let l;
    return e ? l = { getContainer: t, onDragEnter: e.onDragEnter ? (a) => {
      i(a), e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", a));
    } : i, onDragLeave: e.onDragLeave ? (a) => {
      s(a), e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", a));
    } : s, onDragging: e.onDragging ? (a) => {
      o(a), e.onDragging(this.draggingToRowDragEvent("rowDragMove", a));
    } : o, onDragStop: e.onDragStop ? (a) => {
      r(a), e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", a));
    } : r, onDragCancel: e.onDragCancel ? (a) => {
      n(a), e.onDragCancel(this.draggingToRowDragEvent("rowDragCancel", a));
    } : n, fromGrid: true } : l = { getContainer: t, onDragEnter: i, onDragLeave: s, onDragging: o, onDragStop: r, onDragCancel: n, fromGrid: true }, l;
  }
  draggingToRowDragEvent(e, t) {
    const i = this.mouseEventService.getNormalisedPosition(t).y, s = i > this.pageBoundsService.getCurrentPageHeight();
    let o = -1, r;
    s || (o = this.rowModel.getRowIndexAtPixel(i), r = this.rowModel.getRow(o));
    let n;
    switch (t.vDirection) {
      case 1:
        n = "down";
        break;
      case 0:
        n = "up";
        break;
      default:
        n = null;
        break;
    }
    return this.gos.addGridCommonParams({ type: e, event: t.event, node: t.dragItem.rowNode, nodes: t.dragItem.rowNodes, overIndex: o, overNode: r, y: i, vDirection: n });
  }
  dispatchGridEvent(e, t) {
    const i = this.draggingToRowDragEvent(e, t);
    this.eventService.dispatchEvent(i);
  }
  onDragLeave(e) {
    this.dispatchGridEvent("rowDragLeave", e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight();
  }
  onDragStop(e) {
    this.dispatchGridEvent("rowDragEnd", e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && this.dragAndDropService.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  onDragCancel(e) {
    this.dispatchGridEvent("rowDragCancel", e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && this.dragAndDropService.isDropZoneWithinThisGrid(e) && this.clearRowHighlight();
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      t.setDragging(false);
    });
  }
}, Bc = class extends R {
  constructor() {
    super(...arguments), this.beanName = "dragService", this.dragEndFunctions = [], this.dragSources = [];
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService;
  }
  destroy() {
    this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, i = e.mouseDownListener;
    if (t.removeEventListener("mousedown", i), e.touchEnabled) {
      const s = e.touchStartListener;
      t.removeEventListener("touchstart", s, { passive: true });
    }
  }
  removeDragSource(e) {
    const t = this.dragSources.find((i) => i.dragSource === e);
    t && (this.removeListener(t), Fe(this.dragSources, t));
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: i, includeTouch: s, stopPropagationForTouch: o } = e;
    i.addEventListener("mousedown", t);
    let r = null;
    const n = this.gos.get("suppressTouch");
    s && !n && (r = (l) => {
      ao(l.target) || (o && l.stopPropagation(), this.onTouchStart(e, l));
    }, i.addEventListener("touchstart", r, { passive: false })), this.dragSources.push({ dragSource: e, mouseDownListener: t, touchStartListener: r, touchEnabled: !!s });
  }
  getStartTarget() {
    return this.startTarget;
  }
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = false;
    const i = t.touches[0];
    this.touchLastTime = i, this.touchStart = i;
    const s = (a) => this.onTouchMove(a, e.eElement), o = (a) => this.onTouchUp(a, e.eElement), r = (a) => {
      a.cancelable && a.preventDefault();
    }, n = t.target, l = [{ target: di(this.gos), type: "touchmove", listener: r, options: { passive: false } }, { target: n, type: "touchmove", listener: s, options: { passive: true } }, { target: n, type: "touchend", listener: o, options: { passive: true } }, { target: n, type: "touchcancel", listener: o, options: { passive: true } }];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onCommonMove(i, this.touchStart, e.eElement);
  }
  onMouseDown(e, t) {
    const i = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || i._alreadyProcessedByDragService || (i._alreadyProcessedByDragService = true, t.button !== 0)) return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = false, this.mouseStartEvent = t, this.startTarget = t.target;
    const s = (c) => this.onMouseMove(c, e.eElement), o = (c) => this.onMouseUp(c, e.eElement), r = (c) => c.preventDefault(), n = (c) => {
      c.key === y.ESCAPE && this.cancelDrag(e.eElement);
    }, l = di(this.gos), a = [{ target: l, type: "mousemove", listener: s }, { target: l, type: "mouseup", listener: o }, { target: l, type: "contextmenu", listener: r }, { target: l, type: "keydown", listener: n }];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: i, type: s, listener: o, options: r } = t;
      i.addEventListener(s, o, r);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: i, type: s, listener: o, options: r } = t;
        i.removeEventListener(s, o, r);
      });
    });
  }
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: i } = this.currentDragParams, s = E(i) ? i : 4;
    return nn(e, t, s);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++) if (e[t].identifier === this.touchStart.identifier) return e[t];
    return null;
  }
  onCommonMove(e, t, i) {
    var _a3;
    if (!this.dragging) {
      if (this.isEventNearStartEvent(e, t)) return;
      if (this.dragging = true, this.eventService.dispatchEvent({ type: "dragStarted", target: i }), this.currentDragParams.onDragStart(t), !this.currentDragParams) {
        this.dragging = false;
        return;
      }
      this.currentDragParams.onDragging(t);
    }
    (_a3 = this.currentDragParams) == null ? void 0 : _a3.onDragging(e);
  }
  onTouchMove(e, t) {
    const i = this.getFirstActiveTouch(e.touches);
    i && this.onCommonMove(i, this.touchStart, t);
  }
  onMouseMove(e, t) {
    var _a3;
    $e() && ((_a3 = re(this.gos).getSelection()) == null ? void 0 : _a3.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = this.gos.get("enableCellTextSelection"), i = e.type === "mousemove";
    return t && i && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e);
  }
  isOverFormFieldElement(e) {
    var _a3, _b;
    return !!((_b = (_a3 = e.target) == null ? void 0 : _a3.tagName.toLocaleLowerCase()) == null ? void 0 : _b.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(e, t) {
    let i = this.getFirstActiveTouch(e.changedTouches);
    i || (i = this.touchLastTime), this.onUpCommon(i, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    this.dragging && (this.dragging = false, this.currentDragParams.onDragStop(e), this.eventService.dispatchEvent({ type: "dragStopped", target: t })), this.resetDragProperties();
  }
  cancelDrag(e) {
    var _a3, _b;
    this.eventService.dispatchEvent({ type: "dragCancelled", target: e }), (_b = (_a3 = this.currentDragParams) == null ? void 0 : _a3.onDragCancel) == null ? void 0 : _b.call(_a3), this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach((e) => e()), this.dragEndFunctions.length = 0;
  }
}, zs = class extends Y {
  constructor(e, t, i, s, o, r) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = i, this.customGui = s, this.dragStartPixels = o, this.suppressVisibilityChange = r, this.dragSource = null;
  }
  wireBeans(e) {
    this.beans = e;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate('<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'), this.getGui().appendChild(De("rowDrag", this.gos, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
      const e = this.gos.get("rowDragManaged") ? new zc(this, this.beans, this.rowNode, this.column) : new Wc(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(e, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e, void 0, void 0, true), this.addDragSource(t);
  }
  getSelectedNodes() {
    if (!this.gos.get("rowDragMultiRow")) return [this.rowNode];
    const t = this.beans.selectionService.getSelectedNodes();
    return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode];
  }
  checkCompatibility() {
    const e = this.gos.get("rowDragManaged");
    this.gos.get("treeData") && e && F("If using row drag with tree data, you cannot have rowDragManaged=true");
  }
  getDragItem() {
    return { rowNode: this.rowNode, rowNodes: this.getSelectedNodes(), columns: this.column ? [this.column] : void 0, defaultTextValue: this.cellValueFn() };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText) return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.getGui();
    this.gos.get("enableCellTextSelection") && (this.removeMouseDownListener(), this.mouseDownListener = this.addManagedElementListeners(t, { mousedown: (s) => {
      s == null ? void 0 : s.preventDefault();
    } })[0]);
    const i = this.localeService.getLocaleTextFunc();
    this.dragSource = { type: 2, eElement: t, dragItemName: () => {
      var _a3;
      const s = this.getDragItem(), o = ((_a3 = s.rowNodes) == null ? void 0 : _a3.length) || 1, r = this.getRowDragText(this.column);
      return r ? r(s, o) : o === 1 ? this.cellValueFn() : `${o} ${i("rowDragRows", "rows")}`;
    }, getDragItem: () => this.getDragItem(), dragStartPixels: e, dragSourceDomDataKey: this.gos.getDomDataKey() }, this.beans.dragAndDropService.addDragSource(this.dragSource, true);
  }
  destroy() {
    this.removeDragSource(), this.removeMouseDownListener(), super.destroy();
  }
  removeDragSource() {
    this.dragSource && (this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  removeMouseDownListener() {
    this.mouseDownListener && (this.mouseDownListener(), this.mouseDownListener = void 0);
  }
}, gn = class extends R {
  constructor(e, t, i) {
    super(), this.parent = e, this.rowNode = t, this.column = i;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: true };
    if (e) this.parent.setDisplayed(false, t);
    else {
      let i = true, s = false;
      this.column && (i = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), s = Js(this.column.getColDef().rowDrag)), s ? (this.parent.setDisplayed(true, t), this.parent.setVisible(i, t)) : (this.parent.setDisplayed(i, t), this.parent.setVisible(true, t));
    }
  }
}, Wc = class extends gn {
  constructor(e, t, i, s) {
    super(e, i, s), this.beans = t;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.rowNode, { dataChanged: e, cellChanged: e }), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: e }), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
}, zc = class extends gn {
  constructor(e, t, i, s) {
    super(e, i, s), this.beans = t;
  }
  postConstruct() {
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.beans.eventService, { sortChanged: e, filterChanged: e, columnRowGroupChanged: e, newColumnsLoaded: e }), this.addManagedListeners(this.rowNode, { dataChanged: e, cellChanged: e }), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(), i = t && t.shouldPreventRowMove(), s = this.gos.get("suppressRowDrag"), o = this.beans.dragAndDropService.hasExternalDropZones(), r = i && !o || s;
    this.setDisplayedOrVisible(r);
  }
}, _c = /* @__PURE__ */ new Set(["localEventService", "__objectId", "sticky", "__autoHeights", "checkAutoHeightsDebounced"]), Ri = class nt {
  constructor(t) {
    this.rowIndex = null, this.key = null, this.sourceRowIndex = -1, this.childrenMapped = {}, this.treeNode = null, this.treeNodeFlags = 0, this.displayed = false, this.rowTop = null, this.oldRowTop = null, this.selectable = true, this.__objectId = nt.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = false, this.highlighted = null, this.hovered = false, this.selected = false, this.beans = t;
  }
  setData(t) {
    this.setDataCommon(t, false);
  }
  updateData(t) {
    this.setDataCommon(t, true);
  }
  setDataCommon(t, i) {
    var _a3;
    const s = this.data;
    this.data = t, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
    const o = this.createDataChangedEvent(t, s, i);
    (_a3 = this.localEventService) == null ? void 0 : _a3.dispatchEvent(o);
  }
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(t, i, s) {
    return { type: "dataChanged", node: this, oldData: i, newData: t, update: s };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (z("Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid."), null) : this.rowPinned === "top" ? nt.ID_PREFIX_TOP_PINNED + this.rowIndex : this.rowPinned === "bottom" ? nt.ID_PREFIX_BOTTOM_PINNED + this.rowIndex : this.rowIndex.toString();
  }
  createDaemonNode() {
    const t = new nt(this.beans);
    return t.id = this.id, t.data = this.data, t.__daemon = true, t.selected = this.selected, t.level = this.level, t;
  }
  setDataAndId(t, i) {
    var _a3;
    const s = E(this.id) ? this.createDaemonNode() : null, o = this.data;
    this.data = t, this.updateDataOnDetailNode(), this.setId(i), this.checkRowSelectable(), this.beans.selectionService.syncInRowNode(this, s);
    const r = this.createDataChangedEvent(t, o, false);
    (_a3 = this.localEventService) == null ? void 0 : _a3.dispatchEvent(r);
  }
  checkRowSelectable() {
    const t = Zs(this.beans.gos);
    this.setRowSelectable(t ? t(this) : true);
  }
  setRowSelectable(t, i) {
    if (this.selectable !== t) {
      if (this.selectable = t, this.dispatchRowEvent("selectableChanged"), i) return;
      if (Dt(this.beans.gos)) {
        const o = this.calculateSelectedFromChildren();
        this.setSelectedParams({ newValue: o ?? false, source: "selectableChanged" });
        return;
      }
      this.isSelected() && !this.selectable && this.setSelectedParams({ newValue: false, source: "selectableChanged" });
    }
  }
  setId(t) {
    var _a3;
    const i = Ci(this.beans.gos);
    if (i) if (this.data) {
      const s = ((_a3 = this.parent) == null ? void 0 : _a3.getRoute()) ?? [];
      this.id = i({ data: this.data, parentKeys: s.length > 0 ? s : void 0, level: this.level, rowPinned: this.rowPinned }), this.id.startsWith(nt.ID_PREFIX_ROW_GROUP) && z(`Row IDs cannot start with ${nt.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`);
    } else this.id = void 0;
    else this.id = t;
  }
  setRowTop(t) {
    this.oldRowTop = this.rowTop, this.rowTop !== t && (this.rowTop = t, this.dispatchRowEvent("topChanged"), this.setDisplayed(t !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setHovered(t) {
    this.hovered = t;
  }
  isHovered() {
    return this.hovered;
  }
  setMaster(t) {
    this.master !== t && (this.master && !t && (this.expanded = false), this.master = t, this.dispatchRowEvent("masterChanged"));
  }
  setGroup(t) {
    this.group !== t && (this.group && !t && (this.expanded = false), this.group = t, this.updateHasChildren(), this.checkRowSelectable(), this.dispatchRowEvent("groupChanged"));
  }
  setRowHeight(t, i = false) {
    this.rowHeight = t, this.rowHeightEstimated = i, this.dispatchRowEvent("heightChanged");
  }
  setRowAutoHeight(t, i) {
    this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[i.getId()] = t, t != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = Re(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
  }
  checkAutoHeights() {
    var _a3, _b;
    let t = false, i = true, s = 0;
    const o = this.__autoHeights;
    if (o == null || (this.beans.visibleColsService.getAllAutoHeightCols().forEach((l) => {
      let a = o[l.getId()];
      if (a == null) if (this.beans.columnModel.isColSpanActive()) {
        let c = [];
        switch (l.getPinned()) {
          case "left":
            c = this.beans.visibleColsService.getLeftColsForRow(this);
            break;
          case "right":
            c = this.beans.visibleColsService.getRightColsForRow(this);
            break;
          case null:
            c = this.beans.columnViewportService.getColsWithinViewport(this);
            break;
        }
        if (c.includes(l)) {
          t = true;
          return;
        }
        a = -1;
      } else {
        t = true;
        return;
      }
      else i = false;
      a > s && (s = a);
    }), t) || ((i || s < 10) && (s = ut(this.beans.gos, this).height), s == this.rowHeight)) return;
    this.setRowHeight(s), (_b = (_a3 = this.beans.rowModel).onRowHeightChangedDebounced) == null ? void 0 : _b.call(_a3);
  }
  setExpanded(t, i, s) {
    if (this.expanded === t) return;
    this.expanded = t, this.dispatchRowEvent("expandedChanged");
    const o = { ...this.createGlobalRowEvent("rowGroupOpened"), expanded: t, event: i || null };
    this.beans.rowNodeEventThrottle.dispatchExpanded(o, s), this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
  }
  createGlobalRowEvent(t) {
    return this.beans.gos.addGridCommonParams({ type: t, node: this, data: this.data, rowIndex: this.rowIndex, rowPinned: this.rowPinned });
  }
  setDataValue(t, i, s) {
    const r = typeof t != "string" ? t : this.beans.columnModel.getCol(t) ?? this.beans.columnModel.getColDefCol(t), n = this.beans.valueService.getValueForDisplay(r, this);
    if (this.beans.gos.get("readOnlyEdit")) return this.beans.eventService.dispatchEvent({ type: "cellEditRequest", event: null, rowIndex: this.rowIndex, rowPinned: this.rowPinned, column: r, colDef: r.getColDef(), data: this.data, node: this, oldValue: n, newValue: i, value: i, source: s }), false;
    const l = this.beans.valueService.setValue(this, r, i, s);
    return this.dispatchCellChangedEvent(r, i, n), this.checkRowSelectable(), l;
  }
  setGroupValue(t, i) {
    const s = this.beans.columnModel.getCol(t);
    V(this.groupData) && (this.groupData = {});
    const o = s.getColId(), r = this.groupData[o];
    r !== i && (this.groupData[o] = i, this.dispatchCellChangedEvent(s, i, r));
  }
  setAggData(t) {
    const i = this.aggData;
    if (this.aggData = t, this.localEventService) {
      const s = (o) => {
        const r = this.aggData ? this.aggData[o] : void 0, n = i ? i[o] : void 0;
        if (r === n) return;
        const l = this.beans.columnModel.getCol(o);
        l && this.dispatchCellChangedEvent(l, r, n);
      };
      for (const o in i) s(o);
      for (const o in t) (!i || !(o in i)) && s(o);
    }
  }
  updateHasChildren() {
    let t = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    if (it(this.beans.gos)) {
      const s = this.beans.gos.get("treeData"), o = this.beans.gos.get("isServerSideGroup");
      t = !this.stub && !this.footer && (s ? !!o && o(this.data) : !!this.group);
    }
    t !== this.__hasChildren && (this.__hasChildren = !!t, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  dispatchCellChangedEvent(t, i, s) {
    var _a3;
    const o = { type: "cellChanged", node: this, column: t, newValue: i, oldValue: s };
    (_a3 = this.localEventService) == null ? void 0 : _a3.dispatchEvent(o);
  }
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  isExpandable() {
    return this.footer ? false : this.beans.columnModel.isPivotMode() ? this.hasChildren() && !this.leafGroup : this.hasChildren() || !!this.master;
  }
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.selected;
  }
  depthFirstSearch(t) {
    this.childrenAfterGroup && this.childrenAfterGroup.forEach((i) => i.depthFirstSearch(t)), t(this);
  }
  calculateSelectedFromChildren() {
    var _a3;
    let t = false, i = false;
    if (!((_a3 = this.childrenAfterGroup) == null ? void 0 : _a3.length)) return this.selectable ? this.selected : null;
    for (let s = 0; s < this.childrenAfterGroup.length; s++) {
      const o = this.childrenAfterGroup[s];
      let r = o.isSelected();
      if (!o.selectable) {
        const n = o.calculateSelectedFromChildren();
        if (n === null) continue;
        r = n;
      }
      switch (r) {
        case true:
          t = true;
          break;
        case false:
          i = true;
          break;
        default:
          return;
      }
    }
    if (!(t && i)) return t ? true : i ? false : this.selectable ? this.selected : null;
  }
  setSelectedInitialValue(t) {
    this.selected = t;
  }
  dispatchRowEvent(t) {
    var _a3;
    (_a3 = this.localEventService) == null ? void 0 : _a3.dispatchEvent({ type: t, node: this });
  }
  selectThisNode(t, i, s = "api") {
    const o = !this.selectable && t, r = this.selected === t;
    if (o || r) return false;
    this.selected = t, this.dispatchRowEvent("rowSelected");
    const n = this.sibling;
    return n && n.footer && n.localEventService && n.dispatchRowEvent("rowSelected"), this.beans.eventService.dispatchEvent({ ...this.createGlobalRowEvent("rowSelected"), event: i || null, source: s }), true;
  }
  setSelected(t, i = false, s = "api") {
    if (typeof s == "boolean") {
      F("since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.");
      return;
    }
    this.setSelectedParams({ newValue: t, clearSelection: i, rangeSelect: false, source: s });
  }
  setSelectedParams(t) {
    return this.rowPinned ? (F("cannot select pinned rows"), 0) : this.id === void 0 ? (F("cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected({ ...t, nodes: [this.footer ? this.sibling : this] });
  }
  isRowPinned() {
    return !!this.rowPinned;
  }
  addEventListener(t, i) {
    var _a3;
    this.localEventService || (this.localEventService = new Ut()), this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.localEventService.setFrameworkOverrides(this.beans.frameworkOverrides), this.frameworkEventListenerService = new io(this.beans.frameworkOverrides));
    const s = ((_a3 = this.frameworkEventListenerService) == null ? void 0 : _a3.wrap(i)) ?? i;
    this.localEventService.addEventListener(t, s);
  }
  removeEventListener(t, i) {
    var _a3;
    if (!this.localEventService) return;
    const s = ((_a3 = this.frameworkEventListenerService) == null ? void 0 : _a3.unwrap(i)) ?? i;
    this.localEventService.removeEventListener(t, s), this.localEventService.noRegisteredListenersExist() && (this.localEventService = null);
  }
  onMouseEnter() {
    this.dispatchRowEvent("mouseEnter");
  }
  onMouseLeave() {
    this.dispatchRowEvent("mouseLeave");
  }
  isFullWidthCell() {
    if (F("since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option."), this.detail) return true;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this }) : false;
  }
  getRoute() {
    if (this.level === -1) return [];
    if (this.key == null) return;
    const t = [];
    let i = this;
    for (; i && i.key != null; ) t.push(i.key), i = i.parent;
    return t.reverse();
  }
  createFooter() {
    if (this.sibling) return;
    const t = new nt(this.beans);
    Object.keys(this).forEach((i) => {
      _c.has(i) || (t[i] = this[i]);
    }), t.footer = true, t.setRowTop(null), t.setRowIndex(null), t.oldRowTop = null, t.id = "rowGroupFooter_" + this.id, t.sibling = this, this.sibling = t;
  }
  destroyFooter() {
    this.sibling && (this.sibling.setRowTop(null), this.sibling.setRowIndex(null), this.sibling = void 0);
  }
  setFirstChild(t) {
    this.firstChild !== t && (this.firstChild = t, this.dispatchRowEvent("firstChildChanged"));
  }
  setLastChild(t) {
    this.lastChild !== t && (this.lastChild = t, this.dispatchRowEvent("lastChildChanged"));
  }
  setChildIndex(t) {
    this.childIndex !== t && (this.childIndex = t, this.dispatchRowEvent("childIndexChanged"));
  }
  setDisplayed(t) {
    this.displayed !== t && (this.displayed = t, this.dispatchRowEvent("displayedChanged"));
  }
  setDragging(t) {
    this.dragging !== t && (this.dragging = t, this.dispatchRowEvent("draggingChanged"));
  }
  setHighlighted(t) {
    this.highlighted !== t && (this.highlighted = t, this.dispatchRowEvent("rowHighlightChanged"));
  }
  setAllChildrenCount(t) {
    this.allChildrenCount !== t && (this.allChildrenCount = t, this.dispatchRowEvent("allChildrenCountChanged"));
  }
  setRowIndex(t) {
    this.rowIndex !== t && (this.rowIndex = t, this.dispatchRowEvent("rowIndexChanged"));
  }
  setUiLevel(t) {
    this.uiLevel !== t && (this.uiLevel = t, this.dispatchRowEvent("uiLevelChanged"));
  }
};
Ri.ID_PREFIX_ROW_GROUP = "row-group-";
Ri.ID_PREFIX_TOP_PINNED = "t-";
Ri.ID_PREFIX_BOTTOM_PINNED = "b-";
Ri.OBJECT_ID_SEQUENCE = 0;
var Ft = Ri, Uc = class extends R {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advancedFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.dataTypeService = e.dataTypeService, this.quickFilterService = e.quickFilterService, this.advancedFilterService = e.advancedFilterService, this.columnFilterService = e.columnFilterService;
  }
  postConstruct() {
    const e = this.refreshFiltersForAggregations.bind(this), t = this.updateAdvancedFilterColumns.bind(this);
    this.addManagedEventListeners({ columnValueChanged: e, columnPivotChanged: e, columnPivotModeChanged: e, newColumnsLoaded: t, columnVisible: t, advancedFilterEnabledChanged: ({ enabled: i }) => this.onAdvancedFilterEnabledChanged(i), dataTypesInferred: this.processFilterModelUpdateQueue.bind(this) }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.addManagedPropertyListener("advancedFilterModel", (i) => this.setAdvancedFilterModel(i.currentValue)), this.quickFilterService && this.addManagedListeners(this.quickFilterService, { quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" }) });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" ? e({}) : false;
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" ? t(e) : false;
  }
  setFilterModel(e, t = "api") {
    var _a3;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    (_a3 = this.columnFilterService) == null ? void 0 : _a3.setFilterModel(e, t);
  }
  getFilterModel() {
    var _a3;
    return ((_a3 = this.columnFilterService) == null ? void 0 : _a3.getFilterModel()) ?? {};
  }
  isColumnFilterPresent() {
    var _a3;
    return !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.isColumnFilterPresent());
  }
  isAggregateFilterPresent() {
    var _a3;
    return !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.isAggregateFilterPresent());
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  isAdvancedFilterPresent() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
  }
  onAdvancedFilterEnabledChanged(e) {
    var _a3, _b;
    e ? ((_a3 = this.columnFilterService) == null ? void 0 : _a3.disableColumnFilters()) && this.onFilterChanged({ source: "advancedFilter" }) : ((_b = this.advancedFilterService) == null ? void 0 : _b.isFilterPresent()) && (this.advancedFilterService.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvancedFilterEnabled() {
    var _a3;
    return !!((_a3 = this.advancedFilterService) == null ? void 0 : _a3.isEnabled());
  }
  isAdvancedFilterHeaderActive() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  resetQuickFilterCache() {
    var _a3;
    (_a3 = this.quickFilterService) == null ? void 0 : _a3.resetQuickFilterCache();
  }
  refreshFiltersForAggregations() {
    Ls(this.gos) && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: i, columns: s = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.columnFilterService ? this.columnFilterService.updateBeforeFilterChanged(e) : oe.resolve()).then(() => {
      var _a3;
      const o = { source: t, type: "filterChanged", columns: s };
      i && we(o, i), this.eventService.dispatchEvent(o), (_a3 = this.columnFilterService) == null ? void 0 : _a3.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var _a3;
    return !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var _a3;
    return !!((_a3 = this.quickFilterService) == null ? void 0 : _a3.isQuickFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!Ls(this.gos);
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    return !(this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isAggregateFilterPresent() && !this.columnFilterService.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    return !(this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode) || this.isColumnFilterPresent() && !this.columnFilterService.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip) || this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(e.rowNode));
  }
  isFilterActive(e) {
    var _a3;
    return !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.isFilterActive(e));
  }
  getOrCreateFilterWrapper(e) {
    var _a3;
    return ((_a3 = this.columnFilterService) == null ? void 0 : _a3.getOrCreateFilterWrapper(e)) ?? null;
  }
  getDefaultFloatingFilter(e) {
    return this.columnFilterService.getDefaultFloatingFilter(e);
  }
  createFilterParams(e, t) {
    return this.columnFilterService.createFilterParams(e, t);
  }
  isFilterAllowed(e) {
    var _a3;
    return this.isAdvancedFilterEnabled() ? false : !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.isFilterAllowed(e));
  }
  getFloatingFilterCompDetails(e, t) {
    var _a3;
    return (_a3 = this.columnFilterService) == null ? void 0 : _a3.getFloatingFilterCompDetails(e, t);
  }
  getCurrentFloatingFilterParentModel(e) {
    var _a3;
    return (_a3 = this.columnFilterService) == null ? void 0 : _a3.getCurrentFloatingFilterParentModel(e);
  }
  destroyFilter(e, t = "api") {
    var _a3;
    (_a3 = this.columnFilterService) == null ? void 0 : _a3.destroyFilter(e, t);
  }
  areFilterCompsDifferent(e, t) {
    var _a3;
    return !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.areFilterCompsDifferent(e, t));
  }
  getAdvancedFilterModel() {
    return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
  }
  setAdvancedFilterModel(e) {
    var _a3;
    if (this.isAdvancedFilterEnabled()) {
      if ((_a3 = this.dataTypeService) == null ? void 0 : _a3.isPendingInference()) {
        this.advancedFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilterService.setModel(e ?? null), this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  toggleAdvancedFilterBuilder(e, t) {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.getCtrl().toggleFilterBuilder({ source: t, force: e });
  }
  updateAdvancedFilterColumns() {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var _a3;
    return this.isAdvancedFilterEnabled() ? false : !!((_a3 = this.columnFilterService) == null ? void 0 : _a3.hasFloatingFilters());
  }
  getFilterInstance(e, t) {
    var _a3;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    return (_a3 = this.columnFilterService) == null ? void 0 : _a3.getFilterInstance(e, t);
  }
  getColumnFilterInstance(e) {
    var _a3;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve(void 0)) : ((_a3 = this.columnFilterService) == null ? void 0 : _a3.getColumnFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvancedFilters() {
    F("Column Filter API methods have been disabled as Advanced Filters are enabled.");
  }
  setupAdvancedFilterHeaderComp(e) {
    var _a3;
    (_a3 = this.advancedFilterService) == null ? void 0 : _a3.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvancedFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advancedFilterModelUpdateQueue.forEach((e) => this.setAdvancedFilterModel(e)), this.advancedFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    var _a3;
    return (_a3 = this.columnFilterService) == null ? void 0 : _a3.getColumnFilterModel(e);
  }
  setColumnFilterModel(e, t) {
    var _a3;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve()) : ((_a3 = this.columnFilterService) == null ? void 0 : _a3.setColumnFilterModel(e, t)) ?? Promise.resolve();
  }
  setColDefPropertiesForDataType(e, t, i) {
    var _a3;
    (_a3 = this.columnFilterService) == null ? void 0 : _a3.setColDefPropertiesForDataType(e, t, i);
  }
}, Kc = class extends Y {
  constructor(e, t) {
    super('<div class="ag-filter"></div>'), this.column = e, this.source = t, this.filterWrapper = null;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.columnModel = e.columnModel;
  }
  postConstruct() {
    this.createFilter(true), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var _a3;
    return ((_a3 = this.filterWrapper) == null ? void 0 : _a3.filterPromise) ?? null;
  }
  afterInit() {
    var _a3, _b;
    return ((_b = (_a3 = this.filterWrapper) == null ? void 0 : _a3.filterPromise) == null ? void 0 : _b.then(() => {
    })) ?? oe.resolve();
  }
  afterGuiAttached(e) {
    var _a3, _b;
    (_b = (_a3 = this.filterWrapper) == null ? void 0 : _a3.filterPromise) == null ? void 0 : _b.then((t) => {
      var _a4;
      (_a4 = t == null ? void 0 : t.afterGuiAttached) == null ? void 0 : _a4.call(t, e);
    });
  }
  afterGuiDetached() {
    var _a3, _b;
    (_b = (_a3 = this.filterWrapper) == null ? void 0 : _a3.filterPromise) == null ? void 0 : _b.then((e) => {
      var _a4;
      (_a4 = e == null ? void 0 : e.afterGuiDetached) == null ? void 0 : _a4.call(e);
    });
  }
  createFilter(e) {
    var _a3, _b;
    const { column: t, source: i } = this;
    this.filterWrapper = ((_a3 = this.filterManager) == null ? void 0 : _a3.getOrCreateFilterWrapper(t)) ?? null, ((_b = this.filterWrapper) == null ? void 0 : _b.filterPromise) && this.filterWrapper.filterPromise.then((s) => {
      const o = s.getGui();
      E(o) || F(`getGui method from filter returned ${o}; it should be a DOM element.`), this.appendChild(o), e && this.eventService.dispatchEvent({ type: "filterOpened", column: t, source: i, eGui: this.getGui() });
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.columnModel.getColDefCol(this.column) && (xe(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
}, pn = "ag-resizer-wrapper", ot = (e, t) => `<div data-ref="${e}Resizer" class="ag-resizer ag-resizer-${t}"></div>`, $c = `<div class="${pn}">
        ${ot("eTopLeft", "topLeft")}
        ${ot("eTop", "top")}
        ${ot("eTopRight", "topRight")}
        ${ot("eRight", "right")}
        ${ot("eBottomRight", "bottomRight")}
        ${ot("eBottom", "bottom")}
        ${ot("eBottomLeft", "bottomLeft")}
        ${ot("eLeft", "left")}
    </div>`, jc = class extends R {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = { x: 0, y: 0 }, this.position = { x: 0, y: 0 }, this.lastSize = { width: -1, height: -1 }, this.positioned = false, this.resizersAdded = false, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = false, this.isMoving = false, this.resizable = {}, this.movable = false, this.currentResizer = null, this.config = Object.assign({}, { popup: false }, t);
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.resizeObserverService = e.resizeObserverService, this.dragService = e.dragService;
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, i = t / 2 - this.getWidth() / 2, s = e / 2 - this.getHeight() / 2;
    this.offsetElement(i, s);
  }
  initialisePosition() {
    if (this.positioned) return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: i, width: s, minHeight: o, height: r, x: n, y: l } = this.config;
    this.offsetParent || this.setOffsetParent();
    let a = 0, c = 0;
    const u = je(this.element);
    if (u) {
      const d = this.findBoundaryElement(), h = window.getComputedStyle(d);
      if (h.minWidth != null) {
        const g = d.offsetWidth - this.element.offsetWidth;
        c = parseInt(h.minWidth, 10) - g;
      }
      if (h.minHeight != null) {
        const g = d.offsetHeight - this.element.offsetHeight;
        a = parseInt(h.minHeight, 10) - g;
      }
    }
    if (this.minHeight = o || a, this.minWidth = i || c, s && this.setWidth(s), r && this.setHeight(r), (!s || !r) && this.refreshSize(), e) this.center();
    else if (n || l) this.offsetElement(n, l);
    else if (u && t) {
      let d = this.boundaryEl, h = true;
      if (d || (d = this.findBoundaryElement(), h = false), d) {
        const g = parseFloat(d.style.top), m = parseFloat(d.style.left);
        h ? this.offsetElement(isNaN(m) ? 0 : m, isNaN(g) ? 0 : g) : this.setPosition(m, g);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    if (!this.config.popup || e === this.movable) return;
    this.movable = e;
    const i = this.moveElementDragListener || { eElement: t, onDragStart: this.onMoveStart.bind(this), onDragging: this.onMove.bind(this), onDragStop: this.onMoveEnd.bind(this) };
    e ? (this.dragService.addDragSource(i), this.moveElementDragListener = i) : (this.dragService.removeDragSource(i), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === false) return;
      e = { topLeft: e, top: e, topRight: e, right: e, bottomRight: e, bottom: e, bottomLeft: e, left: e };
    }
    Object.keys(e).forEach((t) => {
      const s = !!e[t], o = this.getResizerElement(t), r = { dragStartPixels: 0, eElement: o, onDragStart: (n) => this.onResizeStart(n, t), onDragging: this.onResize.bind(this), onDragStop: (n) => this.onResizeEnd(n, t) };
      (s || !this.isAlive() && !s) && (s ? (this.dragService.addDragSource(r), this.resizeListeners.push(r), o.style.pointerEvents = "all") : o.style.pointerEvents = "none", this.resizable[t] = s);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, i = this.element;
    let s = false;
    if (typeof e == "string" && e.indexOf("%") !== -1) ni(i, e), e = Jr(i), s = true;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const o = this.getAvailableHeight();
      o && e > o && (e = o);
    }
    this.getHeight() !== e && (s ? (i.style.maxHeight = "unset", i.style.minHeight = "unset") : t ? ni(i, e) : (i.style.height = `${e}px`, i.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: i } = this.offsetParent;
    if (!i) return null;
    const s = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), r = e ? this.position.y : s.top, n = e ? 0 : o.top;
    let l = 0;
    if (t) {
      const c = this.element.parentElement;
      if (c) {
        const { bottom: u } = c.getBoundingClientRect();
        l = u - s.bottom;
      }
    }
    return i + n - r - l;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: i } = this.config;
    let s = false;
    if (typeof e == "string" && e.indexOf("%") !== -1) Ne(t, e), e = qi(t), s = true;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: o } = this.offsetParent, r = i ? this.position.x : this.element.getBoundingClientRect().left;
      o && e + r > o && (e = o - r);
    }
    this.getWidth() !== e && (s ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? Ne(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    const { forcePopupParentAsOffsetParent: i } = this.config, s = i ? this.boundaryEl : this.element;
    s && (this.popupService.positionPopup({ ePopup: s, keepWithinBounds: true, skipObserver: this.movable || this.isResizable(), updatePosition: () => ({ x: e, y: t }) }), this.setPosition(parseFloat(s.style.left), parseFloat(s.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    if (!this.config.forcePopupParentAsOffsetParent) return;
    const t = () => {
      const i = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${i}px`);
    };
    e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(this.popupService.getPopupParent(), t) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: i, isTop: s, anywhereWithin: o, topBuffer: r } = e, n = t.clientX - this.dragStartPosition.x, l = t.clientY - this.dragStartPosition.y, a = this.shouldSkipX(t, !!i, !!o, n) ? 0 : n, c = this.shouldSkipY(t, !!s, r, l) ? 0 : l;
    return { movementX: a, movementY: c };
  }
  shouldSkipX(e, t, i, s) {
    const o = this.element.getBoundingClientRect(), r = this.offsetParent.getBoundingClientRect(), n = this.boundaryEl.getBoundingClientRect(), l = this.config.popup ? this.position.x : o.left;
    let a = l <= 0 && r.left >= e.clientX || r.right <= e.clientX && r.right <= n.right;
    return a ? true : (t ? a = s < 0 && e.clientX > l + r.left || s > 0 && e.clientX < l + r.left : i ? a = s < 0 && e.clientX > n.right || s > 0 && e.clientX < l + r.left : a = s < 0 && e.clientX > n.right || s > 0 && e.clientX < n.right, a);
  }
  shouldSkipY(e, t, i = 0, s) {
    const o = this.element.getBoundingClientRect(), r = this.offsetParent.getBoundingClientRect(), n = this.boundaryEl.getBoundingClientRect(), l = this.config.popup ? this.position.y : o.top;
    let a = l <= 0 && r.top >= e.clientY || r.bottom <= e.clientY && r.bottom <= n.bottom;
    return a ? true : (t ? a = s < 0 && e.clientY > l + r.top + i || s > 0 && e.clientY < l + r.top : a = s < 0 && e.clientY > n.bottom || s > 0 && e.clientY < n.bottom, a);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = { topLeft: { element: e.querySelector("[data-ref=eTopLeftResizer]") }, top: { element: e.querySelector("[data-ref=eTopResizer]") }, topRight: { element: e.querySelector("[data-ref=eTopRightResizer]") }, right: { element: e.querySelector("[data-ref=eRightResizer]") }, bottomRight: { element: e.querySelector("[data-ref=eBottomRightResizer]") }, bottom: { element: e.querySelector("[data-ref=eBottomResizer]") }, bottomLeft: { element: e.querySelector("[data-ref=eBottomLeftResizer]") }, left: { element: e.querySelector("[data-ref=eLeftResizer]") } };
  }
  addResizers() {
    if (this.resizersAdded) return;
    const e = this.element;
    if (!e) return;
    const i = new DOMParser().parseFromString($c, "text/html").body;
    e.appendChild(i.firstChild), this.createResizeMap(), this.resizersAdded = true;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${pn}`);
    e && this.element.removeChild(e), this.resizersAdded = false;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = { isTop: !!t.match(/top/i), isRight: !!t.match(/right/i), isBottom: !!t.match(/bottom/i), isLeft: !!t.match(/left/i) }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: i, forcePopupParentAsOffsetParent: s } = this.config;
    !i && !s && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = true, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((i) => !i.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      const o = e[s], r = !!o.style.flex && o.style.flex !== "0 0 auto";
      if (o === this.element) continue;
      let n = this.minHeight || 0, l = this.minWidth || 0;
      if (r) {
        const a = window.getComputedStyle(o);
        a.minHeight && (n = parseInt(a.minHeight, 10)), a.minWidth && (l = parseInt(a.minWidth, 10));
      } else n = o.offsetHeight, l = o.offsetWidth;
      t += n, i += l;
    }
    return { height: t, width: i };
  }
  applySizeToSiblings(e) {
    let t = null;
    const i = this.getSiblings();
    if (i) {
      for (let s = 0; s < i.length; s++) {
        const o = i[s];
        o !== t && (e ? o.style.height = `${o.offsetHeight}px` : o.style.width = `${o.offsetWidth}px`, o.style.flex = "0 0 auto", o === this.element && (t = i[s + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer) return;
    const { popup: t, forcePopupParentAsOffsetParent: i } = this.config, { isTop: s, isRight: o, isBottom: r, isLeft: n } = this.currentResizer, l = o || n, a = r || s, { movementX: c, movementY: u } = this.calculateMouseMovement({ e, isLeft: n, isTop: s }), d = this.position.x, h = this.position.y;
    let g = 0, m = 0;
    if (l && c) {
      const C = n ? -1 : 1, f = this.getWidth(), v = f + c * C;
      let w = false;
      n && (g = f - v, (d + g <= 0 || v <= this.minWidth) && (w = true, g = 0)), w || this.setWidth(v);
    }
    if (a && u) {
      const C = s ? -1 : 1, f = this.getHeight(), v = f + u * C;
      let w = false;
      s ? (m = f - v, (h + m <= 0 || v <= this.minHeight) && (w = true, m = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && f < v && this.getMinSizeOfSiblings().height + v > this.element.parentElement.offsetHeight && (w = true), w || this.setHeight(v);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || i) && g || m) && this.offsetElement(d + g, h + m);
  }
  onResizeEnd(e, t) {
    this.isResizing = false, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = true, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving) return;
    const { x: t, y: i } = this.position;
    let s;
    this.config.calculateTopBuffer && (s = this.config.calculateTopBuffer());
    const { movementX: o, movementY: r } = this.calculateMouseMovement({ e, isTop: true, anywhereWithin: true, topBuffer: s });
    this.offsetElement(t + o, i + r), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = false, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static") return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    for (; this.resizeListeners.length; ) {
      const e = this.resizeListeners.pop();
      this.dragService.removeDragSource(e);
    }
  }
  destroy() {
    super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(false), this.clearResizeListeners(), this.removeResizers();
  }
}, fn = class mn extends R {
  constructor(t, i = {}) {
    super(), this.eFocusableElement = t, this.callbacks = i, this.callbacks = { shouldStopEventPropagation: () => false, onTabKeyDown: (s) => {
      if (s.defaultPrevented) return;
      const o = this.focusService.findNextFocusableElement(this.eFocusableElement, false, s.shiftKey);
      o && (o.focus(), s.preventDefault());
    }, ...i };
  }
  wireBeans(t) {
    this.focusService = t.focusService;
  }
  postConstruct() {
    this.eFocusableElement.classList.add(mn.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedElementListeners(this.eFocusableElement, { focusin: this.callbacks.onFocusIn }), this.callbacks.onFocusOut && this.addManagedElementListeners(this.eFocusableElement, { focusout: this.callbacks.onFocusOut });
  }
  addKeyDownListeners(t) {
    this.addManagedElementListeners(t, { keydown: (i) => {
      if (!(i.defaultPrevented || Ze(i))) {
        if (this.callbacks.shouldStopEventPropagation(i)) {
          zt(i);
          return;
        }
        i.key === y.TAB ? this.callbacks.onTabKeyDown(i) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(i);
      }
    } });
  }
};
fn.FOCUS_MANAGED_CLASS = "ag-focus-managed";
var At = fn, Cn = { applyFilter: "Apply", clearFilter: "Clear", resetFilter: "Reset", cancelFilter: "Cancel", textFilter: "Text Filter", numberFilter: "Number Filter", dateFilter: "Date Filter", setFilter: "Set Filter", filterOoo: "Filter...", empty: "Choose one", equals: "Equals", notEqual: "Does not equal", lessThan: "Less than", greaterThan: "Greater than", inRange: "Between", inRangeStart: "From", inRangeEnd: "To", lessThanOrEqual: "Less than or equal to", greaterThanOrEqual: "Greater than or equal to", contains: "Contains", notContains: "Does not contain", startsWith: "Begins with", endsWith: "Ends with", blank: "Blank", notBlank: "Not blank", before: "Before", after: "After", andCondition: "AND", orCondition: "OR", dateFormatOoo: "yyyy-mm-dd" };
function vo(e, t) {
  return Zi(e) ? (e.debounceMs != null && F("debounceMs is ignored when apply button is present"), 0) : e.debounceMs != null ? e.debounceMs : t;
}
function Zi(e) {
  return !!e.buttons && e.buttons.indexOf("apply") >= 0;
}
var qc = class extends Y {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = false, this.hidePopup = null, this.debouncePending = false, this.appliedModel = null, this.eFilterBody = O, this.buttonListeners = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(new At(this.getFocusableElement(), { handleKeyDown: this.handleKeyDown.bind(this) })), this.positionableFeature = new jc(this.getPositionableElement(), { forcePopupParentAsOffsetParent: true }), this.createBean(this.positionableFeature);
  }
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit);
    const i = `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`;
    this.setTemplate(i, this.getAgComponents(), e), t = this.getGui(), t && t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(true).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.providedFilterParams = e, this.applyActive = Zi(e), this.resetButtonsPanel(e);
  }
  updateParams(e) {
    this.providedFilterParams = e, this.applyActive = Zi(e), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel(e, t) {
    const { buttons: i, readOnly: s } = t ?? {}, { buttons: o, readOnly: r } = e;
    if (s === r && Bi(i, o)) return;
    const n = o && o.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (xe(this.eButtonsPanel), this.buttonListeners.forEach((c) => c()), this.buttonListeners = []) : n && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !n) {
      this.eButtonsPanel && Mt(this.eButtonsPanel);
      return;
    }
    const l = document.createDocumentFragment(), a = (c) => {
      let u, d;
      switch (c) {
        case "apply":
          u = this.translate("applyFilter"), d = (m) => this.onBtApply(false, false, m);
          break;
        case "clear":
          u = this.translate("clearFilter"), d = () => this.onBtClear();
          break;
        case "reset":
          u = this.translate("resetFilter"), d = () => this.onBtReset();
          break;
        case "cancel":
          u = this.translate("cancelFilter"), d = (m) => {
            this.onBtCancel(m);
          };
          break;
        default:
          F("Unknown button type specified");
          return;
      }
      const g = mi(`<button
                    type="${c === "apply" ? "submit" : "button"}"
                    data-ref="${c}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${u}
                </button>`);
      this.buttonListeners.push(...this.addManagedElementListeners(g, { click: d })), l.append(g);
    };
    o.forEach((c) => a(c)), this.eButtonsPanel.append(l), this.getGui().appendChild(this.eButtonsPanel);
  }
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const e = vo(this.providedFilterParams, this.getDefaultDebounceMs()), t = Re(this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = true, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = false, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.providedFilterParams.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const i = () => {
      this.onUiChanged(false, "prevent"), t == null ? void 0 : t();
    };
    e != null ? this.setModelIntoUi(e).then(i) : this.resetUiToDefaults().then(i);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t)) return false;
    const i = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(i, t);
  }
  isModelValid(e) {
    return true;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = false, t = false, i) {
    i && i.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t, source: "columnFilter" });
    const { closeOnApply: s } = this.providedFilterParams;
    s && this.applyActive && !e && !t && this.close(i);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup) return;
    const t = e, i = t && t.key;
    let s;
    (i === "Enter" || i === "Space") && (s = { keyboardEvent: t }), this.hidePopup(s), this.hidePopup = null;
  }
  onUiChanged(e = false, t) {
    if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const i = this.isModelValid(this.getModelFromUi()), s = this.queryForHtmlElement('[data-ref="applyFilterButton"]');
      s && fi(s, !i);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    if (!this.positionableFeature || e === "toolPanel") return;
    const t = e === "floatingFilter" || e === "columnFilter", { positionableFeature: i, gos: s } = this;
    t ? (i.restoreLastSize(), i.setResizable(s.get("enableRtl") ? { bottom: true, bottomLeft: true, left: true } : { bottom: true, bottomRight: true, right: true })) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(false)), this.positionableFeature.constrainSizeToAvailableHeight(true);
  }
  afterGuiDetached() {
    this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(false);
  }
  refresh(e) {
    const t = this.providedFilterParams;
    return this.providedFilterParams = e, this.resetButtonsPanel(e, t), true;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(e) {
    return this.localeService.getLocaleTextFunc()(e, Cn[e]);
  }
  getCellValue(e) {
    return this.providedFilterParams.getValue(e);
  }
  getPositionableElement() {
    return this.eFilterBody;
  }
}, Yc = class extends fo {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(true);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  onChange(e) {
    e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(false, true);
  }
}, Qc = class extends Y {
  constructor(e = "default", t = false) {
    super(`<div class="ag-list ag-${e}-list" role="listbox"></div>`), this.cssIdentifier = e, this.unFocusable = t, this.activeClass = "ag-active-item", this.options = [], this.itemEls = [];
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() }), !this.unFocusable && this.addManagedElementListeners(e, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case y.ENTER:
        if (!this.highlightedEl) this.setValue(this.getValue());
        else {
          const i = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(i);
        }
        break;
      case y.DOWN:
      case y.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case y.PAGE_DOWN:
      case y.PAGE_UP:
      case y.PAGE_HOME:
      case y.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  navigate(e) {
    const t = e === y.DOWN;
    let i;
    if (!this.highlightedEl) i = this.itemEls[t ? 0 : this.itemEls.length - 1];
    else {
      let o = this.itemEls.indexOf(this.highlightedEl) + (t ? 1 : -1);
      o = Math.min(Math.max(o, 0), this.itemEls.length - 1), i = this.itemEls[o];
    }
    this.highlightItem(i);
  }
  navigateToPage(e) {
    if (!this.highlightedEl || this.itemEls.length === 0) return;
    const t = this.itemEls.indexOf(this.highlightedEl), i = this.options.length - 1, s = this.itemEls[0].clientHeight, o = Math.floor(this.getGui().clientHeight / s);
    let r = -1;
    e === y.PAGE_HOME ? r = 0 : e === y.PAGE_END ? r = i : e === y.PAGE_DOWN ? r = Math.min(t + o, i) : e === y.PAGE_UP && (r = Math.max(t - o, 0)), r !== -1 && this.highlightItem(this.itemEls[r]);
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: i } = e, s = i || t;
    return this.options.push({ value: t, text: s }), this.renderOption(t, s), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(true), this.itemEls.forEach((e) => {
      Mt(e);
    }), this.itemEls = [];
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    e.forEach((t, i) => {
      Ma(t, i + 1), Da(t, e.length);
    });
  }
  renderOption(e, t) {
    const i = re(this.gos), s = i.createElement("div");
    Ve(s, "option"), s.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const o = i.createElement("span");
    s.appendChild(o), o.textContent = t, this.unFocusable || (s.tabIndex = -1), this.itemEls.push(s), this.addManagedListeners(s, { mouseover: () => this.highlightItem(s), mousedown: (r) => {
      r.preventDefault(), r.stopPropagation(), this.setValue(e);
    } }), this.createManagedBean(new $t({ getTooltipValue: () => t, getGui: () => s, getLocation: () => "UNKNOWN", shouldDisplayTooltip: () => o.scrollWidth > o.clientWidth })), this.getGui().appendChild(s);
  }
  setValue(e, t) {
    if (this.value === e) return this.fireItemSelected(), this;
    if (e == null) return this.reset(t), this;
    const i = this.options.findIndex((s) => s.value === e);
    if (i !== -1) {
      const s = this.options[i];
      this.value = s.value, this.displayValue = s.text, this.highlightItem(this.itemEls[i]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  highlightItem(e) {
    if (!je(e)) return;
    this.clearHighlighted(), this.highlightedEl = e, this.highlightedEl.classList.add(this.activeClass), ji(this.highlightedEl, true);
    const t = this.getGui(), { scrollTop: i, clientHeight: s } = t, { offsetTop: o, offsetHeight: r } = e;
    (o + r > i + s || o < i) && this.highlightedEl.scrollIntoView({ block: "nearest" }), this.unFocusable || this.highlightedEl.focus();
  }
  clearHighlighted() {
    !this.highlightedEl || !je(this.highlightedEl) || (this.highlightedEl.classList.remove(this.activeClass), ji(this.highlightedEl, false), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, Xc = class extends ln {
  constructor(e) {
    if (super(e, (e == null ? void 0 : e.template) || `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`, (e == null ? void 0 : e.agComponents) || [], e == null ? void 0 : e.className), this.isPickerDisplayed = false, this.skipClick = false, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = O, this.eWrapper = O, this.eDisplayField = O, this.eIcon = O, this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e) return;
    const { pickerGap: t, maxPickerHeight: i, variableWidth: s, minPickerWidth: o, maxPickerWidth: r } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!s, i != null && this.setPickerMaxHeight(i), o != null && this.setPickerMinWidth(o), r != null && this.setPickerMaxWidth(r);
  }
  wireBeans(e) {
    this.popupService = e.popupService;
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: i, inputWidth: s } = this.config;
    if (i) {
      const o = De(i, this.gos);
      o && this.eIcon.appendChild(o);
    }
    s != null && this.setInputWidth(s);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), $i(e, false), this.ariaRole && Ve(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t) return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = false;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case y.UP:
      case y.DOWN:
      case y.ENTER:
      case y.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case y.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = true, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(true);
  }
  renderAndPositionPicker() {
    const e = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({ bodyScroll: () => {
      this.hidePicker();
    } }));
    const t = this.localeService.getLocaleTextFunc(), { pickerAriaLabelKey: i, pickerAriaLabelValue: s, modalPicker: o = true } = this.config, r = { modal: o, eChild: e, closeOnEsc: true, closedCallback: () => {
      const h = Pr(this.gos);
      this.beforeHidePicker(), h && this.isAlive() && this.getFocusableElement().focus();
    }, ariaLabel: t(i, s), anchorToElement: this.eWrapper };
    e.style.position = "absolute";
    const n = this.popupService.addPopup(r), { maxPickerHeight: l, minPickerWidth: a, maxPickerWidth: c, variableWidth: u } = this;
    u ? (a && (e.style.minWidth = a), e.style.width = uo(qi(this.eWrapper)), c && (e.style.maxWidth = c)) : Ji(e, c ?? qi(this.eWrapper));
    const d = l ?? `${co(this.popupService.getPopupParent())}px`;
    return e.style.setProperty("max-height", d), this.alignPickerToComponent(), n.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent) return;
    const { pickerType: e } = this.config, { pickerGap: t } = this, i = this.gos.get("enableRtl") ? "right" : "left";
    this.popupService.positionPopupByComponent({ type: e, eventSource: this.eWrapper, ePopup: this.pickerComponent.getGui(), position: "under", alignSide: i, keepWithinBounds: true, nudgeY: t });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(false);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = false, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive()) return;
    const t = this.getAriaElement();
    $i(t, e), this.eWrapper.classList.toggle("ag-picker-expanded", e), this.eWrapper.classList.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(true);
  }
  onPickerFocusOut(e) {
    var _a3;
    ((_a3 = this.pickerComponent) == null ? void 0 : _a3.getGui().contains(e.relatedTarget)) || this.togglePickerHasFocus(false);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    this.hideCurrentPicker && this.hideCurrentPicker();
  }
  setInputWidth(e) {
    return Ji(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, So = class extends Xc {
  constructor(e) {
    super({ pickerAriaLabelKey: "ariaLabelSelectField", pickerAriaLabelValue: "Select Field", pickerType: "ag-list", className: "ag-select", pickerIcon: "smallDown", ariaRole: "combobox", ...e });
  }
  postConstruct() {
    super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: i } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, true), i && t == null && (this.eDisplayField.textContent = i), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    this.listComponent = this.createBean(new Qc("select", true)), this.listComponent.setParentComponent(this);
    const e = this.listComponent.getAriaElement(), t = `ag-select-list-${this.listComponent.getCompId()}`;
    e.setAttribute("id", t), Ga(this.getAriaElement(), e), this.listComponent.addManagedListeners(this.listComponent, { selectedItem: () => {
      this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
    } }), this.listComponent.addManagedListeners(this.listComponent, { fieldValueChanged: () => {
      this.listComponent && (this.setValue(this.listComponent.getValue(), false, true), this.hidePicker());
    } });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    var _a3;
    const { key: t } = e;
    switch (t === y.TAB && this.hidePicker(), t) {
      case y.ENTER:
      case y.UP:
      case y.DOWN:
      case y.PAGE_UP:
      case y.PAGE_DOWN:
      case y.PAGE_HOME:
      case y.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (_a3 = this.listComponent) == null ? void 0 : _a3.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case y.ESCAPE:
        super.onKeyDown(e);
        break;
      case y.SPACE:
        this.isPickerDisplayed ? e.preventDefault() : super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    this.listComponent && (super.showPicker(), this.listComponent.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var _a3;
    return (_a3 = this.listComponent) == null ? void 0 : _a3.clearOptions(), this;
  }
  setValue(e, t, i) {
    if (this.value === e || !this.listComponent) return this;
    if (i || this.listComponent.setValue(e, true), this.listComponent.getValue() === this.getValue()) return this;
    let o = this.listComponent.getDisplayValue();
    return o == null && this.config.placeholder && (o = this.config.placeholder), this.eDisplayField.textContent = o, this.setTooltip({ newTooltipText: o ?? null, shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth }), super.setValue(e, t);
  }
  destroy() {
    this.listComponent && (this.listComponent = this.destroyBean(this.listComponent)), super.destroy();
  }
}, Jc = { selector: "AG-SELECT", component: So }, vn = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    this.filterOptions && this.filterOptions.forEach((e) => {
      if (typeof e == "string") return;
      const t = [["displayKey"], ["displayName"], ["predicate", "test"]], i = (s) => s.some((o) => e[o] != null) ? true : (F(`ignoring FilterOptionDef as it doesn't contain one of '${s}'`), false);
      if (!t.every(i)) {
        this.filterOptions = this.filterOptions.filter((s) => s === e) || [];
        return;
      }
      this.customFilterOptions[e.displayKey] = e;
    });
  }
  selectDefaultItem(e) {
    if (e.defaultOption) this.defaultOption = e.defaultOption;
    else if (this.filterOptions.length >= 1) {
      const t = this.filterOptions[0];
      typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : F("invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
    } else F("no filter options for filter");
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
}, Sn = class extends qc {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: s } = t;
      return s ?? 1;
    }
    return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
  }
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(true);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, i) => {
      i === 0 ? t.setValue(e, true) : t.setValue(this.optionsFactory.getDefaultOption(), true);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? { filterType: this.getFilterType(), operator: this.getJoinOperator(), conditions: e } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    return this.eJoinOperatorsOr.length === 0 ? this.defaultJoinOperator : this.eJoinOperatorsOr[0].getValue() === true ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t) return true;
    if (!e && t || e && !t) return false;
    const i = !e.operator, s = !t.operator;
    if (!i && s || i && !s) return false;
    let r;
    if (i) {
      const n = e, l = t;
      r = this.areSimpleModelsEqual(n, l);
    } else {
      const n = e, l = t;
      r = n.operator === l.operator && gt(n.conditions, l.conditions, (a, c) => this.areSimpleModelsEqual(a, c));
    }
    return r;
  }
  shouldRefresh(e) {
    var _a3;
    const t = this.getModel(), i = t ? t.conditions ?? [t] : null, s = ((_a3 = e.filterOptions) == null ? void 0 : _a3.map((r) => typeof r == "string" ? r : r.displayKey)) ?? this.getDefaultFilterOptions();
    return !(!(!i || i.every((r) => s.find((n) => n === r.type) !== void 0)) || typeof e.maxNumConditions == "number" && i && i.length > e.maxNumConditions);
  }
  refresh(e) {
    return !this.shouldRefresh(e) || !super.refresh(e) ? false : (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), true);
  }
  setModelIntoUi(e) {
    if (e.operator) {
      const i = e;
      let s = i.conditions;
      s == null && (s = [], F("Filter model is missing 'conditions'"));
      const o = this.validateAndUpdateConditions(s), r = this.getNumConditions();
      if (o < r) this.removeConditionsAndOperators(o);
      else if (o > r) for (let l = r; l < o; l++) this.createJoinOperatorPanel(), this.createOption();
      const n = i.operator === "OR";
      this.eJoinOperatorsAnd.forEach((l) => l.setValue(!n, true)), this.eJoinOperatorsOr.forEach((l) => l.setValue(n, true)), s.forEach((l, a) => {
        this.eTypes[a].setValue(l.type, true), this.setConditionIntoUi(l, a);
      });
    } else {
      const i = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(i.type, true), this.setConditionIntoUi(i, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), oe.resolve();
  }
  validateAndUpdateConditions(e) {
    let t = e.length;
    return t > this.maxNumConditions && (e.splice(this.maxNumConditions), F('Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'), t = this.maxNumConditions), t;
  }
  doesFilterPass(e) {
    const t = this.getModel();
    if (t == null) return true;
    const { operator: i } = t, s = [];
    if (i) {
      const r = t;
      s.push(...r.conditions ?? []);
    } else s.push(t);
    return s[i && i === "OR" ? "some" : "every"]((r) => this.individualConditionPasses(e, r));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = this.getDefaultJoinOperator(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new vn(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(e) {
    this.maxNumConditions = e.maxNumConditions ?? 2, this.maxNumConditions < 1 && (F('"filterParams.maxNumConditions" must be greater than or equal to zero.'), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = e.numAlwaysVisibleConditions ?? 1, this.numAlwaysVisibleConditions < 1 && (F('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (F('"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'), this.numAlwaysVisibleConditions = this.maxNumConditions);
  }
  createOption() {
    const e = this.createManagedBean(new So());
    this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const i = this.getNumConditions() - 1;
    this.forEachPositionInput(i, (s) => this.resetInput(s)), this.addChangedListeners(e, i);
  }
  createJoinOperatorPanel() {
    const e = document.createElement("div");
    this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), i = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const s = this.eJoinOperatorPanels.length - 1, o = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, s, o), this.resetJoinOperatorOr(i, s, o), this.isReadOnly() || (t.onValueChange(this.listener), i.onValueChange(this.listener));
  }
  createJoinOperator(e, t, i) {
    const s = this.createManagedBean(new Yc());
    return e.push(s), s.addCssClass("ag-filter-condition-operator"), s.addCssClass(`ag-filter-condition-operator-${i}`), t.appendChild(s.getGui()), s;
  }
  getDefaultJoinOperator(e) {
    return e === "AND" || e === "OR" ? e : "AND";
  }
  createFilterListOptions() {
    const e = this.optionsFactory.getFilterOptions();
    this.filterListOptions = e.map((t) => typeof t == "string" ? this.createBoilerplateListOption(t) : this.createCustomListOption(t));
  }
  putOptionsIntoDropdown(e) {
    this.filterListOptions.forEach((t) => {
      e.addOption(t);
    }), e.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, i = this.optionsFactory.getCustomOption(e.displayKey);
    return { value: t, text: i ? this.localeService.getLocaleTextFunc()(i.displayKey, i.displayName) : this.translate(t) };
  }
  createBodyTemplate() {
    return "";
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = true;
    for (let i = 0; i < this.getNumConditions(); i++) this.isConditionUiComplete(i) ? e = i : t = false;
    if (this.shouldAddNewConditionAtEnd(t)) this.createJoinOperatorPanel(), this.createOption();
    else {
      const i = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < i) {
        this.removeConditionsAndOperators(i + 1);
        const s = e + 1, o = i - s;
        o > 0 && this.removeConditionsAndOperators(s, o), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((s, o) => {
      const r = this.isConditionDisabled(o, e);
      s.setDisabled(r || this.filterListOptions.length <= 1), o === 1 && (fi(this.eJoinOperatorPanels[0], r), this.eJoinOperatorsAnd[0].setDisabled(r), this.eJoinOperatorsOr[0].setDisabled(r));
    }), this.eConditionBodies.forEach((s, o) => {
      ee(s, this.isConditionBodyVisible(o));
    });
    const i = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((s) => {
      s.setValue(!i, true);
    }), this.eJoinOperatorsOr.forEach((s) => {
      s.setValue(i, true);
    }), this.forEachInput((s, o, r, n) => {
      this.setElementDisplayed(s, o < n), this.setElementDisabled(s, this.isConditionDisabled(r, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions()) return;
    this.removeComponents(this.eTypes, e, t), this.removeElements(this.eConditionBodies, e, t), this.removeValueElements(e, t);
    const i = Math.max(e - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, i, t), this.removeComponents(this.eJoinOperatorsAnd, i, t), this.removeComponents(this.eJoinOperatorsOr, i, t);
  }
  removeElements(e, t, i) {
    this.removeItems(e, t, i).forEach((o) => Mt(o));
  }
  removeComponents(e, t, i) {
    this.removeItems(e, t, i).forEach((o) => {
      Mt(o.getGui()), this.destroyBean(o);
    });
  }
  removeItems(e, t, i) {
    return i == null ? e.splice(t) : e.splice(t, i);
  }
  afterGuiAttached(e) {
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e == null ? void 0 : e.suppressFocus)) if (this.isReadOnly()) this.eFilterBody.focus();
    else {
      const t = this.getInputs(0)[0];
      if (!t) return;
      t instanceof wt && t.getInputElement().focus();
    }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    this.resetUiToActiveModel(e);
    let t = -1, i = -1, s = false;
    const o = this.getJoinOperator();
    for (let n = this.getNumConditions() - 1; n >= 0; n--) if (this.isConditionUiComplete(n)) t === -1 && (t = n, i = n);
    else {
      const l = n >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(n - 1), a = n < t;
      (l || a) && (this.removeConditionsAndOperators(n, 1), s = true, a && i--);
    }
    let r = false;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), r = true), this.shouldAddNewConditionAtEnd(i === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), r = true), r && this.updateConditionStatusesAndValues(i, o), s && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = i;
  }
  getPlaceholderText(e, t) {
    let i = this.translate(e);
    if (Js(this.filterPlaceholder)) {
      const s = this.filterPlaceholder, o = this.eTypes[t].getValue(), r = this.translate(o);
      i = s({ filterOptionKey: o, filterOption: r, placeholder: i });
    } else typeof this.filterPlaceholder == "string" && (i = this.filterPlaceholder);
    return i;
  }
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc();
    this.forEachInput((t, i, s, o) => {
      if (!(t instanceof wt)) return;
      const r = i === 0 && o > 1 ? "inRangeStart" : i === 0 ? "filterOoo" : "inRangeEnd", n = i === 0 && o > 1 ? e("ariaFilterFromValue", "Filter from value") : i === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(r, s)), t.setInputAriaLabel(n);
    });
  }
  setElementValue(e, t, i) {
    e instanceof wt && e.setValue(t != null ? String(t) : null, true);
  }
  setElementDisplayed(e, t) {
    e instanceof Y && ee(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof Y && fi(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof wt && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, i) => {
      this.forEachPositionTypeInput(i, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const i = this.getConditionType(e);
    this.forEachPositionTypeInput(e, i, t);
  }
  forEachPositionTypeInput(e, t, i) {
    const s = this.getNumberOfInputs(t), o = this.getInputs(e);
    for (let r = 0; r < o.length; r++) {
      const n = o[r];
      n != null && i(n, r, e, s);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? true : e === 0 ? false : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((i) => i == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++) this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly()) for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++) this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach((t, i) => this.resetJoinOperatorAnd(t, i, this.joinOperatorId + i)), this.eJoinOperatorsOr.forEach((t, i) => this.resetJoinOperatorOr(t, i, this.joinOperatorId + i)), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), oe.resolve();
  }
  resetType(e) {
    const i = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.getDefaultOption(), true).setAriaLabel(i).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, i) {
    this.resetJoinOperator(e, t, this.isDefaultOperator("AND"), this.translate("andCondition"), i);
  }
  resetJoinOperatorOr(e, t, i) {
    this.resetJoinOperator(e, t, this.isDefaultOperator("OR"), this.translate("orCondition"), i);
  }
  resetJoinOperator(e, t, i, s, o) {
    this.updateJoinOperatorDisabled(e.setValue(i, true).setName(`ag-simple-filter-and-or-${this.getCompId()}-${o}`).setLabel(s), t);
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((e, t) => this.updateJoinOperatorDisabled(e, t)), this.eJoinOperatorsOr.forEach((e, t) => this.updateJoinOperatorDisabled(e, t));
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  setConditionIntoUi(e, t) {
    const i = this.mapValuesFromModel(e);
    this.forEachInput((s, o, r) => {
      r === t && this.setElementValue(s, i[o] != null ? i[o] : null);
    });
  }
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, i, s) => {
      this.setElementValue(t, i === 0 && s === 0 ? e : null, true);
    });
  }
  isDefaultOperator(e) {
    return e === this.defaultJoinOperator;
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (i) => {
      this.attachElementOnChange(i, this.listener);
    }));
  }
  individualConditionPasses(e, t) {
    const i = this.getCellValue(e.node), s = this.mapValuesFromModel(t), o = this.optionsFactory.getCustomOption(t.type), r = this.evaluateCustomFilter(o, s, i);
    return r ?? (i == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(s, i, t, e));
  }
  evaluateCustomFilter(e, t, i) {
    if (e == null) return;
    const { predicate: s } = e;
    if (s != null && !t.some((o) => o == null)) return s(t, i);
  }
  isBlank(e) {
    return e == null || typeof e == "string" && e.trim().length === 0;
  }
  hasInvalidInputs() {
    return false;
  }
}, wn = class extends Sn {
  setParams(e) {
    super.setParams(e), this.scalarFilterParams = e;
  }
  evaluateNullValue(e) {
    switch (e) {
      case "equals":
        if (this.scalarFilterParams.includeBlanksInEquals) return true;
        break;
      case "notEqual":
        if (this.scalarFilterParams.includeBlanksInNotEqual) return true;
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInGreaterThan) return true;
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInLessThan) return true;
        break;
      case "inRange":
        if (this.scalarFilterParams.includeBlanksInRange) return true;
        break;
      case "blank":
        return true;
      case "notBlank":
        return false;
    }
    return false;
  }
  evaluateNonNullValue(e, t, i) {
    const s = this.comparator(), o = e[0] != null ? s(e[0], t) : 0;
    switch (i.type) {
      case "equals":
        return o === 0;
      case "notEqual":
        return o !== 0;
      case "greaterThan":
        return o > 0;
      case "greaterThanOrEqual":
        return o >= 0;
      case "lessThan":
        return o < 0;
      case "lessThanOrEqual":
        return o <= 0;
      case "inRange": {
        const r = s(e[1], t);
        return this.scalarFilterParams.inRangeInclusive ? o >= 0 && r <= 0 : o > 0 && r < 0;
      }
      case "blank":
        return this.isBlank(t);
      case "notBlank":
        return !this.isBlank(t);
      default:
        return F('Unexpected type of filter "' + i.type + '", it looks like the filter was configured with incorrect Filter Options'), true;
    }
  }
}, Zc = 65, eu = 67, tu = 86, iu = 68, su = 90, ou = 89;
function yn(e) {
  var _a3;
  return e.altKey || e.ctrlKey || e.metaKey ? false : ((_a3 = e.key) == null ? void 0 : _a3.length) === 1;
}
function _s(e, t, i, s, o) {
  const r = s ? s.getColDef().suppressKeyboardEvent : void 0;
  if (!r) return false;
  const n = e.addGridCommonParams({ event: t, editing: o, column: s, node: i, data: i.data, colDef: s.getColDef() });
  return !!(r && r(n));
}
function ru(e, t, i, s) {
  const o = s.getDefinition(), r = o && o.suppressHeaderKeyboardEvent;
  if (!E(r)) return false;
  const n = e.addGridCommonParams({ colDef: o, column: s, headerRowIndex: i, event: t });
  return !!r(n);
}
function nu(e) {
  const { keyCode: t } = e;
  let i;
  switch (t) {
    case Zc:
      i = y.A;
      break;
    case eu:
      i = y.C;
      break;
    case tu:
      i = y.V;
      break;
    case iu:
      i = y.D;
      break;
    case su:
      i = y.Z;
      break;
    case ou:
      i = y.Y;
      break;
    default:
      i = e.code;
  }
  return i;
}
function lu(e, t = false) {
  return e === y.DELETE ? true : !t && e === y.BACKSPACE ? qr() : false;
}
var Tt = class extends wt {
  constructor(e, t = "ag-text-field", i = "text") {
    super(e, t, i);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    return this.eInput.value !== e && (this.eInput.value = E(e) ? e : ""), super.setValue(e, t);
  }
  setStartValue(e) {
    this.setValue(e, true);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (i) => {
      yn(i) && i.key && !e.test(i.key) && i.preventDefault();
    };
    this.addManagedListeners(this.eInput, { keydown: t, paste: (i) => {
      var _a3;
      const s = (_a3 = i.clipboardData) == null ? void 0 : _a3.getData("text");
      s && s.split("").some((o) => !e.test(o)) && i.preventDefault();
    } });
  }
}, ns = { selector: "AG-INPUT-TEXT-FIELD", component: Tt }, wo = class extends Tt {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListeners(this.eInput, { blur: () => {
      const o = parseFloat(this.eInput.value), r = isNaN(o) ? "" : this.normalizeValue(o.toString());
      this.value !== r && this.setValue(r);
    }, wheel: this.onWheel.bind(this) }), this.eInput.step = "any";
    const { precision: e, min: t, max: i, step: s } = this.config;
    typeof e == "number" && this.setPrecision(e), typeof t == "number" && this.setMin(t), typeof i == "number" && this.setMax(i), typeof s == "number" && this.setStep(s);
  }
  onWheel(e) {
    te(this.gos) === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "") return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e);
    return this.min != null && t < this.min ? e = this.min.toString() : this.max != null && t > this.max && (e = this.max.toString()), e;
  }
  adjustPrecision(e, t) {
    if (this.precision == null) return e;
    if (t) {
      const s = parseFloat(e).toFixed(this.precision);
      return parseFloat(s).toString();
    }
    const i = String(e).split(".");
    if (i.length > 1) {
      if (i[1].length <= this.precision) return e;
      if (this.precision > 0) return `${i[0]}.${i[1].slice(0, this.precision)}`;
    }
    return i[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, Oe(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, Oe(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Oe(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue((i) => super.setValue(i, t), () => this, e);
  }
  setStartValue(e) {
    return this.setValueOrInputValue((t) => super.setValue(t, true), (t) => {
      this.eInput.value = t;
    }, e);
  }
  setValueOrInputValue(e, t, i) {
    if (E(i)) {
      let s = this.isScientificNotation(i);
      if (s && this.eInput.validity.valid) return e(i);
      if (!s) {
        i = this.adjustPrecision(i);
        const o = this.normalizeValue(i);
        s = i != o;
      }
      if (s) return t(i);
    }
    return e(i);
  }
  getValue() {
    if (!this.eInput.validity.valid) return;
    const e = this.eInput.value;
    return this.isScientificNotation(e) ? this.adjustPrecision(e, true) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, au = { selector: "AG-INPUT-NUMBER-FIELD", component: wo }, Rn = ["equals", "notEqual", "greaterThan", "greaterThanOrEqual", "lessThan", "lessThanOrEqual", "inRange", "blank", "notBlank"], yo = class {
  constructor(e, t, i) {
    this.localeService = e, this.optionsFactory = t, this.valueFormatter = i;
  }
  getModelAsString(e) {
    if (!e) return null;
    const t = e.operator != null, i = this.localeService.getLocaleTextFunc();
    if (t) {
      const s = e, r = (s.conditions ?? []).map((l) => this.getModelAsString(l)), n = s.operator === "AND" ? "andCondition" : "orCondition";
      return r.join(` ${i(n, Cn[n])} `);
    } else {
      if (e.type === "blank" || e.type === "notBlank") return i(e.type, e.type);
      {
        const s = e, o = this.optionsFactory.getCustomOption(s.type), { displayKey: r, displayName: n, numberOfInputs: l } = o || {};
        return r && n && l === 0 ? (i(r, n), n) : this.conditionToString(s, o);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    return this.valueFormatter ? this.valueFormatter(e ?? null) ?? "" : String(e);
  }
}, Fn = class extends yo {
  conditionToString(e, t) {
    const { numberOfInputs: i } = t || {};
    return e.type == "inRange" || i === 2 ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}` : e.filter != null ? this.formatValue(e.filter) : `${e.type}`;
  }
};
function Us(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
var cu = class extends wn {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  refresh(e) {
    return this.numberFilterParams.allowedCharPattern !== e.allowedCharPattern ? false : super.refresh(e);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: i, type: s } = e || {};
    return [this.processValue(t), this.processValue(i)].slice(0, this.getNumberOfInputs(s));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  setParams(e) {
    this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new Fn(this.localeService, this.optionsFactory, this.numberFilterParams.numberFormatter);
  }
  getDefaultFilterOptions() {
    return Rn;
  }
  setElementValue(e, t, i) {
    const s = !i && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(t ?? null) : t;
    super.setElementValue(e, s);
  }
  createValueElement() {
    const e = Us(this.numberFilterParams), t = document.createElement("div");
    return t.classList.add("ag-filter-body"), Ve(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, i, s) {
    const o = this.createManagedBean(s ? new Tt({ allowedCharPattern: s }) : new wo());
    o.addCssClass(`ag-filter-${i}`), o.addCssClass("ag-filter-filter"), t.push(o), e.appendChild(o.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, s, o, r) => {
      s < r && t.push(this.processValue(this.stringToFloat(i.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(e) {
    return e == null || isNaN(e) ? null : e;
  }
  stringToFloat(e) {
    if (typeof e == "number") return e;
    let t = Je(e);
    return t != null && t.trim() === "" && (t = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = { filterType: this.getFilterType(), type: t }, s = this.getValues(e);
    return s.length > 0 && (i.filter = s[0]), s.length > 1 && (i.filterTo = s[1]), i;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
  hasInvalidInputs() {
    let e = false;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = true;
        return;
      }
    }), e;
  }
}, bn = ["contains", "notContains", "equals", "notEqual", "startsWith", "endsWith", "blank", "notBlank"], Pn = class extends yo {
  conditionToString(e, t) {
    const { numberOfInputs: i } = t || {};
    return e.type == "inRange" || i === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
};
function En(e) {
  const t = e && e.trim();
  return t === "" ? e : t;
}
var uu = class extends Sn {
  constructor() {
    super("textFilter"), this.defaultFormatter = (e) => e, this.defaultLowercaseFormatter = (e) => e == null ? null : e.toString().toLowerCase(), this.defaultMatcher = ({ filterOption: e, value: t, filterText: i }) => {
      if (i == null) return false;
      switch (e) {
        case "contains":
          return t.indexOf(i) >= 0;
        case "notContains":
          return t.indexOf(i) < 0;
        case "equals":
          return t === i;
        case "notEqual":
          return t != i;
        case "startsWith":
          return t.indexOf(i) === 0;
        case "endsWith": {
          const s = t.lastIndexOf(i);
          return s >= 0 && s === t.length - i.length;
        }
        default:
          return false;
      }
    }, this.eValuesFrom = [], this.eValuesTo = [];
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter), this.filterModelFormatter = new Pn(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const e = this.textFilterParams.textCustomComparator;
    return e ? (F("textCustomComparator is deprecated, use textMatcher instead."), ({ filterOption: t, value: i, filterText: s }) => e(t, i, s)) : this.textFilterParams.textMatcher || this.defaultMatcher;
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = { filterType: this.getFilterType(), type: t }, s = this.getValuesWithSideEffects(e, true);
    return s.length > 0 && (i.filter = s[0]), s.length > 1 && (i.filterTo = s[1]), i;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, false);
  }
  getValuesWithSideEffects(e, t) {
    const i = [];
    return this.forEachPositionInput(e, (s, o, r, n) => {
      if (o < n) {
        let l = Je(s.getValue());
        t && this.textFilterParams.trimInput && (l = En(l) ?? null, s.setValue(l, true)), i.push(l);
      }
    }), i;
  }
  getDefaultFilterOptions() {
    return bn;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), Ve(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, i) {
    const s = this.createManagedBean(new Tt());
    s.addCssClass(`ag-filter-${i}`), s.addCssClass("ag-filter-filter"), t.push(s), e.appendChild(s.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: i, type: s } = e || {};
    return [t || null, i || null].slice(0, this.getNumberOfInputs(s));
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : false;
  }
  evaluateNonNullValue(e, t, i, s) {
    const o = e.map((h) => this.formatter(h)) || [], r = this.formatter(t), { api: n, colDef: l, column: a, context: c, textFormatter: u } = this.textFilterParams;
    if (i.type === "blank") return this.isBlank(t);
    if (i.type === "notBlank") return !this.isBlank(t);
    const d = { api: n, colDef: l, column: a, context: c, node: s.node, data: s.data, filterOption: i.type, value: r, textFormatter: u };
    return o.some((h) => this.matcher({ ...d, filterText: h }));
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
};
function Dn(e) {
  if (typeof e == "number") return e;
  if (typeof e == "string") {
    const t = parseInt(e);
    return isNaN(t) ? void 0 : t;
  }
}
function ze(e, t = Number.MAX_VALUE) {
  return (i) => {
    const s = Dn(i);
    if (!(s == null || s < e || s > t)) return s;
  };
}
function ai(e, t) {
  return e.toString().padStart(t, "0");
}
function du(e, t) {
  const i = [];
  for (let s = e; s <= t; s++) i.push(s);
  return i;
}
function hu(e, t, i) {
  return typeof e != "number" ? "" : e.toString().replace(".", i).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`);
}
function Ge(e, t = true, i = "-") {
  if (!e) return null;
  let s = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((o) => ai(o, 2)).join(i);
  return t && (s += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((o) => ai(o, 2)).join(":")), s;
}
var Fs = (e) => {
  if (e > 3 && e < 21) return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function ci(e, t = "YYYY-MM-DD") {
  const i = ai(e.getFullYear(), 4), s = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], o = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], r = { YYYY: () => i.slice(i.length - 4, i.length), YY: () => i.slice(i.length - 2, i.length), Y: () => `${e.getFullYear()}`, MMMM: () => s[e.getMonth()], MMM: () => s[e.getMonth()].slice(0, 3), MM: () => ai(e.getMonth() + 1, 2), Mo: () => `${e.getMonth() + 1}${Fs(e.getMonth() + 1)}`, M: () => `${e.getMonth() + 1}`, Do: () => `${e.getDate()}${Fs(e.getDate())}`, DD: () => ai(e.getDate(), 2), D: () => `${e.getDate()}`, dddd: () => o[e.getDay()], ddd: () => o[e.getDay()].slice(0, 3), dd: () => o[e.getDay()].slice(0, 2), do: () => `${e.getDay()}${Fs(e.getDay())}`, d: () => `${e.getDay()}` }, n = new RegExp(Object.keys(r).join("|"), "g");
  return t.replace(n, (l) => l in r ? r[l]() : l);
}
function be(e) {
  if (!e) return null;
  const [t, i] = e.split(" ");
  if (!t) return null;
  const s = t.split("-").map((d) => parseInt(d, 10));
  if (s.filter((d) => !isNaN(d)).length !== 3) return null;
  const [o, r, n] = s, l = new Date(o, r - 1, n);
  if (l.getFullYear() !== o || l.getMonth() !== r - 1 || l.getDate() !== n) return null;
  if (!i || i === "00:00:00") return l;
  const [a, c, u] = i.split(":").map((d) => parseInt(d, 10));
  return a >= 0 && a < 24 && l.setHours(a), c >= 0 && c < 60 && l.setMinutes(c), u >= 0 && u < 60 && l.setSeconds(u), l;
}
var Mn = class {
  constructor(e, t, i, s, o) {
    this.alive = true, this.context = e, this.eParent = s, t.getDateCompDetails(i).newAgStackInstance().then((l) => {
      if (!this.alive) {
        e.destroyBean(l);
        return;
      }
      this.dateComp = l, l && (s.appendChild(l.getGui()), l.afterGuiAttached && l.afterGuiAttached(), this.tempValue && l.setDate(this.tempValue), this.disabled != null && this.setDateCompDisabled(this.disabled), o == null ? void 0 : o(this));
    });
  }
  destroy() {
    this.alive = false, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
  }
  setDisplayed(e) {
    ee(this.eParent, e);
  }
  setInputPlaceholder(e) {
    this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
  }
  afterGuiAttached(e) {
    this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
  }
  updateParams(e) {
    var _a3, _b;
    let t = false;
    ((_a3 = this.dateComp) == null ? void 0 : _a3.refresh) && typeof this.dateComp.refresh == "function" && this.dateComp.refresh(e) !== null && (t = true), !t && ((_b = this.dateComp) == null ? void 0 : _b.onParamsUpdated) && typeof this.dateComp.onParamsUpdated == "function" && this.dateComp.onParamsUpdated(e) !== null && F("Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
  }
  setDateCompDisabled(e) {
    this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
  }
}, xn = ["equals", "notEqual", "lessThan", "greaterThan", "inRange", "blank", "notBlank"], An = class extends yo {
  constructor(e, t, i) {
    super(t, i), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: i } = e, { numberOfInputs: s } = t || {}, o = i == "inRange" || s === 2, r = be(e.dateFrom), n = be(e.dateTo), l = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (o) {
      const a = r !== null ? ci(r, l) : "null", c = n !== null ? ci(n, l) : "null";
      return `${a}-${c}`;
    }
    return r != null ? ci(r, l) : `${i}`;
  }
  updateParams(e) {
    super.updateParams(e), this.dateFilterParams = e.dateFilterParams;
  }
}, er = 1e3, tr = 1 / 0, gu = class extends wn {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = er, this.maxValidYear = tr, this.minValidDate = null, this.maxValidDate = null;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  mapValuesFromModel(e) {
    const { dateFrom: t, dateTo: i, type: s } = e || {};
    return [t && be(t) || null, i && be(i) || null].slice(0, this.getNumberOfInputs(s));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(e, t) {
    const i = t;
    return t == null || i < e ? -1 : i > e ? 1 : 0;
  }
  setParams(e) {
    this.dateFilterParams = e, super.setParams(e);
    const t = (i, s) => {
      if (e[i] != null) if (isNaN(e[i])) F(`DateFilter ${i} is not a number`);
      else return e[i] == null ? s : Number(e[i]);
      return s;
    };
    this.minValidYear = t("minValidYear", er), this.maxValidYear = t("maxValidYear", tr), this.minValidYear > this.maxValidYear && F("DateFilter minValidYear should be <= maxValidYear"), e.minValidDate ? this.minValidDate = e.minValidDate instanceof Date ? e.minValidDate : be(e.minValidDate) : this.minValidDate = null, e.maxValidDate ? this.maxValidDate = e.maxValidDate instanceof Date ? e.maxValidDate : be(e.maxValidDate) : this.maxValidDate = null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && F("DateFilter minValidDate should be <= maxValidDate"), this.filterModelFormatter = new An(this.dateFilterParams, this.localeService, this.optionsFactory);
  }
  createDateCompWrapper(e) {
    const t = new Mn(this.context, this.userComponentFactory, { onDateChanged: () => this.onUiChanged(), filterParams: this.dateFilterParams }, e);
    return this.addDestroyFunc(() => t.destroy()), t;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  getDefaultFilterOptions() {
    return xn;
  }
  createValueElement() {
    const t = re(this.gos).createElement("div");
    return t.classList.add("ag-filter-body"), this.createFromToElement(t, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(t, this.eConditionPanelsTo, this.dateConditionToComps, "to"), t;
  }
  createFromToElement(e, t, i, s) {
    const r = re(this.gos).createElement("div");
    r.classList.add(`ag-filter-${s}`), r.classList.add(`ag-filter-date-${s}`), t.push(r), e.appendChild(r), i.push(this.createDateCompWrapper(r));
  }
  removeValueElements(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), this.removeItems(this.eConditionPanelsFrom, e, t), this.removeItems(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, i) {
    this.removeItems(e, t, i).forEach((o) => o.destroy());
  }
  isValidDateValue(e) {
    if (e === null) return false;
    if (this.minValidDate) {
      if (e < this.minValidDate) return false;
    } else if (e.getUTCFullYear() < this.minValidYear) return false;
    if (this.maxValidDate) {
      if (e > this.maxValidDate) return false;
    } else if (e.getUTCFullYear() > this.maxValidYear) return false;
    return true;
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e)) return false;
    let t = true;
    return this.forEachInput((i, s, o, r) => {
      o !== e || !t || s >= r || (t = t && this.isValidDateValue(i.getDate()));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {}, s = this.getValues(e);
    return s.length > 0 && (i.dateFrom = Ge(s[0])), s.length > 1 && (i.dateTo = Ge(s[1])), { dateFrom: null, dateTo: null, filterType: this.getFilterType(), type: t, ...i };
  }
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), i = e("ariaFilterValue", "Filter Value");
    this.forEachInput((s) => {
      s.setInputPlaceholder(t), s.setInputAriaLabel(i);
    });
  }
  getInputs(e) {
    return e >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[e], this.dateConditionToComps[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, s, o, r) => {
      s < r && t.push(i.getDate());
    }), t;
  }
  translate(e) {
    return e === "lessThan" ? super.translate("before") : e === "greaterThan" ? super.translate("after") : super.translate(e);
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
}, Ro = class extends R {
  constructor(e, t, i, s) {
    super(), this.columnOrGroup = e, this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = s, this.beans = i;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? N(this.colsSpanning) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const e = this.beans.gos.get("suppressColumnMoveAnimation"), t = E(this.columnOrGroup.getOldLeft());
    this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = e.getLeft(), i = e.getOldLeft(), s = this.modifyLeftForPrintLayout(e, i), o = this.modifyLeftForPrintLayout(e, t);
    this.setLeft(s), this.actualLeft = o, this.beans.columnAnimationService.executeNextVMTurn(() => {
      this.actualLeft === o && this.setLeft(o);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    if (!he(this.beans.gos, "print") || e.getPinned() === "left") return t;
    const s = this.beans.visibleColsService.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const o = this.beans.visibleColsService.getBodyContainerWidth();
      return s + o + t;
    }
    return s + t;
  }
  setLeft(e) {
    if (E(e) && (this.eCell.style.left = `${e}px`), ae(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length) return;
      t.length > 1 && Ia(this.ariaEl, t.length);
    }
  }
}, pu = "ag-column-first", fu = "ag-column-last";
function Tn(e, t, i, s) {
  return V(e) ? [] : Cu(e.headerClass, e, t, i, s);
}
function In(e, t, i) {
  e.addOrRemoveCssClass(pu, i.isColAtEdge(t, "first")), e.addOrRemoveCssClass(fu, i.isColAtEdge(t, "last"));
}
function mu(e, t, i, s) {
  return t.addGridCommonParams({ colDef: e, column: i, columnGroup: s });
}
function Cu(e, t, i, s, o) {
  if (V(e)) return [];
  let r;
  if (typeof e == "function") {
    const n = mu(t, i, s, o);
    r = e(n);
  } else r = e;
  return typeof r == "string" ? [r] : Array.isArray(r) ? [...r] : [];
}
var vu = 0, Ln = class On extends R {
  constructor(t, i, s) {
    super(), this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.columnGroupChild = t, this.parentRowCtrl = s, this.beans = i, this.instanceId = t.getUniqueId() + "-" + vu++;
  }
  wireBeans(t) {
    this.pinnedWidthService = t.pinnedWidthService, this.focusService = t.focusService, this.userComponentFactory = t.userComponentFactory, this.ctrlsService = t.ctrlsService, this.dragAndDropService = t.dragAndDropService, this.menuService = t.menuService;
  }
  postConstruct() {
    const t = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], t), this.addManagedEventListeners({ overlayExclusiveChanged: t });
  }
  shouldStopEventPropagation(t) {
    const { headerRowIndex: i, column: s } = this.focusService.getFocusedHeader();
    return ru(this.gos, t, i, s);
  }
  getWrapperHasFocus() {
    return te(this.gos) === this.eGui;
  }
  setGui(t, i) {
    this.eGui = t, this.addDomData(i), i.addManagedListeners(this.beans.eventService, { displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this) }), i.addManagedElementListeners(this.eGui, { focus: this.onGuiFocus.bind(this) }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  onGuiFocus() {
    this.eventService.dispatchEvent({ type: "headerFocused", column: this.column });
  }
  setupAutoHeight(t) {
    const { wrapperElement: i, checkMeasuringCallback: s, compBean: o } = t, { animationFrameService: r, resizeObserverService: n, columnModel: l, gos: a } = this.beans, c = (C) => {
      if (!this.isAlive() || !o.isAlive()) return;
      const { paddingTop: f, paddingBottom: v, borderBottomWidth: w, borderTopWidth: S } = xt(this.getGui()), b = f + v + w + S, M = i.offsetHeight + b;
      if (C < 5) {
        const P = re(a), A = !P || !P.contains(i), I = M == 0;
        if (A || I) {
          r.requestAnimationFrame(() => c(C + 1));
          return;
        }
      }
      l.setColHeaderHeight(this.column, M);
    };
    let u = false, d;
    const h = () => {
      const C = this.column.isAutoHeaderHeight();
      C && !u && g(), !C && u && m();
    }, g = () => {
      u = true, c(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", true), d = n.observeResize(i, () => c(0));
    }, m = () => {
      u = false, d && d(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", false), d = void 0;
    };
    h(), o.addDestroyFunc(() => m()), o.addManagedListeners(this.column, { widthChanged: () => u && c(0) }), o.addManagedEventListeners({ sortChanged: () => {
      u && window.setTimeout(() => c(0));
    } }), s && s(h);
  }
  onDisplayedColumnsChanged() {
    const { comp: t, column: i, beans: s, eGui: o } = this;
    !t || !i || !o || (In(t, i, s.visibleColsService), $r(o, s.visibleColsService.getAriaColIndex(i)));
  }
  addResizeAndMoveKeyboardListeners(t) {
    this.resizeFeature && t.addManagedListeners(this.eGui, { keydown: this.onGuiKeyDown.bind(this), keyup: this.onGuiKeyUp.bind(this) });
  }
  refreshTabIndex() {
    const t = this.focusService.isHeaderFocusSuppressed();
    this.eGui && Oe(this.eGui, "tabindex", t ? null : "-1");
  }
  onGuiKeyDown(t) {
    var _a3;
    const i = te(this.gos), s = t.key === y.LEFT || t.key === y.RIGHT;
    if (this.isResizing && (t.preventDefault(), t.stopImmediatePropagation()), i !== this.eGui || !t.shiftKey && !t.altKey || ((this.isResizing || s) && (t.preventDefault(), t.stopImmediatePropagation()), !s)) return;
    const o = t.key === y.LEFT !== this.gos.get("enableRtl"), r = hn[o ? "Left" : "Right"];
    if (t.altKey) {
      this.isResizing = true, this.resizeMultiplier += 1;
      const n = this.getViewportAdjustedResizeDiff(t);
      this.resizeHeader(n, t.shiftKey), (_a3 = this.resizeFeature) == null ? void 0 : _a3.toggleColumnResizing(true);
    } else this.moveHeader(r);
  }
  getViewportAdjustedResizeDiff(t) {
    let i = this.getResizeDiff(t);
    if (this.column.getPinned()) {
      const o = this.pinnedWidthService.getPinnedLeftWidth(), r = this.pinnedWidthService.getPinnedRightWidth(), n = yi(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (o + r + i > n) if (n > o + r) i = n - o - r;
      else return 0;
    }
    return i;
  }
  getResizeDiff(t) {
    let i = t.key === y.LEFT !== this.gos.get("enableRtl");
    const s = this.column.getPinned(), o = this.gos.get("enableRtl");
    return s && o !== (s === "right") && (i = !i), (i ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = false, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var _a3;
      (_a3 = this.resizeFeature) == null ? void 0 : _a3.toggleColumnResizing(false);
    }, 150));
  }
  handleKeyDown(t) {
    const i = this.getWrapperHasFocus();
    switch (t.key) {
      case y.PAGE_DOWN:
      case y.PAGE_UP:
      case y.PAGE_HOME:
      case y.PAGE_END:
        i && t.preventDefault();
    }
  }
  addDomData(t) {
    const i = On.DOM_DATA_KEY_HEADER_CTRL;
    Et(this.gos, this.eGui, i, this), t.addDestroyFunc(() => Et(this.gos, this.eGui, i, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(t) {
    return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), true) : false;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
  removeDragSource() {
    this.dragSource && (this.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(t, i, s) {
    const o = t ?? i;
    this.gos.get("preventDefaultOnContextMenu") && o.preventDefault(), this.menuService.isHeaderContextMenuEnabled(s) && this.menuService.showHeaderContextMenu(s, t, i), this.dispatchColumnMouseEvent("columnHeaderContextMenu", s);
  }
  dispatchColumnMouseEvent(t, i) {
    this.eventService.dispatchEvent({ type: t, column: i });
  }
  clearComponent() {
    this.removeDragSource(), this.resizeFeature = null, this.comp = null, this.eGui = null;
  }
  destroy() {
    super.destroy(), this.column = null, this.lastFocusEvent = null, this.columnGroupChild = null, this.parentRowCtrl = null;
  }
};
Ln.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var ls = Ln, Fo = class extends R {
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    this.gos.get("columnHoverHighlight") && this.addMouseHoverListeners();
  }
  addMouseHoverListeners() {
    this.addManagedListeners(this.element, { mouseout: this.onMouseOut.bind(this), mouseover: this.onMouseOver.bind(this) });
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
}, Su = class extends ls {
  constructor(e, t, i) {
    super(e, t, i), this.iconCreated = false, this.column = e;
  }
  setComp(e, t, i, s, o) {
    this.comp = e, o = Si(this, this.beans.context, o), this.eButtonShowMainFilter = i, this.eFloatingFilterBody = s, this.setGui(t, o), this.setupActive(), this.setupWidth(o), this.setupLeft(o), this.setupHover(o), this.setupFocus(o), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(o), this.setupUi(), o.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(o), o.addManagedListeners(this.column, { colDefChanged: () => this.onColDefChanged(o) }), o.addDestroyFunc(() => {
      this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.clearComponent();
    });
  }
  resizeHeader() {
  }
  moveHeader() {
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, i = !!e.floatingFilter;
    this.active = t && i;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated) return;
    const e = De("filter", this.gos, this.column);
    e && (this.iconCreated = true, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus(e) {
    e.createManagedBean(new At(this.eGui, { shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this), onTabKeyDown: this.onTabKeyDown.bind(this), handleKeyDown: this.handleKeyDown.bind(this), onFocusIn: this.onFocusIn.bind(this) }));
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc();
    _t(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    if (te(this.gos) === this.eGui) return;
    const s = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (s) {
      this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), s.focus();
      return;
    }
    const o = this.findNextColumnWithFloatingFilter(e.shiftKey);
    o && this.focusService.focusHeaderPosition({ headerPosition: { headerRowIndex: this.getParentRowCtrl().getRowIndex(), column: o }, event: e }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleColsService;
    let i = this.column;
    do
      if (i = e ? t.getColBefore(i) : t.getColAfter(i), !i) break;
    while (!i.getColDef().filter || !i.getColDef().floatingFilter);
    return i;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case y.UP:
      case y.DOWN:
        t || e.preventDefault();
      case y.LEFT:
      case y.RIGHT:
        if (t) return;
        e.stopPropagation();
      case y.ENTER:
        t && this.focusService.focusInto(this.eGui) && e.preventDefault();
        break;
      case y.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget)) return;
    const i = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), s = !!e.relatedTarget && Vt(e.relatedTarget, "ag-floating-filter");
    if (i && s && e.target === this.eGui) {
      const r = this.lastFocusEvent, n = !!(r && r.key === y.TAB);
      if (r && n) {
        const l = r.shiftKey;
        this.focusService.focusInto(this.eGui, l);
      }
    }
    const o = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(o, this.column);
  }
  setupHover(e) {
    e.createManagedBean(new Fo([this.column], this.eGui));
    const t = () => {
      if (!this.gos.get("columnHoverHighlight")) return;
      const i = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", i);
    };
    e.addManagedEventListeners({ columnHoverChanged: t }), t();
  }
  setupLeft(e) {
    const t = new Ro(this.column, this.eGui, this.beans);
    e.createManagedBean(t);
  }
  setupFilterButton() {
    this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column), this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
  }
  setupUserComp() {
    var _a3;
    if (!this.active) return;
    const e = (_a3 = this.beans.filterManager) == null ? void 0 : _a3.getFloatingFilterCompDetails(this.column, () => this.showParentFilter());
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuService.showFilterMenu({ column: this.column, buttonElement: e, containerType: "floatingFilter", positionBy: "button" });
  }
  setupSyncWithFilter(e) {
    if (!this.active) return;
    const { filterManager: t } = this.beans, i = (s) => {
      if ((s == null ? void 0 : s.source) === "filterDestroyed" && !this.isAlive()) return;
      const o = this.comp.getFloatingFilterComp();
      o && o.then((r) => {
        if (r) {
          const n = t == null ? void 0 : t.getCurrentFloatingFilterParentModel(this.column), l = s ? { ...s, columns: s.columns ?? [], source: s.source === "api" ? "api" : "columnFilter" } : null;
          r.onParentModelChanged(n, l);
        }
      });
    };
    [this.destroySyncListener] = e.addManagedListeners(this.column, { filterChanged: i }), (t == null ? void 0 : t.isFilterActive(this.column)) && i(null);
  }
  setupWidth(e) {
    const t = () => {
      const i = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(i);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupFilterChangedListener(e) {
    this.active && ([this.destroyFilterChangedListener] = e.addManagedListeners(this.column, { filterChanged: this.updateFilterButton.bind(this) }), this.updateFilterButton());
  }
  updateFilterButton() {
    var _a3;
    if (!this.suppressFilterButton && this.comp) {
      const e = !!((_a3 = this.beans.filterManager) == null ? void 0 : _a3.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(e), this.highlightFilterButtonWhenActive && e && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged(e) {
    var _a3;
    const t = this.active;
    this.setupActive();
    const i = !t && this.active;
    t && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const s = this.active ? (_a3 = this.beans.filterManager) == null ? void 0 : _a3.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, o = this.comp.getFloatingFilterComp();
    !o || !s ? this.updateCompDetails(e, s, i) : o.then((r) => {
      var _a4;
      !r || ((_a4 = this.beans.filterManager) == null ? void 0 : _a4.areFilterCompsDifferent(this.userCompDetails ?? null, s)) ? this.updateCompDetails(e, s, i) : this.updateFloatingFilterParams(s);
    });
  }
  updateCompDetails(e, t, i) {
    this.isAlive() && (this.setCompDetails(t), this.setupFilterButton(), this.setupUi(), i && (this.setupSyncWithFilter(e), this.setupFilterChangedListener(e)));
  }
  updateFloatingFilterParams(e) {
    var _a3;
    if (!e) return;
    const t = e.params;
    (_a3 = this.comp.getFloatingFilterComp()) == null ? void 0 : _a3.then((i) => {
      let s = false;
      (i == null ? void 0 : i.refresh) && typeof i.refresh == "function" && i.refresh(t) !== null && (s = true), !s && (i == null ? void 0 : i.onParamsUpdated) && typeof i.onParamsUpdated == "function" && i.onParamsUpdated(t) !== null && F("Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
    });
  }
  destroy() {
    super.destroy(), this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
};
var G = "32.3.4";
function wu(e) {
  var _a3, _b;
  return !!((_a3 = e.filterManager) == null ? void 0 : _a3.isColumnFilterPresent()) || !!((_b = e.filterManager) == null ? void 0 : _b.isAggregateFilterPresent());
}
function yu(e, t, i) {
  var _a3;
  return (_a3 = e.filterManager) == null ? void 0 : _a3.getFilterInstance(t, i);
}
function Ru(e, t) {
  var _a3;
  return ((_a3 = e.filterManager) == null ? void 0 : _a3.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function Fu(e, t) {
  var _a3;
  const i = e.columnModel.getColDefCol(t);
  if (i) return (_a3 = e.filterManager) == null ? void 0 : _a3.destroyFilter(i, "api");
}
function bu(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var _a3;
    return (_a3 = e.filterManager) == null ? void 0 : _a3.setFilterModel(t);
  });
}
function Pu(e) {
  var _a3;
  return ((_a3 = e.filterManager) == null ? void 0 : _a3.getFilterModel()) ?? {};
}
function Eu(e, t) {
  var _a3;
  return ((_a3 = e.filterManager) == null ? void 0 : _a3.getColumnFilterModel(t)) ?? null;
}
function Du(e, t, i) {
  var _a3;
  return ((_a3 = e.filterManager) == null ? void 0 : _a3.setColumnFilterModel(t, i)) ?? Promise.resolve();
}
function Mu(e, t) {
  const i = e.columnModel.getCol(t);
  if (!i) {
    z(`column '${t}' not found`);
    return;
  }
  e.menuService.showFilterMenu({ column: i, containerType: "columnFilter", positionBy: "auto" });
}
function xu(e, t, i) {
  if (t == null) return null;
  let s = null;
  const { compName: o, jsComp: r, fwComp: n } = un.getCompKeys(e, t, Co);
  return o ? s = { set: "agSetColumnFloatingFilter", agSetColumnFilter: "agSetColumnFloatingFilter", multi: "agMultiColumnFloatingFilter", agMultiColumnFilter: "agMultiColumnFloatingFilter", group: "agGroupColumnFloatingFilter", agGroupColumnFilter: "agGroupColumnFloatingFilter", number: "agNumberColumnFloatingFilter", agNumberColumnFilter: "agNumberColumnFloatingFilter", date: "agDateColumnFloatingFilter", agDateColumnFilter: "agDateColumnFloatingFilter", text: "agTextColumnFloatingFilter", agTextColumnFilter: "agTextColumnFloatingFilter" }[o] : r == null && n == null && t.filter === true && (s = i()), s;
}
var ir = { january: "January", february: "February", march: "March", april: "April", may: "May", june: "June", july: "July", august: "August", september: "September", october: "October", november: "November", december: "December" }, sr = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"], Au = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnFilterService", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = false, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.userComponentFactory = e.userComponentFactory, this.rowRenderer = e.rowRenderer, this.dataTypeService = e.dataTypeService, this.filterManager = e.filterManager;
  }
  postConstruct() {
    var _a3, _b;
    this.addManagedEventListeners({ gridColumnsChanged: this.onColumnsChanged.bind(this), rowDataUpdated: () => this.onNewRowsLoaded("rowDataUpdated"), dataTypesInferred: this.processFilterModelUpdateQueue.bind(this) }), this.initialFilterModel = { ...((_b = (_a3 = this.gos.get("initialState")) == null ? void 0 : _a3.filter) == null ? void 0 : _b.filterModel) ?? {} };
  }
  setFilterModel(e, t = "api") {
    var _a3;
    if ((_a3 = this.dataTypeService) == null ? void 0 : _a3.isPendingInference()) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const i = [], s = this.getFilterModel(true);
    if (e) {
      const o = new Set(Object.keys(e));
      this.allColumnFilters.forEach((r, n) => {
        const l = e[n];
        i.push(this.setModelOnFilterWrapper(r.filterPromise, l)), o.delete(n);
      }), o.forEach((r) => {
        const n = this.columnModel.getColDefCol(r) || this.columnModel.getCol(r);
        if (!n) {
          F("setFilterModel() - no column found for colId: " + r);
          return;
        }
        if (!n.isFilterAllowed()) {
          F("setFilterModel() - unable to fully apply model, filtering disabled for colId: " + r);
          return;
        }
        const l = this.getOrCreateFilterWrapper(n);
        if (!l) {
          F("setFilterModel() - unable to fully apply model, unable to create filter for colId: " + r);
          return;
        }
        i.push(this.setModelOnFilterWrapper(l.filterPromise, e[r]));
      });
    } else this.allColumnFilters.forEach((o) => {
      i.push(this.setModelOnFilterWrapper(o.filterPromise, null));
    });
    oe.all(i).then(() => {
      var _a4;
      const o = this.getFilterModel(true), r = [];
      this.allColumnFilters.forEach((n, l) => {
        const a = s ? s[l] : null, c = o ? o[l] : null;
        Bi(a, c) || r.push(n.column);
      }), r.length > 0 && ((_a4 = this.filterManager) == null ? void 0 : _a4.onFilterChanged({ columns: r, source: t }));
    });
  }
  setModelOnFilterWrapper(e, t) {
    return new oe((i) => {
      e.then((s) => {
        typeof s.setModel != "function" && (F("filter missing setModel method, which is needed for setFilterModel"), i()), (s.setModel(t) || oe.resolve()).then(() => i());
      });
    });
  }
  getFilterModel(e) {
    const t = {}, { allColumnFilters: i, initialFilterModel: s } = this;
    return i.forEach((o, r) => {
      const n = this.getModelFromFilterWrapper(o);
      E(n) && (t[r] = n);
    }), e || Object.entries(s).forEach(([o, r]) => {
      var _a3;
      E(r) && !i.has(o) && ((_a3 = this.columnModel.getCol(o)) == null ? void 0 : _a3.isFilterAllowed()) && (t[o] = r);
    }), t;
  }
  getModelFromFilterWrapper(e) {
    const { filter: t } = e;
    return t ? typeof t.getModel != "function" ? (F("filter API missing getModel method, which is needed for getFilterModel"), null) : t.getModel() : this.getModelFromInitialState(e.column);
  }
  getModelFromInitialState(e) {
    return this.initialFilterModel[e.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    return this.allColumnFilters.size ? (this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "advancedFilterEnabled")), true) : false;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, true);
  }
  updateActiveFilters() {
    const e = (r) => r ? r.isFilterActive ? r.isFilterActive() : (F("Filter is missing isFilterActive() method"), false) : false, t = !!Ls(this.gos), i = (r) => {
      if (!r.isPrimary()) return true;
      const l = !this.columnModel.isPivotActive();
      return !r.isValueActive() || !l ? false : this.columnModel.isPivotMode() ? true : t;
    }, s = [], o = [];
    return this.forEachColumnFilter((r, n) => {
      e(r) && (i(n.column) ? s.push(r) : o.push(r));
    }).then(() => {
      this.activeAggregateFilters = s, this.activeColumnFilters = o;
    });
  }
  updateFilterFlagInColumns(e, t) {
    return this.forEachColumnFilter((i, s) => s.column.setFilterActive(i.isFilterActive(), e, t));
  }
  forEachColumnFilter(e) {
    return oe.all(Array.from(this.allColumnFilters.values()).map((t) => t.filterPromise.then((i) => e(i, t))));
  }
  doColumnFiltersPass(e, t, i) {
    const { data: s, aggData: o } = e, r = i ? this.activeAggregateFilters : this.activeColumnFilters, n = i ? o : s;
    for (let l = 0; l < r.length; l++) {
      const a = r[l];
      if (!(a == null || a === t)) {
        if (typeof a.doesFilterPass != "function") throw new Error("Filter is missing method doesFilterPass");
        if (!a.doesFilterPass({ node: e, data: n })) return false;
      }
    }
    return true;
  }
  callOnFilterChangedOutsideRenderCycle(e) {
    const t = () => {
      var _a3;
      return (_a3 = this.filterManager) == null ? void 0 : _a3.onFilterChanged(e);
    };
    this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t();
  }
  updateBeforeFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: i } = e;
    return this.updateDependentFilters(), this.updateActiveFilters().then(() => this.updateFilterFlagInColumns("filterChanged", i).then(() => {
      this.allColumnFilters.forEach((s) => {
        s.filterPromise && s.filterPromise.then((o) => {
          o && o !== t && o.onAnyFilterChanged && o.onAnyFilterChanged();
        });
      }), this.processingFilterChange = true;
    }));
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = false;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? false) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    this.forEachColumnFilter((t) => {
      t.onNewRowsLoaded && t.onNewRowsLoaded();
    }).then(() => this.updateFilterFlagInColumns(e, { afterDataChange: true })).then(() => this.updateActiveFilters());
  }
  createValueGetter(e) {
    return ({ node: t }) => this.valueService.getValue(e, t, true);
  }
  createGetValue(e) {
    return (t, i) => {
      const s = i ? this.columnModel.getCol(i) : e;
      return s ? this.valueService.getValue(s, t, true) : void 0;
    };
  }
  isFilterActive(e) {
    const { filter: t } = this.cachedFilter(e) ?? {};
    return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null;
  }
  getOrCreateFilterWrapper(e) {
    if (!e.isFilterAllowed()) return null;
    let t = this.cachedFilter(e);
    return t || (t = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, t)), t;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    var _a3;
    let t;
    if (ps(this.gos)) t = "agSetColumnFilter";
    else {
      const i = (_a3 = this.dataTypeService) == null ? void 0 : _a3.getBaseDataType(e);
      i === "number" ? t = "agNumberColumnFilter" : i === "date" || i === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    var _a3;
    let t;
    if (ps(this.gos)) t = "agSetColumnFloatingFilter";
    else {
      const i = (_a3 = this.dataTypeService) == null ? void 0 : _a3.getBaseDataType(e);
      i === "number" ? t = "agNumberColumnFloatingFilter" : i === "date" || i === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e, t) {
    const i = this.getDefaultFilter(e), s = e.getColDef();
    let o;
    const r = { ...this.createFilterParams(e, s), filterModifiedCallback: () => this.filterModifiedCallbackFactory(o, e)(), filterChangedCallback: (l) => this.filterChangedCallbackFactory(o, e)(l), doesRowPassOtherFilter: (l) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(o, l) : true }, n = this.userComponentFactory.getFilterDetails(s, r, i);
    return n ? { filterPromise: () => {
      const l = n.newAgStackInstance();
      return l == null ? void 0 : l.then((a) => {
        o = a, t && (t.filter = a);
      }), l;
    }, compDetails: n } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return this.gos.addGridCommonParams({ column: e, colDef: kr(t), rowModel: this.rowModel, filterChangedCallback: () => {
    }, filterModifiedCallback: () => {
    }, valueGetter: this.createValueGetter(e), getValue: this.createGetValue(e), doesRowPassOtherFilter: () => true });
  }
  createFilterWrapper(e) {
    const t = { column: e, filterPromise: null, compiledElement: null, compDetails: null }, { filterPromise: i, compDetails: s } = this.createFilterInstance(e, t);
    return t.filterPromise = (i == null ? void 0 : i()) ?? null, t.compDetails = s, t;
  }
  onColumnsChanged() {
    var _a3;
    const e = [];
    this.allColumnFilters.forEach((i, s) => {
      let o;
      i.column.isPrimary() ? o = this.columnModel.getColDefCol(s) : o = this.columnModel.getCol(s), !(o && o === i.column) && (e.push(i.column), this.disposeFilterWrapper(i, "columnChanged"), this.disposeColumnListener(s));
    });
    const t = e.every((i) => i.getColDef().filter === "agGroupColumnFilter");
    e.length > 0 && !t ? (_a3 = this.filterManager) == null ? void 0 : _a3.onFilterChanged({ columns: e, source: "api" }) : this.updateDependentFilters();
  }
  updateDependentFilters() {
    var _a3;
    (_a3 = this.columnModel.getAutoCols()) == null ? void 0 : _a3.forEach((t) => {
      t.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(t);
    });
  }
  isFilterAllowed(e) {
    if (!e.isFilterAllowed()) return false;
    const { filter: i } = this.allColumnFilters.get(e.getColId()) ?? {};
    return i && typeof (i == null ? void 0 : i.isFilterAllowed) == "function" ? i.isFilterAllowed() : true;
  }
  getFloatingFilterCompDetails(e, t) {
    const i = (a) => {
      var _a3;
      const c = (_a3 = this.getOrCreateFilterWrapper(e)) == null ? void 0 : _a3.filterPromise;
      c == null ? void 0 : c.then((u) => {
        a(li(u));
      });
    }, s = e.getColDef(), o = { ...this.createFilterParams(e, s), filterChangedCallback: () => i((a) => this.filterChangedCallbackFactory(a, e)()) }, r = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(s, Co, o);
    let n = xu(this.frameworkOverrides, s, () => this.getDefaultFloatingFilter(e));
    n == null && (n = "agReadOnlyFloatingFilter");
    const l = { column: e, filterParams: r, currentParentModel: () => this.getCurrentFloatingFilterParentModel(e), parentFilterInstance: i, showParentFilter: t, suppressFilterButton: false };
    return this.userComponentFactory.getFloatingFilterCompDetails(s, l, n);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  destroyFilter(e, t = "api") {
    var _a3;
    const i = e.getColId(), s = this.allColumnFilters.get(i);
    this.disposeColumnListener(i), delete this.initialFilterModel[i], s && (this.disposeFilterWrapper(s, t), (_a3 = this.filterManager) == null ? void 0 : _a3.onFilterChanged({ columns: [e], source: "api" }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    e.filterPromise.then((i) => {
      this.destroyBean(i), e.column.setFilterActive(false, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId()), this.eventService.dispatchEvent({ type: "filterDestroyed", source: t, column: e.column });
    });
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      this.eventService.dispatchEvent({ type: "filterModified", column: t, filterInstance: e });
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (i) => {
      const s = (i == null ? void 0 : i.source) ?? "columnFilter", o = { filter: e, additionalEventAttributes: i, columns: [t], source: s };
      this.callOnFilterChangedOutsideRenderCycle(o);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t) return;
    const i = t.column, { compDetails: s } = i.isFilterAllowed() ? this.createFilterInstance(i) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, s)) {
      this.destroyFilter(i, "paramsUpdated");
      return;
    }
    const o = i.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(i, "paramsUpdated");
      return;
    }
    t.filterPromise.then((r) => {
      ((r == null ? void 0 : r.refresh) ? r.refresh({ ...this.createFilterParams(i, i.getColDef()), filterModifiedCallback: this.filterModifiedCallbackFactory(r, i), filterChangedCallback: this.filterChangedCallbackFactory(r, i), doesRowPassOtherFilter: (l) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(r, l) : true, ...o }) : true) === false && this.destroyFilter(i, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const i = e.getColId();
    this.allColumnFilters.set(i, t), this.allColumnListeners.set(i, this.addManagedListeners(e, { colDefChanged: () => this.checkDestroyFilter(i) })[0]);
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e) return true;
    const { componentClass: i } = e, { componentClass: s } = t;
    return !(i === s || (i == null ? void 0 : i.render) && (s == null ? void 0 : s.render) && i.render === s.render);
  }
  hasFloatingFilters() {
    return this.columnModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getFilterInstance(e, t) {
    t && this.getFilterInstanceImpl(e).then((i) => {
      const s = li(i);
      t(s);
    });
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstanceImpl(e).then((i) => {
        t(li(i));
      });
    });
  }
  getFilterInstanceImpl(e) {
    var _a3;
    const t = this.columnModel.getColDefCol(e);
    return t ? ((_a3 = this.getOrCreateFilterWrapper(t)) == null ? void 0 : _a3.filterPromise) ?? oe.resolve(null) : oe.resolve(void 0);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: i }) => {
      this.setColumnFilterModel(e, t).then(() => i());
    }), this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    var _a3;
    if ((_a3 = this.dataTypeService) == null ? void 0 : _a3.isPendingInference()) {
      let r = () => {
      };
      const n = new Promise((l) => {
        r = l;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: r }), n;
    }
    const i = this.columnModel.getColDefCol(e), s = i ? this.getOrCreateFilterWrapper(i) : null;
    return s ? ((r) => new Promise((n) => {
      r.then((l) => n(l));
    }))(this.setModelOnFilterWrapper(s.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    const t = this.columnModel.getColDefCol(e);
    return t ? this.cachedFilter(t) ?? null : null;
  }
  setColDefPropertiesForDataType(e, t, i) {
    const s = ps(this.gos), o = this.localeService.getLocaleTextFunc(), r = (n) => {
      const { filterParams: l } = e;
      e.filterParams = typeof l == "object" ? { ...l, ...n } : n;
    };
    switch (t.baseDataType) {
      case "number": {
        s && r({ comparator: (n, l) => {
          const a = n == null ? 0 : parseInt(n), c = l == null ? 0 : parseInt(l);
          return a === c ? 0 : a > c ? 1 : -1;
        } });
        break;
      }
      case "boolean": {
        r(s ? { valueFormatter: (n) => E(n.value) ? o(String(n.value), n.value ? "True" : "False") : o("blanks", "(Blanks)") } : { maxNumConditions: 1, debounceMs: 0, filterOptions: ["empty", { displayKey: "true", displayName: "True", predicate: (n, l) => l, numberOfInputs: 0 }, { displayKey: "false", displayName: "False", predicate: (n, l) => l === false, numberOfInputs: 0 }] });
        break;
      }
      case "date": {
        s && r({ valueFormatter: (n) => {
          const l = i(n);
          return E(l) ? l : o("blanks", "(Blanks)");
        }, treeList: true, treeListFormatter: (n, l) => {
          if (l === 1 && n != null) {
            const a = sr[Number(n) - 1];
            return o(a, ir[a]);
          }
          return n ?? o("blanks", "(Blanks)");
        } });
        break;
      }
      case "dateString": {
        const n = t.dateParser;
        r(s ? { valueFormatter: (l) => {
          const a = i(l);
          return E(a) ? a : o("blanks", "(Blanks)");
        }, treeList: true, treeListPathGetter: (l) => {
          const a = n(l ?? void 0);
          return a ? [String(a.getFullYear()), String(a.getMonth() + 1), String(a.getDate())] : null;
        }, treeListFormatter: (l, a) => {
          if (a === 1 && l != null) {
            const c = sr[Number(l) - 1];
            return o(c, ir[c]);
          }
          return l ?? o("blanks", "(Blanks)");
        } } : { comparator: (l, a) => {
          const c = n(a);
          return a == null || c < l ? -1 : c > l ? 1 : 0;
        } });
        break;
      }
      case "object": {
        s ? r({ valueFormatter: (n) => {
          const l = i(n);
          return E(l) ? l : o("blanks", "(Blanks)");
        } }) : e.filterValueGetter = (n) => i({ column: n.column, node: n.node, value: this.valueService.getValue(n.column, n.node) });
        break;
      }
    }
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
function Tu(e) {
  var _a3;
  return !!((_a3 = e.filterManager) == null ? void 0 : _a3.isAnyFilterPresent());
}
function Iu(e, t = "api") {
  var _a3;
  (_a3 = e.filterManager) == null ? void 0 : _a3.onFilterChanged({ source: t });
}
var Lu = class extends Y {
  constructor() {
    super(`
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`, [ns]), this.eFloatingFilterText = O;
  }
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e;
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", true), i = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(true).setInputAriaLabel(`${t} ${i("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const i = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(i);
      }
    });
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.init(e);
  }
}, Gn = class extends Y {
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  getDefaultDebounceMs() {
    return 0;
  }
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(e) {
    return e && e.afterFloatingFilter;
  }
  isEventFromDataChange(e) {
    return e == null ? void 0 : e.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const t = e.operator;
    let i;
    t ? i = e.conditions[0] : i = e, this.lastType = i.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e) return this.isTypeEditable(this.lastType);
    if (e.operator) return false;
    const i = e;
    return this.isTypeEditable(i.type);
  }
  init(e) {
    this.setSimpleParams(e, false);
  }
  setSimpleParams(e, t = true) {
    this.optionsFactory = new vn(), this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), t || (this.lastType = this.optionsFactory.getDefaultOption()), this.readOnly = !!e.filterParams.readOnly;
    const i = this.isTypeEditable(this.optionsFactory.getDefaultOption());
    this.setEditable(i);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  doesFilterHaveSingleInput(e) {
    const t = this.optionsFactory.getCustomOption(e), { numberOfInputs: i } = t || {};
    return i == null || i == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", true), i = this.localeService.getLocaleTextFunc();
    return `${t} ${i("ariaFilterInput", "Filter Input")}`;
  }
}, Ou = class extends Gn {
  constructor() {
    super(`
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`, [ns]), this.eReadOnlyText = O, this.eDateWrapper = O;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  getDefaultFilterOptions() {
    return xn;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new An(this.filterParams, this.localeService, this.optionsFactory);
    const t = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(true).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.params = e, this.filterParams = e.filterParams, this.updateDateComponent(), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory, dateFilterParams: this.filterParams }), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      if (e) {
        const i = e;
        this.dateComp.setDate(be(i.dateFrom));
      } else this.dateComp.setDate(null);
      this.eReadOnlyText.setValue("");
    } else this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    ee(this.eDateWrapper, e), ee(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e));
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = Ge(e);
    this.params.parentFilterInstance((i) => {
      if (i) {
        const s = be(t);
        i.onFloatingFilterChanged(this.getLastType() || null, s);
      }
    });
  }
  getDateComponentParams() {
    const e = vo(this.params.filterParams, this.getDefaultDebounceMs());
    return { onDateChanged: Re(this.onDateChanged.bind(this), e), filterParams: this.params.column.getColDef().filterParams };
  }
  createDateComponent() {
    this.dateComp = new Mn(this.context, this.userComponentFactory, this.getDateComponentParams(), this.eDateWrapper, (e) => {
      e.setInputAriaLabel(this.getAriaLabel(this.params));
    }), this.addDestroyFunc(() => this.dateComp.destroy());
  }
  updateDateComponent() {
    const e = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(e);
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
}, Gu = class extends Y {
  constructor() {
    super(`
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`, [ns]), this.eDateInput = O;
  }
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListeners(t, { mouseDown: () => {
      this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus();
    }, input: (i) => {
      i.target === te(this.gos) && (this.eDateInput.isDisabled() || this.params.onDateChanged());
    } });
  }
  setParams(e) {
    const t = this.eDateInput.getInputElement(), i = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = i && $e(), t.type = i ? "date" : "text";
    const { minValidYear: s, maxValidYear: o, minValidDate: r, maxValidDate: n } = e.filterParams || {};
    if (r && s && F("DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored."), n && o && F("DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored."), r && n) {
      const [l, a] = [r, n].map((c) => c instanceof Date ? c : be(c));
      l && a && l.getTime() > a.getTime() && F("DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.");
    }
    r ? r instanceof Date ? t.min = ci(r) : t.min = r : s && (t.min = `${s}-01-01`), n ? n instanceof Date ? t.max = ci(n) : t.max = n : o && (t.max = `${o}-12-31`);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return be(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(Ge(e, false));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus();
  }
  shouldUseBrowserDatePicker(e) {
    return e.filterParams && e.filterParams.browserDatePicker != null ? e.filterParams.browserDatePicker : no() || lo() || $e() && jr() >= 14.1;
  }
}, kn = class extends R {
  constructor(e) {
    super(), this.params = e, this.eFloatingFilterTextInput = O, this.valueChangedListener = () => {
    };
  }
  setupGui(e) {
    var _a3;
    this.eFloatingFilterTextInput = this.createManagedBean(new Tt((_a3 = this.params) == null ? void 0 : _a3.config));
    const t = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t);
    const i = (s) => this.valueChangedListener(s);
    this.addManagedListeners(t, { input: i, keydown: i });
  }
  setEditable(e) {
    this.eFloatingFilterTextInput.setDisabled(!e);
  }
  setAutoComplete(e) {
    this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(e, t) {
    this.eFloatingFilterTextInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, Hn = class extends Gn {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = O;
  }
  postConstruct() {
    this.setTemplate(`
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `);
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.floatingFilterInputService = this.createFloatingFilterInputService(e), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    this.params = e;
    const t = e.browserAutoComplete ?? false;
    if (this.floatingFilterInputService.setParams({ ariaLabel: this.getAriaLabel(e), autoComplete: t }), this.applyActive = Zi(this.params.filterParams), !this.isReadOnly()) {
      const i = vo(this.params.filterParams, this.getDefaultDebounceMs()), s = Re(this.syncUpWithParentFilter.bind(this), i);
      this.floatingFilterInputService.setValueChangedListener(s);
    }
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const t = this.floatingFilterInputService.getValue();
    xe(this.eFloatingFilterInputContainer), this.destroyBean(this.floatingFilterInputService), this.setupFloatingFilterInputService(e), this.floatingFilterInputService.setValue(t, true);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === y.ENTER;
    if (this.applyActive && !t) return;
    let i = this.floatingFilterInputService.getValue();
    this.params.filterParams.trimInput && (i = En(i), this.floatingFilterInputService.setValue(i, true)), this.params.parentFilterInstance((s) => {
      s && s.onFloatingFilterChanged(this.getLastType() || null, i || null);
    });
  }
  setEditable(e) {
    this.floatingFilterInputService.setEditable(e);
  }
}, ku = class extends R {
  constructor() {
    super(...arguments), this.valueChangedListener = () => {
    }, this.numberInputActive = true;
  }
  setupGui(e) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new wo()), this.eFloatingFilterTextInput = this.createManagedBean(new Tt()), this.eFloatingFilterTextInput.setDisabled(true);
    const t = this.eFloatingFilterNumberInput.getGui(), i = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t), e.appendChild(i), this.setupListeners(t, (s) => this.valueChangedListener(s)), this.setupListeners(i, (s) => this.valueChangedListener(s));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eFloatingFilterNumberInput.setAutoComplete(e), this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setupListeners(e, t) {
    this.addManagedListeners(e, { input: t, keydown: t });
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterNumberInput.setInputAriaLabel(e), this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, Hu = class extends Hn {
  init(e) {
    var _a3;
    super.init(e), this.filterModelFormatter = new Fn(this.localeService, this.optionsFactory, (_a3 = e.filterParams) == null ? void 0 : _a3.numberFormatter);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    Us(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return Rn;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = Us(e.filterParams), this.allowedCharPattern ? this.createManagedBean(new kn({ config: { allowedCharPattern: this.allowedCharPattern } })) : this.createManagedBean(new ku());
  }
}, Nu = class extends Hn {
  init(e) {
    super.init(e), this.filterModelFormatter = new Pn(this.localeService, this.optionsFactory);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return bn;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new kn());
  }
};
function Vu(e) {
  var _a3;
  return !!((_a3 = e.filterManager) == null ? void 0 : _a3.isQuickFilterPresent());
}
function Bu(e) {
  return e.gos.get("quickFilterText");
}
function Wu(e) {
  var _a3;
  (_a3 = e.filterManager) == null ? void 0 : _a3.resetQuickFilterCache();
}
var zu = class extends R {
  constructor() {
    super(...arguments), this.beanName = "quickFilterService", this.quickFilter = null, this.quickFilterParts = null;
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.pivotResultColsService = e.pivotResultColsService;
  }
  postConstruct() {
    const e = this.resetQuickFilterCache.bind(this);
    this.addManagedEventListeners({ columnPivotModeChanged: e, newColumnsLoaded: e, columnRowGroupChanged: e, columnVisible: () => {
      this.gos.get("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache();
    } }), this.addManagedPropertyListener("quickFilterText", (t) => this.setQuickFilter(t.currentValue)), this.addManagedPropertyListeners(["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"], () => this.onQuickFilterColumnConfigChanged()), this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText")), this.parser = this.gos.get("quickFilterParser"), this.matcher = this.gos.get("quickFilterMatcher"), this.setQuickFilterParts(), this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setQuickFilterParserAndMatcher());
  }
  refreshQuickFilterCols() {
    var _a3;
    const e = this.columnModel.isPivotMode(), t = this.columnModel.getAutoCols(), i = this.columnModel.getColDefCols();
    let s = (e && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? (_a3 = this.pivotResultColsService.getPivotResultCols()) == null ? void 0 : _a3.list : i) ?? [];
    t && (s = s.concat(t)), this.colsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? s : s.filter((o) => o.isVisible() || o.isRowGroupActive());
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPassQuickFilter(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassQuickFilterMatcher(t, e) : this.quickFilterParts.every((i) => t ? this.doesRowPassQuickFilterCache(e, i) : this.doesRowPassQuickFilterNoCache(e, i));
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  setQuickFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseQuickFilter(e) {
    return E(e) ? Q(this.gos) ? e.toUpperCase() : (F("Quick filtering only works with the Client-Side Row Model"), null) : null;
  }
  setQuickFilter(e) {
    if (e != null && typeof e != "string") {
      F(`Grid option quickFilterText only supports string inputs, received: ${typeof e}`);
      return;
    }
    const t = this.parseQuickFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  setQuickFilterParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), i = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, i && (this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  onQuickFilterColumnConfigChanged() {
    this.refreshQuickFilterCols(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.dispatchLocalEvent({ type: "quickFilterChanged" });
  }
  doesRowPassQuickFilterNoCache(e, t) {
    return this.colsForQuickFilter.some((i) => {
      const s = this.getQuickFilterTextForColumn(i, e);
      return E(s) && s.indexOf(t) >= 0;
    });
  }
  doesRowPassQuickFilterCache(e, t) {
    return this.checkGenerateQuickFilterAggregateText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassQuickFilterMatcher(e, t) {
    let i;
    e ? (this.checkGenerateQuickFilterAggregateText(t), i = t.quickFilterAggregateText) : i = this.getQuickFilterAggregateText(t);
    const { quickFilterParts: s, matcher: o } = this;
    return o(s, i);
  }
  checkGenerateQuickFilterAggregateText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e));
  }
  getQuickFilterTextForColumn(e, t) {
    let i = this.valueService.getValue(e, t, true);
    const s = e.getColDef();
    if (s.getQuickFilterText) {
      const o = this.gos.addGridCommonParams({ value: i, node: t, data: t.data, column: e, colDef: s });
      i = s.getQuickFilterText(o);
    }
    return E(i) ? i.toString().toUpperCase() : null;
  }
  getQuickFilterAggregateText(e) {
    const t = [];
    return this.colsForQuickFilter.forEach((i) => {
      const s = this.getQuickFilterTextForColumn(i, e);
      E(s) && t.push(s);
    }), t.join(`
`);
  }
}, bo = { version: G, moduleName: "@ag-grid-community/filter-core", beans: [Uc] }, _u = { version: G, moduleName: "@ag-grid-community/filter-api", apiFunctions: { isAnyFilterPresent: Tu, onFilterChanged: Iu }, dependantModules: [bo] }, Po = { version: G, moduleName: "@ag-grid-community/column-filter", beans: [Au], dependantModules: [bo] }, Uu = { version: G, moduleName: "@ag-grid-community/column-filter-api", apiFunctions: { isColumnFilterPresent: wu, getFilterInstance: yu, getColumnFilterInstance: Ru, destroyFilter: Fu, setFilterModel: bu, getFilterModel: Pu, getColumnFilterModel: Eu, setColumnFilterModel: Du, showColumnFilter: Mu }, dependantModules: [Po, _u] }, Nn = { version: G, moduleName: "@ag-grid-community/floating-filter-core", controllers: [{ name: "headerFilterCell", classImp: Su }], dependantModules: [Po] }, Ku = { version: G, moduleName: "@ag-grid-community/read-only-floating-filter", userComponents: [{ name: "agReadOnlyFloatingFilter", classImp: Lu }], dependantModules: [Nn] }, $u = { version: G, moduleName: "@ag-grid-community/simple-filter", dependantModules: [Po], userComponents: [{ name: "agTextColumnFilter", classImp: uu }, { name: "agNumberColumnFilter", classImp: cu }, { name: "agDateColumnFilter", classImp: gu }, { name: "agDateInput", classImp: Gu }] }, ju = { version: G, moduleName: "@ag-grid-community/simple-floating-filter", dependantModules: [$u, Nn], userComponents: [{ name: "agTextColumnFloatingFilter", classImp: Nu }, { name: "agNumberColumnFloatingFilter", classImp: Hu }, { name: "agDateColumnFloatingFilter", classImp: Ou }] }, Vn = { version: G, moduleName: "@ag-grid-community/quick-filter-core", beans: [zu], dependantModules: [bo] }, qu = { version: G, moduleName: "@ag-grid-community/quick-filter-api", apiFunctions: { isQuickFilterPresent: Vu, getQuickFilter: Bu, resetQuickFilter: Wu }, dependantModules: [Vn] }, Yu = { version: G, moduleName: "@ag-grid-community/quick-filter", dependantModules: [Vn, qu] }, Qu = { version: G, moduleName: "@ag-grid-community/filter", dependantModules: [ju, Ku, Yu, Uu] }, Ks = ((e) => (e.COLUMN_GROUP = "group", e.COLUMN = "column", e.FLOATING_FILTER = "filter", e))(Ks || {}), Xu = class extends R {
  constructor() {
    super(...arguments), this.beanName = "headerNavigationService", this.currentHeaderRowWithoutSpan = -1;
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.headerPositionUtils = e.headerPositionUtils, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.visibleColService = e.visibleColsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (t) => {
      this.gridBodyCon = t.gridBodyCtrl;
    });
    const e = re(this.gos);
    this.addManagedElementListeners(e, { mousedown: () => this.setCurrentHeaderRowWithoutSpan(-1) });
  }
  getHeaderRowCount() {
    var _a3;
    return ((_a3 = this.ctrlsService.getHeaderRowContainerCtrl()) == null ? void 0 : _a3.getRowCount()) ?? 0;
  }
  getHeaderPositionForColumn(e, t) {
    var _a3;
    let i;
    if (typeof e == "string" ? (i = this.columnModel.getCol(e), i || (i = this.visibleColService.getColumnGroup(e))) : i = e, !i) return null;
    const o = (_a3 = this.ctrlsService.getHeaderRowContainerCtrl()) == null ? void 0 : _a3.getAllCtrls(), r = N(o || []).getType() === "filter", n = this.getHeaderRowCount() - 1;
    let l = -1, a = i;
    for (; a; ) l++, a = a.getParent();
    let c = l;
    return t && r && c === n - 1 && c++, c === -1 ? null : { headerRowIndex: c, column: i };
  }
  navigateVertically(e, t, i) {
    if (t || (t = this.focusService.getFocusedHeader()), !t) return false;
    const { headerRowIndex: s } = t, o = t.column, r = this.getHeaderRowCount(), n = e === 0;
    let { headerRowIndex: l, column: a, headerRowIndexWithoutSpan: c } = n ? this.headerPositionUtils.getColumnVisibleParent(o, s) : this.headerPositionUtils.getColumnVisibleChild(o, s), u = false;
    return l < 0 && (l = 0, a = o, u = true), l >= r ? (l = -1, this.setCurrentHeaderRowWithoutSpan(-1)) : c !== void 0 && (this.currentHeaderRowWithoutSpan = c), !u && !a ? false : this.focusService.focusHeaderPosition({ headerPosition: { headerRowIndex: l, column: a }, allowUserOverride: true, event: i });
  }
  setCurrentHeaderRowWithoutSpan(e) {
    this.currentHeaderRowWithoutSpan = e;
  }
  navigateHorizontally(e, t = false, i) {
    const s = this.focusService.getFocusedHeader(), o = e === 2, r = this.gos.get("enableRtl");
    let n, l;
    if (this.currentHeaderRowWithoutSpan !== -1 ? s.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = s.headerRowIndex, o !== r ? (l = "Before", n = this.headerPositionUtils.findHeader(s, l)) : (l = "After", n = this.headerPositionUtils.findHeader(s, l)), n || !t) return this.focusService.focusHeaderPosition({ headerPosition: n, direction: l, fromTab: t, allowUserOverride: true, event: i });
    if (t) {
      const a = this.gos.getCallback("tabToNextHeader");
      if (a) return this.focusService.focusHeaderPositionFromUserFunc({ userFunc: a, headerPosition: n, direction: l });
    }
    return this.focusNextHeaderRow(s, l, i);
  }
  focusNextHeaderRow(e, t, i) {
    const s = e.headerRowIndex;
    let o = null, r;
    if (t === "Before" ? s > 0 && (r = s - 1, this.currentHeaderRowWithoutSpan -= 1, o = this.headerPositionUtils.findColAtEdgeForHeaderRow(r, "end")) : (r = s + 1, this.currentHeaderRowWithoutSpan < this.getHeaderRowCount() ? this.currentHeaderRowWithoutSpan += 1 : this.setCurrentHeaderRowWithoutSpan(-1), o = this.headerPositionUtils.findColAtEdgeForHeaderRow(r, "start")), !o) return false;
    const { column: n, headerRowIndex: l } = this.headerPositionUtils.getHeaderIndexToFocus(o.column, o == null ? void 0 : o.headerRowIndex);
    return this.focusService.focusHeaderPosition({ headerPosition: { column: n, headerRowIndex: l }, direction: t, fromTab: true, allowUserOverride: true, event: i });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned()) return;
    let i;
    if (ae(e)) {
      const s = e.getDisplayedLeafColumns();
      i = t === "Before" ? N(s) : s[0];
    } else i = e;
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(i);
  }
}, Ju = class extends R {
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.headerNavigationService = e.headerNavigationService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService, this.filterManager = e.filterManager, this.menuService = e.menuService;
  }
  setComp(e, t, i) {
    this.comp = e, this.eGui = t, this.createManagedBean(new At(i, { onTabKeyDown: this.onTabKeyDown.bind(this), handleKeyDown: this.handleKeyDown.bind(this), onFocusOut: this.onFocusOut.bind(this) })), this.addManagedEventListeners({ columnPivotModeChanged: this.onPivotModeChanged.bind(this), displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this) }), this.onPivotModeChanged(), this.setupHeaderHeight();
    const s = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: s }), this.mockContextMenuForIPad(s), this.ctrlsService.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListeners(["headerHeight", "pivotHeaderHeight", "groupHeaderHeight", "pivotGroupHeaderHeight", "floatingFiltersHeight"], e), this.addManagedEventListeners({ displayedColumnsChanged: e, columnHeaderHeightChanged: e, columnGroupHeaderHeightChanged: () => this.animationFrameService.requestAnimationFrame(() => e()), gridStylesChanged: e, advancedFilterEnabledChanged: e });
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    var _a3;
    const { columnModel: e } = this;
    let t = 0;
    const i = this.columnModel.getGroupRowsHeight().reduce((r, n) => r + n, 0), s = this.columnModel.getColumnHeaderRowHeight();
    if (((_a3 = this.filterManager) == null ? void 0 : _a3.hasFloatingFilters()) && (t += e.getFloatingFiltersHeight()), t += i, t += s, this.headerHeight === t) return;
    this.headerHeight = t;
    const o = `${t + 1}px`;
    this.comp.setHeightAndMinHeight(o), this.eventService.dispatchEvent({ type: "headerHeightChanged" });
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e);
  }
  onDisplayedColumnsChanged() {
    const t = this.visibleColsService.getAllCols().some((i) => i.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", t);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), i = e.shiftKey, s = i !== t ? 2 : 3;
    (this.headerNavigationService.navigateHorizontally(s, true, e) || !i && this.focusService.focusOverlay(false) || this.focusService.focusNextGridCoreContainer(i, true)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    switch (e.key) {
      case y.LEFT:
        t = 2;
      case y.RIGHT: {
        E(t) || (t = 3), this.headerNavigationService.navigateHorizontally(t, false, e) && e.preventDefault();
        break;
      }
      case y.UP:
        t = 0;
      case y.DOWN: {
        E(t) || (t = 1), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e;
    !t && this.eGui.contains(te(this.gos)) || this.eGui.contains(t) || this.focusService.clearFocusedHeader();
  }
  onHeaderContextMenu(e, t, i) {
    var _a3;
    if (!e && !i || !this.menuService.isHeaderContextMenuEnabled()) return;
    const { target: s } = e ?? t;
    (s === this.eGui || s === ((_a3 = this.ctrlsService.getHeaderRowContainerCtrl()) == null ? void 0 : _a3.getViewportElement())) && this.menuService.showHeaderContextMenu(void 0, e, i);
  }
  mockContextMenuForIPad(e) {
    if (!pt()) return;
    const t = new ct(this.eGui), i = (s) => {
      e(void 0, s.touchStart, s.touchEvent);
    };
    this.addManagedListeners(t, { longTap: i }), this.addDestroyFunc(() => t.destroy());
  }
}, Eo = class extends R {
  constructor(e, t = false) {
    super(), this.callback = e, this.addSpacer = t;
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({ columnContainerWidthChanged: e, displayedColumnsChanged: e, leftPinnedWidthChanged: e }), this.addSpacer && this.addManagedEventListeners({ rightPinnedWidthChanged: e, scrollVisibilityChanged: e, scrollbarWidthChanged: e }), this.setWidth();
  }
  setWidth() {
    const e = he(this.gos, "print"), t = this.visibleColsService.getBodyContainerWidth(), i = this.visibleColsService.getColsLeftWidth(), s = this.visibleColsService.getDisplayedColumnsRightWidth();
    let o;
    e ? o = t + i + s : (o = t, this.addSpacer && (this.gos.get("enableRtl") ? i : s) === 0 && this.scrollVisibleService.isVerticalScrollShowing() && (o += this.scrollVisibleService.getScrollbarWidth())), this.callback(o);
  }
}, Zu = class extends R {
  constructor(e) {
    super(), this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
  }
  wireBeans(e) {
    this.funcColsService = e.funcColsService;
  }
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly")) return;
    const t = e.dragItem.columns;
    t && t.forEach((i) => {
      i.isPrimary() && (i.isAnyFunctionActive() || (i.isAllowValue() ? this.columnsToAggregate.push(i) : i.isAllowRowGroup() ? this.columnsToGroup.push(i) : i.isAllowPivot() && this.columnsToPivot.push(i)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  onDragging(e) {
  }
  onDragStop(e) {
    this.columnsToAggregate.length > 0 && this.funcColsService.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.funcColsService.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.funcColsService.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};
function Bn(e) {
  const { isFromHeader: t, fromLeft: i, xPosition: s, fromEnter: o, fakeEvent: r, pinned: n, gos: l, columnModel: a, columnMoveService: c, visibleColsService: u } = e;
  let { allMovingColumns: d } = e;
  if (t) {
    const x = [];
    d.forEach((M) => {
      var _a3;
      let P = null, A = M.getParent();
      for (; A != null && A.getDisplayedLeafColumns().length === 1; ) P = A, A = A.getParent();
      P != null ? (!!((_a3 = P.getColGroupDef()) == null ? void 0 : _a3.marryChildren) ? P.getProvidedColumnGroup().getLeafColumns() : P.getLeafColumns()).forEach((L) => {
        x.includes(L) || x.push(L);
      }) : x.includes(M) || x.push(M);
    }), d = x;
  }
  const h = d.slice();
  a.sortColsLikeCols(h);
  const g = sd({ movingCols: h, draggingRight: i, xPosition: s, pinned: n, gos: l, columnModel: a, visibleColsService: u }), m = ed(h, a);
  if (g.length === 0) return;
  const C = g[0];
  let f = m !== null && !o;
  if (t && (f = m !== null), f && !r && (!i && C >= m || i && C <= m)) return;
  const v = u.getAllCols(), w = [];
  let S = null;
  for (let x = 0; x < g.length; x++) {
    const M = g[x], P = c.getProposedColumnOrder(h, M);
    if (!c.doesOrderPassRules(P)) continue;
    const A = P.filter((T) => v.includes(T));
    if (S === null) S = A;
    else if (!gt(A, S)) break;
    const I = td(P);
    w.push({ move: M, fragCount: I });
  }
  if (w.length === 0) return;
  w.sort((x, M) => x.fragCount - M.fragCount);
  const b = w[0].move;
  if (!(b > a.getCols().length - d.length)) return { columns: d, toIndex: b };
}
function Do(e) {
  const { columns: t, toIndex: i } = Bn(e) || {}, { finished: s, columnMoveService: o } = e;
  return !t || i == null ? null : (o.moveColumns(t, i, "uiColumnMoved", s), s ? null : { columns: t, toIndex: i });
}
function ed(e, t) {
  const i = t.getCols(), s = Ul(e.map((a) => i.indexOf(a))), o = s[0];
  return N(s) - o !== s.length - 1 ? null : o;
}
function td(e) {
  function t(s) {
    const o = [];
    let r = s.getOriginalParent();
    for (; r != null; ) o.push(r), r = r.getOriginalParent();
    return o;
  }
  let i = 0;
  for (let s = 0; s < e.length - 1; s++) {
    let o = t(e[s]), r = t(e[s + 1]);
    [o, r] = o.length > r.length ? [o, r] : [r, o], o.forEach((n) => {
      r.indexOf(n) === -1 && i++;
    });
  }
  return i;
}
function id(e, t) {
  switch (t) {
    case "left":
      return e.getLeftCols();
    case "right":
      return e.getRightCols();
    default:
      return e.getCenterCols();
  }
}
function sd(e) {
  const { movingCols: t, draggingRight: i, xPosition: s, pinned: o, gos: r, columnModel: n, visibleColsService: l } = e;
  if (r.get("suppressMovableColumns") || t.some((S) => S.getColDef().suppressMovable)) return [];
  const c = id(l, o), u = n.getCols(), d = c.filter((S) => Rt(t, S)), h = c.filter((S) => !Rt(t, S)), g = u.filter((S) => !Rt(t, S));
  let m = 0, C = s;
  if (i) {
    let S = 0;
    d.forEach((b) => S += b.getActualWidth()), C -= S;
  }
  if (C > 0) {
    for (let S = 0; S < h.length; S++) {
      const b = h[S];
      if (C -= b.getActualWidth(), C < 0) break;
      m++;
    }
    i && m++;
  }
  let f;
  if (m > 0) {
    const S = h[m - 1];
    f = g.indexOf(S) + 1;
  } else f = g.indexOf(h[0]), f === -1 && (f = 0);
  const v = [f], w = (S, b) => S - b;
  if (i) {
    let S = f + 1;
    const b = u.length - 1;
    for (; S <= b; ) v.push(S), S++;
    v.sort(w);
  } else {
    let S = f;
    const b = u.length - 1;
    let x = u[S];
    for (; S <= b && c.indexOf(x) < 0; ) S++, v.push(S), x = u[S];
    S = f - 1;
    const M = 0;
    for (; S >= M; ) v.push(S), S--;
    v.sort(w).reverse();
  }
  return v;
}
function es(e) {
  var _a3;
  const { pinned: t, fromKeyboard: i, gos: s, ctrlsService: o, useHeaderRow: r, skipScrollPadding: n } = e;
  let l = (_a3 = o.getHeaderRowContainerCtrl(t)) == null ? void 0 : _a3.getViewportElement(), { x: a } = e;
  return l ? (i && (a -= l.getBoundingClientRect().left), s.get("enableRtl") && (r && (l = l.querySelector(".ag-header-row")), a = l.clientWidth - a), t == null && !n && (a += o.get("center").getCenterViewportScrollLeft()), a) : 0;
}
function Bt(e, t) {
  for (const i of e) i.setMoving(t, "uiColumnMoved");
}
var or = 7, $s = 100, Di = $s / 2, od = 5, rd = 100, nd = class extends R {
  constructor(e) {
    super(), this.needToMoveLeft = false, this.needToMoveRight = false, this.lastMovedInfo = null, this.pinned = e, this.isCenterContainer = !E(e);
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnMoveService = e.columnMoveService, this.dragAndDropService = e.dragAndDropService, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    var _a3;
    const e = ((_a3 = this.lastDraggingEvent) == null ? void 0 : _a3.dragItem.columns) ?? [];
    for (const t of e) {
      const i = t.getPinned();
      if (t.getColDef().lockPinned) {
        if (i == this.pinned) return "move";
        continue;
      }
      if (i === this.pinned || !this.pinned) return "move";
      if (!i && this.pinned) return "pinned";
    }
    return "notAllowed";
  }
  onDragEnter(e) {
    const t = e.dragItem.columns;
    if (e.dragSource.type === 0) this.setColumnsVisible(t, true, "uiColumnDragged");
    else {
      const s = e.dragItem.visibleState, o = (t || []).filter((r) => s[r.getId()]);
      this.setColumnsVisible(o, true, "uiColumnDragged");
    }
    this.gos.get("suppressMoveWhenColumnDragging") || this.attemptToPinColumns(t, this.pinned), this.onDragging(e, true, true);
  }
  onDragging(e = this.lastDraggingEvent, t = false, i = false, s = false) {
    const o = this.gos.get("suppressMoveWhenColumnDragging");
    if (s && !o) {
      this.finishColumnMoving();
      return;
    }
    if (this.lastDraggingEvent = e, !e || !s && V(e.hDirection)) return;
    const { pinned: r, gos: n, ctrlsService: l } = this, a = es({ x: e.x, pinned: r, gos: n, ctrlsService: l });
    t || this.checkCenterForScrolling(a), o ? this.handleColumnDragWhileSuppressingMovement(e, t, i, a, s) : this.handleColumnDragWhileAllowingMovement(e, t, i, a, s);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.clearHighlighted(), this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, false, true, true), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted(), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, i) {
    if (!e) return;
    const s = e.filter((o) => !o.getColDef().lockVisible);
    this.columnModel.setColsVisible(s, t, i);
  }
  finishColumnMoving() {
    if (this.clearHighlighted(), !this.lastMovedInfo) return;
    const { columns: e, toIndex: t } = this.lastMovedInfo;
    this.columnMoveService.moveColumns(e, t, "uiColumnMoved", true);
  }
  handleColumnDragWhileSuppressingMovement(e, t, i, s, o) {
    const r = this.getAllMovingColumns(e, true);
    if (o) {
      const n = this.isAttemptingToPin(r);
      n && this.attemptToPinColumns(r, void 0, true);
      const { fromLeft: l, xPosition: a } = this.getNormalisedXPositionInfo(r, n) || {};
      if (l == null || a == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({ allMovingColumns: r, xPosition: a, fromEnter: t, fakeEvent: i, fromLeft: l });
    } else {
      if (!this.dragAndDropService.isDropZoneWithinThisGrid(e)) return;
      this.highlightHoveredColumn(r, s);
    }
  }
  handleColumnDragWhileAllowingMovement(e, t, i, s, o) {
    const r = this.getAllMovingColumns(e), n = this.normaliseDirection(e.hDirection) === 1, l = e.dragSource.type === 1, a = this.getMoveColumnParams({ allMovingColumns: r, isFromHeader: l, xPosition: s, fromLeft: n, fromEnter: t, fakeEvent: i }), c = Do({ ...a, finished: o });
    c && (this.lastMovedInfo = c);
  }
  getAllMovingColumns(e, t = false) {
    const i = e.dragSource.getDragItem();
    let s = null;
    t ? (s = i.columnsInSplit, s || (s = i.columns)) : s = i.columns;
    const o = (r) => r.getColDef().lockPinned ? r.getPinned() == this.pinned : true;
    return s ? s.filter(o) : [];
  }
  getMoveColumnParams(e) {
    const { allMovingColumns: t, isFromHeader: i, xPosition: s, fromLeft: o, fromEnter: r, fakeEvent: n } = e, { pinned: l, gos: a, columnModel: c, columnMoveService: u, visibleColsService: d } = this;
    return { allMovingColumns: t, isFromHeader: i, fromLeft: o, xPosition: s, pinned: l, fromEnter: r, fakeEvent: n, gos: a, columnModel: c, columnMoveService: u, visibleColsService: d };
  }
  findFirstAndLastMovingColumns(e) {
    const t = e.length;
    let i, s;
    for (let o = 0; o <= t; o++) {
      if (!i) {
        const r = e[o];
        r.getLeft() != null && (i = r);
      }
      if (!s) {
        const r = e[t - 1 - o];
        r.getLeft() != null && (s = r);
      }
      if (i && s) break;
    }
    return { firstMovingCol: i, lastMovingCol: s };
  }
  highlightHoveredColumn(e, t) {
    var _a3;
    const { gos: i, columnModel: s } = this, o = i.get("enableRtl"), r = s.getCols().filter((u) => u.isVisible() && u.getPinned() === this.pinned);
    let n = null, l = null, a = null;
    for (const u of r) {
      if (l = u.getActualWidth(), n = this.getNormalisedColumnLeft(u, 0, o), n != null) {
        const d = n + l;
        if (n <= t && d >= t) {
          a = u;
          break;
        }
      }
      n = null, l = null;
    }
    if (a) e.indexOf(a) !== -1 && (a = null);
    else {
      for (let u = r.length - 1; u >= 0; u--) {
        const d = r[u], h = r[u].getParent();
        if (!h) {
          a = d;
          break;
        }
        const g = h == null ? void 0 : h.getDisplayedLeafColumns();
        if (g.length) {
          a = N(g);
          break;
        }
      }
      if (!a) return;
      n = this.getNormalisedColumnLeft(a, 0, o), l = a.getActualWidth();
    }
    if (((_a3 = this.lastHighlightedColumn) == null ? void 0 : _a3.column) !== a && this.clearHighlighted(), a == null || n == null || l == null) return;
    let c;
    t - n < l / 2 !== o ? c = 0 : c = 1, a.setHighlighted(c), this.lastHighlightedColumn = { column: a, position: c };
  }
  getNormalisedXPositionInfo(e, t) {
    const { gos: i, visibleColsService: s } = this, o = i.get("enableRtl"), { firstMovingCol: r, column: n, position: l } = this.getColumnMoveAndTargetInfo(e, t, o);
    if (!r || !n || l == null) return;
    const a = s.getAllCols(), c = a.indexOf(r), u = a.indexOf(n), d = l === 0 !== o, h = c < u || c === u && !d;
    let g = 0;
    if (d ? h && (g -= 1) : h || (g += 1), u + g === c) return;
    const m = a[u + g];
    if (!m) return;
    const C = this.getNormalisedColumnLeft(m, 20, o);
    return { fromLeft: h, xPosition: C };
  }
  getColumnMoveAndTargetInfo(e, t, i) {
    const s = this.lastHighlightedColumn || {}, { firstMovingCol: o, lastMovingCol: r } = this.findFirstAndLastMovingColumns(e);
    if (!o || !r || s.column || !t) return { firstMovingCol: o, ...s };
    const l = this.getPinDirection() === "left";
    return { firstMovingCol: o, position: l ? 1 : 0, column: l !== i ? o : r };
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl")) switch (e) {
      case 0:
        return 1;
      case 1:
        return 0;
    }
    return e;
  }
  getNormalisedColumnLeft(e, t, i) {
    const { gos: s, ctrlsService: o } = this, r = e.getLeft();
    if (r == null) return null;
    const n = e.getActualWidth();
    return es({ x: i ? r + n - t : r + t, pinned: e.getPinned(), useHeaderRow: i, skipScrollPadding: true, gos: s, ctrlsService: o });
  }
  isAttemptingToPin(e) {
    const t = this.needToMoveLeft || this.needToMoveRight, i = this.failedMoveAttempts > or;
    return t && i || e.some((s) => s.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(e) {
    const { allMovingColumns: t, xPosition: i, fromEnter: s, fakeEvent: o, fromLeft: r } = e, n = this.getMoveColumnParams({ allMovingColumns: t, isFromHeader: true, xPosition: i, fromLeft: r, fromEnter: s, fakeEvent: o }), { columns: l, toIndex: a } = Bn(n) || {};
    l && a != null && (this.lastMovedInfo = { columns: l, toIndex: a }), this.finishColumnMoving();
  }
  clearHighlighted() {
    this.lastHighlightedColumn && (this.lastHighlightedColumn.column.setHighlighted(null), this.lastHighlightedColumn = null);
  }
  checkCenterForScrolling(e) {
    if (!this.isCenterContainer) return;
    const t = this.ctrlsService.get("center"), i = t.getCenterViewportScrollLeft(), s = i + t.getCenterWidth();
    this.gos.get("enableRtl") ? (this.needToMoveRight = e < i + Di, this.needToMoveLeft = e > s - Di) : (this.needToMoveLeft = e < i + Di, this.needToMoveRight = e > s - Di), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
  }
  ensureIntervalStarted() {
    var _a3;
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), rd), (_a3 = this.dragAndDropService.getDragAndDropImageComponent()) == null ? void 0 : _a3.setIcon(this.needToMoveLeft ? "left" : "right", true));
  }
  ensureIntervalCleared() {
    var _a3;
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.failedMoveAttempts = 0, (_a3 = this.dragAndDropService.getDragAndDropImageComponent()) == null ? void 0 : _a3.setIcon(this.getIconName()));
  }
  moveInterval() {
    var _a3, _b;
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * od, e > $s && (e = $s);
    let t = null;
    const i = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft ? t = i.scrollHorizontally(-e) : this.needToMoveRight && (t = i.scrollHorizontally(e)), t !== 0) this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      if (this.failedMoveAttempts++, this.failedMoveAttempts <= or + 1) return;
      if ((_a3 = this.dragAndDropService.getDragAndDropImageComponent()) == null ? void 0 : _a3.setIcon("pinned"), !this.gos.get("suppressMoveWhenColumnDragging")) {
        const s = (_b = this.lastDraggingEvent) == null ? void 0 : _b.dragItem.columns;
        this.attemptToPinColumns(s, void 0, true);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left") return "left";
    if (this.needToMoveRight || this.pinned === "right") return "right";
  }
  attemptToPinColumns(e, t, i = false) {
    const s = (e || []).filter((o) => !o.getColDef().lockPinned);
    return s.length ? (i && (t = this.getPinDirection()), this.columnModel.setColsPinned(s, t, "uiColumnDragged"), i && this.dragAndDropService.nudge(), s.length) : 0;
  }
  destroy() {
    super.destroy(), this.lastDraggingEvent = null, this.clearHighlighted(), this.lastMovedInfo = null;
  }
}, ld = class extends R {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.columnModel = e.columnModel, this.ctrlsService = e.ctrlsService;
  }
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [[e.gridBodyCtrl.getBodyViewportElement(), e.left.getContainerElement()], [e.bottomLeft.getContainerElement()], [e.topLeft.getContainerElement()]];
          break;
        case "right":
          this.eSecondaryContainers = [[e.gridBodyCtrl.getBodyViewportElement(), e.right.getContainerElement()], [e.bottomRight.getContainerElement()], [e.topRight.getContainerElement()]];
          break;
        default:
          this.eSecondaryContainers = [[e.gridBodyCtrl.getBodyViewportElement(), e.center.getViewportElement()], [e.bottomCenter.getViewportElement()], [e.topCenter.getViewportElement()]];
          break;
      }
    }), this.moveColumnFeature = this.createManagedBean(new nd(this.pinned)), this.bodyDropPivotTarget = this.createManagedBean(new Zu(this.pinned)), this.dragAndDropService.addDropTarget(this), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(this));
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  isDropColumnInPivotMode(e) {
    return this.columnModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
}, ad = class extends R {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.pinnedWidthService = e.pinnedWidthService, this.ctrlsService = e.ctrlsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, i, s, o) {
    super(), this.pinned = e, this.column = t, this.eResize = i, this.comp = s, this.ctrl = o;
  }
  postConstruct() {
    const e = [];
    let t, i;
    const s = () => {
      if (ee(this.eResize, t), !t) return;
      const n = this.horizontalResizeService.addResizeBar({ eResizeBar: this.eResize, onResizeStart: this.onResizeStart.bind(this), onResizing: this.onResizing.bind(this, false), onResizeEnd: this.onResizing.bind(this, true) });
      if (e.push(n), i) {
        const l = this.gos.get("skipHeaderOnAutoSize"), a = () => {
          this.columnAutosizeService.autoSizeColumn(this.column, "uiColumnResized", l);
        };
        this.eResize.addEventListener("dblclick", a);
        const c = new ct(this.eResize);
        c.addEventListener("doubleTap", a), e.push(() => {
          this.eResize.removeEventListener("dblclick", a), c.removeEventListener("doubleTap", a), c.destroy();
        });
      }
    }, o = () => {
      e.forEach((n) => n()), e.length = 0;
    }, r = () => {
      const n = this.column.isResizable(), l = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (n !== t || l !== i) && (t = n, i = l, o(), s());
    };
    r(), this.addDestroyFunc(o), this.ctrl.setRefreshFunction("resize", r);
  }
  onResizing(e, t) {
    const { column: i, lastResizeAmount: s, resizeStartWidth: o } = this, r = this.normaliseResizeAmount(t), n = o + r, l = [{ key: i, newWidth: n }];
    if (this.column.getPinned()) {
      const a = this.pinnedWidthService.getPinnedLeftWidth(), c = this.pinnedWidthService.getPinnedRightWidth(), u = yi(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (a + c + (r - s) > u) return;
    }
    this.lastResizeAmount = r, this.columnSizeService.setColumnWidths(l, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(false);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(true);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  normaliseResizeAmount(e) {
    let t = e;
    const i = this.pinned !== "left", s = this.pinned === "right";
    return this.gos.get("enableRtl") ? i && (t *= -1) : s && (t *= -1), t;
  }
}, cd = class extends R {
  constructor(e) {
    super(), this.cbSelectAllVisible = false, this.processingEventFromCheckbox = false, this.column = e;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(te(this.gos)) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new fo()), this.cbSelectAll.addCssClass("ag-header-select-all"), Ve(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedEventListeners({ newColumnsLoaded: this.onNewColumnsLoaded.bind(this), displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this), selectionChanged: this.onSelectionChanged.bind(this), paginationChanged: this.onSelectionChanged.bind(this), modelUpdated: this.onModelChanged.bind(this) }), this.addManagedListeners(this.cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) }), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onNewColumnsLoaded() {
    this.showOrHideSelectAll();
  }
  onDisplayedColumnsChanged() {
    this.isAlive() && this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox) return;
    this.processingEventFromCheckbox = true;
    const e = this.selectionService.getSelectAllState(this.isFilteredOnly(), this.isCurrentPageOnly());
    this.cbSelectAll.setValue(e);
    const t = this.selectionService.hasNodesToSelect(this.isFilteredOnly(), this.isCurrentPageOnly());
    this.cbSelectAll.setDisabled(!t), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = false;
  }
  refreshSelectAllLabel() {
    const e = this.localeService.getLocaleTextFunc(), i = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), s = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${s} (${i})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(e("ariaHeaderSelection", "Column with Header Selection")), this.headerCellCtrl.announceAriaDescription();
  }
  checkSelectionType(e) {
    return Ar(this.gos) ? true : (F(`${e} is only available if using 'multiRow' selection mode.`), false);
  }
  checkRightRowModelType(e) {
    return Q(this.gos) || it(this.gos) ? true : (F(`${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${this.rowModel.getType()}.`), false);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible) return;
    const e = this.cbSelectAll.getValue(), t = this.isFilteredOnly(), i = this.isCurrentPageOnly();
    let s = "uiSelectAll";
    i ? s = "uiSelectAllCurrentPage" : t && (s = "uiSelectAllFiltered");
    const o = { source: s, justFiltered: t, justCurrentPage: i };
    e ? this.selectionService.selectAllRowNodes(o) : this.selectionService.deselectAllRowNodes(o);
  }
  isCheckboxSelection() {
    const e = this.gos.get("rowSelection"), t = typeof e == "object" && _i(e) && vi(this.column), i = this.column.getColDef().headerCheckboxSelection;
    let s = false;
    return t ? s = true : typeof i == "function" ? s = i(this.gos.addGridCommonParams({ column: this.column, colDef: this.column.getColDef() })) : s = !!i, s && this.checkRightRowModelType(t ? "headerCheckbox" : "headerCheckboxSelection") && this.checkSelectionType(t ? "headerCheckbox" : "headerCheckboxSelection");
  }
  isFilteredOnly() {
    const e = this.gos.get("rowSelection");
    return typeof e == "object" ? e.mode === "multiRow" && e.selectAll === "filtered" : !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
  }
  isCurrentPageOnly() {
    const e = this.gos.get("rowSelection");
    return typeof e == "object" ? e.mode === "multiRow" && e.selectAll === "currentPage" : !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
  }
}, ud = class extends ls {
  constructor(e, t, i) {
    super(e, t, i), this.refreshFunctions = {}, this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map(), this.column = e;
  }
  setComp(e, t, i, s, o) {
    this.comp = e, o = Si(this, this.beans.context, o), this.setGui(t, o), this.updateState(), this.setupWidth(o), this.setupMovingCss(o), this.setupMenuClass(o), this.setupSortableClass(o), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight({ wrapperElement: s, checkMeasuringCallback: (n) => this.setRefreshFunction("measuring", n), compBean: o }), this.addColumnHoverListener(o), this.setupFilterClass(o), this.setupClassesFromColDef(), this.setupTooltip(o), this.addActiveHeaderMouseListeners(o), this.setupSelectAll(o), this.setupUserComp(o), this.refreshAria(), this.resizeFeature = o.createManagedBean(new ad(this.getPinned(), this.column, i, e, this)), o.createManagedBean(new Fo([this.column], t)), o.createManagedBean(new Ro(this.column, t, this.beans)), o.createManagedBean(new At(t, { shouldStopEventPropagation: (n) => this.shouldStopEventPropagation(n), onTabKeyDown: () => null, handleKeyDown: this.handleKeyDown.bind(this), onFocusIn: this.onFocusIn.bind(this), onFocusOut: this.onFocusOut.bind(this) })), this.addResizeAndMoveKeyboardListeners(o), o.addManagedPropertyListeners(["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"], () => this.refresh(o)), o.addManagedListeners(this.column, { colDefChanged: () => this.refresh(o) }), o.addManagedListeners(this.column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const r = () => this.checkDisplayName(o);
    o.addManagedEventListeners({ columnValueChanged: r, columnRowGroupChanged: r, columnPivotChanged: r, headerHeightChanged: this.onHeaderHeightChanged.bind(this) }), o.addDestroyFunc(() => {
      this.refreshFunctions = {}, this.selectAllFeature = null, this.dragSourceElement = void 0, this.userCompDetails = null, this.userHeaderClasses.clear(), this.ariaDescriptionProperties.clear(), this.clearComponent();
    });
  }
  resizeHeader(e, t) {
    if (!this.column.isResizable()) return;
    const i = this.column.getActualWidth(), s = this.column.getMinWidth(), o = this.column.getMaxWidth(), r = Math.min(Math.max(i + e, s), o);
    this.beans.columnSizeService.setColumnWidths([{ key: this.column, newWidth: r }], t, true, "uiColumnResized");
  }
  moveHeader(e) {
    const { eGui: t, beans: i, column: s, ctrlsService: o } = this, { gos: r, columnModel: n, columnMoveService: l, visibleColsService: a } = i, c = this.getPinned(), u = t.getBoundingClientRect().left, d = s.getActualWidth(), h = r.get("enableRtl"), m = es({ x: e === 0 !== h ? u - 20 : u + d + 20, pinned: c, fromKeyboard: true, gos: r, ctrlsService: o }), C = this.focusService.getFocusedHeader();
    Do({ allMovingColumns: [s], isFromHeader: true, fromLeft: e === 1, xPosition: m, pinned: c, fromEnter: false, fakeEvent: false, gos: r, columnModel: n, columnMoveService: l, visibleColsService: a, finished: true }), o.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(s, "auto"), (!this.isAlive() || this.beans.gos.get("ensureDomOrder")) && C && this.restoreFocus(C);
  }
  restoreFocus(e) {
    this.focusService.focusHeaderPosition({ headerPosition: { ...e, column: this.column } });
  }
  setupUserComp(e) {
    const t = this.lookupUserCompDetails(e);
    this.setCompDetails(t);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails(e) {
    const t = this.createParams(e), i = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(i, t);
  }
  createParams(e) {
    return this.gos.addGridCommonParams({ column: this.column, displayName: this.displayName, enableSorting: this.column.isSortable(), enableMenu: this.menuEnabled, enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column), enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(), showColumnMenu: (i) => {
      this.menuService.showColumnMenu({ column: this.column, buttonElement: i, positionBy: "button" });
    }, showColumnMenuAfterMouseClick: (i) => {
      this.menuService.showColumnMenu({ column: this.column, mouseEvent: i, positionBy: "mouse" });
    }, showFilter: (i) => {
      this.menuService.showFilterMenu({ column: this.column, buttonElement: i, containerType: "columnFilter", positionBy: "button" });
    }, progressSort: (i) => {
      this.beans.sortController.progressSort(this.column, !!i, "uiColumnSorted");
    }, setSort: (i, s) => {
      this.beans.sortController.setSortForColumn(this.column, i, !!s, "uiColumnSorted");
    }, eGridHeader: this.getGui(), setTooltip: (i, s) => {
      this.setupTooltip(e, i, s);
    } });
  }
  setupSelectAll(e) {
    this.selectAllFeature = e.createManagedBean(new cd(this.column)), this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e), e.key === y.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === y.ENTER && this.onEnterKeyDown(e), e.key === y.DOWN && e.altKey && this.showMenuOnKeyPress(e, false);
  }
  onEnterKeyDown(e) {
    if (e.ctrlKey || e.metaKey) this.showMenuOnKeyPress(e, true);
    else if (this.sortable) {
      const t = e.shiftKey;
      this.beans.sortController.progressSort(this.column, t, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, t) {
    const i = this.comp.getUserCompInstance();
    !i || !(i instanceof Ws) || i.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.focusService.setFocusedHeader(t, this.column), this.announceAriaDescription();
    }
    this.focusService.isKeyboardMode() && this.setActiveHeader(true);
  }
  onFocusOut(e) {
    this.getGui().contains(e.relatedTarget) || this.setActiveHeader(false);
  }
  setupTooltip(e, t, i) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const s = this.gos.get("tooltipShowMode") === "whenTruncated", o = this.eGui, r = this.column.getColDef();
    !i && s && !r.headerComponent && (i = () => {
      const a = o.querySelector(".ag-header-cell-text");
      return a ? a.scrollWidth > a.clientWidth : true;
    });
    const n = { getColumn: () => this.column, getColDef: () => this.column.getColDef(), getGui: () => o, getLocation: () => "header", getTooltipValue: () => t ?? this.column.getColDef().headerTooltip, shouldDisplayTooltip: i }, l = e.createManagedBean(new $t(n));
    this.setRefreshFunction("tooltip", () => l.refreshToolTip());
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), i = Tn(t, this.gos, this.column, null), s = this.userHeaderClasses;
      this.userHeaderClasses = new Set(i), i.forEach((o) => {
        s.has(o) ? s.delete(o) : this.comp.addOrRemoveCssClass(o, true);
      }), s.forEach((o) => this.comp.addOrRemoveCssClass(o, false));
    };
    this.setRefreshFunction("headerClasses", e), e();
  }
  setDragSource(e) {
    if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable) return;
    const { column: t, beans: i, displayName: s, dragAndDropService: o, gos: r } = this, { columnModel: n } = i;
    let l = !this.gos.get("suppressDragLeaveHidesColumns");
    const a = this.dragSource = { type: 1, eElement: e, getDefaultIconName: () => l ? "hide" : "notAllowed", getDragItem: () => this.createDragItem(t), dragItemName: s, onDragStarted: () => {
      l = !r.get("suppressDragLeaveHidesColumns"), Bt([t], true);
    }, onDragStopped: () => Bt([t], false), onDragCancelled: () => Bt([t], false), onGridEnter: (c) => {
      var _a3;
      if (l) {
        const u = ((_a3 = c == null ? void 0 : c.columns) == null ? void 0 : _a3.filter((d) => !d.getColDef().lockVisible)) || [];
        n.setColsVisible(u, true, "uiColumnMoved");
      }
    }, onGridExit: (c) => {
      var _a3;
      if (l) {
        const u = ((_a3 = c == null ? void 0 : c.columns) == null ? void 0 : _a3.filter((d) => !d.getColDef().lockVisible)) || [];
        n.setColsVisible(u, false, "uiColumnMoved");
      }
    } };
    o.addDragSource(a, true);
  }
  createDragItem(e) {
    const t = {};
    return t[e.getId()] = e.isVisible(), { columns: [e], visibleState: t };
  }
  updateState() {
    this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column), this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(e, t) {
    this.refreshFunctions[e] = t;
  }
  refresh(e) {
    this.updateState(), this.refreshHeaderComp(e), this.refreshAria(), Object.values(this.refreshFunctions).forEach((t) => t());
  }
  refreshHeaderComp(e) {
    const t = this.lookupUserCompDetails(e);
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == t.componentClass ? this.attemptHeaderCompRefresh(t.params) : false) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(t);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? false : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.columnNameService.getDisplayNameForColumn(this.column, "header", true);
  }
  checkDisplayName(e) {
    this.displayName !== this.calculateDisplayName() && this.refresh(e);
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  setupWidth(e) {
    const t = () => {
      const i = this.column.getActualWidth();
      this.comp.setWidth(`${i}px`);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupMovingCss(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    e.addManagedListeners(this.column, { movingChanged: t }), t();
  }
  setupMenuClass(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    e.addManagedListeners(this.column, { menuVisibleChanged: t }), t();
  }
  setupSortableClass(e) {
    const t = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    t(), this.setRefreshFunction("updateSortable", t), e.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(e) {
    const t = () => {
      const i = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", i), this.refreshAria();
    };
    e.addManagedListeners(this.column, { filterActiveChanged: t }), t();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.setRefreshFunction("wrapText", e);
  }
  onHeaderHighlightChanged() {
    const e = this.column.getHighlighted(), t = e === 0, i = e === 1;
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", t), this.comp.addOrRemoveCssClass("ag-header-highlight-after", i);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: i, beans: s } = this, o = this.beans.columnModel.getGroupRowsHeight(), r = o.reduce((d, h) => d += h, 0) === 0;
    if (i.addOrRemoveCssClass("ag-header-parent-hidden", r), !t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), i.addOrRemoveCssClass("ag-header-span-height", false), i.addOrRemoveCssClass("ag-header-span-total", false);
      return;
    }
    const { numberOfParents: n, isSpanningTotal: l } = this.column.getColumnGroupPaddingInfo();
    i.addOrRemoveCssClass("ag-header-span-height", n > 0);
    const { columnModel: a } = s, c = a.getColumnHeaderRowHeight();
    if (n === 0) {
      i.addOrRemoveCssClass("ag-header-span-total", false), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${c}px`);
      return;
    }
    i.addOrRemoveCssClass("ag-header-span-total", l);
    let u = 0;
    for (let d = 0; d < n; d++) u += o[o.length - 1 - d];
    e.style.setProperty("top", `${-u}px`), e.style.setProperty("height", `${c + u}px`);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const e = this.localeService.getLocaleTextFunc(), t = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(Ra(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort"));
    } else this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("filterButton", e("ariaFilterColumn", "Press CTRL ENTER to open filter"));
    } else this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.localeService.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    if (!this.eGui.contains(te(this.beans.gos))) return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((t, i) => t === "filter" ? -1 : i.charCodeAt(0) - t.charCodeAt(0)).map((t) => this.ariaDescriptionProperties.get(t)).join(". ");
    this.beans.ariaAnnouncementService.announceValue(e, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener(e) {
    const t = () => {
      if (!this.gos.get("columnHoverHighlight")) return;
      const i = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", i);
    };
    e.addManagedEventListeners({ columnHoverChanged: t }), t();
  }
  getColId() {
    return this.column.getColId();
  }
  addActiveHeaderMouseListeners(e) {
    const t = (o) => this.handleMouseOverChange(o.type === "mouseenter"), i = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column), s = (o) => this.handleContextMenuMouseEvent(o, void 0, this.column);
    e.addManagedListeners(this.getGui(), { mouseenter: t, mouseleave: t, click: i, contextmenu: s });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e), this.eventService.dispatchEvent({ type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave", column: this.column });
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return t instanceof Ws ? t.getAnchorElementForMenu(e) : this.getGui();
  }
  destroy() {
    super.destroy();
  }
}, dd = class extends R {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.autoWidthCalculator = e.autoWidthCalculator, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, i, s) {
    super(), this.eResize = t, this.comp = e, this.pinned = i, this.columnGroup = s;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(false);
      return;
    }
    const e = this.horizontalResizeService.addResizeBar({ eResizeBar: this.eResize, onResizeStart: this.onResizeStart.bind(this), onResizing: this.onResizing.bind(this, false), onResizeEnd: this.onResizing.bind(this, true) });
    if (this.addDestroyFunc(e), !this.gos.get("suppressAutoSize")) {
      const t = this.gos.get("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const i = [];
        this.columnGroup.getDisplayedLeafColumns().forEach((o) => {
          o.getColDef().suppressAutoSize || i.push(o.getColId());
        }), i.length > 0 && this.columnAutosizeService.autoSizeCols({ colKeys: i, skipHeader: t, stopAtGroup: this.columnGroup, source: "uiColumnResized" }), this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(e) {
    const t = this.getInitialValues(e);
    this.storeLocalValues(t), this.toggleColumnResizing(true);
  }
  onResizing(e, t, i = "uiColumnResized") {
    const s = this.normaliseDragChange(t), o = this.resizeStartWidth + s;
    this.resizeColumnsFromLocalValues(o, i, e);
  }
  getInitialValues(e) {
    const t = this.getColumnsToResize(), i = this.getInitialSizeOfColumns(t), s = this.getSizeRatiosOfColumns(t, i), o = { columnsToResize: t, resizeStartWidth: i, resizeRatios: s };
    let r = null;
    if (e && (r = this.visibleColsService.getGroupAtDirection(this.columnGroup, "After")), r) {
      const n = r.getDisplayedLeafColumns(), l = o.groupAfterColumns = n.filter((c) => c.isResizable()), a = o.groupAfterStartWidth = this.getInitialSizeOfColumns(l);
      o.groupAfterRatios = this.getSizeRatiosOfColumns(l, a);
    } else o.groupAfterColumns = void 0, o.groupAfterStartWidth = void 0, o.groupAfterRatios = void 0;
    return o;
  }
  storeLocalValues(e) {
    const { columnsToResize: t, resizeStartWidth: i, resizeRatios: s, groupAfterColumns: o, groupAfterStartWidth: r, groupAfterRatios: n } = e;
    this.resizeCols = t, this.resizeStartWidth = i, this.resizeRatios = s, this.resizeTakeFromCols = o, this.resizeTakeFromStartWidth = r, this.resizeTakeFromRatios = n;
  }
  clearLocalValues() {
    this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup), i = this.getInitialValues();
    t > i.resizeStartWidth && this.resizeColumns(i, t, e, true);
  }
  resizeColumnsFromLocalValues(e, t, i = true) {
    if (!this.resizeCols || !this.resizeRatios) return;
    const s = { columnsToResize: this.resizeCols, resizeStartWidth: this.resizeStartWidth, resizeRatios: this.resizeRatios, groupAfterColumns: this.resizeTakeFromCols ?? void 0, groupAfterStartWidth: this.resizeTakeFromStartWidth ?? void 0, groupAfterRatios: this.resizeTakeFromRatios ?? void 0 };
    this.resizeColumns(s, e, t, i);
  }
  resizeColumns(e, t, i, s = true) {
    const { columnsToResize: o, resizeStartWidth: r, resizeRatios: n, groupAfterColumns: l, groupAfterStartWidth: a, groupAfterRatios: c } = e, u = [];
    if (u.push({ columns: o, ratios: n, width: t }), l) {
      const d = t - r;
      u.push({ columns: l, ratios: c, width: a - d });
    }
    this.columnSizeService.resizeColumnSets({ resizeSets: u, finished: s, source: i }), s && this.toggleColumnResizing(false);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  getInitialSizeOfColumns(e) {
    return e.reduce((t, i) => t + i.getActualWidth(), 0);
  }
  getSizeRatiosOfColumns(e, t) {
    return e.map((i) => i.getActualWidth() / t);
  }
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.clearLocalValues();
  }
}, hd = class extends R {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, { displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this) }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
}, gd = class extends ls {
  constructor(e, t, i) {
    super(e, t, i), this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving()) this.removeDragSource();
      else if (!this.dragSource) {
        const s = this.getGui();
        this.setDragSource(s);
      }
    }, this.column = e;
  }
  setComp(e, t, i, s, o) {
    this.comp = e, o = Si(this, this.beans.context, o), this.setGui(t, o), this.displayName = this.beans.columnNameService.getDisplayNameForColumnGroup(this.column, "header"), this.addClasses(), this.setupMovingCss(o), this.setupExpandable(o), this.setupTooltip(o), this.setupAutoHeight({ wrapperElement: s, compBean: o }), this.setupUserComp(o), this.addHeaderMouseListeners(o), this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this)), this.refreshMaxHeaderHeight();
    const r = this.getParentRowCtrl().getPinned(), n = this.column.getProvidedColumnGroup().getLeafColumns();
    o.createManagedBean(new Fo(n, t)), o.createManagedBean(new Ro(this.column, t, this.beans)), o.createManagedBean(new hd(e, this.column)), this.resizeFeature = o.createManagedBean(new dd(e, i, r, this.column)), o.createManagedBean(new At(t, { shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this), onTabKeyDown: () => {
    }, handleKeyDown: this.handleKeyDown.bind(this), onFocusIn: this.onFocusIn.bind(this) })), this.addHighlightListeners(o, n), o.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners(o), o.addDestroyFunc(() => this.clearComponent());
  }
  refreshMaxHeaderHeight() {
    const { gos: e, comp: t } = this, i = e.get("groupHeaderHeight");
    i != null ? i === 0 ? t.setHeaderWrapperHidden(true) : t.setHeaderWrapperMaxHeight(i) : (t.setHeaderWrapperHidden(false), t.setHeaderWrapperMaxHeight(null));
  }
  addHighlightListeners(e, t) {
    if (this.beans.gos.get("suppressMoveWhenColumnDragging")) for (const i of t) e.addManagedListeners(i, { headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, i) });
  }
  onLeafColumnHighlightChanged(e) {
    const t = this.column.getDisplayedLeafColumns(), i = t[0] === e, s = N(t) === e;
    if (!i && !s) return;
    const o = e.getHighlighted(), r = !!this.getParentRowCtrl().findHeaderCellCtrl((a) => a.getColumnGroupChild().isMoving());
    let n = false, l = false;
    if (r) {
      const a = this.beans.gos.get("enableRtl"), c = o === 1, u = o === 0;
      i && (a ? l = c : n = u), s && (a ? n = u : l = c);
    }
    this.comp.addOrRemoveCssClass("ag-header-highlight-before", n), this.comp.addOrRemoveCssClass("ag-header-highlight-after", l);
  }
  getColumn() {
    return this.column;
  }
  resizeHeader(e, t) {
    if (!this.resizeFeature) return;
    const i = this.resizeFeature.getInitialValues(t);
    this.resizeFeature.resizeColumns(i, i.resizeStartWidth + e, "uiColumnResized", true);
  }
  moveHeader(e) {
    const { beans: t, eGui: i, column: s, ctrlsService: o } = this, { gos: r, columnModel: n, columnMoveService: l, visibleColsService: a } = t, c = r.get("enableRtl"), u = e === 0, d = this.getPinned(), h = i.getBoundingClientRect(), g = h.left, m = h.width, C = es({ x: u !== c ? g - 20 : g + m + 20, pinned: d, fromKeyboard: true, gos: r, ctrlsService: o }), f = s.getGroupId(), v = this.focusService.getFocusedHeader();
    Do({ allMovingColumns: this.column.getLeafColumns(), isFromHeader: true, fromLeft: e === 1, xPosition: C, pinned: d, fromEnter: false, fakeEvent: false, gos: r, columnModel: n, columnMoveService: l, visibleColsService: a, finished: true });
    const w = s.getDisplayedLeafColumns(), S = u ? w[0] : N(w);
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(S, "auto"), (!this.isAlive() || this.beans.gos.get("ensureDomOrder")) && v && this.restoreFocus(f, s, v);
  }
  restoreFocus(e, t, i) {
    const s = t.getLeafColumns();
    if (!s.length) return;
    const o = s[0].getParent();
    if (!o) return;
    const r = this.findGroupWidthId(o, e);
    r && this.focusService.focusHeaderPosition({ headerPosition: { ...i, column: r } });
  }
  findGroupWidthId(e, t) {
    for (; e; ) {
      if (e.getGroupId() === t) return e;
      e = e.getParent();
    }
    return null;
  }
  resizeLeafColumnsToFit(e) {
    this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e);
  }
  setupUserComp(e) {
    const t = this.gos.addGridCommonParams({ displayName: this.displayName, columnGroup: this.column, setExpanded: (s) => {
      this.beans.columnModel.setColumnGroupOpened(this.column.getProvidedColumnGroup(), s, "gridInitializing");
    }, setTooltip: (s, o) => {
      this.setupTooltip(e, s, o);
    } }), i = this.userComponentFactory.getHeaderGroupCompDetails(t);
    this.comp.setUserCompDetails(i);
  }
  addHeaderMouseListeners(e) {
    const t = (o) => this.handleMouseOverChange(o.type === "mouseenter"), i = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), s = (o) => this.handleContextMenuMouseEvent(o, void 0, this.column.getProvidedColumnGroup());
    e.addManagedListeners(this.getGui(), { mouseenter: t, mouseleave: t, click: i, contextmenu: s });
  }
  handleMouseOverChange(e) {
    this.eventService.dispatchEvent({ type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave", column: this.column.getProvidedColumnGroup() });
  }
  setupTooltip(e, t, i) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const s = this.column.getColGroupDef(), o = this.gos.get("tooltipShowMode") === "whenTruncated", r = this.eGui;
    !i && o && !(s == null ? void 0 : s.headerGroupComponent) && (i = () => {
      const l = r.querySelector(".ag-header-group-text");
      return l ? l.scrollWidth > l.clientWidth : true;
    });
    const n = { getColumn: () => this.column, getGui: () => r, getLocation: () => "headerGroup", getTooltipValue: () => t ?? (s && s.headerTooltip), shouldDisplayTooltip: i };
    s && (n.getColDef = () => s), e.createManagedBean(new $t(n));
  }
  setupExpandable(e) {
    const t = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const i = this.refreshExpanded.bind(this);
    e.addManagedListeners(t, { expandedChanged: i, expandableChanged: i });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  getColId() {
    return this.column.getUniqueId();
  }
  addClasses() {
    const e = this.column.getColGroupDef(), t = Tn(e, this.gos, null, this.column);
    this.column.isPadding() ? (t.push("ag-header-group-cell-no-group"), this.column.getLeafColumns().every((s) => s.isSpanHeaderHeight()) && t.push("ag-header-span-height")) : (t.push("ag-header-group-cell-with-group"), (e == null ? void 0 : e.wrapHeaderText) && t.push("ag-header-cell-wrap-text")), t.forEach((i) => this.comp.addOrRemoveCssClass(i, true));
  }
  setupMovingCss(e) {
    const i = this.column.getProvidedColumnGroup().getLeafColumns(), s = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    i.forEach((o) => {
      e.addManagedListeners(o, { movingChanged: s });
    }), s();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(t, this.column);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === y.ENTER) {
      const i = this.column, s = !i.isExpanded();
      this.beans.columnModel.setColumnGroupOpened(i.getProvidedColumnGroup(), s, "uiColumnExpanded");
    }
  }
  setDragSource(e) {
    if (!this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), !e)) return;
    const { beans: t, column: i, displayName: s, gos: o, dragAndDropService: r } = this, { columnModel: n } = t, l = i.getProvidedColumnGroup().getLeafColumns();
    let a = !o.get("suppressDragLeaveHidesColumns");
    const c = this.dragSource = { type: 1, eElement: e, getDefaultIconName: () => a ? "hide" : "notAllowed", dragItemName: s, getDragItem: () => this.getDragItemForGroup(i), onDragStarted: () => {
      a = !o.get("suppressDragLeaveHidesColumns"), Bt(l, true);
    }, onDragStopped: () => Bt(l, false), onDragCancelled: () => Bt(l, false), onGridEnter: (u) => {
      if (a) {
        const { columns: d = [], visibleState: h } = u ?? {}, g = d.filter((m) => !m.getColDef().lockVisible && (!h || h[m.getColId()]));
        n.setColsVisible(g, true, "uiColumnMoved");
      }
    }, onGridExit: (u) => {
      var _a3;
      if (a) {
        const d = ((_a3 = u == null ? void 0 : u.columns) == null ? void 0 : _a3.filter((h) => !h.getColDef().lockVisible)) || [];
        n.setColsVisible(d, false, "uiColumnMoved");
      }
    } };
    r.addDragSource(c, true);
  }
  getDragItemForGroup(e) {
    const t = e.getProvidedColumnGroup().getLeafColumns(), i = {};
    t.forEach((n) => i[n.getId()] = n.isVisible());
    const s = [];
    this.beans.visibleColsService.getAllCols().forEach((n) => {
      t.indexOf(n) >= 0 && (s.push(n), Fe(t, n));
    }), t.forEach((n) => s.push(n));
    const o = [], r = e.getLeafColumns();
    for (const n of s) r.indexOf(n) !== -1 && o.push(n);
    return { columns: s, columnsInSplit: o, visibleState: i };
  }
  isSuppressMoving() {
    let e = false;
    return this.column.getLeafColumns().forEach((i) => {
      (i.getColDef().suppressMovable || i.getColDef().lockPosition) && (e = true);
    }), e || this.gos.get("suppressMovableColumns");
  }
  destroy() {
    super.destroy();
  }
}, pd = 0, bs = class extends R {
  constructor(e, t, i) {
    super(), this.instanceId = pd++, this.rowIndex = e, this.pinned = t, this.type = i;
    const s = i == "group" ? "ag-header-row-column-group" : i == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${s}`;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.isPrintLayout = he(this.gos, "print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  areCellsRendered() {
    return this.comp ? this.getHeaderCellCtrls().every((e) => e.getGui() != null) : false;
  }
  setComp(e, t, i = true) {
    this.comp = e, t = Si(this, this.beans.context, t), i && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners(t);
  }
  getHeaderRowClass() {
    return this.headerRowClass;
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(e) {
    const t = this.onRowHeightChanged.bind(this);
    e.addManagedEventListeners({ columnResized: this.onColumnResized.bind(this), displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this), virtualColumnsChanged: (i) => this.onVirtualColumnsChanged(i.afterScroll), columnGroupHeaderHeightChanged: t, columnHeaderHeightChanged: t, gridStylesChanged: t, advancedFilterEnabledChanged: t }), e.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), e.addManagedPropertyListener("ensureDomOrder", (i) => this.isEnsureDomOrder = i.currentValue), e.addManagedPropertyListeners(["headerHeight", "pivotHeaderHeight", "groupHeaderHeight", "pivotGroupHeaderHeight", "floatingFiltersHeight"], t);
  }
  getHeaderCellCtrl(e) {
    if (this.headerCellCtrls) return Li(this.headerCellCtrls).find((t) => t.getColumnGroupChild() === e);
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = he(this.gos, "print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleColsService: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { columnModel: e, filterManager: t } = this.beans, i = [], s = e.getGroupRowsHeight(), o = e.getColumnHeaderRowHeight();
    i.push(...s), i.push(o), (t == null ? void 0 : t.hasFloatingFilters()) && i.push(e.getFloatingFiltersHeight());
    let r = 0;
    for (let l = 0; l < this.rowIndex; l++) r += i[l];
    const n = i[this.rowIndex];
    return { topOffset: r, rowHeight: n };
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged(e = false) {
    const t = this.getHeaderCtrls(), i = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, i, e);
  }
  getHeaderCtrls() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const s of t) this.recycleAndCreateHeaderCtrls(s, e);
    const i = (s) => {
      const { focusService: o, visibleColsService: r } = this.beans;
      return o.isHeaderWrapperFocused(s) ? r.isVisible(s.getColumnGroupChild()) : false;
    };
    if (e) for (const [s, o] of e) i(o) ? this.headerCellCtrls.set(s, o) : this.destroyBean(o);
    return this.getHeaderCellCtrls();
  }
  getHeaderCellCtrls() {
    var _a3;
    return Array.from(((_a3 = this.headerCellCtrls) == null ? void 0 : _a3.values()) ?? []);
  }
  recycleAndCreateHeaderCtrls(e, t) {
    if (!this.headerCellCtrls || e.isEmptyGroup()) return;
    const i = e.getUniqueId();
    let s;
    if (t && (s = t.get(i), t.delete(i)), s && s.getColumnGroupChild() != e && (this.destroyBean(s), s = void 0), s == null) switch (this.type) {
      case "filter": {
        s = this.createBean(this.beans.ctrlsFactory.getInstance("headerFilterCell", e, this.beans, this));
        break;
      }
      case "group":
        s = this.createBean(new gd(e, this.beans, this));
        break;
      default:
        s = this.createBean(new ud(e, this.beans, this));
        break;
    }
    this.headerCellCtrls.set(i, s);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null) return [];
    let e = [];
    const t = this.getActualDepth(), { columnViewportService: i } = this.beans;
    return ["left", null, "right"].forEach((s) => {
      const o = i.getHeadersToRender(s, t);
      e = e.concat(o);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.columnViewportService.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  findHeaderCellCtrl(e) {
    if (!this.headerCellCtrls) return;
    const t = this.getHeaderCellCtrls();
    let i;
    return typeof e == "function" ? i = t.find(e) : i = t.find((s) => s.getColumnGroupChild() == e), i;
  }
  focusHeader(e, t) {
    const i = this.findHeaderCellCtrl(e);
    return i ? i.focus(t) : false;
  }
  destroy() {
    var _a3;
    (_a3 = this.headerCellCtrls) == null ? void 0 : _a3.forEach((e) => {
      this.destroyBean(e);
    }), this.headerCellCtrls = void 0, super.destroy();
  }
}, fd = class extends R {
  constructor(e) {
    super(), this.hidden = false, this.includeFloatingFilter = false, this.groupsRowCtrls = [], this.pinned = e;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.focusService = e.focusService, this.filterManager = e.filterManager;
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport);
    const i = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({ gridColumnsChanged: this.onGridColumnsChanged.bind(this), displayedColumnsChanged: i, advancedFilterEnabledChanged: i });
    const s = `${typeof this.pinned == "string" ? this.pinned : "center"}Header`;
    this.ctrlsService.register(s, this), this.columnModel.isReady() && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = false) {
    const t = new go(), i = this.focusService.getFocusHeaderToUseAfterRefresh(), s = () => {
      const l = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let a = 0; a < l; a++) {
        const c = this.createBean(new bs(t.next(), this.pinned, "group"));
        this.groupsRowCtrls.push(c);
      }
    }, o = () => {
      const l = t.next(), a = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.getRowIndex() !== l);
      (a || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), a && (this.columnsRowCtrl = this.createBean(new bs(l, this.pinned, "column")));
    }, r = () => {
      var _a3;
      this.includeFloatingFilter = !!((_a3 = this.filterManager) == null ? void 0 : _a3.hasFloatingFilters()) && !this.hidden;
      const l = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        l();
        return;
      }
      const a = t.next();
      if (this.filtersRowCtrl) {
        const c = this.filtersRowCtrl.getRowIndex() !== a;
        (!e || c) && l();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(new bs(a, this.pinned, "filter")));
    };
    s(), o(), r();
    const n = this.getAllCtrls();
    this.comp.setCtrls(n), this.restoreFocusOnHeader(i);
  }
  getHeaderCtrlForColumn(e) {
    var _a3;
    if (dt(e)) return (_a3 = this.columnsRowCtrl) == null ? void 0 : _a3.getHeaderCellCtrl(e);
    if (this.groupsRowCtrls.length !== 0) for (let t = 0; t < this.groupsRowCtrls.length; t++) {
      const i = this.groupsRowCtrls[t].getHeaderCellCtrl(e);
      if (i) return i;
    }
  }
  getHtmlElementForColumnHeader(e) {
    const t = this.getHeaderCtrlForColumn(e);
    return t ? t.getGui() : null;
  }
  getRowType(e) {
    const i = this.getAllCtrls()[e];
    return i ? i.getType() : void 0;
  }
  focusHeader(e, t, i) {
    const o = this.getAllCtrls()[e];
    return o ? o.focusHeader(t, i) : false;
  }
  getViewportElement() {
    return this.eViewport;
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(e) {
    return this.groupsRowCtrls[e];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewportElement(), { scroll: e });
  }
  destroy() {
    this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy();
  }
  setupDragAndDrop(e) {
    const t = new ld(this.pinned, e);
    this.createManagedBean(t);
  }
  restoreFocusOnHeader(e) {
    if (!e) return;
    const { column: t } = e;
    t.getPinned() == this.pinned && this.focusService.focusHeaderPosition({ headerPosition: e });
  }
  onGridColumnsChanged() {
    this.refresh(true);
  }
  onDisplayedColumnsChanged() {
    var _a3;
    const e = ((_a3 = this.filterManager) == null ? void 0 : _a3.hasFloatingFilters()) && !this.hidden;
    this.includeFloatingFilter !== e && this.refresh(true);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new Eo((e) => this.comp.setCenterWidth(`${e}px`), true));
  }
  setupPinnedWidth() {
    if (this.pinned == null) return;
    const e = this.pinned === "left", t = this.pinned === "right";
    this.hidden = true;
    const i = () => {
      const s = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (s == null) return;
      const o = s == 0, r = this.hidden !== o, n = this.gos.get("enableRtl"), l = this.scrollVisibleService.getScrollbarWidth(), c = this.scrollVisibleService.isVerticalScrollShowing() && (n && e || !n && t) ? s + l : s;
      this.comp.setPinnedContainerWidth(`${c}px`), this.comp.setDisplayed(!o), r && (this.hidden = o, this.refresh());
    };
    this.addManagedEventListeners({ leftPinnedWidthChanged: i, rightPinnedWidthChanged: i, scrollVisibilityChanged: i, scrollbarWidthChanged: i });
  }
}, Mo = class extends R {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.getDomLayout(), t = { autoHeight: e === "autoHeight", normal: e === "normal", print: e === "print" }, i = t.autoHeight ? "ag-layout-auto-height" : t.print ? "ag-layout-print" : "ag-layout-normal";
    this.view.updateLayoutClasses(i, t);
  }
  getDomLayout() {
    const e = this.gos.get("domLayout") ?? "normal";
    return ["normal", "print", "autoHeight"].indexOf(e) === -1 ? (F(`${e} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "normal") : e;
  }
}, md = class extends Y {
  constructor() {
    super(`
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`), this.eOverlayWrapper = O, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeOverlayWrapperCssClass = null, this.elToFocusAfter = null;
  }
  wireBeans(e) {
    this.overlayService = e.overlayService, this.focusService = e.focusService, this.visibleColsService = e.visibleColsService;
  }
  handleKeyDown(e) {
    if (e.key !== y.TAB || e.defaultPrevented || Ze(e) || this.focusService.findNextFocusableElement(this.eOverlayWrapper, false, e.shiftKey)) return;
    let i = false;
    e.shiftKey ? i = this.focusService.focusGridView(N(this.visibleColsService.getAllCols()), true, false) : i = this.focusService.focusNextGridCoreContainer(false), i && e.preventDefault();
  }
  updateLayoutClasses(e, t) {
    const i = this.eOverlayWrapper.classList;
    i.toggle("ag-layout-auto-height", t.autoHeight), i.toggle("ag-layout-normal", t.normal), i.toggle("ag-layout-print", t.print);
  }
  postConstruct() {
    this.createManagedBean(new Mo(this)), this.setDisplayed(false, { skipAriaHidden: true }), this.overlayService.setOverlayWrapperComp(this), this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeOverlayWrapperCssClass && t.toggle(this.activeOverlayWrapperCssClass, false), this.activeOverlayWrapperCssClass = e, t.toggle(e, true);
  }
  showOverlay(e, t, i, s) {
    if (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.elToFocusAfter = null, this.activePromise = e, !!e) {
      if (this.setDisplayed(true, { skipAriaHidden: true }), i && this.focusService.isGridFocused()) {
        const o = te(this.gos);
        o && !Pr(this.gos) && (this.elToFocusAfter = o);
      }
      e.then((o) => {
        if (this.activePromise !== e) {
          this.activeOverlay !== o && (this.destroyBean(o), o = null);
          return;
        }
        if (this.activePromise = null, !o) return;
        if (this.activeOverlay !== o && (this.eOverlayWrapper.appendChild(o.getGui()), this.activeOverlay = o, s)) {
          const n = o;
          this.updateListenerDestroyFunc = this.addManagedPropertyListener(s, ({ currentValue: l }) => {
            var _a3;
            (_a3 = n.refresh) == null ? void 0 : _a3.call(n, this.gos.addGridCommonParams({ ...l ?? {} }));
          });
        }
        const r = this.focusService;
        i && r.isGridFocused() && r.focusInto(this.eOverlayWrapper);
      });
    }
  }
  updateOverlayWrapperPaddingTop(e) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${e}px`);
  }
  destroyActiveOverlay() {
    var _a3;
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e) return;
    let t = this.elToFocusAfter;
    this.activeOverlay = null, this.elToFocusAfter = null, t && !this.focusService.isGridFocused() && (t = null);
    const i = this.updateListenerDestroyFunc;
    i && (i(), this.updateListenerDestroyFunc = null), this.destroyBean(e), xe(this.eOverlayWrapper), (_a3 = t == null ? void 0 : t.focus) == null ? void 0 : _a3.call(t, { preventScroll: true });
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(false, { skipAriaHidden: true });
  }
  destroy() {
    this.elToFocusAfter = null, this.destroyActiveOverlay(), this.overlayService.setOverlayWrapperComp(void 0), super.destroy();
  }
}, Wn = class extends Y {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = O, this.eContainer = O, this.hideTimeout = null, this.setTemplate(e);
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService;
  }
  postConstruct() {
    this.addManagedEventListeners({ scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this) }), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", qr() || pt());
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = Qr(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.addOrRemoveCssClass("ag-scrollbar-active", true), i = () => this.addOrRemoveCssClass("ag-scrollbar-active", false);
    this.addManagedListeners(e, { mouseenter: t, mousedown: t, touchstart: t, mouseleave: i, touchend: i });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({ bodyScroll: (e) => {
      e.direction === this.direction && (this.hideTimeout !== null && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", true));
    }, bodyScrollEnd: () => {
      this.hideTimeout = window.setTimeout(() => {
        this.addOrRemoveCssClass("ag-scrollbar-scrolling", false), this.hideTimeout = null;
      }, 400);
    } });
  }
  attemptSettingScrollPosition(e) {
    const t = this.getViewportElement();
    Il(() => je(t), () => this.setScrollPosition(e), 100);
  }
  getViewportElement() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewportElement(), { scroll: e });
  }
}, Cd = class extends Wn {
  constructor() {
    super(`<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`, "horizontal"), this.eLeftSpacer = O, this.eRightSpacer = O;
  }
  wireBeans(e) {
    super.wireBeans(e), this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({ displayedColumnsChanged: e, displayedColumnsWidthChanged: e, pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this) }), this.addManagedPropertyListener("domLayout", e), this.ctrlsService.register("fakeHScrollComp", this), this.createManagedBean(new Eo((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar) return;
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    let t = this.visibleColsService.getDisplayedColumnsRightWidth();
    const i = !this.enableRtl && e, s = this.scrollVisibleService.getScrollbarWidth();
    i && (t += s), Ne(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= s);
    let o = this.visibleColsService.getColsLeftWidth();
    this.enableRtl && e && (o += s), Ne(this.eLeftSpacer, o), this.eLeftSpacer.classList.toggle("ag-scroller-corner", o <= s);
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isHorizontalScrollShowing(), t = this.invisibleScrollbar, i = this.gos.get("suppressHorizontalScroll"), s = e && this.scrollVisibleService.getScrollbarWidth() || 0, r = i ? 0 : s === 0 && t ? 16 : s;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), ni(this.getGui(), r), ni(this.eViewport, r), ni(this.eContainer, r), this.setDisplayed(e, { skipAriaHidden: true });
  }
  getScrollPosition() {
    return Qi(this.getViewportElement(), this.enableRtl);
  }
  setScrollPosition(e) {
    je(this.getViewportElement()) || this.attemptSettingScrollPosition(e), Xi(this.getViewportElement(), e, this.enableRtl);
  }
}, zn = class extends R {
  wireBeans(e) {
    this.maxDivHeightScaler = e.rowContainerHeightService;
  }
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({ rowContainerHeightChanged: this.onHeightChanged.bind(this) });
  }
  onHeightChanged() {
    const e = this.maxDivHeightScaler.getUiContainerHeight(), t = e != null ? `${e}px` : "";
    this.eContainer.style.height = t, this.eViewport && (this.eViewport.style.height = t);
  }
}, vd = class extends Wn {
  wireBeans(e) {
    super.wireBeans(e), this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  constructor() {
    super(`<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`, "vertical");
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new zn(this.eContainer)), this.ctrlsService.register("fakeVScrollComp", this), this.addManagedEventListeners({ rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this) });
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isVerticalScrollShowing(), t = this.invisibleScrollbar, i = e && this.scrollVisibleService.getScrollbarWidth() || 0, s = i === 0 && t ? 16 : i;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Ne(this.getGui(), s), Ne(this.eViewport, s), Ne(this.eContainer, s), this.setDisplayed(e, { skipAriaHidden: true });
  }
  onRowContainerHeightChanged() {
    const { ctrlsService: e } = this, i = e.getGridBodyCtrl().getBodyViewportElement(), s = this.getScrollPosition(), o = i.scrollTop;
    s != o && this.setScrollPosition(o, true);
  }
  getScrollPosition() {
    return this.getViewportElement().scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !je(this.getViewportElement()) && this.attemptSettingScrollPosition(e), this.getViewportElement().scrollTop = e;
  }
}, js = ((e) => (e.FakeHScrollbar = "fakeHScrollComp", e.Header = "centerHeader", e.PinnedTop = "topCenter", e.PinnedBottom = "bottomCenter", e.StickyTop = "stickyTopCenter", e.StickyBottom = "stickyBottomCenter", e))(js || {}), Sd = class extends R {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = Re(() => this.lastScrollSource[1] = null, 500), this.resetLastVScrollDebounced = Re(() => this.lastScrollSource[0] = null, 500);
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.rowModel = e.rowModel, this.heightScaler = e.rowContainerHeightService, this.rowRenderer = e.rowRenderer, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.addManagedEventListeners({ displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this) }), this.ctrlsService.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  addScrollListener() {
    this.addHorizontalScrollListeners(), this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.getViewportElement(), { scroll: this.onHScroll.bind(this, "Viewport") });
    for (const e of Object.values(js)) {
      const t = this.ctrlsService.get(e);
      this.registerScrollPartner(t, this.onHScroll.bind(this, e));
    }
  }
  addVerticalScrollListeners() {
    const e = this.ctrlsService.get("fakeVScrollComp"), t = this.gos.get("debounceVerticalScrollbar"), i = t ? Re(this.onVScroll.bind(this, "Viewport"), 100) : this.onVScroll.bind(this, "Viewport"), s = t ? Re(this.onVScroll.bind(this, "fakeVScrollComp"), 100) : this.onVScroll.bind(this, "fakeVScrollComp");
    this.addManagedElementListeners(this.eBodyViewport, { scroll: i }), this.registerScrollPartner(e, s);
  }
  registerScrollPartner(e, t) {
    e.onScrollCallback(t);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    this.centerRowsCtrl != null && (e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft()), this.setScrollLeftForAllContainersExceptCurrent(Math.abs(e)));
  }
  setScrollLeftForAllContainersExceptCurrent(e) {
    for (const t of [...Object.values(js), "Viewport"]) {
      if (this.lastScrollSource[1] === t) continue;
      const i = this.getViewportForSource(t);
      Xi(i, e, this.enableRtl);
    }
  }
  getViewportForSource(e) {
    return e === "Viewport" ? this.centerRowsCtrl.getViewportElement() : this.ctrlsService.get(e).getViewportElement();
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (t === 0 ? this.lastScrollSource[0] = e : this.lastScrollSource[1] = e, true) : this.lastScrollSource[t] === e;
  }
  onHScroll(e) {
    if (!this.isControllingScroll(e, 1)) return;
    const t = this.centerRowsCtrl.getViewportElement(), { scrollLeft: i } = t;
    if (this.shouldBlockScrollUpdate(1, i, true)) return;
    const s = Qi(this.getViewportForSource(e), this.enableRtl);
    this.doHorizontalScroll(s), this.resetLastHScrollDebounced();
  }
  onVScroll(e) {
    if (!this.isControllingScroll(e, 0)) return;
    let t;
    e === "Viewport" ? t = this.eBodyViewport.scrollTop : t = this.ctrlsService.get("fakeVScrollComp").getScrollPosition(), !this.shouldBlockScrollUpdate(0, t, true) && (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, e === "Viewport" ? this.ctrlsService.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced());
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(1), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(true));
  }
  fireScrollEvent(e) {
    const t = { type: "bodyScroll", direction: e === 1 ? "horizontal" : "vertical", left: this.scrollLeft, top: this.scrollTop };
    this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
      this.eventService.dispatchEvent({ ...t, type: "bodyScrollEnd" });
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, i = false) {
    return i && !pt() ? false : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = co(this.eBodyViewport), { scrollHeight: i } = this.eBodyViewport;
    return e < 0 || e + t > i;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: i } = this.centerRowsCtrl.getViewportElement();
    if (this.enableRtl && Yi()) {
      if (e > 0) return true;
    } else if (e < 0) return true;
    return Math.abs(e) + t > i;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(0);
  }
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScroll("Viewport");
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  setHorizontalScrollPosition(e, t = false) {
    const s = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl && Yi() ? e = e > 0 ? 0 : s : e = Math.min(Math.max(e, 0), s)), Xi(this.centerRowsCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    return this.lastScrollTop = this.eBodyViewport.scrollTop, this.lastOffsetHeight = this.eBodyViewport.offsetHeight, { top: this.lastScrollTop, bottom: this.lastScrollTop + this.lastOffsetHeight };
  }
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? { top: this.scrollTop, bottom: this.scrollTop + this.lastOffsetHeight } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.getViewportElement().scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.getViewportElement().scrollLeft - t;
  }
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  ensureNodeVisible(e, t = null) {
    const i = this.rowModel.getRowCount();
    let s = -1;
    for (let o = 0; o < i; o++) {
      const r = this.rowModel.getRow(o);
      if (typeof e == "function") {
        if (r && e(r)) {
          s = o;
          break;
        }
      } else if (e === r || e === r.data) {
        s = o;
        break;
      }
    }
    s >= 0 && this.ensureIndexVisible(s, t);
  }
  ensureIndexVisible(e, t) {
    if (he(this.gos, "print")) return;
    const i = this.rowModel.getRowCount();
    if (typeof e != "number" || e < 0 || e >= i) {
      F("Invalid row index for ensureIndexVisible: " + e);
      return;
    }
    const o = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.getFrameworkOverrides().wrapIncoming(() => {
      var _a3;
      o || ((_a3 = this.paginationService) == null ? void 0 : _a3.goToPageWithIndex(e));
      const r = this.ctrlsService.getGridBodyCtrl(), n = r.getStickyTopHeight(), l = r.getStickyBottomHeight(), a = this.rowModel.getRow(e);
      let c;
      do {
        const u = a.rowTop, d = a.rowHeight, h = this.pageBoundsService.getPixelOffset(), g = a.rowTop - h, m = g + a.rowHeight, C = this.getVScrollPosition(), f = this.heightScaler.getDivStretchOffset(), v = C.top + f, w = C.bottom + f, S = w - v, b = this.heightScaler.getScrollPositionForPixel(g), x = this.heightScaler.getScrollPositionForPixel(m - S), M = Math.min((b + x) / 2, g), P = v + n > g, A = w - l < m;
        let I = null;
        t === "top" ? I = b : t === "bottom" ? I = x : t === "middle" ? I = M : P ? I = b - n : A && (I = x + l), I !== null && (this.setVerticalScrollPosition(I), this.rowRenderer.redraw({ afterScroll: true })), c = u !== a.rowTop || d !== a.rowHeight;
      } while (c);
      this.animationFrameService.flushAllFrames();
    });
  }
  ensureColumnVisible(e, t = "auto") {
    const i = this.columnModel.getCol(e);
    if (!i || i.isPinned() || !this.visibleColsService.isColDisplayed(i)) return;
    const s = this.getPositionedHorizontalScroll(i, t);
    this.getFrameworkOverrides().wrapIncoming(() => {
      s !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(s), this.centerRowsCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
    });
  }
  setScrollPosition(e, t) {
    this.getFrameworkOverrides().wrapIncoming(() => {
      this.centerRowsCtrl.setCenterViewportScrollLeft(t), this.setVerticalScrollPosition(e), this.rowRenderer.redraw({ afterScroll: true }), this.animationFrameService.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: i, columnAfterEnd: s } = this.isColumnOutsideViewport(e), o = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), r = this.centerRowsCtrl.getCenterWidth(), n = this.enableRtl;
    let l = (n ? i : s) || o, a = n ? s : i;
    t !== "auto" && (l = t === "start", a = t === "end");
    const c = t === "middle";
    if (l || a || c) {
      const { colLeft: u, colMiddle: d, colRight: h } = this.getColumnBounds(e);
      return c ? d - r / 2 : l ? n ? h : u : n ? u - r : h - r;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: i } = this.getViewportBounds(), { colLeft: s, colRight: o } = this.getColumnBounds(e), r = this.enableRtl, n = r ? t > o : i < o, l = r ? i < s : t > s;
    return { columnBeforeStart: n, columnAfterEnd: l };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, i = this.visibleColsService.getBodyContainerWidth(), s = e.getActualWidth(), o = e.getLeft(), r = t ? -1 : 1, n = t ? i - o : o, l = n + s * r, a = n + s / 2 * r;
    return { colLeft: n, colMiddle: a, colRight: l };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), i = t, s = e + t;
    return { start: i, end: s, width: e };
  }
}, wd = class extends R {
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.ctrlsService = e.ctrlsService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.columnViewportService = e.columnViewportService;
  }
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const e = () => {
      this.animationFrameService.requestAnimationFrame(() => {
        this.onCenterViewportResized();
      });
    };
    this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.scrollVisibleService.onCentreViewportResized(), this.centerContainerCtrl.isViewportInTheDOMTree()) {
      this.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const e = this.centerContainerCtrl.getCenterWidth();
      e !== this.centerWidth && (this.centerWidth = e, this.columnSizeService.refreshFlexedColumns({ viewportWidth: this.centerWidth, updateBodyWidths: true, fireResizedEvent: true }));
    } else this.bodyHeight = 0;
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = yi(e);
    if (t <= 50) return;
    let i = this.getPinnedColumnsOverflowingViewport(t - 50);
    const s = this.gos.getCallback("processUnpinnedColumns");
    i.length && (s && (i = s({ columns: i, viewportWidth: t })), this.columnModel.setColsPinned(i, null, "viewportSizeFeature"));
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.pinnedWidthService.getPinnedRightWidth(), i = this.pinnedWidthService.getPinnedLeftWidth(), s = t + i;
    if (s < e) return [];
    const o = [...this.visibleColsService.getLeftCols()], r = [...this.visibleColsService.getRightCols()];
    let n = 0, l = 0;
    const a = 0, c = [];
    let u = s - a - e;
    for (; (l < o.length || n < r.length) && u > 0; ) {
      if (n < r.length) {
        const d = r[n++];
        u -= d.getActualWidth(), c.push(d);
      }
      if (l < o.length && u > 0) {
        const d = o[l++];
        u -= d.getActualWidth(), c.push(d);
      }
    }
    return c;
  }
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = co(e);
    this.bodyHeight !== t && (this.bodyHeight = t, this.eventService.dispatchEvent({ type: "bodyHeightChanged" }));
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = { horizontalScrollShowing: this.isHorizontalScrollShowing(), verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing() };
    this.scrollVisibleService.setScrollsVisible(e);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnViewportService.setScrollPosition(e, t);
  }
}, yd = class extends R {
  wireBeans(e) {
    this.dragService = e.dragService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    if (!this.rangeService) return;
    this.params = { eElement: this.eContainer, onDragStart: this.rangeService.onDragStart.bind(this.rangeService), onDragStop: this.rangeService.onDragStop.bind(this.rangeService), onDragging: this.rangeService.onDragging.bind(this.rangeService) }, this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
      et(this.gos) ? this.enableFeature() : this.disableFeature();
    }), this.addDestroyFunc(() => this.disableFeature()), et(this.gos) && this.enableFeature();
  }
  enableFeature() {
    this.dragService.addDragSource(this.params);
  }
  disableFeature() {
    this.dragService.removeDragSource(this.params);
  }
}, Rd = class extends Y {
  constructor() {
    super(`
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`, [mo]), this.eCheckbox = O;
  }
  postConstruct() {
    this.eCheckbox.setPassive(true);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = this.rowNode.isSelected(), i = ro(e, t), [s, o] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], r = e(s, o);
    this.eCheckbox.setValue(t, true), this.eCheckbox.setInputAriaLabel(`${r} (${i})`);
  }
  onClicked(e, t, i) {
    return this.rowNode.setSelectedParams({ newValue: e, rangeSelect: i.shiftKey, groupSelectsFiltered: t, event: i, source: "checkboxSelected" });
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), { dblclick: (s) => zt(s), click: (s) => {
      zt(s);
      const o = eo(this.gos) === "filteredDescendants", r = this.eCheckbox.getValue();
      this.shouldHandleIndeterminateState(r, o) ? this.onClicked(true, o, s || {}) === 0 && this.onClicked(false, o, s) : r ? this.onClicked(false, o, s) : this.onClicked(true, o, s || {});
    } }), this.addManagedListeners(this.rowNode, { rowSelected: this.onSelectionChanged.bind(this), dataChanged: this.onDataChanged.bind(this), selectableChanged: this.onSelectableChanged.bind(this) }), Zs(this.gos) || typeof this.getIsVisible() == "function") {
      const s = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: s }), this.addManagedListeners(this.rowNode, { dataChanged: s, cellChanged: s }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  shouldHandleIndeterminateState(e, t) {
    return t && (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) && Q(this.gos);
  }
  showOrHideSelect() {
    var _a3, _b, _c2;
    let e = this.rowNode.selectable;
    const t = this.getIsVisible();
    if (e) if (typeof t == "function") {
      const o = (_a3 = this.overrides) == null ? void 0 : _a3.callbackParams;
      if (!this.column) e = t({ ...o, node: this.rowNode, data: this.rowNode.data });
      else {
        const r = this.column.createColumnFunctionCallbackParams(this.rowNode);
        e = t({ ...o, ...r });
      }
    } else e = t ?? false;
    const i = this.gos.get("rowSelection");
    if (i && typeof i != "string" ? !Hl(i) : (_b = this.column) == null ? void 0 : _b.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!e), this.setVisible(true), this.setDisplayed(true);
      return;
    }
    if ((_c2 = this.overrides) == null ? void 0 : _c2.removeHidden) {
      this.setDisplayed(e);
      return;
    }
    this.setVisible(e);
  }
  getIsVisible() {
    var _a3, _b;
    if (this.overrides) return this.overrides.isVisible;
    const e = this.gos.get("rowSelection");
    return e && typeof e != "string" ? Wt(e) : (_b = (_a3 = this.column) == null ? void 0 : _a3.getColDef()) == null ? void 0 : _b.checkboxSelection;
  }
}, Fd = class extends Y {
  constructor(e, t, i) {
    super('<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'), this.rowNode = e, this.column = t, this.eCell = i;
  }
  postConstruct() {
    this.getGui().appendChild(De("rowDrag", this.gos, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const t = this.column.getColDef().dndSourceOnRowDrag;
    e.dataTransfer.setDragImage(this.eCell, 0, 0);
    const i = () => {
      try {
        const s = JSON.stringify(this.rowNode.data);
        e.dataTransfer.setData("application/json", s), e.dataTransfer.setData("text/plain", s);
      } catch {
      }
    };
    if (t) {
      const s = this.gos.addGridCommonParams({ rowNode: this.rowNode, dragEvent: e });
      t(s);
    } else i();
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
}, bd = class extends R {
  constructor(e, t) {
    super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const e = this.column.getColDef(), { cellClassRules: t } = e, i = this.beans.gos.addGridCommonParams({ value: this.cellCtrl.getValue(), data: this.rowNode.data, node: this.rowNode, colDef: e, column: this.column, rowIndex: this.rowNode.rowIndex });
    this.beans.stylingService.processClassRules(t === this.cellClassRules ? void 0 : this.cellClassRules, t, i, (s) => this.cellComp.addOrRemoveCssClass(s, true), (s) => this.cellComp.addOrRemoveCssClass(s, false)), this.cellClassRules = t;
  }
  applyUserStyles() {
    const e = this.column.getColDef();
    if (!e.cellStyle) return;
    let t;
    if (typeof e.cellStyle == "function") {
      const i = this.beans.gos.addGridCommonParams({ column: this.column, value: this.cellCtrl.getValue(), colDef: e, data: this.rowNode.data, node: this.rowNode, rowIndex: this.rowNode.rowIndex }), s = e.cellStyle;
      t = s(i);
    } else t = e.cellStyle;
    t && this.cellComp.setUserStyles(t);
  }
  applyClassesFromColDef() {
    const e = this.column.getColDef(), t = this.beans.gos.addGridCommonParams({ value: this.cellCtrl.getValue(), data: this.rowNode.data, node: this.rowNode, column: this.column, colDef: e, rowIndex: this.rowNode.rowIndex });
    this.staticClasses.length && this.staticClasses.forEach((i) => this.cellComp.addOrRemoveCssClass(i, false)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach((i) => this.cellComp.addOrRemoveCssClass(i, true));
  }
  destroy() {
    super.destroy();
  }
}, Pd = class extends R {
  constructor(e, t, i, s, o) {
    super(), this.cellCtrl = e, this.beans = t, this.rowNode = s, this.rowCtrl = o;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case y.ENTER:
        this.onEnterKeyDown(e);
        break;
      case y.F2:
        this.onF2KeyDown(e);
        break;
      case y.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case y.TAB:
        this.onTabKeyDown(e);
        break;
      case y.BACKSPACE:
      case y.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case y.DOWN:
      case y.UP:
      case y.RIGHT:
      case y.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), true), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    if (!this.beans.rangeService) return;
    const t = this.beans.rangeService.extendLatestRangeInDirection(e);
    t && this.beans.navigationService.ensureCellVisible(t);
  }
  onTabKeyDown(e) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    const { cellCtrl: i, beans: s, rowNode: o } = this, { gos: r, rangeService: n, eventService: l } = s;
    if (!i.isEditing()) {
      if (l.dispatchEvent({ type: "keyShortcutChangedCellStart" }), lu(e, r.get("enableCellEditingOnBackspace"))) {
        if (n && et(r)) n.clearCellRangeCellValues({ dispatchWrapperEvents: true, wrapperEventSource: "deleteKey" });
        else if (i.isCellEditable()) {
          const a = i.getColumn(), c = this.beans.valueService.getDeleteValue(a, o);
          o.setDataValue(a, c, "cellClear");
        }
      } else i.startRowOrCellEdit(e, t);
      l.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
    }
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing()) this.cellCtrl.stopEditingAndFocus(false, e.shiftKey);
    else if (this.beans.gos.get("enterNavigatesVertically")) {
      const t = e.shiftKey ? y.UP : y.DOWN;
      this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), false);
    } else this.cellCtrl.startRowOrCellEdit(y.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault();
  }
  onF2KeyDown(e) {
    this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(y.F2, e);
  }
  onEscapeKeyDown(e) {
    this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(true), this.cellCtrl.focusCell(true));
  }
  processCharacter(e) {
    if (e.target !== this.eGui || this.cellCtrl.isEditing()) return;
    const s = e.key;
    s === " " ? this.onSpaceKeyDown(e) : this.cellCtrl.startRowOrCellEdit(s, e) && e.preventDefault();
  }
  onSpaceKeyDown(e) {
    const { gos: t } = this.beans;
    if (!this.cellCtrl.isEditing() && Wi(t)) {
      const i = this.rowNode.isSelected(), s = !i, o = eo(t) === "filteredDescendants", r = this.rowNode.setSelectedParams({ newValue: s, rangeSelect: e.shiftKey, groupSelectsFiltered: o, event: e, source: "spaceKey" });
      i === void 0 && r === 0 && this.rowNode.setSelectedParams({ newValue: false, rangeSelect: e.shiftKey, groupSelectsFiltered: o, event: e, source: "spaceKey" });
    }
    e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, Ed = class extends R {
  constructor(e, t, i) {
    super(), this.cellCtrl = e, this.beans = t, this.column = i;
  }
  onMouseEvent(e, t) {
    if (!Ze(t)) switch (e) {
      case "click":
        this.onCellClicked(t);
        break;
      case "mousedown":
      case "touchstart":
        this.onMouseDown(t);
        break;
      case "dblclick":
        this.onCellDoubleClicked(t);
        break;
      case "mouseout":
        this.onMouseOut(t);
        break;
      case "mouseover":
        this.onMouseOver(t);
        break;
    }
  }
  onCellClicked(e) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(e), e.preventDefault();
      return;
    }
    const { eventService: t, rangeService: i, gos: s } = this.beans, o = e.ctrlKey || e.metaKey;
    i && o && i.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && i.intersectLastRange(true);
    const r = this.cellCtrl.createEvent(e, "cellClicked");
    t.dispatchEvent(r);
    const n = this.column.getColDef();
    n.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        n.onCellClicked(r);
      });
    }, 0), (s.get("singleClickEdit") || n.singleClickEdit) && !s.get("suppressClickEdit") && !(e.shiftKey && (i == null ? void 0 : i.getCellRanges().length) != 0) && this.cellCtrl.startRowOrCellEdit();
  }
  isDoubleClickOnIPad() {
    if (!pt() || Or("dblclick")) return false;
    const e = (/* @__PURE__ */ new Date()).getTime(), t = e - this.lastIPadMouseClickEvent < 200;
    return this.lastIPadMouseClickEvent = e, t;
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: i, cellCtrl: s } = this, { eventService: o, frameworkOverrides: r, gos: n } = i, l = t.getColDef(), a = s.createEvent(e, "cellDoubleClicked");
    o.dispatchEvent(a), typeof l.onCellDoubleClicked == "function" && window.setTimeout(() => {
      r.wrapOutgoing(() => {
        l.onCellDoubleClicked(a);
      });
    }, 0), !n.get("singleClickEdit") && !n.get("suppressClickEdit") && s.startRowOrCellEdit(null, e);
  }
  onMouseDown(e) {
    var _a3;
    const { ctrlKey: t, metaKey: i, shiftKey: s } = e, o = e.target, { cellCtrl: r, beans: n } = this, { eventService: l, rangeService: a, focusService: c, gos: u } = n;
    if (this.isRightClickInExistingRange(e)) return;
    const d = a && a.getCellRanges().length != 0;
    if (!s || !d) {
      const g = u.get("enableCellTextSelection") && e.defaultPrevented, m = ($e() || g) && !r.isEditing() && !ao(o);
      r.focusCell(m);
    }
    if (s && d && !c.isCellFocused(r.getCellPosition())) {
      e.preventDefault();
      const h = c.getFocusedCell();
      if (h) {
        const { column: g, rowIndex: m, rowPinned: C } = h, v = (_a3 = n.rowRenderer.getRowByPosition({ rowIndex: m, rowPinned: C })) == null ? void 0 : _a3.getCellCtrl(g);
        (v == null ? void 0 : v.isEditing()) && v.stopEditing(), c.setFocusedCell({ column: g, rowIndex: m, rowPinned: C, forceBrowserFocus: true, preventScrollOnBrowserFocus: true });
      }
    }
    if (!this.containsWidget(o)) {
      if (a) {
        const h = this.cellCtrl.getCellPosition();
        if (s) a.extendLatestRangeToCell(h);
        else {
          const g = t || i;
          a.setRangeToCell(h, g);
        }
      }
      l.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseDown"));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeService: t } = this.beans;
    if (t) {
      const i = t.isCellInAnyRange(this.cellCtrl.getCellPosition()), s = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (i && s) return true;
    }
    return false;
  }
  containsWidget(e) {
    return Vt(e, "ag-selection-checkbox", 3);
  }
  onMouseOut(e) {
    this.mouseStayingInsideCell(e) || (this.beans.eventService.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOut")), this.beans.columnHoverService.clearMouseOver());
  }
  onMouseOver(e) {
    this.mouseStayingInsideCell(e) || (this.beans.eventService.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOver")), this.beans.columnHoverService.setMouseOver([this.column]));
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget) return false;
    const t = this.cellCtrl.getGui(), i = t.contains(e.target), s = t.contains(e.relatedTarget);
    return i && s;
  }
  destroy() {
    super.destroy();
  }
}, Dd = class extends R {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  setComp(e) {
    this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(true));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    gt(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventService, { displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this), displayedColumnsWidthChanged: this.onWidthChanged.bind(this) }));
  }
  onWidthChanged() {
    if (!this.eGui) return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const e = this.column.getColSpan(this.rowNode), t = [];
    if (e === 1) t.push(this.column);
    else {
      let i = this.column;
      const s = this.column.getPinned();
      for (let o = 0; i && o < e && (t.push(i), i = this.beans.visibleColsService.getColAfter(i), !(!i || V(i) || s !== i.getPinned())); o++) ;
    }
    return t;
  }
  onLeftChanged() {
    if (!this.eGui) return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = N(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left") return e;
    const t = this.beans.visibleColsService.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const i = this.beans.visibleColsService.getBodyContainerWidth();
      return t + i + (e || 0);
    }
    return t + (e || 0);
  }
  applyRowSpan(e) {
    if (this.rowSpan === 1 && !e) return;
    const i = ts(this.beans.gos) * this.rowSpan;
    this.eGui.style.height = `${i}px`, this.eGui.style.zIndex = "1";
  }
  destroy() {
    super.destroy();
  }
}, Zt = "ag-cell-range-selected", Md = "ag-cell-range-chart", xd = "ag-cell-range-single-cell", Ad = "ag-cell-range-chart-category", Td = "ag-cell-range-handle", Id = "ag-cell-range-top", Ld = "ag-cell-range-right", Od = "ag-cell-range-bottom", Gd = "ag-cell-range-left", kd = class {
  constructor(e, t) {
    this.beans = e, this.rangeService = e.rangeService, this.selectionHandleFactory = e.selectionHandleFactory, this.cellCtrl = t;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onCellSelectionChanged();
  }
  onCellSelectionChanged() {
    this.cellComp && (this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(Zt, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(`${Zt}-1`, this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(`${Zt}-2`, this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(`${Zt}-3`, this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(`${Zt}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(Md, this.hasChartRange), ji(this.eGui, this.rangeCount > 0 ? true : void 0), this.cellComp.addOrRemoveCssClass(xd, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), i = !t && e.top, s = !t && e.right, o = !t && e.bottom, r = !t && e.left;
    this.cellComp.addOrRemoveCssClass(Id, i), this.cellComp.addOrRemoveCssClass(Ld, s), this.cellComp.addOrRemoveCssClass(Od, o), this.cellComp.addOrRemoveCssClass(Gd, r);
  }
  isSingleCell() {
    const { rangeService: e } = this.beans;
    return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService: e } = this.beans;
    if (!this.rangeCount || !e) return false;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((i) => Rt([1, 0], i.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gos.get("enableRtl");
    let t = false, i = false, s = false, o = false;
    const r = this.cellCtrl.getCellPosition().column, n = this.beans.visibleColsService;
    let l, a;
    e ? (l = n.getColAfter(r), a = n.getColBefore(r)) : (l = n.getColBefore(r), a = n.getColAfter(r));
    const c = this.rangeService.getCellRanges().filter((u) => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), u));
    l || (o = true), a || (i = true);
    for (let u = 0; u < c.length && !(t && i && s && o); u++) {
      const d = c[u], h = this.rangeService.getRangeStartRow(d), g = this.rangeService.getRangeEndRow(d);
      !t && this.beans.rowPositionUtils.sameRow(h, this.cellCtrl.getCellPosition()) && (t = true), !s && this.beans.rowPositionUtils.sameRow(g, this.cellCtrl.getCellPosition()) && (s = true), !o && l && d.columns.indexOf(l) < 0 && (o = true), !i && a && d.columns.indexOf(a) < 0 && (i = true);
    }
    return { top: t, right: i, bottom: s, left: o };
  }
  refreshHandle() {
    if (this.beans.context.isDestroyed()) return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(Td, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const e = this.beans.gos, t = this.rangeService.getCellRanges(), i = t.length;
    if (this.rangeCount < 1 || i < 1) return false;
    const s = N(t), o = this.cellCtrl.getCellPosition(), r = zo(e) && !this.cellCtrl.isSuppressFillHandle(), n = Wl(e);
    let l = i === 1 && !this.cellCtrl.isEditing() && (r || n);
    if (this.hasChartRange) {
      const c = t[0].type === 1 && this.rangeService.isCellInSpecificRange(o, t[0]);
      this.cellComp.addOrRemoveCssClass(Ad, c), l = s.type === 0;
    }
    return l && s.endRow != null && this.rangeService.isContiguousRange(s) && this.rangeService.isBottomRightCell(s, o);
  }
  addSelectionHandle() {
    const e = N(this.rangeService.getCellRanges()).type, i = zo(this.beans.gos) && V(e) ? 0 : 1;
    this.selectionHandle && this.selectionHandle.getType() !== i && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(i)), this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}, Hd = "ag-cell", Nd = "ag-cell-auto-height", Vd = "ag-cell-normal-height", Bd = "ag-cell-focus", Wd = "ag-cell-first-right-pinned", zd = "ag-cell-last-left-pinned", _d = "ag-cell-not-inline-editing", Ud = "ag-column-hover", Kd = "ag-cell-wrap-text", $d = 0, _n = class qs extends R {
  constructor(t, i, s, o) {
    super(), this.column = t, this.rowNode = i, this.beans = s, this.rowCtrl = o, this.cellRangeFeature = void 0, this.cellPositionFeature = void 0, this.cellCustomStyleFeature = void 0, this.tooltipFeature = void 0, this.cellMouseListenerFeature = void 0, this.cellKeyboardListenerFeature = void 0, this.suppressRefreshCell = false, this.onCellCompAttachedFuncs = [], this.onCellEditorAttachedFuncs = [], this.instanceId = t.getId() + "-" + $d++, this.colIdSanitised = Ke(this.column.getId()), this.createCellPosition(), this.updateAndFormatValue(false);
  }
  shouldRestoreFocus() {
    return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
  }
  onFocusOut() {
    this.beans.focusService.clearRestoreFocus();
  }
  addFeatures() {
    this.cellPositionFeature = new Dd(this, this.beans), this.cellCustomStyleFeature = new bd(this, this.beans), this.cellMouseListenerFeature = new Ed(this, this.beans, this.column), this.cellKeyboardListenerFeature = new Pd(this, this.beans, this.column, this.rowNode, this.rowCtrl), this.column.isTooltipEnabled() && this.enableTooltipFeature(), this.beans.rangeService && et(this.beans.gos) && (this.cellRangeFeature = new kd(this.beans, this));
  }
  removeFeatures() {
    const t = this.beans.context;
    this.cellPositionFeature = t.destroyBean(this.cellPositionFeature), this.cellCustomStyleFeature = t.destroyBean(this.cellCustomStyleFeature), this.cellMouseListenerFeature = t.destroyBean(this.cellMouseListenerFeature), this.cellKeyboardListenerFeature = t.destroyBean(this.cellKeyboardListenerFeature), this.cellRangeFeature = t.destroyBean(this.cellRangeFeature), this.disableTooltipFeature();
  }
  enableTooltipFeature(t, i) {
    const s = () => {
      const n = this.column.getColDef(), l = this.rowNode.data;
      if (n.tooltipField && E(l)) return ri(l, n.tooltipField, this.column.isTooltipFieldContainsDots());
      const a = n.tooltipValueGetter;
      return a ? a(this.beans.gos.addGridCommonParams({ location: "cell", colDef: this.column.getColDef(), column: this.column, rowIndex: this.cellPosition.rowIndex, node: this.rowNode, data: this.rowNode.data, value: this.value, valueFormatted: this.valueFormatted })) : null;
    }, o = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
    !i && o && !this.isCellRenderer() && (i = () => {
      const n = this.getGui(), l = n.children.length === 0 ? n : n.querySelector(".ag-cell-value");
      return l ? l.scrollWidth > l.clientWidth : true;
    });
    const r = { getColumn: () => this.column, getColDef: () => this.column.getColDef(), getRowIndex: () => this.cellPosition.rowIndex, getRowNode: () => this.rowNode, getGui: () => this.getGui(), getLocation: () => "cell", getTooltipValue: t != null ? () => t : s, getValueFormatted: () => this.valueFormatted, shouldDisplayTooltip: i };
    this.tooltipFeature = new $t(r, this.beans);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  setComp(t, i, s, o, r, n) {
    var _a3, _b, _c2, _d2;
    this.cellComp = t, this.eGui = i, this.printLayout = o, n ?? (n = this), this.addDomData(n), this.addFeatures(), n.addDestroyFunc(() => this.removeFeatures()), this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(s, n), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (_a3 = this.cellPositionFeature) == null ? void 0 : _a3.setComp(i), (_b = this.cellCustomStyleFeature) == null ? void 0 : _b.setComp(t), (_c2 = this.tooltipFeature) == null ? void 0 : _c2.refreshToolTip(), (_d2 = this.cellKeyboardListenerFeature) == null ? void 0 : _d2.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, i), r && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach((l) => l()), this.onCellCompAttachedFuncs = []);
  }
  setupAutoHeight(t, i) {
    if (this.isAutoHeight = this.column.isAutoHeight(), !this.isAutoHeight || !t) return;
    const s = t.parentElement, o = ut(this.beans.gos, this.rowNode).height, r = (a) => {
      if (this.editing || !this.isAlive() || !i.isAlive()) return;
      const { paddingTop: c, paddingBottom: u, borderBottomWidth: d, borderTopWidth: h } = xt(s), g = c + u + d + h, C = t.offsetHeight + g;
      if (a < 5) {
        const v = re(this.beans.gos), w = !v || !v.contains(t), S = C == 0;
        if (w || S) {
          window.setTimeout(() => r(a + 1), 0);
          return;
        }
      }
      const f = Math.max(C, o);
      this.rowNode.setRowAutoHeight(f, this.column);
    }, n = () => r(0);
    n();
    const l = this.beans.resizeObserverService.observeResize(t, n);
    i.addDestroyFunc(() => {
      l(), this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  isCellRenderer() {
    const t = this.column.getColDef();
    return t.cellRenderer != null || t.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(t = false) {
    var _a3;
    const { beans: i, column: s, rowNode: o, cellRangeFeature: r, cellComp: n } = this, { userComponentFactory: l, animationFrameService: a } = i, c = this.getValueToDisplay();
    let u;
    if (o.stub && ((_a3 = o.groupData) == null ? void 0 : _a3[this.column.getId()]) == null) {
      const h = this.createCellRendererParams();
      u = l.getLoadingCellRendererDetails(s.getColDef(), h);
    } else if (this.isCellRenderer()) {
      const h = this.createCellRendererParams();
      u = l.getCellRendererDetails(s.getColDef(), h);
    }
    n.setRenderDetails(u, c, t), a.requestAnimationFrame(() => r == null ? void 0 : r.refreshHandle());
  }
  setupControlComps() {
    const t = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(t)), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  isIncludeControl(t) {
    return this.rowNode.rowPinned != null ? false : typeof t == "function" || t === true;
  }
  isCheckboxSelection(t) {
    const { rowSelection: i } = this.beans.gridOptions;
    return t.checkboxSelection || vi(this.column) && i && typeof i != "string" && Wt(i);
  }
  refreshShouldDestroy() {
    const t = this.column.getColDef(), i = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(t)), s = this.includeRowDrag != this.isIncludeControl(t.rowDrag), o = this.includeDndSource != this.isIncludeControl(t.dndSource), r = this.isAutoHeight != this.column.isAutoHeight();
    return i || s || o || r;
  }
  startEditing(t = null, i = false, s = null) {
    const { editService: o } = this.beans;
    return !this.isCellEditable() || this.editing || !o ? true : this.cellComp ? o.startEditing(this, t, i, s) : (this.onCellCompAttachedFuncs.push(() => {
      this.startEditing(t, i, s);
    }), true);
  }
  setEditing(t, i) {
    this.editCompDetails = i, this.editing !== t && (this.editing = t);
  }
  stopRowOrCellEdit(t = false) {
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.stopEditing(t) : this.stopEditing(t);
  }
  onPopupEditorClosed() {
    this.editing && this.stopEditingAndFocus();
  }
  stopEditing(t = false) {
    this.onCellEditorAttachedFuncs = [];
    const { editService: i } = this.beans;
    return !this.editing || !i ? false : i.stopEditing(this, t);
  }
  createCellRendererParams() {
    return this.beans.gos.addGridCommonParams({ value: this.value, valueFormatted: this.valueFormatted, getValue: () => this.beans.valueService.getValueForDisplay(this.column, this.rowNode), setValue: (i) => this.beans.valueService.setValue(this.rowNode, this.column, i), formatValue: this.formatValue.bind(this), data: this.rowNode.data, node: this.rowNode, pinned: this.column.getPinned(), colDef: this.column.getColDef(), column: this.column, refreshCell: this.refreshCell.bind(this), eGridCell: this.getGui(), eParentOfValue: this.cellComp.getParentOfValue(), registerRowDragger: (i, s, o, r) => this.registerRowDragger(i, s, r), setTooltip: (i, s) => {
      var _a3;
      this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(i, s), (_a3 = this.tooltipFeature) == null ? void 0 : _a3.refreshToolTip();
    } });
  }
  setFocusOutOnEditor() {
    var _a3;
    this.editing && ((_a3 = this.beans.editService) == null ? void 0 : _a3.setFocusOutOnEditor(this));
  }
  setFocusInOnEditor() {
    var _a3;
    this.editing && ((_a3 = this.beans.editService) == null ? void 0 : _a3.setFocusInOnEditor(this));
  }
  onCellChanged(t) {
    t.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(t) {
    var _a3;
    this.refreshShouldDestroy() ? (_a3 = this.rowCtrl) == null ? void 0 : _a3.recreateCell(this) : this.refreshCell(t);
  }
  refreshCell(t) {
    var _a3, _b, _c2, _d2, _e2;
    if (this.suppressRefreshCell || this.editing) return;
    const i = this.column.getColDef(), s = t != null && !!t.newData, o = t != null && !!t.suppressFlash || !!i.suppressCellFlash, r = i.field == null && i.valueGetter == null && i.showRowGroup == null, n = t && t.forceRefresh || r || s, l = !!this.cellComp, a = this.updateAndFormatValue(l), c = n || a;
    if (l) {
      if (c) {
        this.showValue(s);
        const u = (_a3 = this.beans.filterManager) == null ? void 0 : _a3.isSuppressFlashingCellsBecauseFiltering();
        !o && !u && (this.beans.gos.get("enableCellChangeFlash") || i.enableCellChangeFlash) && this.flashCell(), (_b = this.cellCustomStyleFeature) == null ? void 0 : _b.applyUserStyles(), (_c2 = this.cellCustomStyleFeature) == null ? void 0 : _c2.applyClassesFromColDef();
      }
      (_d2 = this.tooltipFeature) == null ? void 0 : _d2.refreshToolTip(), (_e2 = this.cellCustomStyleFeature) == null ? void 0 : _e2.applyCellClassRules();
    }
  }
  stopEditingAndFocus(t = false, i = false) {
    var _a3;
    (_a3 = this.beans.editService) == null ? void 0 : _a3.stopEditingAndFocus(this, t, i);
  }
  flashCell(t) {
    const i = (t == null ? void 0 : t.flashDuration) ?? (t == null ? void 0 : t.flashDelay), s = (t == null ? void 0 : t.fadeDuration) ?? (t == null ? void 0 : t.fadeDelay);
    this.animateCell("data-changed", i, s);
  }
  animateCell(t, i, s) {
    if (!this.cellComp) return;
    const { gos: o } = this.beans;
    if (i || (i = o.get("cellFlashDuration")), i === 0) return;
    E(s) || (s = o.get("cellFadeDuration"));
    const r = `ag-cell-${t}`, n = `ag-cell-${t}-animation`;
    this.cellComp.addOrRemoveCssClass(r, true), this.cellComp.addOrRemoveCssClass(n, false), this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        this.isAlive() && (this.cellComp.addOrRemoveCssClass(r, false), this.cellComp.addOrRemoveCssClass(n, true), this.eGui.style.transition = `background-color ${s}ms`, window.setTimeout(() => {
          this.isAlive() && (this.cellComp.addOrRemoveCssClass(n, false), this.eGui.style.transition = "");
        }, s));
      }, i);
    });
  }
  onFlashCells(t) {
    if (!this.cellComp) return;
    const i = this.beans.cellPositionUtils.createId(this.getCellPosition());
    t.cells[i] && this.animateCell("highlight");
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(t) {
    return this.callValueFormatter(t) ?? t;
  }
  callValueFormatter(t) {
    return this.beans.valueService.formatValue(this.column, this.rowNode, t);
  }
  updateAndFormatValue(t) {
    const i = this.value, s = this.valueFormatted;
    return this.value = this.beans.valueService.getValueForDisplay(this.column, this.rowNode), this.valueFormatted = this.callValueFormatter(this.value), t ? !this.valuesAreEqual(i, this.value) || this.valueFormatted != s : true;
  }
  valuesAreEqual(t, i) {
    const s = this.column.getColDef();
    return s.equals ? s.equals(t, i) : t === i;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  addDomData(t) {
    const i = this.getGui();
    Et(this.beans.gos, i, qs.DOM_DATA_KEY_CELL_CTRL, this), t.addDestroyFunc(() => Et(this.beans.gos, i, qs.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(t, i) {
    return this.beans.gos.addGridCommonParams({ type: i, node: this.rowNode, data: this.rowNode.data, value: this.value, column: this.column, colDef: this.column.getColDef(), rowPinned: this.rowNode.rowPinned, event: t, rowIndex: this.rowNode.rowIndex });
  }
  processCharacter(t) {
    var _a3;
    (_a3 = this.cellKeyboardListenerFeature) == null ? void 0 : _a3.processCharacter(t);
  }
  onKeyDown(t) {
    var _a3;
    (_a3 = this.cellKeyboardListenerFeature) == null ? void 0 : _a3.onKeyDown(t);
  }
  onMouseEvent(t, i) {
    var _a3;
    (_a3 = this.cellMouseListenerFeature) == null ? void 0 : _a3.onMouseEvent(t, i);
  }
  getGui() {
    return this.eGui;
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var _a3;
    this.cellComp && ((_a3 = this.cellPositionFeature) == null ? void 0 : _a3.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { cellComp: t, column: i, beans: s } = this;
    In(t, i, s.visibleColsService);
  }
  refreshAriaColIndex() {
    const t = this.beans.visibleColsService.getAriaColIndex(this.column);
    $r(this.getGui(), t);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var _a3;
    return (_a3 = this.cellPositionFeature) == null ? void 0 : _a3.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  startRowOrCellEdit(t, i = null) {
    return this.cellComp ? this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.startRowEditing(t, this) : this.startEditing(t, true, i) : (this.onCellCompAttachedFuncs.push(() => {
      this.startRowOrCellEdit(t, i);
    }), true);
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return { rowIndex: this.cellPosition.rowIndex, rowPinned: this.cellPosition.rowPinned };
  }
  updateRangeBordersIfRangeCount() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
  }
  onCellSelectionChanged() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onCellSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(t = false) {
    this.beans.focusService.setFocusedCell({ rowIndex: this.getCellPosition().rowIndex, column: this.column, rowPinned: this.rowNode.rowPinned, forceBrowserFocus: t });
  }
  onRowIndexChanged() {
    this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onCellSelectionChanged();
  }
  onSuppressCellFocusChanged(t) {
    this.eGui && Oe(this.eGui, "tabindex", t ? void 0 : -1);
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp) return;
    const t = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(Wd, t);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp) return;
    const t = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(zd, t);
  }
  onCellFocused(t) {
    if (this.beans.focusService.isCellFocusSuppressed()) return;
    const i = this.beans.focusService.isCellFocused(this.cellPosition);
    if (!this.cellComp) {
      i && (t == null ? void 0 : t.forceBrowserFocus) && (this.focusEventToRestore = t);
      return;
    }
    if (this.focusEventToRestore = void 0, this.cellComp.addOrRemoveCssClass(Bd, i), i && t && t.forceBrowserFocus) {
      let o = this.cellComp.getFocusableElement();
      if (this.editing) {
        const r = this.beans.focusService.findFocusableElements(o, null, true);
        r.length && (o = r[0]);
      }
      o.focus({ preventScroll: !!t.preventScrollOnBrowserFocus });
    }
    const s = this.beans.gos.get("editType") === "fullRow";
    !i && !s && this.editing && this.stopRowOrCellEdit(), i && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    this.cellPosition = { rowIndex: this.rowNode.rowIndex, rowPinned: Je(this.rowNode.rowPinned), column: this.column };
  }
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(Hd, true), this.cellComp.addOrRemoveCssClass(_d, true);
    const t = this.column.isAutoHeight() == true;
    this.cellComp.addOrRemoveCssClass(Nd, t), this.cellComp.addOrRemoveCssClass(Vd, !t);
  }
  onColumnHover() {
    if (!this.cellComp || !this.beans.gos.get("columnHoverHighlight")) return;
    const t = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(Ud, t);
  }
  onColDefChanged() {
    var _a3;
    if (!this.cellComp) return;
    this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing ? (_a3 = this.beans.editService) == null ? void 0 : _a3.handleColDefChanged(this) : this.refreshOrDestroyCell({ forceRefresh: true, suppressFlash: true });
  }
  setWrapText() {
    const t = this.column.getColDef().wrapText == true;
    this.cellComp.addOrRemoveCssClass(Kd, t);
  }
  dispatchCellContextMenuEvent(t) {
    const i = this.column.getColDef(), s = this.createEvent(t, "cellContextMenu");
    this.beans.eventService.dispatchEvent(s), i.onCellContextMenu && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        i.onCellContextMenu(s);
      });
    }, 0);
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [], this.onCellEditorAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    const t = new Rd();
    return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
  }
  createDndSource() {
    const t = new Fd(this.rowNode, this.column, this.eGui);
    return this.beans.context.createBean(t), t;
  }
  registerRowDragger(t, i, s) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(t, i);
      return;
    }
    const o = this.createRowDragComp(t, i, s);
    o && (this.customRowDragComp = o, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(o), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(t, i, s) {
    const o = this.beans.gos.get("pagination"), r = this.beans.gos.get("rowDragManaged"), n = Q(this.beans.gos);
    if (r) {
      if (!n) {
        F("managed row dragging is only allowed in the Client Side Row Model");
        return;
      }
      if (o) {
        F("managed row dragging is not possible when doing pagination");
        return;
      }
    }
    const l = new zs(() => this.value, this.rowNode, this.column, t, i, s);
    return this.beans.context.createBean(l), l;
  }
  setSuppressRefreshCell(t) {
    this.suppressRefreshCell = t;
  }
  getEditCompDetails() {
    return this.editCompDetails;
  }
  onCellEditorAttached(t) {
    this.onCellEditorAttachedFuncs.push(t);
  }
  cellEditorAttached() {
    this.onCellEditorAttachedFuncs.forEach((t) => t()), this.onCellEditorAttachedFuncs = [];
  }
};
_n.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var bt = _n, jd = 0, Un = class Ys extends R {
  constructor(t, i, s, o, r) {
    var _a3;
    super(), this.allRowGuis = [], this.active = true, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = { left: false, center: false, right: false, fullWidth: false }, this.fadeInAnimation = { left: false, center: false, right: false, fullWidth: false }, this.rowDragComps = [], this.lastMouseDownOnDragger = false, this.emptyStyle = {}, this.updateColumnListsPending = false, this.rowId = null, this.businessKeySanitised = null, this.beans = i, this.gos = i.gos, this.rowNode = t, this.paginationPage = ((_a3 = i.paginationService) == null ? void 0 : _a3.getCurrentPage()) ?? 0, this.useAnimationFrameForCreate = o, this.printLayout = r, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = t.id + "-" + jd++, this.rowId = Ke(t.id), this.initRowBusinessKey(), this.rowFocused = i.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = i.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.setAnimateFlags(s), this.rowStyles = this.processStylesFromGridOptions(), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function") return;
    const t = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = Ke(t);
  }
  getRowId() {
    return this.rowId;
  }
  getRowStyles() {
    return this.rowStyles;
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  updateGui(t, i) {
    t === "left" ? this.leftGui = i : t === "right" ? this.rightGui = i : t === "fullWidth" ? this.fullWidthGui = i : this.centerGui = i;
  }
  setComp(t, i, s, o) {
    o = Si(this, this.beans.context, o);
    const r = { rowComp: t, element: i, containerType: s, compBean: o };
    this.allRowGuis.push(r), this.updateGui(s, r), this.initialiseRowComp(r), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(t) {
    this.allRowGuis = this.allRowGuis.filter((i) => i.containerType !== t), this.updateGui(t, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(t) {
    const i = t ? "none" : "";
    this.allRowGuis.forEach((s) => s.element.style.display = i);
  }
  initialiseRowComp(t) {
    const i = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.listenOnDomOrder(t), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights(), this.onRowHeightChanged(t), this.updateRowIndexes(t), this.setFocusedClasses(t), this.setStylesFromGridOptions(false, t), Wi(i) && this.rowNode.selectable && this.onRowSelected(t), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const s = t.rowComp;
    this.getInitialRowClasses(t.containerType).forEach((r) => s.addOrRemoveCssClass(r, true)), this.executeSlideAndFadeAnimations(t), this.rowNode.group && $i(t.element, this.rowNode.expanded == true), this.setRowCompRowId(s), this.setRowCompRowBusinessKey(s), Et(i, t.element, Ys.DOM_DATA_KEY_ROW_CTRL, this), t.compBean.addDestroyFunc(() => Et(i, t.element, Ys.DOM_DATA_KEY_ROW_CTRL, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(this.addHoverFunctionality.bind(this, t), this.rowNode.rowIndex, "createTasksP2") : this.addHoverFunctionality(t), this.isFullWidth() && this.setupFullWidth(t), i.get("rowDragEntireRow") && this.addRowDraggerToRow(t), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
      this.isAlive() && t.rowComp.addOrRemoveCssClass("ag-after-created", true);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(t) {
    this.businessKeySanitised != null && t.setRowBusinessKey(this.businessKeySanitised);
  }
  getBusinessKey() {
    return this.businessKeySanitised;
  }
  setRowCompRowId(t) {
    this.rowId = Ke(this.rowNode.id), this.rowId != null && t.setRowId(this.rowId);
  }
  executeSlideAndFadeAnimations(t) {
    const { containerType: i } = t;
    this.slideInAnimation[i] && (Bo(() => {
      this.onTopChanged();
    }), this.slideInAnimation[i] = false), this.fadeInAnimation[i] && (Bo(() => {
      t.rowComp.addOrRemoveCssClass("ag-opacity-zero", false);
    }), this.fadeInAnimation[i] = false);
  }
  addRowDraggerToRow(t) {
    if (et(this.gos)) {
      F("Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `cellSelection: true`");
      return;
    }
    const i = this.beans.localeService.getLocaleTextFunc(), s = new zs(() => `1 ${i("rowDragRow", "row")}`, this.rowNode, void 0, t.element, void 0, true), o = this.createBean(s, this.beans.context);
    this.rowDragComps.push(o), t.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((r) => r !== o), this.destroyBean(o, this.beans.context);
    });
  }
  setupFullWidth(t) {
    const i = this.getPinnedForContainer(t.containerType);
    if (this.rowType == "FullWidthDetail" && !this.gos.assertModuleRegistered("@ag-grid-enterprise/master-detail", "cell renderer 'agDetailCellRenderer' (for master detail)")) return;
    const s = this.createFullWidthCompDetails(t.element, i);
    t.rowComp.showFullWidth(s);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderers() {
    var _a3, _b;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((t) => {
      var _a4;
      return (_a4 = t == null ? void 0 : t.rowComp) == null ? void 0 : _a4.getFullWidthCellRenderer();
    }) : [(_b = (_a3 = this.fullWidthGui) == null ? void 0 : _a3.rowComp) == null ? void 0 : _b.getFullWidthCellRenderer()];
  }
  getCellElement(t) {
    const i = this.getCellCtrl(t);
    return i ? i.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    const t = this.gos.getCallback("processRowPostCreate");
    if (!t || !this.areAllContainersReady()) return;
    const i = { eRow: this.centerGui.element, ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0, ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0, node: this.rowNode, rowIndex: this.rowNode.rowIndex, addRenderedRowListener: this.addEventListener.bind(this) };
    t(i);
  }
  areAllContainersReady() {
    const t = !!this.leftGui || !this.beans.visibleColsService.isPinningLeft(), i = !!this.centerGui, s = !!this.rightGui || !this.beans.visibleColsService.isPinningRight();
    return t && i && s;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail) return true;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this.rowNode }) : false;
  }
  setRowType() {
    const t = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents"), i = this.isNodeFullWidthCell(), s = this.gos.get("masterDetail") && this.rowNode.detail, o = this.beans.columnModel.isPivotMode(), n = !!this.rowNode.group && !this.rowNode.footer && ss(this.gos, o);
    t ? this.rowType = "FullWidthLoading" : s ? this.rowType = "FullWidthDetail" : i ? this.rowType = "FullWidth" : n ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(t = false, i = false) {
    if (this.isFullWidth()) return;
    if (t || this.gos.get("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(i);
      return;
    }
    this.updateColumnListsPending || (this.beans.animationFrameService.createTask(() => {
      this.active && this.updateColumnListsImpl(true);
    }, this.rowNode.rowIndex, "createTasksP1"), this.updateColumnListsPending = true);
  }
  createCellCtrls(t, i, s = null) {
    const o = { list: [], map: {} }, r = (l, a, c) => {
      c != null ? o.list.splice(c, 0, a) : o.list.push(a), o.map[l] = a;
    }, n = [];
    for (const l of i) {
      const a = l.getInstanceId();
      let c = t.map[a];
      c || (c = new bt(l, this.rowNode, this.beans, this)), r(a, c);
    }
    for (const l of t.list) {
      const a = l.getColumn().getInstanceId();
      if (o.map[a] != null) continue;
      !this.isCellEligibleToBeRemoved(l, s) ? n.push([a, l]) : l.destroy();
    }
    if (n.length) for (const [l, a] of n) {
      const c = o.list.findIndex((d) => d.getColumn().getLeft() > a.getColumn().getLeft()), u = c === -1 ? void 0 : Math.max(c - 1, 0);
      r(l, a, u);
    }
    return o;
  }
  updateColumnListsImpl(t) {
    this.updateColumnListsPending = false, this.createAllCellCtrls(), this.setCellCtrls(t);
  }
  setCellCtrls(t) {
    this.allRowGuis.forEach((i) => {
      const s = this.getCellCtrlsForContainer(i.containerType);
      i.rowComp.setCellCtrls(s, t);
    });
  }
  getCellCtrlsForContainer(t) {
    switch (t) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const t = this.beans.columnViewportService, i = this.beans.visibleColsService;
    if (this.printLayout) this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, i.getAllCols()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const s = t.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, s);
      const o = i.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, o, "left");
      const r = i.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, r, "right");
    }
  }
  isCellEligibleToBeRemoved(t, i) {
    if (t.getColumn().getPinned() != i) return true;
    const n = t.isEditing(), l = this.beans.focusService.isCellFocused(t.getCellPosition());
    if (n || l) {
      const c = t.getColumn();
      return !(this.beans.visibleColsService.getAllCols().indexOf(c) >= 0);
    }
    return true;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || he(this.gos, "print");
  }
  listenOnDomOrder(t) {
    const i = () => {
      t.rowComp.setDomOrder(this.getDomOrder());
    };
    t.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], i);
  }
  setAnimateFlags(t) {
    if (this.isSticky() || !t) return;
    const i = E(this.rowNode.oldRowTop), s = this.beans.visibleColsService.isPinningLeft(), o = this.beans.visibleColsService.isPinningRight();
    if (i) {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.slideInAnimation.fullWidth = true;
        return;
      }
      this.slideInAnimation.center = true, this.slideInAnimation.left = s, this.slideInAnimation.right = o;
    } else {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.fadeInAnimation.fullWidth = true;
        return;
      }
      this.fadeInAnimation.center = true, this.fadeInAnimation.left = s, this.fadeInAnimation.right = o;
    }
  }
  isEditing() {
    return this.editingRow;
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const t = (l, a) => l ? l.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(l.element, a).params) : true, i = t(this.fullWidthGui, null), s = t(this.centerGui, null), o = t(this.leftGui, "left"), r = t(this.rightGui, "right");
    return i && s && o && r;
  }
  addListeners() {
    this.addManagedListeners(this.rowNode, { heightChanged: () => this.onRowHeightChanged(), rowSelected: () => this.onRowSelected(), rowIndexChanged: this.onRowIndexChanged.bind(this), topChanged: this.onTopChanged.bind(this), expandedChanged: this.updateExpandedCss.bind(this), hasChildrenChanged: this.updateExpandedCss.bind(this) }), this.rowNode.detail && this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(this.rowNode, { dataChanged: this.onRowNodeDataChanged.bind(this), cellChanged: this.postProcessCss.bind(this), rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this), draggingChanged: this.postProcessRowDragging.bind(this), uiLevelChanged: this.onUiLevelChanged.bind(this) }), this.addManagedListeners(this.beans.eventService, { paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this), heightScaleChanged: this.onTopChanged.bind(this), displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this), virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this), cellFocused: this.onCellFocusChanged.bind(this), cellFocusCleared: this.onCellFocusChanged.bind(this), paginationChanged: this.onPaginationChanged.bind(this), modelUpdated: this.refreshFirstAndLastRowStyles.bind(this), columnMoved: () => this.updateColumnLists() }), this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context));
    }), this.addManagedPropertyListeners(["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"], this.postProcessCss.bind(this)), this.addManagedPropertyListener("rowDragEntireRow", () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((i) => {
          this.addRowDraggerToRow(i);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, { rowIndexChanged: () => {
      this.getAllCellCtrls().forEach((t) => t.onRowIndexChanged());
    }, cellChanged: (t) => {
      this.getAllCellCtrls().forEach((i) => i.onCellChanged(t));
    } });
  }
  onRowNodeDataChanged(t) {
    if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach((s) => s.refreshCell({ suppressFlash: !t.update, newData: !t.update })), this.allRowGuis.forEach((s) => {
      this.setRowCompRowId(s.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(s.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(true), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const t = this.rowNode.highlighted;
    this.allRowGuis.forEach((i) => {
      const s = t === 0, o = t === 1;
      i.rowComp.addOrRemoveCssClass("ag-row-highlight-above", s), i.rowComp.addOrRemoveCssClass("ag-row-highlight-below", o);
    });
  }
  postProcessRowDragging() {
    const t = this.rowNode.dragging;
    this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-dragging", t));
  }
  updateExpandedCss() {
    const t = this.rowNode.isExpandable(), i = this.rowNode.expanded == true;
    this.allRowGuis.forEach((s) => {
      s.rowComp.addOrRemoveCssClass("ag-row-group", t), s.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && i), s.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !i), $i(s.element, t && i);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(true), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(false, true);
  }
  getRowPosition() {
    return { rowPinned: Je(this.rowNode.rowPinned), rowIndex: this.rowNode.rowIndex };
  }
  findFullWidthRowGui(t) {
    return this.allRowGuis.find((i) => i.element.contains(t));
  }
  onKeyboardNavigate(t) {
    const i = this.findFullWidthRowGui(t.target);
    if (!((i ? i.element : null) === t.target)) return;
    const r = this.rowNode, n = this.beans.focusService.getFocusedCell(), l = { rowIndex: r.rowIndex, rowPinned: r.rowPinned, column: (n == null ? void 0 : n.column) ?? this.getColumnForFullWidth(i) };
    this.beans.navigationService.navigateToNextCell(t, t.key, l, true), t.preventDefault();
  }
  onTabKeyDown(t) {
    if (t.defaultPrevented || Ze(t)) return;
    const i = this.allRowGuis.find((a) => a.element.contains(t.target)), s = i ? i.element : null, o = s === t.target, r = te(this.gos);
    let n = false;
    s && r && (n = s.contains(r) && r.classList.contains("ag-cell"));
    let l = null;
    !o && !n && (l = this.beans.focusService.findNextFocusableElement(s, false, t.shiftKey)), (this.isFullWidth() && o || !l) && this.beans.navigationService.onTabKeyDown(this, t);
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var _a3;
    const t = (_a3 = this.allRowGuis.find((i) => je(i.element))) == null ? void 0 : _a3.element;
    return t ? t.getBoundingClientRect().top : 0;
  }
  onSuppressCellFocusChanged(t) {
    const i = this.isFullWidth() && t ? void 0 : -1;
    this.allRowGuis.forEach((s) => {
      Oe(s.element, "tabindex", i);
    });
  }
  onFullWidthRowFocused(t) {
    var _a3;
    const i = this.rowNode, s = t ? this.isFullWidth() && t.rowIndex === i.rowIndex && t.rowPinned == i.rowPinned : false, o = this.fullWidthGui ? this.fullWidthGui.element : (_a3 = this.centerGui) == null ? void 0 : _a3.element;
    o && (o.classList.toggle("ag-full-width-focus", s), s && (t == null ? void 0 : t.forceBrowserFocus) && o.focus({ preventScroll: true }));
  }
  recreateCell(t) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), t.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(t, i) {
    const s = { list: [], map: {} };
    return t.list.forEach((o) => {
      o !== i && (s.list.push(o), s.map[o.getColumn().getInstanceId()] = o);
    }), s;
  }
  onMouseEvent(t, i) {
    switch (t) {
      case "dblclick":
        this.onRowDblClick(i);
        break;
      case "click":
        this.onRowClick(i);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(i);
        break;
    }
  }
  createRowEvent(t, i) {
    return this.gos.addGridCommonParams({ type: t, node: this.rowNode, data: this.rowNode.data, rowIndex: this.rowNode.rowIndex, rowPinned: this.rowNode.rowPinned, event: i });
  }
  createRowEventWithSource(t, i) {
    const s = this.createRowEvent(t, i);
    return s.source = this, s;
  }
  onRowDblClick(t) {
    Ze(t) || this.beans.eventService.dispatchEvent(this.createRowEventWithSource("rowDoubleClicked", t));
  }
  getColumnForFullWidth(t) {
    const { visibleColsService: i } = this.beans;
    switch (t == null ? void 0 : t.containerType) {
      case "center":
        return i.getCenterCols()[0];
      case "left":
        return i.getLeftCols()[0];
      case "right":
        return i.getRightCols()[0];
      default:
        return i.getAllCols()[0];
    }
  }
  onRowMouseDown(t) {
    if (this.lastMouseDownOnDragger = Vt(t.target, "ag-row-drag", 3), !this.isFullWidth()) return;
    const i = this.rowNode;
    this.beans.rangeService && this.beans.rangeService.removeAllCellRanges();
    const s = this.findFullWidthRowGui(t.target), o = s == null ? void 0 : s.element, r = t.target;
    let n = true;
    o && o.contains(r) && ao(r) && (n = false), this.beans.focusService.setFocusedCell({ rowIndex: i.rowIndex, column: this.getColumnForFullWidth(s), rowPinned: i.rowPinned, forceBrowserFocus: n });
  }
  onRowClick(t) {
    if (Ze(t) || this.lastMouseDownOnDragger) return;
    const { gos: s } = this;
    this.beans.eventService.dispatchEvent(this.createRowEventWithSource("rowClicked", t));
    const o = t.ctrlKey || t.metaKey, r = t.shiftKey, n = this.rowNode.isSelected(), l = Dt(s), a = _o(s), c = zl(s);
    if (l && this.rowNode.group || this.isRowSelectionBlocked() || !c && !n || !a && n) return;
    const u = _l(s), d = "rowClicked";
    if (n) u ? this.rowNode.setSelectedParams({ newValue: false, event: t, source: d }) : o ? a && this.rowNode.setSelectedParams({ newValue: false, event: t, source: d }) : c && this.rowNode.setSelectedParams({ newValue: true, clearSelection: !r, rangeSelect: r, event: t, source: d });
    else {
      const h = u ? false : !o;
      this.rowNode.setSelectedParams({ newValue: true, clearSelection: h, rangeSelect: r, event: t, source: d });
    }
  }
  isRowSelectionBlocked() {
    return !this.rowNode.selectable || !!this.rowNode.rowPinned || !Wi(this.gos);
  }
  setupDetailRowAutoHeight(t) {
    if (this.rowType !== "FullWidthDetail" || !this.gos.get("detailRowAutoHeight")) return;
    const i = () => {
      const o = t.clientHeight;
      if (o != null && o > 0) {
        const r = () => {
          this.rowNode.setRowHeight(o), (Q(this.gos) || it(this.gos)) && this.beans.rowModel.onRowHeightChanged();
        };
        window.setTimeout(r, 0);
      }
    }, s = this.beans.resizeObserverService.observeResize(t, i);
    this.addDestroyFunc(s), i();
  }
  createFullWidthCompDetails(t, i) {
    const { gos: s, rowNode: o } = this, r = s.addGridCommonParams({ fullWidth: true, data: o.data, node: o, value: o.key, valueFormatted: o.key, eGridCell: t, eParentOfValue: t, pinned: i, addRenderedRowListener: this.addEventListener.bind(this), registerRowDragger: (l, a, c, u) => this.addFullWidthRowDragging(l, a, c, u), setTooltip: (l, a) => this.refreshRowTooltip(l, a) }), n = this.beans.userComponentFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return n.getFullWidthDetailCellRendererDetails(r);
      case "FullWidthGroup":
        return n.getFullWidthGroupCellRendererDetails(r);
      case "FullWidthLoading":
        return n.getFullWidthLoadingCellRendererDetails(r);
      default:
        return n.getFullWidthCellRendererDetails(r);
    }
  }
  refreshRowTooltip(t, i) {
    if (!this.fullWidthGui) return;
    const s = { getGui: () => this.fullWidthGui.element, getTooltipValue: () => t, getLocation: () => "fullWidthRow", shouldDisplayTooltip: i };
    this.tooltipFeature && this.destroyBean(this.tooltipFeature, this.beans.context), this.tooltipFeature = this.createBean(new $t(s, this.beans));
  }
  addFullWidthRowDragging(t, i, s = "", o) {
    if (!this.isFullWidth()) return;
    const r = new zs(() => s, this.rowNode, void 0, t, i, o);
    this.createBean(r, this.beans.context), this.addDestroyFunc(() => {
      this.destroyBean(r, this.beans.context);
    });
  }
  onUiLevelChanged() {
    const t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != t) {
      const i = "ag-row-level-" + t, s = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((o) => {
        o.rowComp.addOrRemoveCssClass(i, true), o.rowComp.addOrRemoveCssClass(s, false);
      });
    }
    this.rowLevel = t;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const t = this.isFirstRowOnPage(), i = this.isLastRowOnPage();
    this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass("ag-row-first", t))), this.lastRowOnPage !== i && (this.lastRowOnPage = i, this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass("ag-row-last", i)));
  }
  stopEditing(t = false) {
    var _a3;
    this.stoppingRowEdit || ((_a3 = this.beans.rowEditService) == null ? void 0 : _a3.stopEditing(this, t));
  }
  setInlineEditingCss() {
    const t = this.editingRow || this.getAllCellCtrls().some((i) => i.isEditing());
    this.allRowGuis.forEach((i) => {
      i.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), i.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
    });
  }
  setEditingRow(t) {
    this.editingRow = t;
  }
  startRowEditing(t = null, i = null, s = null) {
    var _a3;
    return this.editingRow ? true : ((_a3 = this.beans.rowEditService) == null ? void 0 : _a3.startEditing(this, t, i, s)) ?? true;
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    const t = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    !t || !t.length || t.forEach((i) => {
      this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass(i, true));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, (t) => {
      this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(t, true));
    }, (t) => {
      this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(t, false));
    });
  }
  setStylesFromGridOptions(t, i) {
    t && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(i, (s) => s.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(t) {
    return t === "left" || t === "right" ? t : null;
  }
  getInitialRowClasses(t) {
    const i = this.getPinnedForContainer(t), s = { rowNode: this.rowNode, rowFocused: this.rowFocused, fadeRowIn: this.fadeInAnimation[t], rowIsEven: this.rowNode.rowIndex % 2 === 0, rowLevel: this.rowLevel, fullWidthRow: this.isFullWidth(), firstRowOnPage: this.isFirstRowOnPage(), lastRowOnPage: this.isLastRowOnPage(), printLayout: this.printLayout, expandable: this.rowNode.isExpandable(), pinned: i };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(s);
  }
  processStylesFromGridOptions() {
    const t = this.gos.get("rowStyle");
    if (t && typeof t == "function") {
      F("rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const i = this.gos.getCallback("getRowStyle");
    let s;
    if (i) {
      const o = { data: this.rowNode.data, node: this.rowNode, rowIndex: this.rowNode.rowIndex };
      s = i(o);
    }
    return s || t ? Object.assign({}, t, s) : this.emptyStyle;
  }
  onRowSelected(t) {
    const i = !!this.rowNode.isSelected();
    this.forEachGui(t, (s) => {
      s.rowComp.addOrRemoveCssClass("ag-row-selected", i), ji(s.element, i), s.element.contains(te(this.gos)) && (s === this.centerGui || s === this.fullWidthGui) && this.announceDescription();
    });
  }
  announceDescription() {
    if (this.isRowSelectionBlocked()) return;
    const t = this.rowNode.isSelected();
    if (t && !_o(this.gos)) return;
    const s = this.beans.localeService.getLocaleTextFunc()(t ? "ariaRowDeselect" : "ariaRowSelect", `Press SPACE to ${t ? "deselect" : "select"} this row.`);
    this.beans.ariaAnnouncementService.announceValue(s, "rowSelection");
  }
  addHoverFunctionality(t) {
    if (!this.active) return;
    const { element: i, compBean: s } = t, { rowNode: o, beans: r, gos: n } = this;
    s.addManagedListeners(i, { mouseenter: () => o.onMouseEnter(), mouseleave: () => o.onMouseLeave() }), s.addManagedListeners(o, { mouseEnter: () => {
      !r.dragService.isDragging() && !n.get("suppressRowHoverHighlight") && (i.classList.add("ag-row-hover"), o.setHovered(true));
    }, mouseLeave: () => {
      i.classList.remove("ag-row-hover"), o.setHovered(false);
    } });
  }
  roundRowTopToBounds(t) {
    const i = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition(), s = this.applyPaginationOffset(i.top, true) - 100, o = this.applyPaginationOffset(i.bottom, true) + 100;
    return Math.min(Math.max(s, t), o);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(t, i) {
    t ? i(t) : this.allRowGuis.forEach(i);
  }
  onRowHeightChanged(t) {
    if (this.rowNode.rowHeight == null) return;
    const i = this.rowNode.rowHeight, s = this.beans.environment.getDefaultRowHeight(), r = Fr(this.gos) ? ut(this.gos, this.rowNode).height : void 0, n = r ? `${Math.min(s, r) - 2}px` : void 0;
    this.forEachGui(t, (l) => {
      l.element.style.height = `${i}px`, n && l.element.style.setProperty("--ag-line-height", n);
    });
  }
  addEventListener(t, i) {
    super.addEventListener(t, i);
  }
  removeEventListener(t, i) {
    super.removeEventListener(t, i);
  }
  destroyFirstPass(t = false) {
    if (this.active = false, !t && Nt(this.gos) && !this.isSticky()) if (this.rowNode.rowTop != null) {
      const o = this.roundRowTopToBounds(this.rowNode.rowTop);
      this.setRowTop(o);
    } else this.allRowGuis.forEach((o) => o.rowComp.addOrRemoveCssClass("ag-opacity-zero", true));
    this.rowNode.setHovered(false);
    const i = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(i), this.beans.eventService.dispatchEvent(i), super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0, this.stopEditing();
    const t = (i) => (i.list.forEach((s) => s.destroy()), { list: [], map: {} });
    this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
  }
  setFocusedClasses(t) {
    this.forEachGui(t, (i) => {
      i.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), i.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(false);
  }
  onPaginationChanged() {
    var _a3;
    const t = ((_a3 = this.beans.paginationService) == null ? void 0 : _a3.getCurrentPage()) ?? 0;
    this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  applyPaginationOffset(t, i = false) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky) return t;
    const s = this.beans.pageBoundsService.getPixelOffset();
    return t + s * (i ? 1 : -1);
  }
  setRowTop(t) {
    if (!this.printLayout && E(t)) {
      const i = this.applyPaginationOffset(t), r = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? i : this.beans.rowContainerHeightService.getRealPixelPosition(i)}px`;
      this.setRowTopStyle(r);
    }
  }
  getInitialRowTop(t) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(t) : void 0;
  }
  getInitialTransform(t) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(t)})`;
  }
  getInitialRowTopShared(t) {
    if (this.printLayout) return "";
    const i = this.rowNode;
    let s;
    if (this.isSticky()) s = i.stickyRowTop;
    else {
      const o = this.slideInAnimation[t] ? this.roundRowTopToBounds(i.oldRowTop) : i.rowTop, r = this.applyPaginationOffset(o);
      s = i.isRowPinned() ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r);
    }
    return s + "px";
  }
  setRowTopStyle(t) {
    this.allRowGuis.forEach((i) => this.suppressRowTransform ? i.rowComp.setTop(t) : i.rowComp.setTransform(`translateY(${t})`));
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(t) {
    let i = null;
    return this.getAllCellCtrls().forEach((s) => {
      s.getColumn() == t && (i = s);
    }), i != null || this.getAllCellCtrls().forEach((s) => {
      s.getColSpanningList().indexOf(t) >= 0 && (i = s);
    }), i;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  getRowIndex() {
    return this.rowNode.getRowIndexString();
  }
  updateRowIndexes(t) {
    var _a3;
    const i = this.rowNode.getRowIndexString();
    if (i === null) return;
    const s = this.beans.headerNavigationService.getHeaderRowCount() + (((_a3 = this.beans.filterManager) == null ? void 0 : _a3.getHeaderRowCount()) ?? 0), o = this.rowNode.rowIndex % 2 === 0, r = s + this.rowNode.rowIndex + 1;
    this.forEachGui(t, (n) => {
      n.rowComp.setRowIndex(i), n.rowComp.addOrRemoveCssClass("ag-row-even", o), n.rowComp.addOrRemoveCssClass("ag-row-odd", !o), Aa(n.element, r);
    });
  }
  setStoppingRowEdit(t) {
    this.stoppingRowEdit = t;
  }
};
Un.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var Pt = Un, qd = class extends R {
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.valueService = e.valueService, this.menuService = e.menuService, this.ctrlsService = e.ctrlsService, this.navigationService = e.navigationService, this.focusService = e.focusService, this.undoRedoService = e.undoRedoService, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.rangeService = e.rangeService, this.clipboardService = e.clipboardService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", Or("touchstart") ? "touchstart" : "mousedown"].forEach((i) => {
      const s = this.processMouseEvent.bind(this, i);
      this.addManagedElementListeners(this.element, { [i]: s });
    });
  }
  processMouseEvent(e, t) {
    if (!this.mouseEventService.isEventFromThisGrid(t) || Ze(t)) return;
    const i = this.getRowForEvent(t), s = this.mouseEventService.getRenderedCellForEvent(t);
    e === "contextmenu" ? this.handleContextMenuMouseEvent(t, void 0, i, s) : (s && s.onMouseEvent(e, t), i && i.onMouseEvent(e, t));
  }
  mockContextMenuForIPad() {
    if (!pt()) return;
    const e = new ct(this.element), t = (i) => {
      const s = this.getRowForEvent(i.touchEvent), o = this.mouseEventService.getRenderedCellForEvent(i.touchEvent);
      this.handleContextMenuMouseEvent(void 0, i.touchEvent, s, o);
    };
    this.addManagedListeners(e, { longTap: t }), this.addDestroyFunc(() => e.destroy());
  }
  getRowForEvent(e) {
    let t = e.target;
    for (; t; ) {
      const i = ui(this.gos, t, Pt.DOM_DATA_KEY_ROW_CTRL);
      if (i) return i;
      t = t.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(e, t, i, s) {
    const o = i ? i.getRowNode() : null, r = s ? s.getColumn() : null;
    let n = null;
    if (r) {
      const c = e || t;
      s.dispatchCellContextMenuEvent(c ?? null), n = this.valueService.getValue(r, o);
    }
    const l = this.ctrlsService.getGridBodyCtrl(), a = s ? s.getGui() : l.getGridBodyElement();
    this.menuService.showContextMenu({ mouseEvent: e, touchEvent: t, rowNode: o, column: r, value: n, anchorToElement: a });
  }
  getControlsForEventTarget(e) {
    return { cellCtrl: Os(this.gos, e, bt.DOM_DATA_KEY_CELL_CTRL), rowCtrl: Os(this.gos, e, Pt.DOM_DATA_KEY_ROW_CTRL) };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: i, rowCtrl: s } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (i ? this.processCellKeyboardEvent(i, e, t) : s && s.isFullWidth() && this.processFullWidthRowKeyboardEvent(s, e, t));
  }
  processCellKeyboardEvent(e, t, i) {
    const s = e.getRowNode(), o = e.getColumn(), r = e.isEditing();
    !_s(this.gos, i, s, o, r) && t === "keydown" && (!r && this.navigationService.handlePageScrollingKey(i) || e.onKeyDown(i), this.doGridOperations(i, e.isEditing()), yn(i) && e.processCharacter(i)), t === "keydown" && this.eventService.dispatchEvent(e.createEvent(i, "cellKeyDown"));
  }
  processFullWidthRowKeyboardEvent(e, t, i) {
    const s = e.getRowNode(), o = this.focusService.getFocusedCell(), r = o && o.column;
    if (!_s(this.gos, i, s, r, false)) {
      const l = i.key;
      if (t === "keydown") switch (l) {
        case y.PAGE_HOME:
        case y.PAGE_END:
        case y.PAGE_UP:
        case y.PAGE_DOWN:
          this.navigationService.handlePageScrollingKey(i, true);
          break;
        case y.UP:
        case y.DOWN:
          e.onKeyboardNavigate(i);
          break;
        case y.TAB:
          e.onTabKeyDown(i);
          break;
      }
    }
    t === "keydown" && this.eventService.dispatchEvent(e.createRowEvent("cellKeyDown", i));
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !this.mouseEventService.isEventFromThisGrid(e)) return;
    const i = nu(e);
    if (i === y.A) return this.onCtrlAndA(e);
    if (i === y.C) return this.onCtrlAndC(e);
    if (i === y.D) return this.onCtrlAndD(e);
    if (i === y.V) return this.onCtrlAndV(e);
    if (i === y.X) return this.onCtrlAndX(e);
    if (i === y.Y) return this.onCtrlAndY();
    if (i === y.Z) return this.onCtrlAndZ(e);
  }
  onCtrlAndA(e) {
    const { pinnedRowModel: t, rowModel: i, rangeService: s } = this;
    if (s && i.isRowsToRender()) {
      const [o, r] = [t.isEmpty("top"), t.isEmpty("bottom")], n = o ? null : "top";
      let l, a;
      r ? (l = null, a = i.getRowCount() - 1) : (l = "bottom", a = t.getPinnedBottomRowCount() - 1);
      const c = this.visibleColsService.getAllCols();
      if (Me(c)) return;
      s.setCellRange({ rowStartIndex: 0, rowStartPinned: n, rowEndIndex: a, rowEndPinned: l, columnStart: c[0], columnEnd: N(c) });
    }
    e.preventDefault();
  }
  onCtrlAndC(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection")) return;
    const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(e.target);
    (t == null ? void 0 : t.isEditing()) || (i == null ? void 0 : i.isEditing()) || (e.preventDefault(), this.clipboardService.copyToClipboard());
  }
  onCtrlAndX(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) return;
    const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(e.target);
    (t == null ? void 0 : t.isEditing()) || (i == null ? void 0 : i.isEditing()) || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e) {
    const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(e.target);
    (t == null ? void 0 : t.isEditing()) || (i == null ? void 0 : i.isEditing()) || this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard();
  }
  onCtrlAndD(e) {
    this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault();
  }
  onCtrlAndZ(e) {
    !this.gos.get("undoRedoCellEditing") || !this.undoRedoService || (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"));
  }
  onCtrlAndY() {
    var _a3;
    (_a3 = this.undoRedoService) == null ? void 0 : _a3.redo("ui");
  }
}, Yd = class extends R {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({ leftPinnedWidthChanged: this.onPinnedLeftWidthChanged.bind(this) });
  }
  onPinnedLeftWidthChanged() {
    const e = this.pinnedWidthService.getPinnedLeftWidth(), t = e > 0;
    ee(this.element, t), Ne(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
}, Qd = class extends R {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({ rightPinnedWidthChanged: this.onPinnedRightWidthChanged.bind(this) });
  }
  onPinnedRightWidthChanged() {
    const e = this.pinnedWidthService.getPinnedRightWidth(), t = e > 0;
    ee(this.element, t), Ne(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
}, Mi = (e) => e.getTopRowCtrls(), xi = (e) => e.getStickyTopRowCtrls(), Ai = (e) => e.getStickyBottomRowCtrls(), Ti = (e) => e.getBottomRowCtrls(), Ii = (e) => e.getCentreRowCtrls(), Xd = { center: { type: "center", container: "ag-center-cols-container", viewport: "ag-center-cols-viewport", getRowCtrls: Ii }, left: { type: "left", container: "ag-pinned-left-cols-container", pinnedType: "left", getRowCtrls: Ii }, right: { type: "right", container: "ag-pinned-right-cols-container", pinnedType: "right", getRowCtrls: Ii }, fullWidth: { type: "fullWidth", container: "ag-full-width-container", fullWidth: true, getRowCtrls: Ii }, topCenter: { type: "center", container: "ag-floating-top-container", viewport: "ag-floating-top-viewport", getRowCtrls: Mi }, topLeft: { type: "left", container: "ag-pinned-left-floating-top", pinnedType: "left", getRowCtrls: Mi }, topRight: { type: "right", container: "ag-pinned-right-floating-top", pinnedType: "right", getRowCtrls: Mi }, topFullWidth: { type: "fullWidth", container: "ag-floating-top-full-width-container", fullWidth: true, getRowCtrls: Mi }, stickyTopCenter: { type: "center", container: "ag-sticky-top-container", viewport: "ag-sticky-top-viewport", getRowCtrls: xi }, stickyTopLeft: { type: "left", container: "ag-pinned-left-sticky-top", pinnedType: "left", getRowCtrls: xi }, stickyTopRight: { type: "right", container: "ag-pinned-right-sticky-top", pinnedType: "right", getRowCtrls: xi }, stickyTopFullWidth: { type: "fullWidth", container: "ag-sticky-top-full-width-container", fullWidth: true, getRowCtrls: xi }, stickyBottomCenter: { type: "center", container: "ag-sticky-bottom-container", viewport: "ag-sticky-bottom-viewport", getRowCtrls: Ai }, stickyBottomLeft: { type: "left", container: "ag-pinned-left-sticky-bottom", pinnedType: "left", getRowCtrls: Ai }, stickyBottomRight: { type: "right", container: "ag-pinned-right-sticky-bottom", pinnedType: "right", getRowCtrls: Ai }, stickyBottomFullWidth: { type: "fullWidth", container: "ag-sticky-bottom-full-width-container", fullWidth: true, getRowCtrls: Ai }, bottomCenter: { type: "center", container: "ag-floating-bottom-container", viewport: "ag-floating-bottom-viewport", getRowCtrls: Ti }, bottomLeft: { type: "left", container: "ag-pinned-left-floating-bottom", pinnedType: "left", getRowCtrls: Ti }, bottomRight: { type: "right", container: "ag-pinned-right-floating-bottom", pinnedType: "right", getRowCtrls: Ti }, bottomFullWidth: { type: "fullWidth", container: "ag-floating-bottom-full-width-container", fullWidth: true, getRowCtrls: Ti } };
function Ht(e) {
  return Xd[e];
}
var Jd = ["topCenter", "topLeft", "topRight"], Zd = ["bottomCenter", "bottomLeft", "bottomRight"], eh = ["center", "left", "right"], th = ["center", "left", "right", "fullWidth"], ih = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], sh = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], oh = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], Kn = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], $n = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], rh = [...Kn, "stickyTopFullWidth", ...$n, "stickyBottomFullWidth"], nh = [...Jd, ...Zd, ...eh, ...Kn, ...$n], lh = class extends R {
  constructor(e) {
    super(), this.visible = true, this.EMPTY_CTRLS = [], this.name = e, this.options = Ht(e);
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService, this.columnViewportService = e.columnViewportService, this.resizeObserverService = e.resizeObserverService, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new wd(this)), this.addManagedEventListeners({ stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this) });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.ctrlsService.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(e, t, i) {
    this.comp = e, this.eContainer = t, this.eViewport = i, this.createManagedBean(new qd(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder();
    const s = () => this.onPinnedWidthChanged();
    this.forContainers(sh, () => {
      this.pinnedWidthFeature = this.createManagedBean(new Yd(this.eContainer)), this.addManagedEventListeners({ leftPinnedWidthChanged: s });
    }), this.forContainers(oh, () => {
      this.pinnedWidthFeature = this.createManagedBean(new Qd(this.eContainer)), this.addManagedEventListeners({ rightPinnedWidthChanged: s });
    }), this.forContainers(th, () => this.createManagedBean(new zn(this.eContainer, this.name === "center" ? i : void 0))), this.forContainers(nh, () => this.createManagedBean(new yd(this.eContainer))), this.forContainers(ih, () => this.createManagedBean(new Eo((o) => this.comp.setContainerWidth(`${o}px`)))), this.visible = this.isContainerVisible(), this.addListeners(), this.registerWithCtrlsService();
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewportElement(), { scroll: e });
  }
  addListeners() {
    this.addManagedEventListeners({ displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this), displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this), displayedRowsChanged: (e) => this.onDisplayedRowsChanged(e.afterScroll) }), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if (rh.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(true);
      return;
    }
    const t = () => {
      const i = this.gos.get("ensureDomOrder"), s = he(this.gos, "print");
      this.comp.setDomOrder(i || s);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  addPreventScrollWhileDragging() {
    const e = (t) => {
      this.dragService.isDragging() && t.cancelable && t.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", e, { passive: false }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", e));
  }
  onHorizontalViewportChanged(e = false) {
    const t = this.getCenterWidth(), i = this.getCenterViewportScrollLeft();
    this.columnViewportService.setScrollPosition(t, i, e);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return yi(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return Qi(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = this.resizeObserverService.observeResize(this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return en(this.eViewport);
  }
  getViewportScrollLeft() {
    return Qi(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || za(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setHorizontalScroll(e) {
    this.comp.setHorizontalScroll(e);
  }
  getHScrollPosition() {
    return { left: this.eViewport.scrollLeft, right: this.eViewport.scrollLeft + this.eViewport.offsetWidth };
  }
  setCenterViewportScrollLeft(e) {
    Xi(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = false) {
    const t = this.options.getRowCtrls(this.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const i = he(this.gos, "print"), o = this.gos.get("embedFullWidthRows") || i, r = t.filter((n) => {
      const l = n.isFullWidth();
      return this.options.fullWidth ? !o && l : o || !l;
    });
    this.comp.setRowCtrls({ rowCtrls: r, useFlushSync: e });
  }
}, ah = "ag-force-vertical-scroll", ch = "ag-selectable", uh = "ag-column-moving", dh = class extends R {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.menuService = e.menuService, this.headerNavigationService = e.headerNavigationService, this.dragAndDropService = e.dragAndDropService, this.pinnedRowModel = e.pinnedRowModel, this.rowRenderer = e.rowRenderer, this.popupService = e.popupService, this.mouseEventService = e.mouseEventService, this.rowModel = e.rowModel, this.filterManager = e.filterManager, this.environment = e.environment;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(e, t, i, s, o, r, n) {
    var _a3;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = i, this.eTop = s, this.eBottom = o, this.eStickyTop = r, this.eStickyBottom = n, this.eCenterColsViewport = i.querySelector(`.${Ht("center").viewport}`), this.eFullWidthContainer = i.querySelector(`.${Ht("fullWidth").container}`), this.eStickyTopFullWidthContainer = r.querySelector(`.${Ht("stickyTopFullWidth").container}`), this.eStickyBottomFullWidthContainer = n.querySelector(`.${Ht("stickyBottomFullWidth").container}`), this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener("enableCellTextSelection", (l) => this.setCellTextSelection(l.currentValue)), this.createManagedBean(new Mo(this.comp)), this.bodyScrollFeature = this.createManagedBean(new Sd(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([s, i, o, r, n]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.updateScrollingClasses(), (_a3 = this.filterManager) == null ? void 0 : _a3.setupAdvancedFilterHeaderComp(s), this.ctrlsService.register("gridBodyCtrl", this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    const e = this.setFloatingHeights.bind(this);
    this.addManagedEventListeners({ gridColumnsChanged: this.onGridColumnsChanged.bind(this), scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this), scrollGapChanged: this.onScrollGapChanged.bind(this), pinnedRowDataChanged: e, pinnedHeightChanged: e, headerHeightChanged: this.onHeaderHeightChanged.bind(this) });
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, { focusin: (i) => {
        const { target: s } = i, o = Vt(s, "ag-root", t);
        t.classList.toggle("ag-has-focus", !o);
      }, focusout: (i) => {
        const { target: s, relatedTarget: o } = i, r = t.contains(o), n = Vt(o, "ag-root", t);
        Vt(s, "ag-root", t) || (!r || n) && t.classList.remove("ag-has-focus");
      } });
    });
  }
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(uh, e);
  }
  setCellTextSelection(e = false) {
    this.comp.setCellSelectableCss(ch, e);
  }
  onScrollVisibilityChanged() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(e), this.setStickyWidth(e), this.setStickyBottomOffsetBottom();
    const t = e && this.scrollVisibleService.getScrollbarWidth() || 0, i = Qr() ? 16 : 0, s = `calc(100% + ${t + i}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(s)), this.updateScrollingClasses();
  }
  onScrollGapChanged() {
    this.updateScrollingClasses();
  }
  updateScrollingClasses() {
    this.eGridBody.classList.toggle("ag-body-vertical-content-no-gap", !this.scrollVisibleService.hasVerticalScrollGap()), this.eGridBody.classList.toggle("ag-body-horizontal-content-no-gap", !this.scrollVisibleService.hasHorizontalScrollGap());
  }
  onGridColumnsChanged() {
    const e = this.columnModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, { dragstart: (e) => {
      if (e.target instanceof HTMLImageElement) return e.preventDefault(), false;
    } });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus")) return;
    const e = (i) => {
      const s = i.relatedTarget;
      if (Bs(s) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let o = t.some((r) => r.contains(s)) && this.mouseEventService.isElementInThisGrid(s);
      if (!o) {
        const r = this.popupService;
        o = r.getActivePopups().some((n) => n.contains(s)) || r.isElementWithinCustomPopup(s);
      }
      o || this.rowRenderer.stopEditing();
    }, t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
    t.forEach((i) => this.addManagedElementListeners(i, { focusout: e }));
  }
  updateRowCount() {
    var _a3;
    const e = this.headerNavigationService.getHeaderRowCount() + (((_a3 = this.filterManager) == null ? void 0 : _a3.getHeaderRowCount()) ?? 0), t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1, i = t === -1 ? -1 : e + t;
    this.comp.setRowCount(i);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? ah : null, i = he(this.gos, "normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || i && _a(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    let e = this.environment.hasMeasuredSizes();
    const t = () => {
      const i = e && Nt(this.gos) && !this.rowContainerHeightService.isStretching(), s = i ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(s, i);
    };
    t(), this.addManagedEventListeners({ heightScaleChanged: t }), this.addManagedPropertyListener("animateRows", t), this.addManagedEventListeners({ gridStylesChanged: () => {
      !e && this.environment.hasMeasuredSizes() && (e = true, t());
    } });
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const e = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { contextmenu: e }), this.mockContextMenuForIPad(e), this.addManagedElementListeners(this.eBodyViewport, { wheel: this.onBodyViewportWheel.bind(this) }), this.addManagedElementListeners(this.eStickyTop, { wheel: this.onStickyWheel.bind(this) }), this.addManagedElementListeners(this.eStickyBottom, { wheel: this.onStickyWheel.bind(this) }), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, { wheel: (e) => this.onFullWidthContainerWheel(e) });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX: t, deltaY: i, shiftKey: s } = e;
    (s || Math.abs(t) > Math.abs(i)) && this.mouseEventService.isEventFromThisGrid(e) && this.scrollGridBodyToMatchEvent(e);
  }
  onStickyWheel(e) {
    const { deltaX: t, deltaY: i, shiftKey: s } = e, o = s || Math.abs(t) > Math.abs(i), r = e.target;
    o ? (this.eStickyTopFullWidthContainer.contains(r) || this.eStickyBottomFullWidthContainer.contains(r)) && this.scrollGridBodyToMatchEvent(e) : (e.preventDefault(), this.scrollVertically(i));
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX: t, deltaY: i } = e;
    e.preventDefault(), this.eCenterColsViewport.scrollBy({ left: t || i });
  }
  onBodyViewportContextMenu(e, t, i) {
    if (!e && !i) return;
    this.gos.get("preventDefaultOnContextMenu") && (e || i).preventDefault();
    const { target: s } = e || t;
    (s === this.eBodyViewport || s === this.ctrlsService.get("center").getViewportElement()) && this.menuService.showContextMenu({ mouseEvent: e, touchEvent: i, value: null, anchorToElement: this.eGridBody });
  }
  mockContextMenuForIPad(e) {
    if (!pt()) return;
    const t = new ct(this.eBodyViewport), i = (s) => {
      e(void 0, s.touchStart, s.touchEvent);
    };
    this.addManagedListeners(t, { longTap: i }), this.addDestroyFunc(() => t.destroy());
  }
  onBodyViewportWheel(e) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault();
  }
  getGui() {
    return this.eGridBody;
  }
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new Vc(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(this.rowDragFeature));
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this, t = e.getPinnedTopTotalHeight(), i = e.getPinnedBottomTotalHeight();
    this.comp.setTopHeight(t), this.comp.setBottomHeight(i), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(i ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  getStickyBottomHeight() {
    return this.stickyBottomHeight;
  }
  setStickyWidth(e) {
    if (!e) this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.scrollVisibleService.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    var _a3;
    const t = this.ctrlsService.get("gridHeaderCtrl").getHeaderHeight() + (((_a3 = this.filterManager) == null ? void 0 : _a3.getHeaderHeight()) ?? 0), i = this.pinnedRowModel.getPinnedTopTotalHeight();
    let s = 0;
    t > 0 && (s += t), i > 0 && (s += i), s > 0 && (s += 1), this.comp.setStickyTopTop(`${s}px`);
  }
  setStickyBottomOffsetBottom() {
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight(), i = this.scrollVisibleService.isHorizontalScrollShowing() && this.scrollVisibleService.getScrollbarWidth() || 0, s = e + i;
    this.comp.setStickyBottomBottom(`${s}px`);
  }
  sizeColumnsToFit(e, t) {
    const s = this.isVerticalScrollShowing() ? this.scrollVisibleService.getScrollbarWidth() : 0, r = yi(this.eGridBody) - s;
    if (r > 0) {
      this.columnSizeService.sizeColumnsToFit(r, "sizeColumnsToFit", false, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, -1);
    }, 500) : F("tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
  }
  addScrollEventListener(e) {
    this.eBodyViewport.addEventListener("scroll", e, { passive: true });
  }
  removeScrollEventListener(e) {
    this.eBodyViewport.removeEventListener("scroll", e);
  }
};
function ei(e) {
  return e.map((t) => `<ag-row-container name="${t}"></ag-row-container>`).join("");
}
`${ei(["topLeft", "topCenter", "topRight", "topFullWidth"])}${ei(["left", "center", "right", "fullWidth"])}${ei(["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}${ei(["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}${ei(["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}`;
var hh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnAnimationService = e.columnAnimationService;
  }
  postConstruct() {
    this.getScrollbarWidth(), this.addManagedEventListeners({ displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this), displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this) });
  }
  onDisplayedColumnsChanged() {
    this.updateScrollVisible();
  }
  onDisplayedColumnsWidthChanged() {
    this.updateScrollVisible();
  }
  onCentreViewportResized() {
    this.updateScrollGap();
  }
  updateScrollVisible() {
    this.columnAnimationService.isActive() ? this.columnAnimationService.executeLaterVMTurn(() => {
      this.columnAnimationService.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
    }) : this.updateScrollVisibleImpl();
  }
  updateScrollVisibleImpl() {
    const e = this.ctrlsService.get("center");
    if (!e || this.columnAnimationService.isActive()) return;
    const t = { horizontalScrollShowing: e.isHorizontalScrollShowing(), verticalScrollShowing: this.isVerticalScrollShowing() };
    this.setScrollsVisible(t), this.updateScrollGap();
  }
  updateScrollGap() {
    const e = this.ctrlsService.get("center"), t = e.hasHorizontalScrollGap(), i = e.hasVerticalScrollGap();
    (this.horizontalScrollGap !== t || this.verticalScrollGap !== i) && (this.horizontalScrollGap = t, this.verticalScrollGap = i, this.eventService.dispatchEvent({ type: "scrollGapChanged" }));
  }
  setScrollsVisible(e) {
    (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) && (this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing, this.eventService.dispatchEvent({ type: "scrollVisibilityChanged" }));
  }
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
  hasHorizontalScrollGap() {
    return this.horizontalScrollGap;
  }
  hasVerticalScrollGap() {
    return this.verticalScrollGap;
  }
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const e = this.gos.get("scrollbarWidth"), i = typeof e == "number" && e >= 0 ? e : Va();
      i != null && (this.scrollbarWidth = i, this.eventService.dispatchEvent({ type: "scrollbarWidthChanged" }));
    }
    return this.scrollbarWidth;
  }
}, rr = "__ag_grid_instance", jn = class qn extends R {
  constructor() {
    super(...arguments), this.beanName = "mouseEventService", this.gridInstanceId = qn.gridInstanceSequence.next();
  }
  wireBeans(t) {
    this.ctrlsService = t.ctrlsService;
  }
  stampTopLevelGridCompWithGridInstance(t) {
    t[rr] = this.gridInstanceId;
  }
  getRenderedCellForEvent(t) {
    return Os(this.gos, t.target, bt.DOM_DATA_KEY_CELL_CTRL);
  }
  isEventFromThisGrid(t) {
    return this.isElementInThisGrid(t.target);
  }
  isElementInThisGrid(t) {
    let i = t;
    for (; i; ) {
      const s = i[rr];
      if (E(s)) return s === this.gridInstanceId;
      i = i.parentElement;
    }
    return false;
  }
  getCellPositionForEvent(t) {
    const i = this.getRenderedCellForEvent(t);
    return i ? i.getCellPosition() : null;
  }
  getNormalisedPosition(t) {
    const i = he(this.gos, "normal"), s = t;
    let o, r;
    if (s.clientX != null || s.clientY != null ? (o = s.clientX, r = s.clientY) : (o = s.x, r = s.y), i) {
      const n = this.ctrlsService.getGridBodyCtrl(), l = n.getScrollFeature().getVScrollPosition(), a = n.getScrollFeature().getHScrollPosition();
      o += a.left, r += l.top;
    }
    return { x: o, y: r };
  }
};
jn.gridInstanceSequence = new go();
var gh = jn, ph = class extends R {
  constructor() {
    super(), this.beanName = "navigationService", this.onPageDown = Wo(this.onPageDown, 100), this.onPageUp = Wo(this.onPageUp, 100);
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.ctrlsService = e.ctrlsService, this.rowRenderer = e.rowRenderer, this.headerNavigationService = e.headerNavigationService, this.rowPositionUtils = e.rowPositionUtils, this.cellNavigationService = e.cellNavigationService, this.pinnedRowModel = e.pinnedRowModel, this.scrollVisibleService = e.scrollVisibleService, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = false) {
    const i = e.key, s = e.altKey, o = e.ctrlKey || e.metaKey, r = !!this.rangeService && e.shiftKey, n = this.mouseEventService.getCellPositionForEvent(e);
    let l = false;
    switch (i) {
      case y.PAGE_HOME:
      case y.PAGE_END:
        !o && !s && (this.onHomeOrEndKey(i), l = true);
        break;
      case y.LEFT:
      case y.RIGHT:
      case y.UP:
      case y.DOWN:
        if (!n) return false;
        o && !s && !r && (this.onCtrlUpDownLeftRight(i, n), l = true);
        break;
      case y.PAGE_DOWN:
      case y.PAGE_UP:
        !o && !s && (l = this.handlePageUpDown(i, n, t));
        break;
    }
    return l && e.preventDefault(), l;
  }
  handlePageUpDown(e, t, i) {
    return i && (t = this.focusService.getFocusedCell()), t ? (e === y.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), true) : false;
  }
  navigateTo(e) {
    var _a3;
    const { scrollIndex: t, scrollType: i, scrollColumn: s, focusIndex: o, focusColumn: r } = e;
    E(s) && !s.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(s), E(t) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t, i), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(o), this.focusService.setFocusedCell({ rowIndex: o, column: r, rowPinned: null, forceBrowserFocus: true }), (_a3 = this.rangeService) == null ? void 0 : _a3.setRangeToCell({ rowIndex: o, rowPinned: null, column: r });
  }
  onPageDown(e) {
    const i = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), s = this.getViewportHeight(), o = this.pageBoundsService.getPixelOffset(), r = i.top + s, n = this.rowModel.getRowIndexAtPixel(r + o);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, n) : this.navigateToNextPage(e, n);
  }
  onPageUp(e) {
    const i = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), s = this.pageBoundsService.getPixelOffset(), o = i.top, r = this.rowModel.getRowIndexAtPixel(o + s);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, r, true) : this.navigateToNextPage(e, r, true);
  }
  navigateToNextPage(e, t, i = false) {
    const s = this.getViewportHeight(), o = this.pageBoundsService.getFirstRow(), r = this.pageBoundsService.getLastRow(), n = this.pageBoundsService.getPixelOffset(), l = this.rowModel.getRow(e.rowIndex), a = i ? (l == null ? void 0 : l.rowHeight) - s - n : s - n, c = (l == null ? void 0 : l.rowTop) + a;
    let u = this.rowModel.getRowIndexAtPixel(c + n);
    if (u === e.rowIndex) {
      const h = i ? -1 : 1;
      t = u = e.rowIndex + h;
    }
    let d;
    i ? (d = "bottom", u < o && (u = o), t < o && (t = o)) : (d = "top", u > r && (u = r), t > r && (t = r)), this.isRowTallerThanView(u) && (t = u, d = "top"), this.navigateTo({ scrollIndex: t, scrollType: d, scrollColumn: null, focusIndex: u, focusColumn: e.column });
  }
  navigateToNextPageWithAutoHeight(e, t, i = false) {
    this.navigateTo({ scrollIndex: t, scrollType: i ? "bottom" : "top", scrollColumn: null, focusIndex: t, focusColumn: e.column }), setTimeout(() => {
      const s = this.getNextFocusIndexForAutoHeight(e, i);
      this.navigateTo({ scrollIndex: t, scrollType: i ? "bottom" : "top", scrollColumn: null, focusIndex: s, focusColumn: e.column, isAsync: true });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = false) {
    const i = t ? -1 : 1, s = this.getViewportHeight(), o = this.pageBoundsService.getLastRow();
    let r = 0, n = e.rowIndex;
    for (; n >= 0 && n <= o; ) {
      const l = this.rowModel.getRow(n);
      if (l) {
        const a = l.rowHeight ?? 0;
        if (r + a > s) break;
        r += a;
      }
      n += i;
    }
    return Math.max(0, Math.min(n, o));
  }
  getViewportHeight() {
    const e = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), t = this.scrollVisibleService.getScrollbarWidth();
    let i = e.bottom - e.top;
    return this.ctrlsService.get("center").isHorizontalScrollShowing() && (i -= t), i;
  }
  isRowTallerThanView(e) {
    const t = this.rowModel.getRow(e);
    if (!t) return false;
    const i = t.rowHeight;
    return typeof i != "number" ? false : i > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const i = this.cellNavigationService.getNextCellToFocus(e, t, true), { rowIndex: s } = i, o = i.column;
    this.navigateTo({ scrollIndex: s, scrollType: null, scrollColumn: o, focusIndex: s, focusColumn: o });
  }
  onHomeOrEndKey(e) {
    const t = e === y.PAGE_HOME, i = this.visibleColsService.getAllCols(), s = t ? i[0] : N(i), o = t ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow();
    this.navigateTo({ scrollIndex: o, scrollType: null, scrollColumn: s, focusIndex: o, focusColumn: s });
  }
  onTabKeyDown(e, t) {
    const i = t.shiftKey, s = this.tabToNextCellCommon(e, i, t);
    if (s !== false) {
      s ? t.preventDefault() : s === null && this.focusService.allowFocusForNextGridCoreContainer(i);
      return;
    }
    if (i) {
      const { rowIndex: o, rowPinned: r } = e.getRowPosition();
      (r ? o === 0 : o === this.pageBoundsService.getFirstRow()) && (this.gos.get("headerHeight") === 0 || this.focusService.isHeaderFocusSuppressed() ? this.focusService.focusNextGridCoreContainer(true, true) : (t.preventDefault(), this.focusService.focusPreviousFromFirstCell(t)));
    } else e instanceof bt && e.focusCell(true), (!i && this.focusService.focusOverlay(false) || this.focusService.focusNextGridCoreContainer(i)) && t.preventDefault();
  }
  tabToNextCell(e, t) {
    const i = this.focusService.getFocusedCell();
    if (!i) return false;
    let s = this.getCellByPosition(i);
    return !s && (s = this.rowRenderer.getRowByPosition(i), !s || !s.isFullWidth()) ? false : !!this.tabToNextCellCommon(s, e, t);
  }
  tabToNextCellCommon(e, t, i) {
    let s = e.isEditing();
    if (!s && e instanceof bt) {
      const n = e.getRowCtrl();
      n && (s = n.isEditing());
    }
    let o;
    return s ? this.gos.get("editType") === "fullRow" ? o = this.moveToNextEditingRow(e, t, i) : o = this.moveToNextEditingCell(e, t, i) : o = this.moveToNextCellNotEditing(e, t), o === null ? o : o || !!this.focusService.getFocusedHeader();
  }
  moveToNextEditingCell(e, t, i = null) {
    const s = e.getCellPosition();
    e.getGui().focus(), e.stopEditing();
    const o = this.findNextCellToFocusOn(s, t, true);
    return o === false ? null : o == null ? false : (o.startEditing(null, true, i), o.focusCell(false), true);
  }
  moveToNextEditingRow(e, t, i = null) {
    const s = e.getCellPosition(), o = this.findNextCellToFocusOn(s, t, true);
    if (o === false) return null;
    if (o == null) return false;
    const r = o.getCellPosition(), n = this.isCellEditable(s), l = this.isCellEditable(r), a = r && s.rowIndex === r.rowIndex && s.rowPinned === r.rowPinned;
    return n && e.setFocusOutOnEditor(), a || (e.getRowCtrl().stopEditing(), o.getRowCtrl().startRowEditing(void 0, void 0, i)), l ? (o.setFocusInOnEditor(), o.focusCell()) : o.focusCell(true), true;
  }
  moveToNextCellNotEditing(e, t) {
    const i = this.visibleColsService.getAllCols();
    let s;
    e instanceof Pt ? s = { ...e.getRowPosition(), column: t ? i[0] : N(i) } : s = e.getCellPosition();
    const o = this.findNextCellToFocusOn(s, t, false);
    if (o === false) return null;
    if (o instanceof bt) o.focusCell(true);
    else if (o) return this.tryToFocusFullWidthRow(o.getRowPosition(), t);
    return E(o);
  }
  findNextCellToFocusOn(e, t, i) {
    var _a3;
    let s = e;
    for (; ; ) {
      e !== s && (e = s), t || (s = this.getLastCellOfColSpan(s)), s = this.cellNavigationService.getNextTabbedCell(s, t);
      const o = this.gos.getCallback("tabToNextCell");
      if (E(o)) {
        const a = o({ backwards: t, editing: i, previousCellPosition: e, nextCellPosition: s || null });
        if (a === true || a === null) a === null && F("Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour."), s = e;
        else {
          if (a === false) return false;
          s = { rowIndex: a.rowIndex, column: a.column, rowPinned: a.rowPinned };
        }
      }
      if (!s) return null;
      if (s.rowIndex < 0) {
        const l = this.headerNavigationService.getHeaderRowCount();
        return this.focusService.focusHeaderPosition({ headerPosition: { headerRowIndex: l + s.rowIndex, column: s.column }, fromCell: true }), null;
      }
      const r = this.gos.get("editType") === "fullRow";
      if (i && !r && !this.isCellEditable(s)) continue;
      this.ensureCellVisible(s);
      const n = this.getCellByPosition(s);
      if (!n) {
        const l = this.rowRenderer.getRowByPosition(s);
        if (!l || !l.isFullWidth() || i) continue;
        return l;
      }
      if (!n.isSuppressNavigable()) return (_a3 = this.rangeService) == null ? void 0 : _a3.setRangeToCell(s), n;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : false;
  }
  getCellByPosition(e) {
    const t = this.rowRenderer.getRowByPosition(e);
    return t ? t.getCellCtrl(e.column) : null;
  }
  lookupRowNodeForCell(e) {
    return e.rowPinned === "top" ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : e.rowPinned === "bottom" ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.rowModel.getRow(e.rowIndex);
  }
  navigateToNextCell(e, t, i, s) {
    let o = i, r = false;
    for (; o && (o === i || !this.isValidNavigateCell(o)); ) this.gos.get("enableRtl") ? t === y.LEFT && (o = this.getLastCellOfColSpan(o)) : t === y.RIGHT && (o = this.getLastCellOfColSpan(o)), o = this.cellNavigationService.getNextCellToFocus(t, o), r = V(o);
    if (r && e && e.key === y.UP && (o = { rowIndex: -1, rowPinned: null, column: i.column }), s) {
      const l = this.gos.getCallback("navigateToNextCell");
      if (E(l)) {
        const c = l({ key: t, previousCellPosition: i, nextCellPosition: o || null, event: e });
        E(c) ? o = { rowPinned: c.rowPinned, rowIndex: c.rowIndex, column: c.column } : o = null;
      }
    }
    if (!o) return;
    if (o.rowIndex < 0) {
      const l = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({ headerPosition: { headerRowIndex: l + o.rowIndex, column: i.column }, event: e || void 0, fromCell: true });
      return;
    }
    const n = this.getNormalisedPosition(o);
    n ? this.focusPosition(n) : this.tryToFocusFullWidthRow(o);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = this.getCellByPosition(e);
    return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t) {
    const i = this.visibleColsService.getAllCols(), s = this.rowRenderer.getRowByPosition(e);
    if (!s || !s.isFullWidth()) return false;
    const o = this.focusService.getFocusedCell(), r = { rowIndex: e.rowIndex, rowPinned: e.rowPinned, column: e.column || (t ? N(i) : i[0]) };
    this.focusPosition(r);
    const n = t ?? (o != null && this.rowPositionUtils.before(r, o));
    return this.eventService.dispatchEvent({ type: "fullWidthRowFocused", rowIndex: r.rowIndex, rowPinned: r.rowPinned, column: r.column, isFullWidthCell: true, fromBelow: n }), true;
  }
  focusPosition(e) {
    var _a3;
    this.focusService.setFocusedCell({ rowIndex: e.rowIndex, column: e.column, rowPinned: e.rowPinned, forceBrowserFocus: true }), (_a3 = this.rangeService) == null ? void 0 : _a3.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!this.rowPositionUtils.getRowNode(e);
  }
  getLastCellOfColSpan(e) {
    const t = this.getCellByPosition(e);
    if (!t) return e;
    const i = t.getColSpanningList();
    return i.length === 1 ? e : { rowIndex: e.rowIndex, column: N(i), rowPinned: e.rowPinned };
  }
  ensureCellVisible(e) {
    const t = is(this.gos), i = this.rowModel.getRow(e.rowIndex);
    !(t && (i == null ? void 0 : i.sticky)) && V(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column);
  }
}, fh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeService";
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService;
  }
  addResizeBar(e) {
    const t = { dragStartPixels: e.dragStartPixels || 0, eElement: e.eResizeBar, onDragStart: this.onDragStart.bind(this, e), onDragStop: this.onDragStop.bind(this, e), onDragging: this.onDragging.bind(this, e), onDragCancel: this.onDragStop.bind(this, e), includeTouch: true, stopPropagationForTouch: true };
    return this.dragService.addDragSource(t), () => this.dragService.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const i = t instanceof MouseEvent && t.shiftKey === true;
    e.onResizeStart(i);
  }
  setResizeIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(true), e.disableUserSelect(true);
  }
  onDragStop(e) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(false), e.disableUserSelect(false);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, mh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.menuService = e.menuService;
  }
  hideActiveMenu() {
    this.hidePopup && this.hidePopup();
  }
  showMenuAfterMouseEvent(e, t, i) {
    this.showPopup(e, (s) => {
      this.popupService.positionPopupUnderMouseEvent({ column: e, type: i, mouseEvent: t, ePopup: s });
    }, i, t.target, this.menuService.isLegacyMenuEnabled());
  }
  showMenuAfterButtonClick(e, t, i) {
    let s = -1, o = "left";
    const r = this.menuService.isLegacyMenuEnabled();
    !r && this.gos.get("enableRtl") && (s = 1, o = "right");
    const n = r ? void 0 : 4 * s, l = r ? void 0 : 4;
    this.showPopup(e, (a) => {
      this.popupService.positionPopupByComponent({ type: i, eventSource: t, ePopup: a, nudgeX: n, nudgeY: l, alignSide: o, keepWithinBounds: true, position: "under", column: e });
    }, i, t, r);
  }
  showPopup(e, t, i, s, o) {
    const r = e ? this.createBean(new Kc(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = r, !(r == null ? void 0 : r.hasFilter()) || !e) throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    const n = document.createElement("div");
    Ve(n, "presentation"), n.classList.add("ag-menu"), o || n.classList.add("ag-filter-menu"), [this.tabListener] = this.addManagedElementListeners(n, { keydown: (m) => this.trapFocusWithin(m, n) }), n.appendChild(r == null ? void 0 : r.getGui());
    let l;
    const a = () => r == null ? void 0 : r.afterGuiDetached(), c = this.menuService.isColumnMenuAnchoringEnabled() ? s ?? this.ctrlsService.getGridBodyCtrl().getGui() : void 0, u = (m) => {
      e.setMenuVisible(false, "contextMenu");
      const C = m instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), C && s && je(s)) {
        const f = this.focusService.findTabbableParent(s);
        f && f.focus();
      }
      a(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(false, i, e);
    }, d = this.localeService.getLocaleTextFunc(), h = o && i !== "columnFilter" ? d("ariaLabelColumnMenu", "Column Menu") : d("ariaLabelColumnFilter", "Column Filter"), g = this.popupService.addPopup({ modal: true, eChild: n, closeOnEsc: true, closedCallback: u, positionCallback: () => t(n), anchorToElement: c, ariaLabel: h });
    g && (this.hidePopup = l = g.hideFunc), r.afterInit().then(() => {
      t(n), r.afterGuiAttached({ container: i, hidePopup: l });
    }), e.setMenuVisible(true, "contextMenu"), this.dispatchVisibleChangedEvent(true, i, e);
  }
  trapFocusWithin(e, t) {
    e.key !== y.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, false, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, i) {
    this.eventService.dispatchEvent({ type: "columnMenuVisibleChanged", visible: e, switchingTab: false, key: t, column: i ?? null, columnGroup: null });
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, Ch = class extends R {
  constructor() {
    super(...arguments), this.beanName = "resizeObserverService";
  }
  observeResize(e, t) {
    const s = br(this.gos).ResizeObserver, o = s ? new s(t) : null;
    return o == null ? void 0 : o.observe(e), () => o == null ? void 0 : o.disconnect();
  }
}, vh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "animationFrameService", this.createTasksP1 = { list: [], sorted: false }, this.createTasksP2 = { list: [], sorted: false }, this.destroyTasks = [], this.ticking = false, this.scrollGoingDown = true, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  setScrollTop(e) {
    var _a3;
    const t = this.gos.get("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, t && e === 0) {
      const i = ((_a3 = this.paginationService) == null ? void 0 : _a3.getCurrentPage()) ?? 0;
      i !== this.lastPage && (this.lastPage = i, this.scrollGoingDown = true);
    }
    this.lastScrollTop = e;
  }
  postConstruct() {
    this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  verifyAnimationFrameOn(e) {
    this.useAnimationFrame === false && F(`AnimationFrameService.${e} called but animation frames are off`);
  }
  createTask(e, t, i) {
    this.verifyAnimationFrameOn(i);
    const s = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[i], s), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = false;
  }
  sortTaskList(e) {
    if (e.sorted) return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort((i, s) => i.index !== s.index ? t * (s.index - i.index) : s.createOrder - i.createOrder), e.sorted = true;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, i = t.list, s = this.createTasksP2, o = s.list, r = this.destroyTasks, n = (/* @__PURE__ */ new Date()).getTime();
    let l = (/* @__PURE__ */ new Date()).getTime() - n;
    const a = e <= 0, c = this.ctrlsService.getGridBodyCtrl();
    for (; a || l < e; ) {
      if (!c.getScrollFeature().scrollGridIfNeeded()) {
        let d;
        if (i.length) this.sortTaskList(t), d = i.pop().task;
        else if (o.length) this.sortTaskList(s), d = o.pop().task;
        else if (r.length) d = r.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(d) || d();
      }
      l = (/* @__PURE__ */ new Date()).getTime() - n;
    }
    i.length || o.length || r.length ? this.requestFrame() : this.stopTicking();
  }
  stopTicking() {
    this.ticking = false;
  }
  flushAllFrames() {
    this.useAnimationFrame && this.executeFrame(-1);
  }
  schedule() {
    this.useAnimationFrame && (this.ticking || (this.ticking = true, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(e);
  }
  requestAnimationFrame(e) {
    const t = br(this.gos);
    t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  debounce(e) {
    let t = false;
    return () => {
      if (!this.isOn()) {
        window.setTimeout(e, 0);
        return;
      }
      t || (t = true, this.addDestroyTask(() => {
        t = false, e();
      }));
    };
  }
}, H = ((e) => (e.EVERYTHING = "group", e.FILTER = "filter", e.SORT = "sort", e.MAP = "map", e.AGGREGATE = "aggregate", e.FILTER_AGGREGATES = "filter_aggregates", e.PIVOT = "pivot", e.NOTHING = "nothing", e))(H || {}), Sh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "expansionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.isClientSideRowModel = Q(this.gos);
  }
  expandRows(e) {
    if (!this.isClientSideRowModel) return;
    const t = new Set(e);
    this.rowModel.forEachNode((i) => {
      i.id && t.has(i.id) && (i.expanded = true);
    }), this.onGroupExpandedOrCollapsed();
  }
  getExpandedRows() {
    const e = [];
    return this.rowModel.forEachNode(({ expanded: t, id: i }) => {
      t && i && e.push(i);
    }), e;
  }
  expandAll(e) {
    this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e);
  }
  setRowNodeExpanded(e, t, i, s) {
    e && (i && e.parent && e.parent.level !== -1 && this.setRowNodeExpanded(e.parent, t, i, s), e.setExpanded(t, void 0, s));
  }
  onGroupExpandedOrCollapsed() {
    this.isClientSideRowModel && this.rowModel.refreshModel({ step: "map" });
  }
}, wh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "menuService";
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.filterMenuFactory = e.filterMenuFactory, this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.filterManager = e.filterManager, this.rowRenderer = e.rowRenderer, this.columnChooserFactory = e.columnChooserFactory, this.contextMenuFactory = e.contextMenuFactory, this.enterpriseMenuFactory = e.enterpriseMenuFactory;
  }
  postConstruct() {
    this.activeMenuFactory = this.enterpriseMenuFactory ?? this.filterMenuFactory;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const t = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
    this.showColumnMenuCommon(t, e, e.containerType, true);
  }
  showHeaderContextMenu(e, t, i) {
    this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, i);
  }
  getContextMenuPosition(e, t) {
    const i = this.getRowCtrl(e), s = this.getCellGui(i, t);
    if (!s) return i ? { x: 0, y: i.getRowYPosition() } : { x: 0, y: 0 };
    const o = s.getBoundingClientRect();
    return { x: o.x + o.width / 2, y: o.y + o.height / 2 };
  }
  showContextMenu(e) {
    var _a3;
    const t = e.rowNode, i = e.column;
    let { anchorToElement: s, value: o } = e;
    t && i && o == null && (o = this.valueService.getValueForDisplay(i, t)), s == null && (s = this.getContextMenuAnchorElement(t, i)), (_a3 = this.contextMenuFactory) == null ? void 0 : _a3.onContextMenu(e.mouseEvent ?? null, e.touchEvent ?? null, t ?? null, i ?? null, o, s);
  }
  showColumnChooser(e) {
    var _a3;
    (_a3 = this.columnChooserFactory) == null ? void 0 : _a3.showColumnChooser(e);
  }
  hidePopupMenu() {
    var _a3;
    (_a3 = this.contextMenuFactory) == null ? void 0 : _a3.hideActiveMenu(), this.activeMenuFactory.hideActiveMenu();
  }
  hideColumnChooser() {
    var _a3;
    (_a3 = this.columnChooserFactory) == null ? void 0 : _a3.hideActiveColumnChooser();
  }
  isColumnMenuInHeaderEnabled(e) {
    const { suppressMenu: t, suppressHeaderMenuButton: i } = e.getColDef();
    return !(i ?? t) && this.activeMenuFactory.isMenuEnabled(e) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var _a3;
    return !e.getColDef().suppressHeaderFilterButton && !!((_a3 = this.filterManager) == null ? void 0 : _a3.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    var _a3;
    return !((_a3 = e && dt(e) ? e.getColDef() : e == null ? void 0 : e.getColGroupDef()) == null ? void 0 : _a3.suppressHeaderContextMenu) && this.getColumnMenuType() === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(pt() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var _a3;
    return !!((_a3 = this.filterManager) == null ? void 0 : _a3.isFilterAllowed(e)) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isColumnMenuAnchoringEnabled() {
    return !this.isLegacyMenuEnabled();
  }
  areAdditionalColumnMenuItemsEnabled() {
    return this.getColumnMenuType() === "new";
  }
  isLegacyMenuEnabled() {
    return this.getColumnMenuType() === "legacy";
  }
  isFloatingFilterButtonEnabled(e) {
    var _a3;
    const t = e.getColDef(), i = (_a3 = t.floatingFilterComponentParams) == null ? void 0 : _a3.suppressFilterButton;
    return i != null && F("As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead."), t.suppressFloatingFilterButton == null ? !i : !t.suppressFloatingFilterButton;
  }
  getColumnMenuType() {
    return this.gos.get("columnMenu");
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos.get("suppressMenuHide");
    return this.isLegacyMenuEnabled() ? this.gos.exists("suppressMenuHide") ? e : false : e;
  }
  showColumnMenuCommon(e, t, i, s) {
    const { positionBy: o } = t, r = t.column;
    if (o === "button") {
      const { buttonElement: n } = t;
      e.showMenuAfterButtonClick(r, n, i, s);
    } else if (o === "mouse") {
      const { mouseEvent: n } = t;
      e.showMenuAfterMouseEvent(r, n, i, s);
    } else r && (this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(r, "auto"), this.animationFrameService.requestAnimationFrame(() => {
      var _a3;
      const n = (_a3 = this.ctrlsService.getHeaderRowContainerCtrl(r.getPinned())) == null ? void 0 : _a3.getHeaderCtrlForColumn(r);
      n && e.showMenuAfterButtonClick(r, n.getAnchorElementForMenu(s), i, true);
    }));
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: i } = e || {};
    if (t != null) return this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: i }) || void 0;
  }
  getCellGui(e, t) {
    var _a3;
    return !e || !t ? void 0 : ((_a3 = e.getCellCtrl(t)) == null ? void 0 : _a3.getGui()) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const i = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(), s = this.getRowCtrl(e);
    if (!s) return i;
    const o = this.getCellGui(s, t);
    return o || (s.isFullWidth() ? s.getFullWidthElement() : i);
  }
}, yh = class extends wt {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const i = super.setValue(e, t);
    return this.eInput.value = e, i;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, Rh = { selector: "AG-INPUT-TEXT-AREA", component: yh }, Fh = class extends jt {
  constructor() {
    super(`<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`, [Rh]), this.eTextArea = O;
  }
  init(e) {
    this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), E(e.value, true) && this.eTextArea.setValue(e.value.toString(), true), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(e) {
    const t = e.key;
    (t === y.LEFT || t === y.UP || t === y.RIGHT || t === y.DOWN || e.shiftKey && t === y.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const e = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const e = this.eTextArea.getValue();
    return !E(e) && !E(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
}, bh = class extends jt {
  constructor(e) {
    super('<div class="ag-popup-editor" tabindex="-1"/>'), this.params = e;
  }
  postConstruct() {
    Et(this.gos, this.getGui(), "popupEditorWrapper", true), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, i = (s) => {
      _s(this.gos, s, t.node, t.column, true) || t.onKeyDown(s);
    };
    this.addManagedElementListeners(e, { keydown: i });
  }
}, Ph = class extends jt {
  constructor() {
    super(`<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`, [Jc]), this.eSelect = O, this.startedByEnter = false;
  }
  wireBeans(e) {
    this.valueService = e.valueService;
  }
  init(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eSelect: t, valueService: i, gos: s } = this, { values: o, value: r, eventKey: n } = e;
    if (V(o)) {
      F("no values found for select cellEditor");
      return;
    }
    this.startedByEnter = n != null ? n === y.ENTER : false;
    let l = false;
    o.forEach((d) => {
      const h = { value: d }, g = i.formatValue(e.column, null, d), m = g != null;
      h.text = m ? g : d, t.addOption(h), l = l || r === d;
    }), l ? t.setValue(e.value, true) : e.values.length && t.setValue(e.values[0], true);
    const { valueListGap: a, valueListMaxWidth: c, valueListMaxHeight: u } = e;
    a != null && t.setPickerGap(a), u != null && t.setPickerMaxHeight(u), c != null && t.setPickerMaxWidth(c), s.get("editType") !== "fullRow" && this.addManagedListeners(this.eSelect, { selectedItem: () => e.stopEditing() });
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eSelect.showPicker();
    });
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return false;
  }
}, as = class extends jt {
  constructor(e) {
    super(`
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`, e.getAgComponents()), this.cellEditorInput = e, this.eInput = O;
  }
  init(e) {
    this.params = e;
    const { cellStartedEdit: t, eventKey: i, suppressPreventDefault: s } = e, o = this.eInput;
    this.cellEditorInput.init(o, e);
    let r, n = true;
    t ? (this.focusAfterAttached = true, i === y.BACKSPACE || i === y.DELETE ? r = "" : i && i.length === 1 ? s ? n = false : r = i : (r = this.cellEditorInput.getStartValue(), i !== y.F2 && (this.highlightAllOnFocus = true))) : (this.focusAfterAttached = false, r = this.cellEditorInput.getStartValue()), n && r != null && o.setStartValue(r), this.addManagedElementListeners(o.getGui(), { keydown: (l) => {
      const { key: a } = l;
      (a === y.PAGE_UP || a === y.PAGE_DOWN) && l.preventDefault();
    } });
  }
  afterGuiAttached() {
    var _a3, _b;
    const e = this.localeService.getLocaleTextFunc(), t = this.eInput;
    if (t.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), !this.focusAfterAttached) return;
    $e() || t.getFocusableElement().focus();
    const i = t.getInputElement();
    this.highlightAllOnFocus ? i.select() : (_b = (_a3 = this.cellEditorInput).setCaret) == null ? void 0 : _b.call(_a3);
  }
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), i = e.getInputElement();
    t.focus(), i.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return false;
  }
}, Eh = class {
  getTemplate() {
    return '<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>';
  }
  getAgComponents() {
    return [ns];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.maxLength != null && e.setMaxLength(t.maxLength);
  }
  getValue() {
    const e = this.eInput.getValue();
    return !E(e) && !E(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
  getStartValue() {
    return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const e = this.eInput.getValue(), t = E(e) && e.length || 0;
    t && this.eInput.getInputElement().setSelectionRange(t, t);
  }
}, Yn = class extends as {
  constructor() {
    super(new Eh());
  }
}, Dh = class {
  getTemplate() {
    return '<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>';
  }
  getAgComponents() {
    return [au];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.max != null && e.setMax(t.max), t.min != null && e.setMin(t.min), t.precision != null && e.setPrecision(t.precision), t.step != null && e.setStep(t.step);
    const i = e.getInputElement();
    t.preventStepping ? e.addManagedElementListeners(i, { keydown: this.preventStepping }) : t.showStepperButtons && i.classList.add("ag-number-field-input-stepper");
  }
  preventStepping(e) {
    (e.key === y.UP || e.key === y.DOWN) && e.preventDefault();
  }
  getValue() {
    const e = this.eInput.getValue();
    if (!E(e) && !E(this.params.value)) return this.params.value;
    let t = this.params.parseValue(e);
    if (t == null) return t;
    if (typeof t == "string") {
      if (t === "") return null;
      t = Number(t);
    }
    return isNaN(t) ? null : t;
  }
  getStartValue() {
    return this.params.value;
  }
  setCaret() {
    $e() && this.eInput.getInputElement().focus({ preventScroll: true });
  }
}, Mh = class extends as {
  constructor() {
    super(new Dh());
  }
}, xh = class extends Tt {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const e = $e();
    this.addManagedListeners(this.eInput, { wheel: this.onWheel.bind(this), mousedown: () => {
      this.isDisabled() || e || this.eInput.focus();
    } }), this.eInput.step = "any";
  }
  onWheel(e) {
    te(this.gos) === this.eInput && e.preventDefault();
  }
  setMin(e) {
    const t = e instanceof Date ? Ge(e ?? null, false) ?? void 0 : e;
    return this.min === t ? this : (this.min = t, Oe(this.eInput, "min", t), this);
  }
  setMax(e) {
    const t = e instanceof Date ? Ge(e ?? null, false) ?? void 0 : e;
    return this.max === t ? this : (this.max = t, Oe(this.eInput, "max", t), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Oe(this.eInput, "step", e), this);
  }
  getDate() {
    if (this.eInput.validity.valid) return be(this.getValue()) ?? void 0;
  }
  setDate(e, t) {
    this.setValue(Ge(e ?? null, false), t);
  }
}, Qn = { selector: "AG-INPUT-DATE-FIELD", component: xh }, Ah = class {
  getTemplate() {
    return '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>';
  }
  getAgComponents() {
    return [Qn];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.eInput.getDate();
    return !E(e) && !E(this.params.value) ? this.params.value : e ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date) return Ge(e, false);
  }
}, Th = class extends as {
  constructor() {
    super(new Ah());
  }
}, Ih = class {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>';
  }
  getAgComponents() {
    return [Qn];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.formatDate(this.eInput.getDate());
    return !E(e) && !E(this.params.value) ? this.params.value : this.params.parseValue(e ?? "");
  }
  getStartValue() {
    return Ge(this.parseDate(this.params.value ?? void 0) ?? null, false);
  }
  parseDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateParserFunction(this.params.column)(e) : be(e) ?? void 0;
  }
  formatDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateFormatterFunction(this.params.column)(e) : Ge(e ?? null, false) ?? void 0;
  }
}, Lh = class extends as {
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  constructor() {
    super(new Ih(() => this.dataTypeService));
  }
}, Oh = class extends jt {
  constructor() {
    super(`
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`, [mo]), this.eCheckbox = O;
  }
  init(e) {
    this.params = e;
    const t = e.value ?? void 0;
    this.eCheckbox.setValue(t), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(t), this.addManagedListeners(this.eCheckbox, { fieldValueChanged: (s) => this.setAriaLabel(s.selected) });
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return false;
  }
  setAriaLabel(e) {
    const t = this.localeService.getLocaleTextFunc(), i = ro(t, e), s = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${s} (${i})`);
  }
}, oi = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, Ps = class extends oi {
  constructor(e, t, i, s) {
    super(e), this.initialRange = t, this.finalRange = i, this.ranges = s;
  }
}, Gh = 10, nr = class {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || Gh, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}, kh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "undoRedoService", this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = false, this.isRangeInAction = false, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, i = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, t), s = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
      if (!(i || s || this.isPasting || this.isRangeInAction)) return;
      const { rowPinned: r, rowIndex: n, column: l, oldValue: a, value: c } = e, u = { rowPinned: r, rowIndex: n, columnId: l.getColId(), newValue: c, oldValue: a };
      this.cellValueChanges.push(u);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.cellPositionUtils = e.cellPositionUtils, this.rowPositionUtils = e.rowPositionUtils, this.columnModel = e.columnModel, this.rangeService = e.rangeService;
  }
  postConstruct() {
    if (!this.gos.get("undoRedoCellEditing")) return;
    const e = this.gos.get("undoRedoCellEditingLimit");
    if (e <= 0) return;
    this.undoStack = new nr(e), this.redoStack = new nr(e), this.addListeners();
    const t = this.clearStacks.bind(this);
    this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this), modelUpdated: (i) => {
      i.keepUndoRedoStack || this.clearStacks();
    }, columnPivotModeChanged: t, newColumnsLoaded: t, columnGroupOpened: t, columnRowGroupChanged: t, columnMoved: t, columnPinned: t, columnVisible: t, rowDragEnd: t }), this.ctrlsService.whenReady(this, (i) => {
      this.gridBodyCtrl = i.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(e) {
    this.eventService.dispatchEvent({ type: "undoStarted", source: e });
    const t = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo");
    this.eventService.dispatchEvent({ type: "undoEnded", source: e, operationPerformed: t });
  }
  redo(e) {
    this.eventService.dispatchEvent({ type: "redoStarted", source: e });
    const t = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo");
    this.eventService.dispatchEvent({ type: "redoEnded", source: e, operationPerformed: t });
  }
  undoRedo(e, t, i, s, o) {
    if (!e) return false;
    const r = e.pop();
    return !r || !r.cellValueChanges ? false : (this.processAction(r, (n) => n[s], o), r instanceof Ps ? this.processRange(this.rangeService, r.ranges || [r[i]]) : this.processCell(r.cellValueChanges), t.push(r), true);
  }
  processAction(e, t, i) {
    e.cellValueChanges.forEach((s) => {
      const { rowIndex: o, rowPinned: r, columnId: n } = s, l = { rowIndex: o, rowPinned: r }, a = this.rowPositionUtils.getRowNode(l);
      a.displayed && a.setDataValue(n, t(s), i);
    });
  }
  processRange(e, t) {
    let i;
    e.removeAllCellRanges(true), t.forEach((s, o) => {
      if (!s) return;
      const r = s.startRow, n = s.endRow;
      o === t.length - 1 && (i = { rowPinned: r.rowPinned, rowIndex: r.rowIndex, columnId: s.startColumn.getColId() }, this.setLastFocusedCell(i));
      const l = { rowStartIndex: r.rowIndex, rowStartPinned: r.rowPinned, rowEndIndex: n.rowIndex, rowEndPinned: n.rowPinned, columnStart: s.startColumn, columns: s.columns };
      e.addCellRange(l);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: i, rowPinned: s } = t, o = { rowIndex: i, rowPinned: s }, r = this.rowPositionUtils.getRowNode(o), n = { rowPinned: t.rowPinned, rowIndex: r.rowIndex, columnId: t.columnId };
    this.setLastFocusedCell(n, this.rangeService);
  }
  setLastFocusedCell(e, t) {
    const { rowIndex: i, columnId: s, rowPinned: o } = e, r = this.gridBodyCtrl.getScrollFeature(), n = this.columnModel.getCol(s);
    if (!n) return;
    r.ensureIndexVisible(i), r.ensureColumnVisible(n);
    const l = { rowIndex: i, column: n, rowPinned: o };
    this.focusService.setFocusedCell({ ...l, forceBrowserFocus: true }), t == null ? void 0 : t.setRangeToCell(l);
  }
  addListeners() {
    this.addManagedEventListeners({ rowEditingStarted: (e) => {
      this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    }, rowEditingStopped: () => {
      const e = new oi(this.cellValueChanges);
      this.pushActionsToUndoStack(e), this.activeRowEdit = null;
    }, cellEditingStarted: (e) => {
      this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    }, cellEditingStopped: (e) => {
      if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
        const i = new oi(this.cellValueChanges);
        this.pushActionsToUndoStack(i);
      }
    }, pasteStart: () => {
      this.isPasting = true;
    }, pasteEnd: () => {
      const e = new oi(this.cellValueChanges);
      this.pushActionsToUndoStack(e), this.isPasting = false;
    }, fillStart: () => {
      this.isRangeInAction = true;
    }, fillEnd: (e) => {
      const t = new Ps(this.cellValueChanges, e.initialRange, e.finalRange);
      this.pushActionsToUndoStack(t), this.isRangeInAction = false;
    }, keyShortcutChangedCellStart: () => {
      this.isRangeInAction = true;
    }, keyShortcutChangedCellEnd: () => {
      let e;
      this.rangeService && et(this.gos) ? e = new Ps(this.cellValueChanges, void 0, void 0, [...this.rangeService.getCellRanges()]) : e = new oi(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = false;
    } });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
};
function Hh(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
}
function Nh(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getHScrollPosition();
}
function Xn(e, t, i = "auto") {
  e.frameworkOverrides.wrapIncoming(() => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(t, i), "ensureVisible");
}
function Jn(e, t, i) {
  e.frameworkOverrides.wrapIncoming(() => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureIndexVisible(t, i), "ensureVisible");
}
function Vh(e, t, i = null) {
  e.frameworkOverrides.wrapIncoming(() => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureNodeVisible(t, i), "ensureVisible");
}
function Bh(e) {
  var _a3;
  (_a3 = e.undoRedoService) == null ? void 0 : _a3.undo("api");
}
function Wh(e) {
  var _a3;
  (_a3 = e.undoRedoService) == null ? void 0 : _a3.redo("api");
}
function zh(e, t = {}) {
  return e.rowRenderer.getCellEditorInstances(t).map(li);
}
function _h(e) {
  return e.rowRenderer.getEditingCells();
}
function Uh(e, t = false) {
  e.rowRenderer.stopEditing(t);
}
function Kh(e, t) {
  const i = e.columnModel.getCol(t.colKey);
  if (!i) {
    F(`no column found for ${t.colKey}`);
    return;
  }
  const s = { rowIndex: t.rowIndex, rowPinned: t.rowPinned || null, column: i };
  t.rowPinned == null && Jn(e, t.rowIndex), Xn(e, t.colKey);
  const r = e.navigationService.getCellByPosition(s);
  if (!r) return;
  const { focusService: n, gos: l } = e, a = () => {
    const u = te(l), d = r.getGui();
    return u !== d && !!(d == null ? void 0 : d.contains(u));
  }, c = l.get("stopEditingWhenCellsLoseFocus") && a();
  (c || !n.isCellFocused(s)) && n.setFocusedCell({ ...s, forceBrowserFocus: c, preventScrollOnBrowserFocus: true }), r.startRowOrCellEdit(t.key);
}
function $h(e) {
  var _a3;
  return ((_a3 = e.undoRedoService) == null ? void 0 : _a3.getCurrentUndoStackSize()) ?? 0;
}
function jh(e) {
  var _a3;
  return ((_a3 = e.undoRedoService) == null ? void 0 : _a3.getCurrentRedoStackSize()) ?? 0;
}
var qh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "editService";
  }
  wireBeans(e) {
    this.navigationService = e.navigationService, this.userComponentFactory = e.userComponentFactory, this.valueService = e.valueService;
  }
  startEditing(e, t = null, i = false, s = null) {
    var _a3;
    const o = this.createCellEditorParams(e, t, i), r = e.getColumn().getColDef(), n = this.userComponentFactory.getCellEditorDetails(r, o), l = (n == null ? void 0 : n.popupFromSelector) != null ? n.popupFromSelector : !!r.cellEditorPopup, a = (n == null ? void 0 : n.popupPositionFromSelector) != null ? n.popupPositionFromSelector : r.cellEditorPopupPosition;
    return e.setEditing(true, n), e.getComp().setEditDetails(n, l, a, this.gos.get("reactiveCustomComponents")), this.eventService.dispatchEvent(e.createEvent(s, "cellEditingStarted")), !((_a3 = n == null ? void 0 : n.params) == null ? void 0 : _a3.suppressPreventDefault);
  }
  stopEditing(e, t) {
    const i = e.getComp(), { newValue: s, newValueExists: o } = this.takeValueFromCellEditor(t, i), r = e.getRowNode(), n = e.getColumn(), l = this.valueService.getValueForDisplay(n, r);
    let a = false;
    return o && (a = this.saveNewValue(e, l, s, r, n)), e.setEditing(false, void 0), i.setEditDetails(), e.updateAndFormatValue(false), e.refreshCell({ forceRefresh: true, suppressFlash: true }), this.eventService.dispatchEvent({ ...e.createEvent(null, "cellEditingStopped"), oldValue: l, newValue: s, valueChanged: a }), a;
  }
  handleColDefChanged(e) {
    const t = e.getCellEditor();
    if (t == null ? void 0 : t.refresh) {
      const { eventKey: i, cellStartedEdit: s } = e.getEditCompDetails().params, o = this.createCellEditorParams(e, i, s), r = e.getColumn().getColDef(), n = this.userComponentFactory.getCellEditorDetails(r, o);
      t.refresh(n.params);
    }
  }
  setFocusOutOnEditor(e) {
    const t = e.getComp().getCellEditor();
    t && t.focusOut && t.focusOut();
  }
  setFocusInOnEditor(e) {
    const t = e.getComp(), i = t.getCellEditor();
    (i == null ? void 0 : i.focusIn) ? i.focusIn() : (e.focusCell(true), e.onCellEditorAttached(() => {
      var _a3, _b;
      return (_b = (_a3 = t.getCellEditor()) == null ? void 0 : _a3.focusIn) == null ? void 0 : _b.call(_a3);
    }));
  }
  stopEditingAndFocus(e, t = false, i = false) {
    e.stopRowOrCellEdit(), e.focusCell(true), t || this.navigateAfterEdit(i, e.getCellPosition());
  }
  createPopupEditorWrapper(e) {
    return new bh(e);
  }
  takeValueFromCellEditor(e, t) {
    const i = { newValueExists: false };
    if (e) return i;
    const s = t.getCellEditor();
    return !s || s.isCancelAfterEnd && s.isCancelAfterEnd() ? i : { newValue: s.getValue(), newValueExists: true };
  }
  saveNewValue(e, t, i, s, o) {
    if (i === t) return false;
    e.setSuppressRefreshCell(true);
    const r = s.setDataValue(o, i, "edit");
    return e.setSuppressRefreshCell(false), r;
  }
  createCellEditorParams(e, t, i) {
    const s = e.getColumn(), o = e.getRowNode();
    return this.gos.addGridCommonParams({ value: this.valueService.getValueForDisplay(s, o), eventKey: t, column: s, colDef: s.getColDef(), rowIndex: e.getCellPosition().rowIndex, node: o, data: o.data, cellStartedEdit: i, onKeyDown: e.onKeyDown.bind(e), stopEditing: e.stopEditingAndFocus.bind(e), eGridCell: e.getGui(), parseValue: (r) => this.valueService.parseValue(s, o, r, e.getValue()), formatValue: e.formatValue.bind(e) });
  }
  navigateAfterEdit(e, t) {
    if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const s = e ? y.UP : y.DOWN;
      this.navigationService.navigateToNextCell(null, s, t, false);
    }
  }
}, Yh = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowEditService";
  }
  startEditing(e, t = null, i = null, s = null) {
    let o = true;
    return e.getAllCellCtrls().reduce((n, l) => {
      const a = l === i;
      return a ? o = l.startEditing(t, a, s) : l.startEditing(null, a, s), n ? true : l.isEditing();
    }, false) && this.setEditing(e, true), o;
  }
  stopEditing(e, t = false) {
    const i = e.getAllCellCtrls(), s = e.isEditing();
    e.setStoppingRowEdit(true);
    let o = false;
    for (const r of i) {
      const n = r.stopEditing(t);
      s && !t && !o && n && (o = true);
    }
    o && this.eventService.dispatchEvent(e.createRowEvent("rowValueChanged")), s && this.setEditing(e, false), e.setStoppingRowEdit(false);
  }
  setEditing(e, t) {
    e.setEditingRow(t), e.forEachGui(void 0, (s) => s.rowComp.addOrRemoveCssClass("ag-row-editing", t));
    const i = t ? e.createRowEvent("rowEditingStarted") : e.createRowEvent("rowEditingStopped");
    this.eventService.dispatchEvent(i);
  }
}, It = { version: G, moduleName: "@ag-grid-community/edit-core", beans: [qh] }, Qh = { version: G, moduleName: "@ag-grid-community/edit-api", apiFunctions: { undoCellEditing: Bh, redoCellEditing: Wh, getCellEditorInstances: zh, getEditingCells: _h, stopEditing: Uh, startEditingCell: Kh, getCurrentUndoSize: $h, getCurrentRedoSize: jh }, dependantModules: [It] }, Xh = { version: G, moduleName: "@ag-grid-community/undo-redo-edit", beans: [kh], dependantModules: [It] }, Jh = { version: G, moduleName: "@ag-grid-community/full-row-edit", beans: [Yh], dependantModules: [It] }, Zn = { version: G, moduleName: "@ag-grid-community/default-editor", userComponents: [{ name: "agCellEditor", classImp: Yn }], dependantModules: [It] }, Zh = { version: G, moduleName: "@ag-grid-community/data-type-editors", userComponents: [{ name: "agTextCellEditor", classImp: Yn }, { name: "agNumberCellEditor", classImp: Mh, params: { suppressPreventDefault: true } }, { name: "agDateCellEditor", classImp: Th }, { name: "agDateStringCellEditor", classImp: Lh }, { name: "agCheckboxCellEditor", classImp: Oh }], dependantModules: [Zn] }, eg = { version: G, moduleName: "@ag-grid-community/select-editor", userComponents: [{ name: "agSelectCellEditor", classImp: Ph }], dependantModules: [It] }, tg = { version: G, moduleName: "@ag-grid-community/large-text-editor", userComponents: [{ name: "agLargeTextCellEditor", classImp: Fh }], dependantModules: [It] }, ig = { version: G, moduleName: "@ag-grid-community/all-editors", dependantModules: [Zn, Zh, eg, tg] }, sg = { version: G, moduleName: "@ag-grid-community/editing", dependantModules: [It, Xh, Jh, ig, Qh] }, og = class extends R {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalculator";
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  getPreferredWidthForColumn(e, t) {
    const i = this.getHeaderCellForColumn(e);
    if (!i) return -1;
    const s = this.rowRenderer.getAllCellsForColumn(e);
    return t || s.push(i), this.addElementsToContainerAndGetWidth(s);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const i = this.centerRowContainerCtrl.getContainerElement();
    e.forEach((r) => this.cloneItemIntoDummy(r, t)), i.appendChild(t);
    const s = t.offsetWidth;
    i.removeChild(t);
    const o = this.getAutoSizePadding();
    return s + o;
  }
  getAutoSizePadding() {
    return this.gos.get("autoSizePadding");
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.ctrlsService.getHeaderRowContainerCtrls().forEach((i) => {
      const s = i.getHtmlElementForColumnHeader(e);
      s != null && (t = s);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const i = e.cloneNode(true);
    i.style.width = "", i.style.position = "static", i.style.left = "";
    const s = document.createElement("div"), o = s.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((l) => i.classList.contains(l)) ? (o.add("ag-header", "ag-header-row"), s.style.position = "static") : o.add("ag-row");
    let n = e.parentElement;
    for (; n; ) {
      if (["ag-header-row", "ag-row"].some((a) => n.classList.contains(a))) {
        for (let a = 0; a < n.classList.length; a++) {
          const c = n.classList[a];
          c != "ag-row-position-absolute" && o.add(c);
        }
        break;
      }
      n = n.parentElement;
    }
    s.appendChild(i), t.appendChild(s);
  }
}, rg = class extends R {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.extraTopHeight = 0, this.extraBottomHeight = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.isClientSide = Q(this.gos), this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    }), this.resetStickyContainers();
  }
  getStickyTopRowCtrls() {
    return this.stickyTopRowCtrls;
  }
  getStickyBottomRowCtrls() {
    return this.stickyBottomRowCtrls;
  }
  setOffsetTop(e) {
    this.extraTopHeight !== e && (this.extraTopHeight = e, this.eventService.dispatchEvent({ type: "stickyTopOffsetChanged", offset: e }));
  }
  setOffsetBottom(e) {
    this.extraBottomHeight !== e && (this.extraBottomHeight = e);
  }
  resetOffsets() {
    this.setOffsetBottom(0), this.setOffsetTop(0);
  }
  getExtraTopHeight() {
    return this.extraTopHeight;
  }
  getExtraBottomHeight() {
    return this.extraBottomHeight;
  }
  getLastPixelOfGroup(e) {
    return this.isClientSide ? this.getClientSideLastPixelOfGroup(e) : this.getServerSideLastPixelOfGroup(e);
  }
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  getServerSideLastPixelOfGroup(e) {
    var _a3, _b;
    if (this.isClientSide) throw new Error("This func should only be called in server side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.master) return e.detailNode.rowTop + e.detailNode.rowHeight;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let i = (_a3 = e.childStore) == null ? void 0 : _a3.getStoreBounds();
        return e.footer && (i = (_b = e.sibling.childStore) == null ? void 0 : _b.getStoreBounds()), ((i == null ? void 0 : i.heightPx) ?? 0) + ((i == null ? void 0 : i.topPx) ?? 0);
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  getClientSideLastPixelOfGroup(e) {
    if (!this.isClientSide) throw new Error("This func should only be called in client side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.footer && e.rowIndex === 0) return Number.MAX_SAFE_INTEGER;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let s = e.footer ? e.sibling : e;
        for (; s.isExpandable() && s.expanded; ) if (s.master) s = s.detailNode;
        else if (s.childrenAfterSort) {
          if (s.childrenAfterSort.length === 0) break;
          s = N(s.childrenAfterSort);
        }
        return s.rowTop + s.rowHeight;
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let i = 0;
    if (!this.canRowsBeSticky()) return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), i);
    const s = t ? this.rowRenderer.getFirstVisibleVerticalPixel() - this.extraTopHeight : this.rowRenderer.getLastVisibleVerticalPixel() - this.extraTopHeight, o = /* @__PURE__ */ new Set(), r = (c) => {
      if (o.add(c), t) {
        const u = this.getLastPixelOfGroup(c), d = s + i + c.rowHeight;
        u < d ? c.stickyRowTop = i + (u - d) : c.stickyRowTop = i;
      } else {
        const u = this.getFirstPixelOfGroup(c), d = s - (i + c.rowHeight);
        u > d ? c.stickyRowTop = i - (u - d) : c.stickyRowTop = i;
      }
      i = 0, o.forEach((u) => {
        const d = u.stickyRowTop + u.rowHeight;
        i < d && (i = d);
      });
    }, n = this.areFooterRowsStickySuppressed(), l = this.gos.get("suppressGroupRowsSticky"), a = (c) => {
      if (!c.displayed) return false;
      if (c.footer) {
        if (n === true || n === "grand" && c.level === -1 || n === "group" && c.level > -1) return false;
        const u = c.sibling.rowIndex ? c.sibling.rowIndex + 1 === c.rowIndex : false;
        return e === "bottom" && u ? false : !o.has(c);
      }
      return c.isExpandable() ? l === true || e === "bottom" ? false : !o.has(c) && c.expanded : false;
    };
    for (let c = 0; c < 100; c++) {
      let u = s + i;
      t || (u = s - i);
      const d = this.rowModel.getRowIndexAtPixel(u), h = this.rowModel.getRow(d);
      if (h == null) break;
      const m = this.getStickyAncestors(h).find((f) => (t ? f.rowIndex < d : f.rowIndex > d) && a(f));
      if (m) {
        r(m);
        continue;
      }
      if ((t ? h.rowTop < u : h.rowTop + h.rowHeight > u) && a(h)) {
        r(h);
        continue;
      }
      break;
    }
    return t || o.forEach((c) => {
      c.stickyRowTop = i - (c.stickyRowTop + c.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, o, i);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === true) return true;
    const t = !!this.gos.get("groupIncludeFooter") || e === "group", i = !!this.gos.get("groupIncludeTotalFooter") || e === "grand";
    return t && i ? true : i ? "grand" : t ? "group" : false;
  }
  canRowsBeSticky() {
    const e = is(this.gos), t = this.areFooterRowsStickySuppressed(), i = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !i);
  }
  getStickyAncestors(e) {
    const t = [];
    let i = e.footer ? e.sibling : e.parent;
    for (; i; ) i.sibling && t.push(i.sibling), t.push(i), i = i.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.resetStickyContainers();
  }
  resetStickyContainers() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((i) => i.getRowNode() === e)) {
      for (let i = 0; i < this.stickyTopRowCtrls.length; i++) {
        const s = this.stickyTopRowCtrls[i].getRowNode();
        s !== e && t.add(s);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let i = 0; i < this.stickyBottomRowCtrls.length; i++) {
      const s = this.stickyBottomRowCtrls[i].getRowNode();
      s !== e && t.add(s);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  refreshNodesAndContainerHeight(e, t, i) {
    const s = e === "top", o = s ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, r = {}, n = [];
    for (let h = 0; h < o.length; h++) {
      const g = o[h].getRowNode();
      if (!t.has(g)) {
        r[g.id] = o[h], g.sticky = false;
        continue;
      }
      n.push(o[h]);
    }
    const l = /* @__PURE__ */ new Set();
    for (let h = 0; h < n.length; h++) l.add(n[h].getRowNode());
    const a = [];
    t.forEach((h) => {
      l.has(h) || (h.sticky = true, a.push(this.createRowCon(h, false, false)));
    });
    let c = !!a.length || n.length !== o.length;
    s ? this.topContainerHeight !== i && (this.topContainerHeight = i, this.gridBodyCtrl.setStickyTopHeight(i), c = true) : this.bottomContainerHeight !== i && (this.bottomContainerHeight = i, this.gridBodyCtrl.setStickyBottomHeight(i), c = true), this.destroyRowCtrls(r, false);
    const u = [...n, ...a];
    u.sort((h, g) => g.getRowNode().rowIndex - h.getRowNode().rowIndex), s || u.reverse(), u.forEach((h) => h.setRowTop(h.getRowNode().stickyRowTop));
    let d = 0;
    return s ? (t.forEach((h) => {
      h.rowIndex < this.pageBoundsService.getFirstRow() && (d += h.rowHeight);
    }), d > this.topContainerHeight && (d = this.topContainerHeight), this.setOffsetTop(d)) : (t.forEach((h) => {
      h.rowIndex > this.pageBoundsService.getLastRow() && (d += h.rowHeight);
    }), d > this.bottomContainerHeight && (d = this.bottomContainerHeight), this.setOffsetBottom(d)), c ? (s ? this.stickyTopRowCtrls = u : this.stickyBottomRowCtrls = u, true) : false;
  }
  ensureRowHeightsValid() {
    let e = false;
    const t = (i) => {
      const s = i.getRowNode();
      if (s.rowHeightEstimated) {
        const o = ut(this.gos, s);
        s.setRowHeight(o.height), e = true;
      }
    };
    return this.stickyTopRowCtrls.forEach(t), this.stickyBottomRowCtrls.forEach(t), e;
  }
}, ng = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = false, this.dataFirstRenderedFired = false, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((r) => r.onCellSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((r) => r.updateRangeBordersIfRangeCount());
      }, i = () => {
        this.eventService.addEventListener("cellSelectionChanged", e), this.eventService.addEventListener("columnMoved", t), this.eventService.addEventListener("columnPinned", t), this.eventService.addEventListener("columnVisible", t);
      }, s = () => {
        this.eventService.removeEventListener("cellSelectionChanged", e), this.eventService.removeEventListener("columnMoved", t), this.eventService.removeEventListener("columnPinned", t), this.eventService.removeEventListener("columnVisible", t);
      };
      this.addDestroyFunc(() => s()), this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        et(this.gos) ? i() : s();
      }), et(this.gos) && i();
    };
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusService = e.focusService, this.beans = e, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({ paginationChanged: this.onPageLoaded.bind(this), pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this), displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this), bodyScroll: this.onBodyScroll.bind(this), bodyHeightChanged: this.redraw.bind(this, {}) }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListener("suppressCellFocus", (e) => this.onSuppressCellFocusChanged(e.currentValue)), this.addManagedPropertyListeners(["groupSuppressBlankHeader", "getBusinessKeyForNode", "fullWidthCellRenderer", "fullWidthCellRendererParams", "suppressStickyTotalRow", "groupRowRenderer", "groupRowRendererParams", "loadingCellRenderer", "loadingCellRendererParams", "detailCellRenderer", "detailCellRendererParams", "enableRangeSelection", "enableCellTextSelection", "rowSelection"], () => this.redrawRows()), is(this.gos) && (Q(this.gos) || it(this.gos)) && (this.stickyRowFeature = this.createManagedBean(new rg(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this)))), this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = he(this.gos, "print"), this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new lg(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyTopRowCtrls() : [];
  }
  getStickyBottomRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyBottomRowCtrls() : [];
  }
  updateAllRowCtrls() {
    const e = Ko(this.rowCtrlsByRowIndex), t = Ko(this.zombieRowCtrls), i = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    t.length > 0 || i.length > 0 ? this.allRowCtrls = [...e, ...t, ...i] : this.allRowCtrls = e;
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  onSuppressCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onSuppressCellFocusChanged(e)), this.getFullWidthRowCtrls().forEach((t) => t.onSuppressCellFocusChanged(e));
  }
  registerCellEventListeners() {
    this.addManagedEventListeners({ cellFocused: (e) => {
      this.onCellFocusChanged(e);
    }, cellFocusCleared: () => this.onCellFocusChanged(), flashCells: (e) => {
      this.getAllCellCtrls().forEach((t) => t.onFlashCells(e));
    }, columnHoverChanged: () => {
      this.getAllCellCtrls().forEach((e) => e.onColumnHover());
    }, displayedColumnsChanged: () => {
      this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
    }, displayedColumnsWidthChanged: () => {
      this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
    } }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({ gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this) }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.columnModel.getCols().forEach((t) => {
      const i = (a) => {
        this.getAllCellCtrls().forEach((c) => {
          c.getColumn() === t && a(c);
        });
      }, s = () => {
        i((a) => a.onLeftChanged());
      }, o = () => {
        i((a) => a.onWidthChanged());
      }, r = () => {
        i((a) => a.onFirstRightPinnedChanged());
      }, n = () => {
        i((a) => a.onLastLeftPinnedChanged());
      }, l = () => {
        i((a) => a.onColDefChanged());
      };
      t.addEventListener("leftChanged", s), t.addEventListener("widthChanged", o), t.addEventListener("firstRightPinnedChanged", r), t.addEventListener("lastLeftPinnedChanged", n), t.addEventListener("colDefChanged", l), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", s), t.removeEventListener("widthChanged", o), t.removeEventListener("firstRightPinnedChanged", r), t.removeEventListener("lastLeftPinnedChanged", n), t.removeEventListener("colDefChanged", l);
      });
    });
  }
  onDomLayoutChanged() {
    const e = he(this.gos, "print"), t = e || this.gos.get("embedFullWidthRows"), i = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, i && this.redrawAfterModelUpdate({ domLayoutChanged: true });
  }
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = { recycleRows: e.keepRenderedRows, animate: e.animate, newData: e.newData, newPage: e.newPage, onlyBody: true };
    this.redrawAfterModelUpdate(t);
  }
  getAllCellsForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((i) => {
      const s = i.getCellElement(e);
      s && t.push(s);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, "top"), this.refreshFloatingRows(this.bottomRowCtrls, "bottom");
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getCentreRowCtrls() {
    return this.allRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  refreshFloatingRows(e, t) {
    const { pinnedRowModel: i, beans: s, printLayout: o } = this, r = Object.fromEntries(e.map((l) => [l.getRowNode().id, l]));
    i.forEachPinnedRow(t, (l, a) => {
      const c = e[a];
      c && i.getPinnedRowById(c.getRowNode().id, t) === void 0 && (c.destroyFirstPass(), c.destroySecondPass()), l.id in r ? (e[a] = r[l.id], delete r[l.id]) : e[a] = new Pt(l, s, false, false, o);
    });
    const n = t === "top" ? i.getPinnedTopRowCount() : i.getPinnedBottomRowCount();
    e.length = n;
  }
  onPinnedRowDataChanged() {
    const e = { recycleRows: true };
    this.redrawAfterModelUpdate(e);
  }
  redrawRow(e, t = false) {
    var _a3;
    if (e.sticky) this.stickyRowFeature.refreshStickyNode(e);
    else if ((_a3 = this.cachedRowCtrls) == null ? void 0 : _a3.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const i = (s) => {
        const o = s[e.rowIndex];
        o && o.getRowNode() === e && (o.destroyFirstPass(), o.destroySecondPass(), s[e.rowIndex] = this.createRowCon(e, false, false));
      };
      switch (e.rowPinned) {
        case "top":
          i(this.topRowCtrls);
          break;
        case "bottom":
          i(this.bottomRowCtrls);
          break;
        default:
          i(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(false);
  }
  redrawRows(e) {
    if (e != null) {
      e == null ? void 0 : e.forEach((i) => this.redrawRow(i, true)), this.dispatchDisplayedRowsChanged(false);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = (e == null ? void 0 : e.suppressKeepFocus) ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (t == null) return null;
    const i = te(this.gos), s = ui(this.gos, i, bt.DOM_DATA_KEY_CELL_CTRL), o = ui(this.gos, i, Pt.DOM_DATA_KEY_ROW_CTRL);
    return s || o ? t : null;
  }
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const i = !e.domLayoutChanged && !!e.recycleRows, s = e.animate && Nt(this.gos), o = i ? this.getRowsToRecycle() : null;
    if (i || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature) {
      this.stickyRowFeature.checkStickyRows();
      const r = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      r && this.updateContainerHeights(r);
    }
    this.recycleRows(o, s), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var _a3;
    const t = e.newData || e.newPage, i = this.gos.get("suppressScrollOnNewData");
    t && !i && (this.gridBodyCtrl.getScrollFeature().scrollToTop(), (_a3 = this.stickyRowFeature) == null ? void 0 : _a3.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let t = this.pageBoundsService.getCurrentPageHeight();
    t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t + e);
  }
  getLockOnRefresh() {
    var _a3, _b;
    if (this.refreshInProgress) throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.");
    this.refreshInProgress = true, (_b = (_a3 = this.frameworkOverrides).getLockOnRefresh) == null ? void 0 : _b.call(_a3);
  }
  releaseLockOnRefresh() {
    var _a3, _b;
    this.refreshInProgress = false, (_b = (_a3 = this.frameworkOverrides).releaseLockOnRefresh) == null ? void 0 : _b.call(_a3);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  restoreFocusedCell(e) {
    e && this.focusService.restoreFocusedCell(e, () => {
      this.onCellFocusChanged(this.gos.addGridCommonParams({ rowIndex: e.rowIndex, column: e.column, rowPinned: e.rowPinned, forceBrowserFocus: true, preventScrollOnBrowserFocus: true, type: "cellFocused" }));
    });
  }
  stopEditing(e = false) {
    this.getAllRowCtrls().forEach((t) => {
      t.stopEditing(e);
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), i = t.length;
    for (let s = 0; s < i; s++) {
      const o = t[s].getAllCellCtrls(), r = o.length;
      for (let n = 0; n < r; n++) e.push(o[n]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [], t = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [], i = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t];
    for (const s in this.rowCtrlsByRowIndex) i.push(this.rowCtrlsByRowIndex[s]);
    return i;
  }
  addRenderedRowListener(e, t, i) {
    const s = this.rowCtrlsByRowIndex[t];
    s && s.addEventListener(e, i);
  }
  flashCells(e = {}) {
    this.getCellCtrls(e.rowNodes, e.columns).forEach((t) => t.flashCell(e));
  }
  refreshCells(e = {}) {
    const t = { forceRefresh: e.force, newData: false, suppressFlash: e.suppressFlash };
    for (const i of this.getCellCtrls(e.rowNodes, e.columns)) i.refreshOrDestroyCell(t);
    this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e) return;
    let t = null;
    this.stickyRowFeature && Qo() && (t = this.getCellToRestoreFocusToAfterRefresh() || null);
    for (const i of this.getRowCtrls(e)) {
      if (!i.isFullWidth()) continue;
      i.refreshFullWidth() || this.redrawRow(i.getRowNode(), true);
    }
    this.dispatchDisplayedRowsChanged(false), t && this.restoreFocusedCell(t);
  }
  getCellRendererInstances(e) {
    var _a3;
    const t = this.getCellCtrls(e.rowNodes, e.columns).map((o) => o.getCellRenderer()).filter((o) => o != null);
    if ((_a3 = e.columns) == null ? void 0 : _a3.length) return t;
    const i = [], s = this.mapRowNodes(e.rowNodes);
    return this.getAllRowCtrls().forEach((o) => {
      if (s && !this.isRowInMap(o.getRowNode(), s) || !o.isFullWidth()) return;
      const r = o.getFullWidthCellRenderers();
      for (let n = 0; n < r.length; n++) {
        const l = r[n];
        l != null && i.push(l);
      }
    }), [...i, ...t];
  }
  getCellEditorInstances(e) {
    const t = [];
    return this.getCellCtrls(e.rowNodes, e.columns).forEach((i) => {
      const s = i.getCellEditor();
      s && t.push(s);
    }), t;
  }
  getEditingCells() {
    const e = [];
    return this.getAllCellCtrls().forEach((t) => {
      if (t.isEditing()) {
        const i = t.getCellPosition();
        e.push(i);
      }
    }), e;
  }
  mapRowNodes(e) {
    if (!e) return;
    const t = { top: {}, bottom: {}, normal: {} };
    return e.forEach((i) => {
      const s = i.id;
      switch (i.rowPinned) {
        case "top":
          t.top[s] = i;
          break;
        case "bottom":
          t.bottom[s] = i;
          break;
        default:
          t.normal[s] = i;
          break;
      }
    }), t;
  }
  isRowInMap(e, t) {
    const i = e.id;
    switch (e.rowPinned) {
      case "top":
        return t.top[i] != null;
      case "bottom":
        return t.bottom[i] != null;
      default:
        return t.normal[i] != null;
    }
  }
  getRowCtrls(e) {
    const t = this.mapRowNodes(e), i = this.getAllRowCtrls();
    return !e || !t ? i : i.filter((s) => {
      const o = s.getRowNode();
      return this.isRowInMap(o, t);
    });
  }
  getCellCtrls(e, t) {
    let i;
    E(t) && (i = {}, t.forEach((o) => {
      const r = this.columnModel.getCol(o);
      E(r) && (i[r.getId()] = true);
    }));
    const s = [];
    return this.getRowCtrls(e).forEach((o) => {
      o.getAllCellCtrls().forEach((r) => {
        const n = r.getColumn().getId();
        i && !i[n] || s.push(r);
      });
    }), s;
  }
  destroy() {
    this.removeAllRowComps(true), super.destroy();
  }
  removeAllRowComps(e = false) {
    const t = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(t, e), this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    He(this.rowCtrlsByRowIndex, (i, s) => {
      s.getRowNode().id == null && e.push(i);
    }), this.removeRowCtrls(e);
    const t = {};
    return He(this.rowCtrlsByRowIndex, (i, s) => {
      const o = s.getRowNode();
      t[o.id] = s;
    }), this.rowCtrlsByRowIndex = {}, t;
  }
  removeRowCtrls(e, t = false) {
    e.forEach((i) => {
      const s = this.rowCtrlsByRowIndex[i];
      s && (s.destroyFirstPass(t), s.destroySecondPass()), delete this.rowCtrlsByRowIndex[i];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: true });
  }
  redraw(e = {}) {
    const { afterScroll: t } = e;
    let i;
    this.stickyRowFeature && Qo() && (i = this.getCellToRestoreFocusToAfterRefresh() || void 0);
    const s = this.firstRenderedRow, o = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let r = false;
    if (this.stickyRowFeature) {
      r = this.stickyRowFeature.checkStickyRows();
      const l = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      l && this.updateContainerHeights(l);
    }
    const n = this.firstRenderedRow !== s || this.lastRenderedRow !== o;
    if (!(t && !r && !n) && (this.getLockOnRefresh(), this.recycleRows(null, false, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !r), i != null)) {
      const l = this.getCellToRestoreFocusToAfterRefresh();
      i != null && l == null && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(i));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const i = {};
    e.forEach((r) => i[r] = true);
    const o = Object.keys(this.rowCtrlsByRowIndex).filter((r) => !i[r]);
    this.removeRowCtrls(o, t);
  }
  calculateIndexesToDraw(e) {
    const t = du(this.firstRenderedRow, this.lastRenderedRow), i = (o, r) => {
      const n = r.getRowNode().rowIndex;
      n != null && (n < this.firstRenderedRow || n > this.lastRenderedRow) && this.doNotUnVirtualiseRow(r) && t.push(n);
    };
    He(this.rowCtrlsByRowIndex, i), He(e, i), t.sort((o, r) => o - r);
    const s = [];
    for (let o = 0; o < t.length; o++) {
      const r = t[o], n = this.rowModel.getRow(r);
      n && !n.sticky && s.push(r);
    }
    return s;
  }
  recycleRows(e, t = false, i = false) {
    const s = this.calculateIndexesToDraw(e);
    (this.printLayout || i) && (t = false), this.removeRowCompsNotToDraw(s, !t), s.forEach((o) => {
      this.createOrUpdateRowCtrl(o, e, t, i);
    }), e && (i && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
      this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }) : this.destroyRowCtrls(e, t)), this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = false) {
    this.eventService.dispatchEvent({ type: "displayedRowsChanged", afterScroll: e });
  }
  onDisplayedColumnsChanged() {
    const e = this.visibleColsService.isPinningLeft(), t = this.visibleColsService.isPinningRight();
    (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const i = t.getRowNode().rowIndex;
      e.push(i.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: true });
  }
  getFullWidthRowCtrls(e) {
    const t = this.mapRowNodes(e);
    return this.getAllRowCtrls().filter((i) => {
      if (!i.isFullWidth()) return false;
      const s = i.getRowNode();
      return !(t != null && !this.isRowInMap(s, t));
    });
  }
  createOrUpdateRowCtrl(e, t, i, s) {
    let o, r = this.rowCtrlsByRowIndex[e];
    if (r || (o = this.rowModel.getRow(e), E(o) && E(t) && t[o.id] && o.alreadyRendered && (r = t[o.id], t[o.id] = null)), !r) if (o || (o = this.rowModel.getRow(e)), E(o)) r = this.createRowCon(o, i, s);
    else return;
    return o && (o.alreadyRendered = true), this.rowCtrlsByRowIndex[e] = r, r;
  }
  destroyRowCtrls(e, t) {
    const i = [];
    He(e, (s, o) => {
      if (o) {
        if (this.cachedRowCtrls && o.isCacheable()) {
          this.cachedRowCtrls.addRow(o);
          return;
        }
        if (o.destroyFirstPass(!t), t) {
          const r = o.instanceId;
          this.zombieRowCtrls[r] = o, i.push(() => {
            o.destroySecondPass(), delete this.zombieRowCtrls[r];
          });
        } else o.destroySecondPass();
      }
    }), t && (i.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), Al(i));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = ts(this.gos);
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    this.rowContainerHeightService.updateOffset();
    let e, t;
    if (!this.rowModel.isRowsToRender()) e = 0, t = -1;
    else if (this.printLayout) this.environment.refreshRowHeightVariable(), e = this.pageBoundsService.getFirstRow(), t = this.pageBoundsService.getLastRow();
    else {
      const l = this.getRowBufferInPixels(), a = this.ctrlsService.getGridBodyCtrl(), c = this.gos.get("suppressRowVirtualisation");
      let u = false, d, h;
      do {
        const v = this.pageBoundsService.getPixelOffset(), { pageFirstPixel: w, pageLastPixel: S } = this.pageBoundsService.getCurrentPagePixelRange(), b = this.rowContainerHeightService.getDivStretchOffset(), x = a.getScrollFeature().getVScrollPosition(), M = x.top, P = x.bottom;
        c ? (d = w + b, h = S + b) : (d = Math.max(M + v - l, w) + b, h = Math.min(P + v + l, S) + b), this.firstVisibleVPixel = Math.max(M + v, w) + b, this.lastVisibleVPixel = Math.min(P + v, S) + b, u = this.ensureAllRowsInRangeHaveHeightsCalculated(d, h);
      } while (u);
      let g = this.rowModel.getRowIndexAtPixel(d), m = this.rowModel.getRowIndexAtPixel(h);
      const C = this.pageBoundsService.getFirstRow(), f = this.pageBoundsService.getLastRow();
      g < C && (g = C), m > f && (m = f), e = g, t = m;
    }
    const i = he(this.gos, "normal"), s = this.gos.get("suppressMaxRenderedRowRestriction"), o = Math.max(this.getRowBuffer(), 500);
    i && !s && t - e > o && (t = e + o);
    const r = e !== this.firstRenderedRow, n = t !== this.lastRenderedRow;
    (r || n) && (this.firstRenderedRow = e, this.lastRenderedRow = t, this.eventService.dispatchEvent({ type: "viewportChanged", firstRow: e, lastRow: t }));
  }
  dispatchFirstDataRenderedEvent() {
    this.dataFirstRenderedFired || (this.dataFirstRenderedFired = true, window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent({ type: "firstDataRendered", firstRow: this.firstRenderedRow, lastRow: this.lastRenderedRow });
    }));
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var _a3, _b;
    const i = (_a3 = this.pinnedRowModel) == null ? void 0 : _a3.ensureRowHeightsValid(), s = (_b = this.stickyRowFeature) == null ? void 0 : _b.ensureRowHeightsValid(), o = this.rowModel.ensureRowHeightsValid(e, t, this.pageBoundsService.getFirstRow(), this.pageBoundsService.getLastRow());
    return (o || s) && this.eventService.dispatchEvent({ type: "recalculateRowBounds" }), s || o || i ? (this.updateContainerHeights(), true) : false;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getLastVisibleVerticalPixel() {
    return this.lastVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  doNotUnVirtualiseRow(e) {
    const s = e.getRowNode(), o = this.focusService.isRowNodeFocused(s), r = e.isEditing(), n = s.detail;
    return o || r || n ? !!this.isRowPresent(s) : false;
  }
  isRowPresent(e) {
    return this.rowModel.isRowPresent(e) ? this.paginationService ? this.paginationService.isRowPresent(e) : true : false;
  }
  createRowCon(e, t, i) {
    const s = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
    if (s) return s;
    const o = this.gos.get("suppressAnimationFrame"), r = i && !o && !this.printLayout;
    return new Pt(e, this.beans, t, r, this.printLayout);
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.values(e).map((t) => t.getRowNode());
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: i } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[i];
        break;
      case "bottom":
        t = this.bottomRowCtrls[i];
        break;
      default:
        t = this.rowCtrlsByRowIndex[i], t || (t = this.getStickyTopRowCtrls().find((s) => s.getRowNode().rowIndex === i) || null, t || (t = this.getStickyBottomRowCtrls().find((s) => s.getRowNode().rowIndex === i) || null));
        break;
    }
    return t;
  }
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null) return false;
    const s = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !s;
  }
}, lg = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(true), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null) return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(false), t.getRowNode() != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, i = this.entriesMap[t];
    delete this.entriesMap[t], Fe(this.entriesList, i);
  }
  removeFromCache(e) {
    const t = e.getRowNode().id;
    delete this.entriesMap[t], Fe(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
}, ag = class extends R {
  constructor() {
    super(...arguments), this.beanName = "pinnedRowModel", this.nextId = 0, this.pinnedTopRows = new lr(), this.pinnedBottomRows = new lr();
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.setPinnedRowData(this.gos.get("pinnedTopRowData"), "top"), this.setPinnedRowData(this.gos.get("pinnedBottomRowData"), "bottom"), this.addManagedPropertyListener("pinnedTopRowData", (e) => this.setPinnedRowData(e.currentValue, "top")), this.addManagedPropertyListener("pinnedBottomRowData", (e) => this.setPinnedRowData(e.currentValue, "bottom")), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  isEmpty(e) {
    return (e === "top" ? this.pinnedTopRows : this.pinnedBottomRows).isEmpty();
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const t = (i) => {
        i.setRowHeight(i.rowHeight, true);
      };
      this.pinnedBottomRows.forEach(t), this.pinnedTopRows.forEach(t);
    }
  }
  ensureRowHeightsValid() {
    var _a3, _b;
    let e = false, t = 0;
    const i = (s) => {
      if (s.rowHeightEstimated) {
        const o = ut(this.gos, s);
        s.setRowTop(t), s.setRowHeight(o.height), t += o.height, e = true;
      }
    };
    return (_a3 = this.pinnedBottomRows) == null ? void 0 : _a3.forEach(i), t = 0, (_b = this.pinnedTopRows) == null ? void 0 : _b.forEach(i), this.eventService.dispatchEvent({ type: "pinnedHeightChanged" }), e;
  }
  setPinnedRowData(e, t) {
    this.updateNodesFromRowData(e, t), this.eventService.dispatchEvent({ type: "pinnedRowDataChanged" });
  }
  updateNodesFromRowData(e, t) {
    const i = t === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (e === void 0) {
      i.clear();
      return;
    }
    const s = Ci(this.gos), o = t === "top" ? Ft.ID_PREFIX_TOP_PINNED : Ft.ID_PREFIX_BOTTOM_PINNED, r = i.getIds(), n = [], l = /* @__PURE__ */ new Set();
    let a = 0, c = -1;
    for (const u of e) {
      const d = (s == null ? void 0 : s({ data: u, level: 0, rowPinned: t })) ?? o + this.nextId++;
      if (l.has(d)) {
        F("Duplicate ID", d, "found for pinned row with data", u, "When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter.");
        continue;
      }
      c++, l.add(d), n.push(d);
      const h = i.getById(d);
      if (h !== void 0) h.data !== u && h.setData(u), a += this.setRowTopAndRowIndex(h, a, c), r.delete(d);
      else {
        const g = new Ft(this.beans);
        g.id = d, g.data = u, g.rowPinned = t, a += this.setRowTopAndRowIndex(g, a, c), i.push(g);
      }
    }
    r.forEach((u) => {
      var _a3;
      (_a3 = i.getById(u)) == null ? void 0 : _a3.clearRowTopAndRowIndex();
    }), i.removeAllById(r), i.setOrder(n);
  }
  setRowTopAndRowIndex(e, t, i) {
    return e.setRowTop(t), e.setRowHeight(ut(this.gos, e).height), e.setRowIndex(i), e.rowHeight;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows.getSize();
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows.getSize();
  }
  getPinnedTopRow(e) {
    return this.pinnedTopRows.getByIndex(e);
  }
  getPinnedBottomRow(e) {
    return this.pinnedBottomRows.getByIndex(e);
  }
  getPinnedRowById(e, t) {
    return t === "top" ? this.pinnedTopRows.getById(e) : this.pinnedBottomRows.getById(e);
  }
  forEachPinnedRow(e, t) {
    return e === "top" ? this.pinnedTopRows.forEach(t) : this.pinnedBottomRows.forEach(t);
  }
  getTotalHeight(e) {
    const t = e.getSize();
    if (t === 0) return 0;
    const i = e.getByIndex(t - 1);
    return i === void 0 ? 0 : i.rowTop + i.rowHeight;
  }
}, lr = class {
  constructor() {
    this.cache = {}, this.ordering = [];
  }
  getById(e) {
    return this.cache[e];
  }
  getByIndex(e) {
    const t = this.ordering[e];
    return this.cache[t];
  }
  push(e) {
    this.cache[e.id] = e, this.ordering.push(e.id);
  }
  removeAllById(e) {
    for (const t of e) delete this.cache[t];
    this.ordering = this.ordering.filter((t) => !e.has(t));
  }
  setOrder(e) {
    this.ordering = e;
  }
  forEach(e) {
    this.ordering.forEach((t, i) => {
      const s = this.cache[t];
      s && e(s, i);
    });
  }
  clear() {
    this.ordering.length = 0, this.cache = {};
  }
  isEmpty() {
    return this.ordering.length === 0;
  }
  getSize() {
    return this.ordering.length;
  }
  getIds() {
    return new Set(this.ordering);
  }
}, cg = class {
  constructor() {
    this.root = null, this.end = null, this.cachedRange = [];
  }
  init(e) {
    this.rowModel = e;
  }
  reset() {
    this.root = null, this.end = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.root = e, this.end = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.end = e, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null) return this.cachedRange;
      this.cachedRange = this.rowModel.getNodesInRangeForSelection(e, t);
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.root === null ? false : this.getRange().some((t) => t.id === e.id);
  }
  getRoot() {
    var _a3;
    return this.root && ((_a3 = this.root) == null ? void 0 : _a3.key) === null && (this.root = this.rowModel.getRowNode(this.root.id) ?? null), this.root;
  }
  getEnd() {
    var _a3;
    return this.end && ((_a3 = this.end) == null ? void 0 : _a3.key) === null && (this.end = this.rowModel.getRowNode(this.end.id) ?? null), this.end;
  }
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0) return { keep: [], discard: [] };
    const i = t[0].id === this.root.id, s = t.findIndex((o) => o.id === e.id);
    if (s > -1) {
      const o = t.slice(0, s), r = t.slice(s + 1);
      return this.setEndRange(e), i ? { keep: o, discard: r } : { keep: r, discard: o };
    } else return { keep: t, discard: [] };
  }
  extend(e, t = false) {
    const i = this.getRoot();
    if (i == null) {
      const o = this.getRange().slice();
      return t && e.depthFirstSearch((r) => !r.group && o.push(r)), o.push(e), this.setRoot(e), { keep: o, discard: [] };
    }
    if (this.rowModel.getNodesInRangeForSelection(i, e).find((o) => {
      var _a3;
      return o.id === ((_a3 = this.end) == null ? void 0 : _a3.id);
    })) return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const o = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: o };
    }
  }
}, ug = class extends R {
  constructor() {
    super(...arguments), this.beanName = "stylingService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService;
  }
  processAllCellClasses(e, t, i, s) {
    this.processClassRules(void 0, e.cellClassRules, t, i, s), this.processStaticCellClasses(e, t, i);
  }
  processClassRules(e, t, i, s, o) {
    if (t == null && e == null) return;
    const r = {}, n = {}, l = (a, c) => {
      a.split(" ").forEach((u) => {
        u.trim() != "" && c(u);
      });
    };
    if (t) {
      const a = Object.keys(t);
      for (let c = 0; c < a.length; c++) {
        const u = a[c], d = t[u];
        let h;
        typeof d == "string" ? h = this.expressionService.evaluate(d, i) : typeof d == "function" && (h = d(i)), l(u, (g) => {
          h ? r[g] = true : n[g] = true;
        });
      }
    }
    e && o && Object.keys(e).forEach((a) => l(a, (c) => {
      r[c] || (n[c] = true);
    })), o && Object.keys(n).forEach(o), Object.keys(r).forEach(s);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: i } = e;
    if (!i) return [];
    let s;
    return typeof i == "function" ? s = i(t) : s = i, typeof s == "string" && (s = [s]), s || [];
  }
  processStaticCellClasses(e, t, i) {
    this.getStaticCellClasses(e, t).forEach((o) => {
      i(o);
    });
  }
}, ki = ((e) => (e.TAB_GUARD = "ag-tab-guard", e.TAB_GUARD_TOP = "ag-tab-guard-top", e.TAB_GUARD_BOTTOM = "ag-tab-guard-bottom", e))(ki || {}), el = class extends R {
  constructor(e) {
    super(), this.skipTabGuardFocus = false, this.forcingFocusOut = false, this.allowFocus = false;
    const { comp: t, eTopGuard: i, eBottomGuard: s, focusTrapActive: o, forceFocusOutWhenTabGuardsAreEmpty: r, isFocusableContainer: n, focusInnerElement: l, onFocusIn: a, onFocusOut: c, shouldStopEventPropagation: u, onTabKeyDown: d, handleKeyDown: h, eFocusableElement: g } = e;
    this.comp = t, this.eTopGuard = i, this.eBottomGuard = s, this.providedFocusInnerElement = l, this.eFocusableElement = g, this.focusTrapActive = !!o, this.forceFocusOutWhenTabGuardsAreEmpty = !!r, this.isFocusableContainer = !!n, this.providedFocusIn = a, this.providedFocusOut = c, this.providedShouldStopEventPropagation = u, this.providedOnTabKeyDown = d, this.providedHandleKeyDown = h;
  }
  wireBeans(e) {
    this.focusService = e.focusService;
  }
  postConstruct() {
    this.createManagedBean(new At(this.eFocusableElement, { shouldStopEventPropagation: () => this.shouldStopEventPropagation(), onTabKeyDown: (e) => this.onTabKeyDown(e), handleKeyDown: (e) => this.handleKeyDown(e), onFocusIn: (e) => this.onFocusIn(e), onFocusOut: (e) => this.onFocusOut(e) })), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach((e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) }));
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : false;
  }
  activateTabGuards() {
    if (this.forcingFocusOut) return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = false;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget)) return;
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  findNextElementOutsideAndFocus(e) {
    var _a3;
    const t = re(this.gos), i = this.focusService.findFocusableElements(t.body, null, true), s = i.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (s === -1) return;
    let o, r;
    e ? (o = 0, r = s) : (o = s + 1, r = i.length);
    const n = i.slice(o, r), l = this.gos.get("tabIndex");
    n.sort((a, c) => {
      const u = parseInt(a.getAttribute("tabindex") || "0"), d = parseInt(c.getAttribute("tabindex") || "0");
      return d === l ? 1 : u === l ? -1 : u === 0 ? 1 : d === 0 ? -1 : u - d;
    }), (_a3 = n[e ? n.length - 1 : 0]) == null ? void 0 : _a3.focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented) return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const i = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), i && (i.focus(), e.preventDefault());
  }
  focusInnerElement(e = false) {
    const t = this.focusService.findFocusableElements(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: true });
  }
  getNextFocusableElement(e) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, false, e);
  }
  forceFocusOutOfContainer(e = false) {
    if (this.forcingFocusOut) return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = true, this.forcingFocusOut = true, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = false, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? true);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, dg = class extends R {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: i, eFocusableElement: s } = this, o = [t, i], r = { setTabIndex: (C) => {
      o.forEach((f) => C != null ? f.setAttribute("tabindex", C) : f.removeAttribute("tabindex"));
    } };
    this.addTabGuards(t, i);
    const { focusTrapActive: n = false, onFocusIn: l, onFocusOut: a, focusInnerElement: c, handleKeyDown: u, onTabKeyDown: d, shouldStopEventPropagation: h, forceFocusOutWhenTabGuardsAreEmpty: g, isFocusableContainer: m } = e;
    this.tabGuardCtrl = this.createManagedBean(new el({ comp: r, focusTrapActive: n, eTopGuard: t, eBottomGuard: i, eFocusableElement: s, onFocusIn: l, onFocusOut: a, focusInnerElement: c, handleKeyDown: u, onTabKeyDown: d, shouldStopEventPropagation: h, forceFocusOutWhenTabGuardsAreEmpty: g, isFocusableContainer: m }));
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = re(this.gos).createElement("div"), i = e === "top" ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
    return t.classList.add("ag-tab-guard", i), Ve(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", e), this.eFocusableElement.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    xe(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = false) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, i) {
    ho(t) || (t = t.getGui());
    const { eBottomGuard: s } = this;
    s ? s.insertAdjacentElement("beforebegin", t) : e(t, i);
  }
}, hg = class extends Y {
  initialiseTabGuard(t) {
    this.tabGuardFeature = this.createManagedBean(new dg(this)), this.tabGuardFeature.initialiseTabGuard(t);
  }
  forceFocusOutOfContainer(t = false) {
    this.tabGuardFeature.forceFocusOutOfContainer(t);
  }
  appendChild(t, i) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), t, i);
  }
}, gg = 0, pg = 200, fg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "popupService", this.popupList = [];
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.resizeObserverService = e.resizeObserverService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: i } = e, s = this.getPopupIndex(i);
    if (s !== -1) {
      const g = this.popupList[s];
      g.alignedToElement = t;
    }
    const o = t.getBoundingClientRect(), r = this.getParentRect(), n = this.keepXYWithinBounds(i, o.top - r.top, 0), l = i.clientWidth > 0 ? i.clientWidth : 200;
    i.style.minWidth = `${l}px`;
    const c = r.right - r.left - l;
    let u;
    this.gos.get("enableRtl") ? (u = h(), u < 0 && (u = d(), this.setAlignedStyles(i, "left")), u > c && (u = 0, this.setAlignedStyles(i, "right"))) : (u = d(), u > c && (u = h(), this.setAlignedStyles(i, "right")), u < 0 && (u = 0, this.setAlignedStyles(i, "left"))), i.style.left = `${u}px`, i.style.top = `${n}px`;
    function d() {
      return o.right - r.left - 2;
    }
    function h() {
      return o.left - r.left - l;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: i, nudgeY: s, skipObserver: o } = e;
    this.positionPopup({ ePopup: t, nudgeX: i, nudgeY: s, keepWithinBounds: true, skipObserver: o, updatePosition: () => this.calculatePointerAlign(e.mouseEvent), postProcessCallback: () => this.callPostProcessPopup(e.type, e.ePopup, null, e.mouseEvent, e.column, e.rowNode) });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return { x: e.clientX - t.left, y: e.clientY - t.top };
  }
  positionPopupByComponent(e) {
    const { ePopup: t, nudgeX: i, nudgeY: s, keepWithinBounds: o, eventSource: r, alignSide: n = "left", position: l = "over", column: a, rowNode: c, type: u } = e, d = r.getBoundingClientRect(), h = this.getParentRect(), g = this.getPopupIndex(t);
    if (g !== -1) {
      const C = this.popupList[g];
      C.alignedToElement = r;
    }
    const m = () => {
      let C = d.left - h.left;
      n === "right" && (C -= t.offsetWidth - d.width);
      let f;
      return l === "over" ? (f = d.top - h.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, d, h, e.nudgeY || 0) === "under" ? f = d.top - h.top + d.height : f = d.top - t.offsetHeight - (s || 0) * 2 - h.top), { x: C, y: f };
    };
    this.positionPopup({ ePopup: t, nudgeX: i, nudgeY: s, keepWithinBounds: o, updatePosition: m, postProcessCallback: () => this.callPostProcessPopup(u, t, r, null, a, c) });
  }
  shouldRenderUnderOrAbove(e, t, i, s) {
    const o = i.bottom - t.bottom, r = t.top - i.top, n = e.offsetHeight + s;
    return o > n ? "under" : r > n || r > o ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const i = this.getPopupIndex(e);
    if (i === -1) return;
    const s = this.popupList[i], { alignedToElement: o } = s;
    !o || (["right", "left", "over", "above", "under"].forEach((n) => {
      o.classList.remove(`ag-has-popup-positioned-${n}`), e.classList.remove(`ag-popup-positioned-${n}`);
    }), !t) || (o.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  callPostProcessPopup(e, t, i, s, o, r) {
    const n = this.gos.getCallback("postProcessPopup");
    n && n({ column: o, rowNode: r, ePopup: t, type: e, eventSource: i, mouseEvent: s });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: i, nudgeX: s, nudgeY: o, skipObserver: r, updatePosition: n } = e, l = { width: 0, height: 0 }, a = (c = false) => {
      let { x: u, y: d } = n();
      c && t.clientWidth === l.width && t.clientHeight === l.height || (l.width = t.clientWidth, l.height = t.clientHeight, s && (u += s), o && (d += o), i && (u = this.keepXYWithinBounds(t, u, 1), d = this.keepXYWithinBounds(t, d, 0)), t.style.left = `${u}px`, t.style.top = `${d}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (a(), !r) {
      const c = this.resizeObserverService.observeResize(t, () => a(true));
      setTimeout(() => c(), pg);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const e = re(this.gos);
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), Zr(t);
  }
  keepXYWithinBounds(e, t, i) {
    const s = i === 0, o = s ? "clientHeight" : "clientWidth", r = s ? "top" : "left", n = s ? "height" : "width", l = s ? "scrollTop" : "scrollLeft", a = re(this.gos), c = a.documentElement, u = this.getPopupParent(), d = e.getBoundingClientRect(), h = u.getBoundingClientRect(), g = a.documentElement.getBoundingClientRect(), m = u === a.body, C = Math.ceil(d[n]);
    let v = m ? (s ? Jr : qi)(c) + c[l] : u[o];
    m && (v -= Math.abs(g[r] - h[r]));
    const w = v - C;
    return Math.min(Math.max(t, 0), Math.abs(w));
  }
  addPopup(e) {
    const t = re(this.gos), { eChild: i, ariaLabel: s, alwaysOnTop: o, positionCallback: r, anchorToElement: n } = e;
    if (!t) return F("could not find the document, document is empty"), { hideFunc: () => {
    } };
    const l = this.getPopupIndex(i);
    if (l !== -1) return { hideFunc: this.popupList[l].hideFunc };
    this.initialisePopupPosition(i);
    const a = this.createPopupWrapper(i, s, !!o), c = this.addEventListenersToPopup({ ...e, wrapperEl: a });
    return r && r(), this.addPopupToPopupList(i, a, c, n), { hideFunc: c };
  }
  initialisePopupPosition(e) {
    const i = this.getPopupParent().getBoundingClientRect();
    E(e.style.top) || (e.style.top = `${i.top * -1}px`), E(e.style.left) || (e.style.left = `${i.left * -1}px`);
  }
  createPopupWrapper(e, t, i) {
    const s = this.getPopupParent(), o = document.createElement("div");
    return this.environment.applyThemeClasses(o), o.classList.add("ag-popup"), e.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || Ve(e, "dialog"), _t(e, t), o.appendChild(e), s.appendChild(o), i ? this.setAlwaysOnTop(e, true) : this.bringPopupToFront(e), o;
  }
  handleThemeChange(e) {
    if (e.themeChanged) for (const t of this.popupList) this.environment.applyThemeClasses(t.wrapper);
  }
  addEventListenersToPopup(e) {
    const t = re(this.gos), i = this.getPopupParent(), { wrapperEl: s, eChild: o, closedCallback: r, afterGuiAttached: n, closeOnEsc: l, modal: a } = e;
    let c = false;
    const u = (m) => {
      if (!s.contains(te(this.gos))) return;
      m.key === y.ESCAPE && !Ze(m) && g({ keyboardEvent: m });
    }, d = (m) => g({ mouseEvent: m }), h = (m) => g({ touchEvent: m }), g = (m = {}) => {
      const { mouseEvent: C, touchEvent: f, keyboardEvent: v, forceHide: w } = m;
      !w && (this.isEventFromCurrentPopup({ mouseEvent: C, touchEvent: f }, o) || c) || (c = true, i.removeChild(s), t.removeEventListener("keydown", u), t.removeEventListener("mousedown", d), t.removeEventListener("touchstart", h), t.removeEventListener("contextmenu", d), this.eventService.removeEventListener("dragStarted", d), r && r(C || f || v), this.removePopupFromPopupList(o));
    };
    return n && n({ hidePopup: g }), window.setTimeout(() => {
      l && t.addEventListener("keydown", u), a && (t.addEventListener("mousedown", d), this.eventService.addEventListener("dragStarted", d), t.addEventListener("touchstart", h), t.addEventListener("contextmenu", d));
    }, 0), g;
  }
  addPopupToPopupList(e, t, i, s) {
    this.popupList.push({ element: e, wrapper: t, hideFunc: i, instanceId: gg++, isAnchored: !!s }), s && this.setPopupPositionRelatedToElement(e, s);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const i = this.getPopupIndex(e);
    if (i === -1) return;
    const s = this.popupList[i];
    if (s.stopAnchoringPromise && s.stopAnchoringPromise.then((r) => r && r()), s.stopAnchoringPromise = void 0, s.isAnchored = false, !t) return;
    const o = this.keepPopupPositionedRelativeTo({ element: t, ePopup: e, hidePopup: s.hideFunc });
    return s.stopAnchoringPromise = o, s.isAnchored = true, o;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), i = t.getBoundingClientRect(), { element: s, ePopup: o } = e, r = s.getBoundingClientRect(), n = (d) => parseInt(d.substring(0, d.length - 1), 10), l = (d, h) => {
      const g = i[d] - r[d], m = n(o.style[d]);
      return { initialDiff: g, lastDiff: g, initial: m, last: m, direction: h };
    }, a = l("top", 0), c = l("left", 1), u = this.getFrameworkOverrides();
    return new oe((d) => {
      u.wrapIncoming(() => {
        u.setInterval(() => {
          const h = t.getBoundingClientRect(), g = s.getBoundingClientRect();
          if (g.top == 0 && g.left == 0 && g.height == 0 && g.width == 0) {
            e.hidePopup();
            return;
          }
          const C = (f, v) => {
            const w = n(o.style[v]);
            f.last !== w && (f.initial = w, f.last = w);
            const S = h[v] - g[v];
            if (S != f.lastDiff) {
              const b = this.keepXYWithinBounds(o, f.initial + f.initialDiff - S, f.direction);
              o.style[v] = `${b}px`, f.last = b;
            }
            f.lastDiff = S;
          };
          C(a, "top"), C(c, "left");
        }, 200).then((h) => {
          d(() => {
            h != null && window.clearInterval(h);
          });
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: i, touchEvent: s } = e, o = i || s;
    if (!o) return false;
    const r = this.getPopupIndex(t);
    if (r === -1) return false;
    for (let n = r; n < this.popupList.length; n++) {
      const l = this.popupList[n];
      if (Yl(l.element, o)) return true;
    }
    return this.isElementWithinCustomPopup(o.target);
  }
  isElementWithinCustomPopup(e) {
    const t = re(this.gos);
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null) return true;
      e = e.parentElement;
    }
    return false;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; ) e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const i = this.getWrapper(e);
    i && (i.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(i));
  }
  bringPopupToFront(e) {
    const t = this.getPopupParent(), i = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), s = i.length, o = this.getWrapper(e);
    if (!o || s <= 1 || !t.contains(e)) return;
    const r = [], n = [];
    for (const h of i) h !== o && (h.classList.contains("ag-always-on-top") ? n.push(h) : r.push(h));
    const l = [], a = n.length, d = o.classList.contains("ag-always-on-top") || !a ? [...r, ...n, o] : [...r, o, ...n];
    for (let h = 0; h <= s; h++) {
      const g = d[h];
      if (i[h] === d[h] || g === o) continue;
      g.querySelectorAll("div").forEach((C) => {
        C.scrollTop !== 0 && l.push([C, C.scrollTop]);
      }), h === 0 ? t.insertAdjacentElement("afterbegin", g) : d[h - 1].insertAdjacentElement("afterend", g);
    }
    for (; l.length; ) {
      const h = l.pop();
      h[0].scrollTop = h[1];
    }
  }
}, mg = ["touchstart", "touchend", "touchmove", "touchcancel"], tl = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t();
  }
  setInterval(e, t) {
    return new oe((i) => {
      i(window.setInterval(e, t));
    });
  }
  addEventListener(e, t, i, s) {
    const o = Rt(mg, t);
    e.addEventListener(t, i, { capture: !!s, passive: o });
  }
  get shouldWrapOutgoing() {
    return false;
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return false;
  }
  getDocLink(e) {
    return `https://www.ag-grid.com/${this.frameworkName === "solid" ? "react" : this.frameworkName}-data-grid${e ? `/${e}` : ""}`;
  }
}, Cg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "cellNavigationService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.pinnedRowModel = e.pinnedRowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  getNextCellToFocus(e, t, i = false) {
    return i ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const i = e === y.UP, s = e === y.DOWN, o = e === y.LEFT;
    let r, n;
    if (i || s) n = i ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow(), r = t.column;
    else {
      const l = this.visibleColsService.getAllCols(), a = this.gos.get("enableRtl");
      n = t.rowIndex, r = o !== a ? l[0] : N(l);
    }
    return { rowIndex: n, rowPinned: null, column: r };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let i = t, s = false;
    for (; !s; ) {
      switch (e) {
        case y.UP:
          i = this.getCellAbove(i);
          break;
        case y.DOWN:
          i = this.getCellBelow(i);
          break;
        case y.RIGHT:
          this.gos.get("enableRtl") ? i = this.getCellToLeft(i) : i = this.getCellToRight(i);
          break;
        case y.LEFT:
          this.gos.get("enableRtl") ? i = this.getCellToRight(i) : i = this.getCellToLeft(i);
          break;
        default:
          i = null, F("unknown key for navigation ", e);
          break;
      }
      i ? s = this.isCellGoodToFocusOn(i) : s = true;
    }
    return i;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let i;
    switch (e.rowPinned) {
      case "top":
        i = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        i = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        i = this.rowModel.getRow(e.rowIndex);
        break;
    }
    return i ? !t.isSuppressNavigable(i) : false;
  }
  getCellToLeft(e) {
    if (!e) return null;
    const t = this.visibleColsService.getColBefore(e.column);
    return t ? { rowIndex: e.rowIndex, column: t, rowPinned: e.rowPinned } : null;
  }
  getCellToRight(e) {
    if (!e) return null;
    const t = this.visibleColsService.getColAfter(e.column);
    return t ? { rowIndex: e.rowIndex, column: t, rowPinned: e.rowPinned } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, i = e.rowPinned;
    let s = false;
    if (this.isLastRowInContainer(e)) switch (i) {
      case "bottom":
        return null;
      case "top":
        return this.rowModel.isRowsToRender() ? { rowIndex: this.pageBoundsService.getFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      default:
        return this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
    }
    else i && (s = true);
    const o = this.rowModel.getRow(e.rowIndex), r = s ? void 0 : this.getNextStickyPosition(o);
    return r || { rowIndex: t + 1, rowPinned: i };
  }
  getNextStickyPosition(e, t) {
    if (!is(this.gos) || !e || !e.sticky) return;
    const i = this.rowRenderer.getStickyTopRowCtrls().some((l) => l.getRowNode().rowIndex === e.rowIndex);
    let s = [];
    i ? s = [...this.rowRenderer.getStickyTopRowCtrls()].sort((l, a) => l.getRowNode().rowIndex - a.getRowNode().rowIndex) : s = [...this.rowRenderer.getStickyBottomRowCtrls()].sort((l, a) => a.getRowNode().rowIndex - l.getRowNode().rowIndex);
    const o = t ? -1 : 1, r = s.findIndex((l) => l.getRowNode().rowIndex === e.rowIndex), n = s[r + o];
    if (n) return { rowIndex: n.getRowNode().rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e) return null;
    const t = this.getRowBelow(e);
    return t ? { rowIndex: t.rowIndex, column: e.column, rowPinned: t.rowPinned } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, i = e.rowIndex;
    return t === "top" ? this.pinnedRowModel.getPinnedTopRowCount() - 1 <= i : t === "bottom" ? this.pinnedRowModel.getPinnedBottomRowCount() - 1 <= i : this.pageBoundsService.getLastRow() <= i;
  }
  getRowAbove(e) {
    const t = e.rowIndex, i = e.rowPinned, s = i ? t === 0 : t === this.pageBoundsService.getFirstRow();
    let o = false;
    if (s) return i === "top" ? null : i ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
    i && (o = true);
    const r = this.rowModel.getRow(e.rowIndex), n = o ? void 0 : this.getNextStickyPosition(r, true);
    return n || { rowIndex: t - 1, rowPinned: i };
  }
  getCellAbove(e) {
    if (!e) return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? { rowIndex: t.rowIndex, column: e.column, rowPinned: t.rowPinned } : null;
  }
  getLastBodyCell() {
    return { rowIndex: this.pageBoundsService.getLastRow(), rowPinned: null };
  }
  getLastFloatingTopRow() {
    return { rowIndex: this.pinnedRowModel.getPinnedTopRowCount() - 1, rowPinned: "top" };
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    var _a3;
    const t = this.visibleColsService.getAllCols();
    let i = e.rowIndex, s = e.rowPinned, o = this.visibleColsService.getColAfter(e.column);
    if (!o) {
      o = t[0];
      const r = this.getRowBelow(e);
      if (V(r) || !r.rowPinned && !(((_a3 = this.paginationService) == null ? void 0 : _a3.isRowInPage(r)) ?? true)) return null;
      i = r ? r.rowIndex : null, s = r ? r.rowPinned : null;
    }
    return { rowIndex: i, column: o, rowPinned: s };
  }
  getNextTabbedCellBackwards(e) {
    var _a3;
    const t = this.visibleColsService.getAllCols();
    let i = e.rowIndex, s = e.rowPinned, o = this.visibleColsService.getColBefore(e.column);
    if (!o) {
      o = N(t);
      const r = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (V(r) || !r.rowPinned && !(((_a3 = this.paginationService) == null ? void 0 : _a3.isRowInPage(r)) ?? true)) return null;
      i = r ? r.rowIndex : null, s = r ? r.rowPinned : null;
    }
    return { rowIndex: i, column: o, rowPinned: s };
  }
}, Ce = (e, t) => {
  for (const i in t) t[i] = e;
  return t;
}, ar = { ...Ce("@ag-grid-community/core", { dispatchEvent: 0, destroy: 0, getGridId: 0, getGridOption: 0, isDestroyed: 0, setGridOption: 0, updateGridOptions: 0, getState: 0, setNodesSelected: 0, selectAll: 0, deselectAll: 0, selectAllFiltered: 0, deselectAllFiltered: 0, selectAllOnCurrentPage: 0, deselectAllOnCurrentPage: 0, getSelectedNodes: 0, getSelectedRows: 0, redrawRows: 0, setRowNodeExpanded: 0, getRowNode: 0, addRenderedRowListener: 0, getRenderedNodes: 0, forEachNode: 0, getFirstDisplayedRow: 0, getFirstDisplayedRowIndex: 0, getLastDisplayedRow: 0, getLastDisplayedRowIndex: 0, getDisplayedRowAtIndex: 0, getDisplayedRowCount: 0, getModel: 0, getVerticalPixelRange: 0, getHorizontalPixelRange: 0, ensureColumnVisible: 0, ensureIndexVisible: 0, ensureNodeVisible: 0, getFocusedCell: 0, clearFocusedCell: 0, setFocusedCell: 0, tabToNextCell: 0, tabToPreviousCell: 0, setFocusedHeader: 0, addEventListener: 0, addGlobalListener: 0, removeEventListener: 0, removeGlobalListener: 0, expireValueCache: 0, getValue: 0, getCellValue: 0, showColumnMenuAfterButtonClick: 0, showColumnMenuAfterMouseClick: 0, showColumnMenu: 0, hidePopupMenu: 0, onSortChanged: 0, getPinnedTopRowCount: 0, getPinnedBottomRowCount: 0, getPinnedTopRow: 0, getPinnedBottomRow: 0, showLoadingOverlay: 0, showNoRowsOverlay: 0, hideOverlay: 0, setGridAriaProperty: 0, refreshCells: 0, flashCells: 0, refreshHeader: 0, isAnimationFrameQueueEmpty: 0, flushAllAnimationFrames: 0, getSizesForCurrentTheme: 0, getCellRendererInstances: 0, addRowDropZone: 0, removeRowDropZone: 0, getRowDropZoneParams: 0, getColumnDef: 0, getColumnDefs: 0, sizeColumnsToFit: 0, setColumnGroupOpened: 0, getColumnGroup: 0, getProvidedColumnGroup: 0, getDisplayNameForColumn: 0, getDisplayNameForColumnGroup: 0, getColumn: 0, getColumns: 0, applyColumnState: 0, getColumnState: 0, resetColumnState: 0, getColumnGroupState: 0, setColumnGroupState: 0, resetColumnGroupState: 0, isPinning: 0, isPinningLeft: 0, isPinningRight: 0, getDisplayedColAfter: 0, getDisplayedColBefore: 0, setColumnVisible: 0, setColumnsVisible: 0, setColumnPinned: 0, setColumnsPinned: 0, getAllGridColumns: 0, getDisplayedLeftColumns: 0, getDisplayedCenterColumns: 0, getDisplayedRightColumns: 0, getAllDisplayedColumns: 0, getAllDisplayedVirtualColumns: 0, moveColumn: 0, moveColumnByIndex: 0, moveColumns: 0, setColumnWidth: 0, setColumnWidths: 0, getLeftDisplayedColumnGroups: 0, getCenterDisplayedColumnGroups: 0, getRightDisplayedColumnGroups: 0, getAllDisplayedColumnGroups: 0, autoSizeColumn: 0, autoSizeColumns: 0, autoSizeAllColumns: 0, undoCellEditing: 0, redoCellEditing: 0, getCellEditorInstances: 0, getEditingCells: 0, stopEditing: 0, startEditingCell: 0, getCurrentUndoSize: 0, getCurrentRedoSize: 0, isAnyFilterPresent: 0, onFilterChanged: 0, isColumnFilterPresent: 0, getFilterInstance: 0, getColumnFilterInstance: 0, destroyFilter: 0, setFilterModel: 0, getFilterModel: 0, getColumnFilterModel: 0, setColumnFilterModel: 0, showColumnFilter: 0, isQuickFilterPresent: 0, getQuickFilter: 0, resetQuickFilter: 0, paginationIsLastPageFound: 0, paginationGetPageSize: 0, paginationGetCurrentPage: 0, paginationGetTotalPages: 0, paginationGetRowCount: 0, paginationGoToNextPage: 0, paginationGoToPreviousPage: 0, paginationGoToFirstPage: 0, paginationGoToLastPage: 0, paginationGoToPage: 0, expandAll: 0, collapseAll: 0, onRowHeightChanged: 0, setRowCount: 0, getCacheBlockState: 0, isLastRowIndexKnown: 0 }), ...Ce("@ag-grid-community/client-side-row-model", { onGroupExpandedOrCollapsed: 0, refreshClientSideRowModel: 0, isRowDataEmpty: 0, forEachLeafNode: 0, forEachNodeAfterFilter: 0, forEachNodeAfterFilterAndSort: 0, resetRowHeights: 0, applyTransaction: 0, applyTransactionAsync: 0, flushAsyncTransactions: 0, getBestCostNodeSelection: 0 }), ...Ce("@ag-grid-community/csv-export", { getDataAsCsv: 0, exportDataAsCsv: 0 }), ...Ce("@ag-grid-community/infinite-row-model", { refreshInfiniteCache: 0, purgeInfiniteCache: 0, getInfiniteRowCount: 0 }), ...Ce("@ag-grid-enterprise/advanced-filter", { getAdvancedFilterModel: 0, setAdvancedFilterModel: 0, showAdvancedFilterBuilder: 0, hideAdvancedFilterBuilder: 0 }), ...Ce("@ag-grid-enterprise/charts", { getChartModels: 0, getChartRef: 0, getChartImageDataURL: 0, downloadChart: 0, openChartToolPanel: 0, closeChartToolPanel: 0, createRangeChart: 0, createPivotChart: 0, createCrossFilterChart: 0, updateChart: 0, restoreChart: 0 }), ...Ce("@ag-grid-enterprise/clipboard", { copyToClipboard: 0, cutToClipboard: 0, copySelectedRowsToClipboard: 0, copySelectedRangeToClipboard: 0, copySelectedRangeDown: 0, pasteFromClipboard: 0 }), ...Ce("@ag-grid-enterprise/excel-export", { getDataAsExcel: 0, exportDataAsExcel: 0, getSheetDataForExcel: 0, getMultipleSheetsAsExcel: 0, exportMultipleSheetsAsExcel: 0 }), ...Ce("@ag-grid-enterprise/master-detail", { addDetailGridInfo: 0, removeDetailGridInfo: 0, getDetailGridInfo: 0, forEachDetailGridInfo: 0 }), ...Ce("@ag-grid-enterprise/menu", { showContextMenu: 0, showColumnChooser: 0, hideColumnChooser: 0 }), ...Ce("@ag-grid-enterprise/range-selection", { getCellRanges: 0, addCellRange: 0, clearRangeSelection: 0, clearCellSelection: 0 }), ...Ce("@ag-grid-enterprise/row-grouping", { addAggFunc: 0, addAggFuncs: 0, clearAggFuncs: 0, setColumnAggFunc: 0, isPivotMode: 0, getPivotResultColumn: 0, setValueColumns: 0, getValueColumns: 0, removeValueColumn: 0, removeValueColumns: 0, addValueColumn: 0, addValueColumns: 0, setRowGroupColumns: 0, removeRowGroupColumn: 0, removeRowGroupColumns: 0, addRowGroupColumn: 0, addRowGroupColumns: 0, getRowGroupColumns: 0, moveRowGroupColumn: 0, setPivotColumns: 0, removePivotColumn: 0, removePivotColumns: 0, addPivotColumn: 0, addPivotColumns: 0, getPivotColumns: 0, setPivotResultColumns: 0, getPivotResultColumns: 0 }), ...Ce("@ag-grid-enterprise/server-side-row-model", { getServerSideSelectionState: 0, setServerSideSelectionState: 0, applyServerSideTransaction: 0, applyServerSideTransactionAsync: 0, applyServerSideRowData: 0, retryServerSideLoads: 0, flushServerSideAsyncTransactions: 0, refreshServerSide: 0, getServerSideGroupLevelState: 0 }), ...Ce("@ag-grid-enterprise/side-bar", { isSideBarVisible: 0, setSideBarVisible: 0, setSideBarPosition: 0, openToolPanel: 0, closeToolPanel: 0, getOpenedToolPanel: 0, refreshToolPanel: 0, isToolPanelShowing: 0, getToolPanelInstance: 0, getSideBar: 0 }), ...Ce("@ag-grid-enterprise/status-bar", { getStatusPanel: 0 }) }, Es = { isDestroyed: () => true, destroy() {
}, preConstruct() {
}, postConstruct() {
}, preWireBeans() {
}, wireBeans() {
} }, vg = (e, t) => e.eventService.dispatchEvent(t), il = class {
};
Reflect.defineProperty(il, "name", { value: "GridApi" });
var Sg = class extends R {
  constructor() {
    super(), this.beanName = "apiFunctionService", this.api = new il(), this.fns = { ...Es, dispatchEvent: vg }, this.beans = null, this.preDestroyLink = "";
    const { api: e } = this;
    for (const t in ar) e[t] = this.makeApi(t)[t];
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.preDestroyLink = this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(e, t) {
    var _a3;
    const { fns: i, beans: s } = this;
    i !== Es && (i[e] = ((_a3 = s == null ? void 0 : s.validationService) == null ? void 0 : _a3.validateApiFunction(e, t)) ?? t);
  }
  makeApi(e) {
    return { [e]: (...t) => {
      const { beans: i, fns: { [e]: s } } = this;
      return s ? s(i, ...t) : this.apiNotFound(e);
    } };
  }
  apiNotFound(e) {
    const { beans: t, gos: i, preDestroyLink: s } = this;
    if (!t) F(`Grid API function ${e}() cannot be called as the grid has been destroyed.
Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${s}`);
    else {
      const o = ar[e];
      i.assertModuleRegistered(o, `api.${e}`) && F(`API function '${e}' not registered to module '${o}'`);
    }
  }
  destroy() {
    super.destroy(), this.fns = Es, this.beans = null;
  }
};
function wg(e) {
  return { beanName: "gridApi", bean: e.getBean("apiFunctionService").api };
}
var yg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnDefFactory";
  }
  buildColumnDefs(e, t, i) {
    const s = [], o = {};
    return e.forEach((r) => {
      const n = this.createDefFromColumn(r, t, i);
      let l = true, a = n, c = r.getOriginalParent(), u = null;
      for (; c; ) {
        let d = null;
        if (c.isPadding()) {
          c = c.getOriginalParent();
          continue;
        }
        const h = o[c.getGroupId()];
        if (h) {
          h.children.push(a), l = false;
          break;
        }
        if (d = this.createDefFromGroup(c), d && (d.children = [a], o[d.groupId] = d, a = d, c = c.getOriginalParent()), c != null && u === c) {
          l = false;
          break;
        }
        u = c;
      }
      l && s.push(a);
    }), s;
  }
  createDefFromGroup(e) {
    const t = ks(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, i) {
    const s = ks(e.getColDef());
    return s.colId = e.getColId(), s.width = e.getActualWidth(), s.rowGroup = e.isRowGroupActive(), s.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, s.pivot = e.isPivotActive(), s.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null, s.aggFunc = e.isValueActive() ? e.getAggFunc() : null, s.hide = e.isVisible() ? void 0 : true, s.pinned = e.isPinned() ? e.getPinned() : null, s.sort = e.getSort() ? e.getSort() : null, s.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, s;
  }
}, Rg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnEventDispatcher";
  }
  visibleCols(e) {
    this.eventService.dispatchEvent({ type: "displayedColumnsChanged", source: e });
  }
  gridColumns() {
    this.eventService.dispatchEvent({ type: "gridColumnsChanged" });
  }
  headerHeight(e) {
    this.eventService.dispatchEvent({ type: "columnHeaderHeightChanged", column: e, columns: [e], source: "autosizeColumnHeaderHeight" });
  }
  groupHeaderHeight(e) {
    this.eventService.dispatchEvent({ type: "columnGroupHeaderHeightChanged", columnGroup: e, source: "autosizeColumnGroupHeaderHeight" });
  }
  groupOpened(e) {
    this.eventService.dispatchEvent({ type: "columnGroupOpened", columnGroup: e.length === 1 ? e[0] : void 0, columnGroups: e });
  }
  rowGroupChanged(e, t) {
    this.eventService.dispatchEvent({ type: "columnRowGroupChanged", columns: e, column: e.length === 1 ? e[0] : null, source: t });
  }
  genericColumnEvent(e, t, i) {
    this.eventService.dispatchEvent({ type: e, columns: t, column: t.length === 1 ? t[0] : null, source: i });
  }
  pivotModeChanged() {
    this.eventService.dispatchEvent({ type: "columnPivotModeChanged" });
  }
  virtualColumnsChanged(e) {
    this.eventService.dispatchEvent({ type: "virtualColumnsChanged", afterScroll: e });
  }
  newColumnsLoaded(e) {
    this.eventService.dispatchEvent({ type: "newColumnsLoaded", source: e });
  }
  everythingChanged(e) {
    this.eventService.dispatchEvent({ type: "columnEverythingChanged", source: e });
  }
  columnMoved(e) {
    const { movedColumns: t, source: i, toIndex: s, finished: o } = e;
    this.eventService.dispatchEvent({ type: "columnMoved", columns: t, column: t && t.length === 1 ? t[0] : null, toIndex: s, finished: o, source: i });
  }
  columnPinned(e, t) {
    if (!e.length) return;
    const i = e.length === 1 ? e[0] : null, s = this.getCommonValue(e, (o) => o.getPinned());
    this.eventService.dispatchEvent({ type: "columnPinned", pinned: s ?? null, columns: e, column: i, source: t });
  }
  columnVisible(e, t) {
    if (!e.length) return;
    const i = e.length === 1 ? e[0] : null, s = this.getCommonValue(e, (o) => o.isVisible());
    this.eventService.dispatchEvent({ type: "columnVisible", visible: s, columns: e, column: i, source: t });
  }
  getCommonValue(e, t) {
    if (!e || e.length == 0) return;
    const i = t(e[0]);
    for (let s = 1; s < e.length; s++) if (i !== t(e[s])) return;
    return i;
  }
  columnChanged(e, t, i) {
    this.eventService.dispatchEvent({ type: e, columns: t, column: t && t.length == 1 ? t[0] : null, source: i });
  }
  columnResized(e, t, i, s = null) {
    e && e.length && this.eventService.dispatchEvent({ type: "columnResized", columns: e, column: e.length === 1 ? e[0] : null, flexColumns: s, finished: t, source: i });
  }
}, Fg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnGetStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService;
  }
  getColumnState() {
    const e = this.columnModel.getColDefCols();
    if (V(e) || !this.columnModel.isAlive()) return [];
    const i = this.columnModel.getAllCols().map((s) => this.createStateItemFromColumn(s));
    return this.orderColumnStateList(i), i;
  }
  createStateItemFromColumn(e) {
    const t = this.funcColsService.getRowGroupColumns(), i = this.funcColsService.getPivotColumns(), s = e.isRowGroupActive() ? t.indexOf(e) : null, o = e.isPivotActive() ? i.indexOf(e) : null, r = e.isValueActive() ? e.getAggFunc() : null, n = e.getSort() != null ? e.getSort() : null, l = e.getSortIndex() != null ? e.getSortIndex() : null, a = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null;
    return { colId: e.getColId(), width: e.getActualWidth(), hide: !e.isVisible(), pinned: e.getPinned(), sort: n, sortIndex: l, aggFunc: r, rowGroup: e.isRowGroupActive(), rowGroupIndex: s, pivot: e.isPivotActive(), pivotIndex: o, flex: a };
  }
  orderColumnStateList(e) {
    const t = this.columnModel.getCols(), i = new Map(t.map((s, o) => [s.getColId(), o]));
    e.sort((s, o) => {
      const r = i.has(s.colId) ? i.get(s.colId) : -1, n = i.has(o.colId) ? i.get(o.colId) : -1;
      return r - n;
    });
  }
}, bg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnGroupStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService;
  }
  getColumnGroupState() {
    const e = [], t = this.columnModel.getColTree();
    return tt(null, t, (i) => {
      Se(i) && e.push({ groupId: i.getGroupId(), open: i.isExpanded() });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.columnModel.getColDefColTree();
    if (!t) return;
    const i = [];
    tt(null, t, (s) => {
      if (Se(s)) {
        const o = s.getColGroupDef(), r = { groupId: s.getGroupId(), open: o ? o.openByDefault : void 0 };
        i.push(r);
      }
    }), this.setColumnGroupState(i, e);
  }
  setColumnGroupState(e, t) {
    if (!this.columnModel.getColTree()) return;
    this.columnAnimationService.start();
    const s = [];
    e.forEach((o) => {
      const r = o.groupId, n = o.open, l = this.columnModel.getProvidedColGroup(r);
      l && l.isExpanded() !== n && (l.setExpanded(n), s.push(l));
    }), this.visibleColsService.refresh(t, true), s.length && this.eventDispatcher.groupOpened(s), this.columnAnimationService.finish();
  }
}, Pg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnViewportService", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, i = false) {
    const s = this.visibleColsService.isBodyWidthDirty();
    if (!(e === this.scrollWidth && t === this.scrollPosition && !s)) {
      if (this.scrollWidth = e, this.scrollPosition = t, this.visibleColsService.setBodyWidthDirty(), this.gos.get("enableRtl")) {
        const r = this.visibleColsService.getBodyContainerWidth();
        this.viewportLeft = r - this.scrollPosition - this.scrollWidth, this.viewportRight = r - this.scrollPosition;
      } else this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition;
      this.columnModel.isReady() && this.checkViewportColumns(i);
    }
  }
  getHeadersToRender(e, t) {
    let i;
    switch (e) {
      case "left":
        i = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        i = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        i = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return i || [];
  }
  extractViewportColumns() {
    const e = this.visibleColsService.getCenterCols();
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, this.colsWithinViewportHash = "";
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() || this.isAnyParentAutoHeaderHeight(e) ? true : this.isColumnInRowViewport(e);
  }
  isAnyParentAutoHeaderHeight(e) {
    for (; e; ) {
      if (e.isAutoHeaderHeight()) return true;
      e = e.getParent();
    }
    return false;
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight()) return true;
    const t = e.getLeft() || 0, i = t + e.getActualWidth(), s = this.viewportLeft - 200, o = this.viewportRight + 200, r = t < s && i < s, n = t > o && i > o;
    return !r && !n;
  }
  getViewportColumns() {
    const e = this.visibleColsService.getLeftCols(), t = this.visibleColsService.getRightCols();
    return this.colsWithinViewport.concat(e).concat(t);
  }
  getColsWithinViewport(e) {
    if (!this.columnModel.isColSpanActive()) return this.colsWithinViewport;
    const t = (o) => {
      const r = o.getLeft();
      return E(r) && r > this.viewportLeft;
    }, i = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this), s = this.visibleColsService.getColsCenter();
    return this.visibleColsService.getColsForRow(e, s, i, t);
  }
  checkViewportColumns(e = false) {
    this.extractViewport() && this.eventDispatcher.virtualColumnsChanged(e);
  }
  calculateHeaderRows() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
    const e = {}, t = this.visibleColsService.getLeftCols(), i = this.visibleColsService.getRightCols();
    this.headerColsWithinViewport.concat(t).concat(i).forEach((r) => e[r.getId()] = true);
    const o = (r, n, l) => {
      let a = false;
      for (let c = 0; c < r.length; c++) {
        const u = r[c];
        let d = false;
        if (dt(u)) d = e[u.getId()] === true;
        else {
          const g = u.getDisplayedChildren();
          g && (d = o(g, n, l + 1));
        }
        d && (a = true, n[l] || (n[l] = []), n[l].push(u));
      }
      return a;
    };
    o(this.visibleColsService.getTreeLeft(), this.rowsOfHeadersToRenderLeft, 0), o(this.visibleColsService.getTreeRight(), this.rowsOfHeadersToRenderRight, 0), o(this.visibleColsService.getTreeCenter(), this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const e = (s) => `${s.getId()}-${s.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), i = this.colsWithinViewportHash !== t;
    return i && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), i;
  }
}, Eg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "agComponentUtils";
  }
  wireBeans(e) {
    this.componentMetadataProvider = e.componentMetadataProvider;
  }
  adaptFunction(e, t) {
    const i = this.componentMetadataProvider.retrieve(e);
    return i && i.functionAdapter ? i.functionAdapter(t) : null;
  }
  adaptCellRendererFunction(e) {
    class t {
      refresh() {
        return false;
      }
      getGui() {
        return this.eGui;
      }
      init(s) {
        const o = e(s), r = typeof o;
        if (r === "string" || r === "number" || r === "boolean") {
          this.eGui = mi("<span>" + o + "</span>");
          return;
        }
        if (o == null) {
          this.eGui = mi("<span></span>");
          return;
        }
        this.eGui = o;
      }
    }
    return t;
  }
  doesImplementIComponent(e) {
    return e ? e.prototype && "getGui" in e.prototype : false;
  }
}, Dg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "componentMetadataProvider";
  }
  wireBeans(e) {
    this.agComponentUtils = e.agComponentUtils;
  }
  postConstruct() {
    this.componentMetaData = { dateComponent: { mandatoryMethodList: ["getDate", "setDate"], optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "onParamsUpdated", "refresh"] }, detailCellRenderer: { mandatoryMethodList: [], optionalMethodList: ["refresh"], functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils) }, dragAndDropImageComponent: { mandatoryMethodList: ["setIcon", "setLabel"], optionalMethodList: [] }, headerComponent: { mandatoryMethodList: [], optionalMethodList: ["refresh"] }, headerGroupComponent: { mandatoryMethodList: [], optionalMethodList: [] }, loadingCellRenderer: { mandatoryMethodList: [], optionalMethodList: [], functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils) }, loadingOverlayComponent: { mandatoryMethodList: [], optionalMethodList: ["refresh"] }, noRowsOverlayComponent: { mandatoryMethodList: [], optionalMethodList: ["refresh"] }, floatingFilterComponent: { mandatoryMethodList: ["onParentModelChanged"], optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"] }, cellRenderer: { mandatoryMethodList: [], optionalMethodList: ["refresh", "afterGuiAttached"], functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils) }, cellEditor: { mandatoryMethodList: ["getValue"], optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached", "refresh"] }, innerRenderer: { mandatoryMethodList: [], optionalMethodList: ["afterGuiAttached"], functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils) }, fullWidthCellRenderer: { mandatoryMethodList: [], optionalMethodList: ["refresh", "afterGuiAttached"], functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils) }, groupRowRenderer: { mandatoryMethodList: [], optionalMethodList: ["afterGuiAttached"], functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils) }, filter: { mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"], optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged", "refresh"] }, statusPanel: { mandatoryMethodList: [], optionalMethodList: ["refresh"] }, toolPanel: { mandatoryMethodList: [], optionalMethodList: ["refresh", "getState"] }, tooltipComponent: { mandatoryMethodList: [], optionalMethodList: [] }, menuItem: { mandatoryMethodList: [], optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"] } };
  }
  retrieve(e) {
    return this.componentMetaData[e];
  }
}, Mg = ["rowPositionUtils", "cellPositionUtils", "headerPositionUtils", "paginationAutoPageSizeService", "apiFunctionService", "gridApi", "userComponentRegistry", "agComponentUtils", "componentMetadataProvider", "resizeObserverService", "userComponentFactory", "rowContainerHeightService", "horizontalResizeService", "localeService", "validationService", "pinnedRowModel", "dragService", "visibleColsService", "eventService", "gos", "popupService", "selectionService", "columnFilterService", "quickFilterService", "filterManager", "columnModel", "headerNavigationService", "pageBoundsService", "paginationService", "pageBoundsListener", "rowRenderer", "expressionService", "columnFactory", "alignedGridsService", "navigationService", "valueCache", "valueService", "loggerFactory", "autoWidthCalculator", "filterMenuFactory", "dragAndDropService", "focusService", "mouseEventService", "environment", "cellNavigationService", "stylingService", "scrollVisibleService", "sortController", "columnHoverService", "columnAnimationService", "selectableService", "autoColService", "controlsColService", "changeDetectionService", "animationFrameService", "undoRedoService", "columnDefFactory", "rowCssClassCalculator", "rowNodeBlockLoader", "rowNodeSorter", "ctrlsService", "pinnedWidthService", "rowNodeEventThrottle", "ctrlsFactory", "dataTypeService", "syncService", "overlayService", "stateService", "expansionService", "apiEventService", "ariaAnnouncementService", "menuService", "columnApplyStateService", "columnEventDispatcher", "columnMoveService", "columnAutosizeService", "columnGetStateService", "columnGroupStateService", "columnSizeService", "funcColsService", "columnNameService", "columnViewportService", "pivotResultColsService", "showRowGroupColsService"], cr = Object.fromEntries(Mg.map((e, t) => [e, t]));
function xg(e, t) {
  const i = (e.beanName ? cr[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, s = (t.beanName ? cr[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return i - s;
}
function Ag(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroyService" ? -1 : 0;
}
var Tg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "ctrlsFactory", this.registry = {};
  }
  register(e) {
    this.registry[e.name] = e.classImp;
  }
  getInstance(e, ...t) {
    const i = this.registry[e];
    if (i != null) return new i(...t);
  }
}, Ig = class extends R {
  constructor() {
    super(...arguments), this.beanName = "ctrlsService", this.params = { gridCtrl: void 0, gridBodyCtrl: void 0, center: void 0, left: void 0, right: void 0, bottomCenter: void 0, bottomLeft: void 0, bottomRight: void 0, topCenter: void 0, topLeft: void 0, topRight: void 0, stickyTopCenter: void 0, stickyTopLeft: void 0, stickyTopRight: void 0, stickyBottomCenter: void 0, stickyBottomLeft: void 0, stickyBottomRight: void 0, fakeHScrollComp: void 0, fakeVScrollComp: void 0, gridHeaderCtrl: void 0, centerHeader: void 0, leftHeader: void 0, rightHeader: void 0 }, this.ready = false, this.readyCallbacks = [], this.runReadyCallbacksAsync = false;
  }
  wireBeans(e) {
    var _a3, _b;
    this.runReadyCallbacksAsync = ((_b = (_a3 = e.frameworkOverrides).runWhenReadyAsync) == null ? void 0 : _b.call(_a3)) ?? false;
  }
  postConstruct() {
    this.addEventListener("ready", () => {
      this.updateReady(), this.ready && (this.readyCallbacks.forEach((e) => e(this.params)), this.readyCallbacks.length = 0);
    }, this.runReadyCallbacksAsync);
  }
  updateReady() {
    this.ready = Object.values(this.params).every((e) => (e == null ? void 0 : e.isAlive()) ?? false);
  }
  whenReady(e, t) {
    this.ready ? t(this.params) : this.readyCallbacks.push(t), e.addDestroyFunc(() => {
      const i = this.readyCallbacks.indexOf(t);
      i >= 0 && this.readyCallbacks.splice(i, 1);
    });
  }
  register(e, t) {
    this.params[e] = t, this.updateReady(), this.ready && this.dispatchLocalEvent({ type: "ready" }), t.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(e) {
    return this.params[e];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: i } = this.params;
    return [e, i, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
}, Lg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "cellPositionUtils";
  }
  createId(e) {
    const { rowIndex: t, rowPinned: i, column: s } = e;
    return this.createIdFromValues({ rowIndex: t, column: s, rowPinned: i });
  }
  createIdFromValues(e) {
    const { rowIndex: t, rowPinned: i, column: s } = e;
    return `${t}.${i ?? "null"}.${s.getId()}`;
  }
  equals(e, t) {
    const i = e.column === t.column, s = e.rowPinned === t.rowPinned, o = e.rowIndex === t.rowIndex;
    return i && s && o;
  }
}, Og = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowNodeEventThrottle", this.events = [];
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowModel = e.rowModel;
  }
  postConstruct() {
    Q(this.gos) && (this.clientSideRowModel = this.rowModel);
  }
  dispatchExpanded(e, t) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(e);
      return;
    }
    this.events.push(e);
    const i = () => {
      this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach((s) => this.eventService.dispatchEvent(s)), this.events = [];
    };
    t ? i() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(i)), this.dispatchExpandedDebounced());
  }
}, Gg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowPositionUtils";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.pageBoundsService = e.pageBoundsService;
  }
  getFirstRow() {
    let e = 0, t;
    return this.pinnedRowModel.getPinnedTopRowCount() ? t = "top" : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (t = "bottom"), t === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getLastRow() {
    let e, t = null;
    const i = this.pinnedRowModel.getPinnedBottomRowCount(), s = this.pinnedRowModel.getPinnedTopRowCount();
    return i ? (t = "bottom", e = i - 1) : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getLastRow()) : s && (t = "top", e = s - 1), e === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  sameRow(e, t) {
    return !e && !t ? true : e && !t || !e && t ? false : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
  }
  before(e, t) {
    switch (e.rowPinned) {
      case "top":
        if (t.rowPinned !== "top") return true;
        break;
      case "bottom":
        if (t.rowPinned !== "bottom") return false;
        break;
      default:
        if (E(t.rowPinned)) return t.rowPinned !== "top";
        break;
    }
    return e.rowIndex < t.rowIndex;
  }
}, ur = { cssName: "--ag-row-height", changeKey: "rowHeightChanged", defaultValue: 42 }, dr = { cssName: "--ag-header-height", changeKey: "headerHeightChanged", defaultValue: 48 }, hr = { cssName: "--ag-list-item-height", changeKey: "listItemHeightChanged", defaultValue: 24 }, kg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "environment", this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.ancestorThemeClasses = [], this.sizesMeasured = false, this.gridTheme = null;
  }
  wireBeans(e) {
    this.resizeObserverService = e.resizeObserverService, this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    this.addManagedPropertyListener("theme", () => this.handleThemeGridOptionChange()), this.handleThemeGridOptionChange(), this.addDestroyFunc(() => this.stopUsingTheme()), this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.ancestorThemeClasses = this.readAncestorThemeClasses(), this.setUpThemeClassObservers(), this.getSizeEl(ur), this.getSizeEl(dr), this.getSizeEl(hr);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(ur);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(dr);
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(hr);
  }
  hasMeasuredSizes() {
    return this.sizesMeasured;
  }
  getGridThemeClass() {
    var _a3;
    return ((_a3 = this.gridTheme) == null ? void 0 : _a3.getCssClass()) || null;
  }
  getThemeClasses() {
    return this.gridTheme ? [this.gridTheme.getCssClass()] : this.ancestorThemeClasses;
  }
  applyThemeClasses(e) {
    const t = this.getThemeClasses();
    for (const i of Array.from(e.classList)) i.startsWith("ag-theme-") && !t.includes(i) && e.classList.remove(i);
    e.classList.add(...t);
  }
  refreshRowHeightVariable() {
    const e = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(), t = this.gos.get("rowHeight");
    if (t == null || isNaN(t) || !isFinite(t)) return e !== null && this.eGridDiv.style.setProperty("--ag-line-height", null), -1;
    const i = `${t}px`;
    return e != i ? (this.eGridDiv.style.setProperty("--ag-line-height", i), t) : e != "" ? parseFloat(e) : -1;
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null) return t;
    const i = this.measureSizeEl(e);
    return i === "detached" || i === "no-styles" ? e.defaultValue : (this.lastKnownValues.set(e, i), i);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null) return "detached";
    const i = t.offsetWidth;
    return i === gr ? "no-styles" : (this.sizesMeasured = true, i);
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t) return t;
    let i = this.eMeasurementContainer;
    i || (i = this.eMeasurementContainer = document.createElement("div"), i.className = "ag-measurement-container", this.gos.get("theme") && this.applyThemeClasses(i), this.eGridDiv.appendChild(i)), t = document.createElement("div"), t.style.width = `var(${e.cssName}, ${gr}px)`, i.appendChild(t), this.sizeEls.set(e, t);
    let s = this.measureSizeEl(e);
    s === "no-styles" && F(`no value for ${e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e.defaultValue} will be used and updated when styles load.`);
    const o = this.resizeObserverService.observeResize(t, () => {
      const r = this.measureSizeEl(e);
      r === "detached" || r === "no-styles" || (this.lastKnownValues.set(e, r), r !== s && (s = r, this.fireGridStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => o()), t;
  }
  fireGridStylesChangedEvent(e) {
    this.eventService.dispatchEvent({ type: "gridStylesChanged", [e]: true });
  }
  setUpThemeClassObservers() {
    const e = new MutationObserver(() => {
      const i = this.readAncestorThemeClasses();
      Hg(i, this.ancestorThemeClasses) || (this.ancestorThemeClasses = i, this.fireGridStylesChangedEvent("themeChanged"));
    });
    let t = this.eGridDiv;
    for (; t; ) e.observe(t || this.eGridDiv, { attributes: true, attributeFilter: ["class"] }), t = t.parentElement;
    this.addDestroyFunc(() => e.disconnect());
  }
  readAncestorThemeClasses() {
    let e = this.eGridDiv;
    const t = [];
    for (; e; ) {
      const i = Array.from(e.classList).filter((s) => s.startsWith("ag-theme-"));
      for (const s of i) t.includes(s) || t.unshift(s);
      e = e.parentElement;
    }
    return Object.freeze(t);
  }
  handleThemeGridOptionChange() {
    const { gos: e, eMeasurementContainer: t, gridTheme: i } = this, s = e.get("theme") || null;
    s !== i && (i == null ? void 0 : i.stopUse(), this.gridTheme = s, s == null ? void 0 : s.startUse({ loadThemeGoogleFonts: e.get("loadThemeGoogleFonts"), container: this.eGridDiv }), t && this.applyThemeClasses(t), this.fireGridStylesChangedEvent("themeChanged"));
  }
  stopUsingTheme() {
    var _a3;
    (_a3 = this.gridTheme) == null ? void 0 : _a3.stopUse(), this.gridTheme = null;
  }
}, Hg = (e, t) => e.length === t.length && e.findIndex((i, s) => e[s] !== t[s]) === -1, gr = 15538, Ng = class extends R {
  constructor() {
    super(...arguments), this.beanName = "eventService", this.globalEventService = new Ut();
  }
  wireBeans(e) {
    this.globalEventListener = e.globalEventListener, this.globalSyncEventListener = e.globalSyncEventListener;
  }
  postConstruct() {
    if (this.globalEventListener) {
      const e = zi(this.gos);
      this.addGlobalListener(this.globalEventListener, e);
    }
    this.globalSyncEventListener && this.addGlobalListener(this.globalSyncEventListener, false);
  }
  addEventListener(e, t, i) {
    this.globalEventService.addEventListener(e, t, i);
  }
  removeEventListener(e, t, i) {
    this.globalEventService.removeEventListener(e, t, i);
  }
  addGlobalListener(e, t = false) {
    this.globalEventService.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = false) {
    this.globalEventService.removeGlobalListener(e, t);
  }
  dispatchLocalEvent() {
  }
  dispatchEvent(e) {
    this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(e));
  }
  dispatchEventOnce(e) {
    this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(e));
  }
}, xo = class Te extends R {
  constructor() {
    super(...arguments), this.beanName = "focusService";
  }
  wireBeans(t) {
    this.eGridDiv = t.eGridDiv, this.columnModel = t.columnModel, this.visibleColsService = t.visibleColsService, this.headerNavigationService = t.headerNavigationService, this.headerPositionUtils = t.headerPositionUtils, this.rowRenderer = t.rowRenderer, this.rowPositionUtils = t.rowPositionUtils, this.cellPositionUtils = t.cellPositionUtils, this.navigationService = t.navigationService, this.ctrlsService = t.ctrlsService, this.filterManager = t.filterManager, this.rangeService = t.rangeService, this.advancedFilterService = t.advancedFilterService, this.overlayService = t.overlayService;
  }
  static addKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.addEventListener("keydown", Te.toggleKeyboardMode), t.addEventListener("mousedown", Te.toggleKeyboardMode));
  }
  static removeKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.removeEventListener("keydown", Te.toggleKeyboardMode), t.removeEventListener("mousedown", Te.toggleKeyboardMode));
  }
  static toggleKeyboardMode(t) {
    const i = Te.keyboardModeActive, s = t.type === "keydown";
    s && (t.ctrlKey || t.metaKey || t.altKey) || i !== s && (Te.keyboardModeActive = s);
  }
  postConstruct() {
    const t = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({ columnPivotModeChanged: t, newColumnsLoaded: this.onColumnEverythingChanged.bind(this), columnGroupOpened: t, columnRowGroupChanged: t }), this.registerKeyboardFocusEvents(), this.ctrlsService.whenReady(this, (i) => {
      this.gridCtrl = i.gridCtrl;
    });
  }
  registerKeyboardFocusEvents() {
    const t = re(this.gos);
    Te.addKeyboardModeEvents(t), Te.instanceCount++, this.addDestroyFunc(() => {
      Te.instanceCount--, Te.removeKeyboardModeEvents(t);
    });
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition) return;
    const t = this.focusedCellPosition.column, i = this.columnModel.getCol(t.getId());
    t !== i && this.clearFocusedCell();
  }
  isKeyboardMode() {
    return Te.keyboardModeActive;
  }
  getFocusCellToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(te(this.gos), Pt.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(te(this.gos), ls.DOM_DATA_KEY_HEADER_CTRL) ? null : this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(t, i) {
    let s = t;
    for (; s; ) {
      if (ui(this.gos, s, i)) return false;
      s = s.parentNode;
    }
    return true;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  shouldRestoreFocus(t) {
    return this.isCellRestoreFocused(t) ? (setTimeout(() => {
      this.restoredFocusedCellPosition = null;
    }, 0), true) : false;
  }
  clearRestoreFocus() {
    this.restoredFocusedCellPosition = null, this.awaitRestoreFocusedCell = false;
  }
  restoreFocusedCell(t, i) {
    this.awaitRestoreFocusedCell = true, setTimeout(() => {
      this.awaitRestoreFocusedCell && (this.setRestoreFocusedCell(t), i());
    });
  }
  isCellRestoreFocused(t) {
    return this.restoredFocusedCellPosition == null ? false : this.cellPositionUtils.equals(t, this.restoredFocusedCellPosition);
  }
  setRestoreFocusedCell(t) {
    this.getFrameworkOverrides().renderingEngine === "react" && (this.restoredFocusedCellPosition = t);
  }
  getFocusEventParams(t) {
    const { rowIndex: i, rowPinned: s, column: o } = t, r = { rowIndex: i, rowPinned: s, column: o, isFullWidthCell: false }, n = this.rowRenderer.getRowByPosition({ rowIndex: i, rowPinned: s });
    return n && (r.isFullWidthCell = n.isFullWidth()), r;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCellPosition = null, this.focusedCellPosition == null) return;
    const t = this.getFocusEventParams(this.focusedCellPosition);
    this.focusedCellPosition = null, this.eventService.dispatchEvent({ type: "cellFocusCleared", ...t });
  }
  setFocusedCell(t) {
    const { column: i, rowIndex: s, rowPinned: o, forceBrowserFocus: r = false, preventScrollOnBrowserFocus: n = false } = t, l = this.columnModel.getCol(i);
    if (!l) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = { rowIndex: s, rowPinned: Je(o), column: l }, this.eventService.dispatchEvent({ type: "cellFocused", ...this.getFocusEventParams(this.focusedCellPosition), forceBrowserFocus: r, preventScrollOnBrowserFocus: n });
  }
  isCellFocused(t) {
    return this.focusedCellPosition == null ? false : this.cellPositionUtils.equals(t, this.focusedCellPosition);
  }
  isRowNodeFocused(t) {
    return this.isRowFocused(t.rowIndex, t.rowPinned);
  }
  isHeaderWrapperFocused(t) {
    if (this.focusedHeaderPosition == null) return false;
    const i = t.getColumnGroupChild(), s = t.getRowIndex(), o = t.getPinned(), { column: r, headerRowIndex: n } = this.focusedHeaderPosition;
    return i === r && s === n && o == r.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(t, i) {
    this.focusedHeaderPosition = { headerRowIndex: t, column: i };
  }
  isHeaderFocusSuppressed() {
    return this.gos.get("suppressHeaderFocus") || this.overlayService.isExclusive();
  }
  isCellFocusSuppressed() {
    return this.gos.get("suppressCellFocus") || this.overlayService.isExclusive();
  }
  focusHeaderPosition(t) {
    var _a3;
    if (this.isHeaderFocusSuppressed()) return false;
    const { direction: i, fromTab: s, allowUserOverride: o, event: r, fromCell: n, rowWithoutSpanValue: l } = t;
    let { headerPosition: a } = t;
    if (n && ((_a3 = this.filterManager) == null ? void 0 : _a3.isAdvancedFilterHeaderActive())) return this.focusAdvancedFilter(a);
    if (o) {
      const c = this.getFocusedHeader(), u = this.headerNavigationService.getHeaderRowCount();
      if (s) {
        const d = this.gos.getCallback("tabToNextHeader");
        d && (a = this.getHeaderPositionFromUserFunc({ userFunc: d, direction: i, currentPosition: c, headerPosition: a, headerRowCount: u }));
      } else {
        const d = this.gos.getCallback("navigateToNextHeader");
        if (d && r) {
          const h = { key: r.key, previousHeaderPosition: c, nextHeaderPosition: a, headerRowCount: u, event: r };
          a = d(h);
        }
      }
    }
    return a ? this.focusProvidedHeaderPosition({ headerPosition: a, direction: i, event: r, fromCell: n, rowWithoutSpanValue: l }) : false;
  }
  focusHeaderPositionFromUserFunc(t) {
    if (this.isHeaderFocusSuppressed()) return false;
    const { userFunc: i, headerPosition: s, direction: o, event: r } = t, n = this.getFocusedHeader(), l = this.headerNavigationService.getHeaderRowCount(), a = this.getHeaderPositionFromUserFunc({ userFunc: i, direction: o, currentPosition: n, headerPosition: s, headerRowCount: l });
    return !!a && this.focusProvidedHeaderPosition({ headerPosition: a, direction: o, event: r });
  }
  getHeaderPositionFromUserFunc(t) {
    const { userFunc: i, direction: s, currentPosition: o, headerPosition: r, headerRowCount: n } = t, a = i({ backwards: s === "Before", previousHeaderPosition: o, nextHeaderPosition: r, headerRowCount: n });
    return a === true || a === null ? (a === null && F("Since v31.3 Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour."), o) : a === false ? null : a;
  }
  focusProvidedHeaderPosition(t) {
    var _a3, _b;
    const { headerPosition: i, direction: s, fromCell: o, rowWithoutSpanValue: r, event: n } = t, { column: l, headerRowIndex: a } = i;
    if (a === -1) return ((_a3 = this.filterManager) == null ? void 0 : _a3.isAdvancedFilterHeaderActive()) ? this.focusAdvancedFilter(i) : this.focusGridView(l);
    this.headerNavigationService.scrollToColumn(l, s);
    const u = ((_b = this.ctrlsService.getHeaderRowContainerCtrl(l.getPinned())) == null ? void 0 : _b.focusHeader(i.headerRowIndex, l, n)) || false;
    return u && (r != null || o) && this.headerNavigationService.setCurrentHeaderRowWithoutSpan(r ?? -1), u;
  }
  focusFirstHeader() {
    if (this.overlayService.isExclusive() && this.focusOverlay()) return true;
    let t = this.visibleColsService.getAllCols()[0];
    if (!t) return false;
    t.getParent() && (t = this.visibleColsService.getColGroupAtLevel(t, 0));
    const i = this.headerPositionUtils.getHeaderIndexToFocus(t, 0);
    return this.focusHeaderPosition({ headerPosition: i, rowWithoutSpanValue: 0 });
  }
  focusLastHeader(t) {
    if (this.overlayService.isExclusive() && this.focusOverlay(true)) return true;
    const i = this.headerNavigationService.getHeaderRowCount() - 1, s = N(this.visibleColsService.getAllCols());
    return this.focusHeaderPosition({ headerPosition: { headerRowIndex: i, column: s }, rowWithoutSpanValue: -1, event: t });
  }
  focusPreviousFromFirstCell(t) {
    var _a3;
    return ((_a3 = this.filterManager) == null ? void 0 : _a3.isAdvancedFilterHeaderActive()) ? this.focusAdvancedFilter(null) : this.focusLastHeader(t);
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(t, i) {
    return this.focusedCellPosition == null ? false : this.focusedCellPosition.rowIndex === t && this.focusedCellPosition.rowPinned === Je(i);
  }
  findFocusableElements(t, i, s = false) {
    const o = Ba;
    let r = Xr;
    i && (r += ", " + i), s && (r += ', [tabindex="-1"]');
    const n = Array.prototype.slice.apply(t.querySelectorAll(o)).filter((c) => je(c)), l = Array.prototype.slice.apply(t.querySelectorAll(r));
    return l.length ? ((c, u) => c.filter((d) => u.indexOf(d) === -1))(n, l) : n;
  }
  focusInto(t, i = false, s = false) {
    const o = this.findFocusableElements(t, null, s), r = i ? N(o) : o[0];
    return r ? (r.focus({ preventScroll: true }), true) : false;
  }
  findFocusableElementBeforeTabGuard(t, i) {
    if (!i) return null;
    const s = this.findFocusableElements(t), o = s.indexOf(i);
    if (o === -1) return null;
    let r = -1;
    for (let n = o - 1; n >= 0; n--) if (s[n].classList.contains("ag-tab-guard-top")) {
      r = n;
      break;
    }
    return r <= 0 ? null : s[r - 1];
  }
  findNextFocusableElement(t = this.eGridDiv, i, s) {
    const o = this.findFocusableElements(t, i ? ':not([tabindex="-1"])' : null), r = te(this.gos);
    let n;
    i ? n = o.findIndex((a) => a.contains(r)) : n = o.indexOf(r);
    const l = n + (s ? -1 : 1);
    return l < 0 || l >= o.length ? null : o[l];
  }
  isTargetUnderManagedComponent(t, i) {
    if (!i) return false;
    const s = t.querySelectorAll(`.${At.FOCUS_MANAGED_CLASS}`);
    if (!s.length) return false;
    for (let o = 0; o < s.length; o++) if (s[o].contains(i)) return true;
    return false;
  }
  findTabbableParent(t, i = 5) {
    let s = 0;
    for (; t && Bs(t) === null && ++s <= i; ) t = t.parentElement;
    return Bs(t) === null ? null : t;
  }
  focusOverlay(t) {
    var _a3;
    const i = this.overlayService.isVisible() && ((_a3 = this.overlayService.getOverlayWrapper()) == null ? void 0 : _a3.getGui());
    return !!i && this.focusInto(i, t);
  }
  focusGridViewFailed(t, i) {
    return i && this.focusOverlay(t) || t && this.focusLastHeader();
  }
  focusGridView(t, i = false, s = true) {
    var _a3, _b, _c2;
    if (this.overlayService.isExclusive()) return s && this.focusOverlay(i);
    if (this.isCellFocusSuppressed()) return i && !this.isHeaderFocusSuppressed() ? this.focusLastHeader() : s && this.focusOverlay(i) ? true : this.focusNextGridCoreContainer(false);
    const o = i ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (o) {
      const { rowIndex: r, rowPinned: n } = o;
      if (t ?? (t = (_a3 = this.getFocusedHeader()) == null ? void 0 : _a3.column), t && r !== void 0 && r !== null) return this.navigationService.ensureCellVisible({ rowIndex: r, column: t, rowPinned: n }), i && ((_b = this.rowRenderer.getRowByPosition(o)) == null ? void 0 : _b.isFullWidth()) && this.navigationService.tryToFocusFullWidthRow(o, i) || (this.setFocusedCell({ rowIndex: r, column: t, rowPinned: Je(n), forceBrowserFocus: true }), (_c2 = this.rangeService) == null ? void 0 : _c2.setRangeToCell({ rowIndex: r, rowPinned: n, column: t })), true;
    }
    return !!(s && this.focusOverlay(i) || i && this.focusLastHeader());
  }
  isGridFocused() {
    const t = te(this.gos);
    return !!t && this.eGridDiv.contains(t);
  }
  focusNextGridCoreContainer(t, i = false) {
    return !i && this.gridCtrl.focusNextInnerContainer(t) ? true : ((i || !t && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(t), false);
  }
  focusAdvancedFilter(t) {
    var _a3;
    return this.advancedFilterFocusColumn = t == null ? void 0 : t.column, ((_a3 = this.advancedFilterService) == null ? void 0 : _a3.getCtrl().focusHeaderComp()) ?? false;
  }
  focusNextFromAdvancedFilter(t, i) {
    var _a3;
    const s = (i ? void 0 : this.advancedFilterFocusColumn) ?? ((_a3 = this.visibleColsService.getAllCols()) == null ? void 0 : _a3[0]);
    return t ? this.focusHeaderPosition({ headerPosition: { column: s, headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1 } }) : this.focusGridView(s);
  }
  clearAdvancedFilterColumn() {
    this.advancedFilterFocusColumn = void 0;
  }
  addFocusableContainer(t) {
    this.gridCtrl.addFocusableContainer(t);
  }
  removeFocusableContainer(t) {
    this.gridCtrl.removeFocusableContainer(t);
  }
  focusGridInnerElement(t) {
    return this.gridCtrl.focusInnerElement(t);
  }
  allowFocusForNextGridCoreContainer(t) {
    this.gridCtrl.allowFocusForNextCoreContainer(t);
  }
};
xo.keyboardModeActive = false;
xo.instanceCount = 0;
var Vg = xo, Bg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "pinnedWidthService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({ displayedColumnsChanged: e, displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const e = he(this.gos, "print"), t = e ? 0 : this.visibleColsService.getColsLeftWidth(), i = e ? 0 : this.visibleColsService.getDisplayedColumnsRightWidth();
    t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({ type: "leftPinnedWidthChanged" })), i != this.rightWidth && (this.rightWidth = i, this.eventService.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
}, Wg = class extends R {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.beans = e, this.focusService = e.focusService, this.visibleColsService = e.visibleColsService;
  }
  setComp(e, t, i) {
    this.view = e, this.eGridHostDiv = t, this.eGui = i, this.eGui.setAttribute("grid-id", this.beans.context.getGridId());
    const { dragAndDropService: s, mouseEventService: o, ctrlsService: r, resizeObserverService: n } = this.beans, l = { getContainer: () => this.eGui, isInterestedIn: (c) => c === 1 || c === 0, getIconName: () => "notAllowed" };
    s.addDropTarget(l), this.addDestroyFunc(() => s.removeDropTarget(l)), o.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new Mo(this.view)), this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr"), this.updateGridThemeClass(), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
    const a = n.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => a()), r.register("gridCtrl", this);
  }
  isDetailGrid() {
    var _a3, _b;
    return ((_b = (_a3 = this.focusService.findTabbableParent(this.getGui())) == null ? void 0 : _a3.getAttribute("row-id")) == null ? void 0 : _b.startsWith("detail")) || false;
  }
  getOptionalSelectors() {
    var _a3, _b, _c2, _d2, _e2;
    const e = this.beans;
    return { paginationSelector: (_a3 = e.paginationService) == null ? void 0 : _a3.getPaginationSelector(), gridHeaderDropZonesSelector: (_b = e.columnDropZonesService) == null ? void 0 : _b.getDropZoneSelector(), sideBarSelector: (_c2 = e.sideBarService) == null ? void 0 : _c2.getSideBarSelector(), statusBarSelector: (_d2 = e.statusBarService) == null ? void 0 : _d2.getStatusPanelSelector(), watermarkSelector: (_e2 = e.licenseManager) == null ? void 0 : _e2.getWatermarkSelector() };
  }
  onGridSizeChanged() {
    this.eventService.dispatchEvent({ type: "gridSizeChanged", clientWidth: this.eGridHostDiv.clientWidth, clientHeight: this.eGridHostDiv.clientHeight });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), { indexWithFocus: i, nextIndex: s } = this.getNextFocusableIndex(t, e);
    if (s < 0 || s >= t.length) return false;
    if (s === 0) {
      if (i > 0) {
        const o = this.visibleColsService.getAllCols(), r = N(o);
        if (this.focusService.focusGridView(r, true)) return true;
      }
      return false;
    }
    return this.focusContainer(t[s], e);
  }
  focusInnerElement(e) {
    const t = this.gos.getCallback("focusGridInnerElement");
    if (t && t({ fromBottom: !!e })) return true;
    const i = this.getFocusableContainers(), s = this.visibleColsService.getAllCols();
    if (e) {
      if (i.length > 1) return this.focusContainer(N(i), true);
      const o = N(s);
      if (this.focusService.focusGridView(o, true)) return true;
    }
    if (this.gos.get("headerHeight") === 0 || this.focusService.isHeaderFocusSuppressed()) {
      if (this.focusService.focusGridView(s[0])) return true;
      for (let o = 1; o < i.length; o++) if (this.focusService.focusInto(i[o].getGui())) return true;
      return false;
    }
    return this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = false) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  allowFocusForNextCoreContainer(e) {
    var _a3;
    const t = this.view.getFocusableContainers(), { nextIndex: i, indexWithFocus: s } = this.getNextFocusableIndex(t, e);
    if (s === -1 || i < 0 || i >= t.length) return;
    const o = t[i];
    (_a3 = o.setAllowFocus) == null ? void 0 : _a3.call(o, true), setTimeout(() => {
      var _a4;
      (_a4 = o.setAllowFocus) == null ? void 0 : _a4.call(o, false);
    });
  }
  getNextFocusableIndex(e, t) {
    const i = te(this.gos), s = e.findIndex((r) => r.getGui().contains(i)), o = s + (t ? -1 : 1);
    return { indexWithFocus: s, nextIndex: o };
  }
  focusContainer(e, t) {
    var _a3, _b;
    (_a3 = e.setAllowFocus) == null ? void 0 : _a3.call(e, true);
    const i = this.focusService.focusInto(e.getGui(), t);
    return (_b = e.setAllowFocus) == null ? void 0 : _b.call(e, false), i;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  updateGridThemeClass() {
    const e = this.beans.environment.getGridThemeClass();
    e && this.view.setGridThemeClass(e);
  }
  handleThemeChange(e) {
    e.themeChanged && this.updateGridThemeClass();
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, zg = class extends R {
  constructor() {
    super(...arguments), this.beanName = "alignedGridsService", this.consuming = false;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.ctrlsService = e.ctrlsService, this.columnApplyStateService = e.columnApplyStateService;
  }
  getAlignedGridApis() {
    let e = this.gos.get("alignedGrids") ?? [];
    const t = typeof e == "function";
    typeof e == "function" && (e = e());
    const i = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
    return e.map((o) => {
      var _a3;
      if (!o) {
        z("alignedGrids contains an undefined option."), t || z(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`), z(i());
        return;
      }
      if (this.isGridApi(o)) return o;
      const r = o;
      return "current" in r ? (_a3 = r.current) == null ? void 0 : _a3.api : (r.api || z(`alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${i()}`), r.api);
    }).filter((o) => !!o && !o.isDestroyed());
  }
  isGridApi(e) {
    return !!e && !!e.dispatchEvent;
  }
  postConstruct() {
    const e = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({ columnMoved: e, columnVisible: e, columnPinned: e, columnGroupOpened: e, columnResized: e, bodyScroll: this.fireScrollEvent.bind(this), alignedGridColumn: ({ event: t }) => this.onColumnEvent(t), alignedGridScroll: ({ event: t }) => this.onScrollEvent(t) });
  }
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      t.isDestroyed() || t.dispatchEvent(e);
    });
  }
  onEvent(e) {
    this.consuming = true, e(), this.consuming = false;
  }
  fireColumnEvent(e) {
    this.fireEvent({ type: "alignedGridColumn", event: e });
  }
  fireScrollEvent(e) {
    e.direction === "horizontal" && this.fireEvent({ type: "alignedGridScroll", event: e });
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, true);
    });
  }
  extractDataFromEvent(e, t) {
    const i = [];
    return e.columns ? e.columns.forEach((s) => {
      i.push(t(s));
    }) : e.column && i.push(t(e.column)), i;
  }
  getMasterColumns(e) {
    return this.extractDataFromEvent(e, (t) => t);
  }
  getColumnIds(e) {
    return this.extractDataFromEvent(e, (t) => t.getColId());
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          this.processColumnEvent(e);
          break;
        }
        case "columnGroupOpened": {
          this.processGroupOpenedEvent(e);
          break;
        }
        case "columnPivotChanged":
          F("pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    const { columnModel: t } = this;
    e.columnGroups.forEach((i) => {
      let s = null;
      i && (s = t.getProvidedColGroup(i.getGroupId())), !(i && !s) && t.setColumnGroupOpened(s, i.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(e) {
    var _a3;
    const t = e.column;
    let i = null;
    if (t && (i = this.columnModel.getColDefCol(t.getColId())), t && !i) return;
    const s = this.getMasterColumns(e), { columnApplyStateService: o, columnSizeService: r, ctrlsService: n } = this;
    switch (e.type) {
      case "columnMoved":
        {
          const u = e.api.getColumnState().map((d) => ({ colId: d.colId }));
          o.applyColumnState({ state: u, applyOrder: true }, "alignedGridChanged");
        }
        break;
      case "columnVisible":
        {
          const u = e.api.getColumnState().map((d) => ({ colId: d.colId, hide: d.hide }));
          o.applyColumnState({ state: u }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const u = e.api.getColumnState().map((d) => ({ colId: d.colId, pinned: d.pinned }));
          o.applyColumnState({ state: u }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const c = e, u = {};
        s.forEach((d) => {
          u[d.getId()] = { key: d.getColId(), newWidth: d.getActualWidth() };
        }), (_a3 = c.flexColumns) == null ? void 0 : _a3.forEach((d) => {
          u[d.getId()] && delete u[d.getId()];
        }), r.setColumnWidths(Object.values(u), false, c.finished, "alignedGridChanged");
        break;
      }
    }
    const a = n.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((c) => {
      c.setGridOption("alwaysShowVerticalScroll", a);
    });
  }
}, _g = { version: G, moduleName: "@ag-grid-community/aligned-grid", beans: [zg] };
function Ug(e, t) {
  const i = e.columnModel.getColDefCol(t);
  return i ? i.getColDef() : null;
}
function Kg(e) {
  return e.columnModel.getColumnDefs();
}
function $g(e, t) {
  typeof t == "number" ? e.columnSizeService.sizeColumnsToFit(t, "api") : e.ctrlsService.getGridBodyCtrl().sizeColumnsToFit(t);
}
function jg(e, t, i) {
  e.columnModel.setColumnGroupOpened(t, i, "api");
}
function qg(e, t, i) {
  return e.visibleColsService.getColumnGroup(t, i);
}
function Yg(e, t) {
  return e.columnModel.getProvidedColGroup(t);
}
function Qg(e, t, i) {
  return e.columnNameService.getDisplayNameForColumn(t, i) || "";
}
function Xg(e, t, i) {
  return e.columnNameService.getDisplayNameForColumnGroup(t, i) || "";
}
function Jg(e, t) {
  return e.columnModel.getColDefCol(t);
}
function Zg(e) {
  return e.columnModel.getColDefCols();
}
function ep(e, t) {
  return e.columnApplyStateService.applyColumnState(t, "api");
}
function tp(e) {
  return e.columnGetStateService.getColumnState();
}
function ip(e) {
  e.columnApplyStateService.resetColumnState("api");
}
function sp(e) {
  return e.columnGroupStateService.getColumnGroupState();
}
function op(e, t) {
  e.columnGroupStateService.setColumnGroupState(t, "api");
}
function rp(e) {
  e.columnGroupStateService.resetColumnGroupState("api");
}
function np(e) {
  return e.visibleColsService.isPinningLeft() || e.visibleColsService.isPinningRight();
}
function lp(e) {
  return e.visibleColsService.isPinningLeft();
}
function ap(e) {
  return e.visibleColsService.isPinningRight();
}
function cp(e, t) {
  return e.visibleColsService.getColAfter(t);
}
function up(e, t) {
  return e.visibleColsService.getColBefore(t);
}
function dp(e, t, i) {
  e.columnModel.setColsVisible([t], i, "api");
}
function hp(e, t, i) {
  e.columnModel.setColsVisible(t, i, "api");
}
function gp(e, t, i) {
  e.columnModel.setColsPinned([t], i, "api");
}
function pp(e, t, i) {
  e.columnModel.setColsPinned(t, i, "api");
}
function fp(e) {
  return e.columnModel.getCols();
}
function mp(e) {
  return e.visibleColsService.getLeftCols();
}
function Cp(e) {
  return e.visibleColsService.getCenterCols();
}
function vp(e) {
  return e.visibleColsService.getRightCols();
}
function Sp(e) {
  return e.visibleColsService.getAllCols();
}
function wp(e) {
  return e.columnViewportService.getViewportColumns();
}
function yp(e, t, i) {
  e.columnMoveService.moveColumns([t], i, "api");
}
function Rp(e, t, i) {
  e.columnMoveService.moveColumnByIndex(t, i, "api");
}
function Fp(e, t, i) {
  e.columnMoveService.moveColumns(t, i, "api");
}
function bp(e, t, i, s = true, o = "api") {
  e.columnSizeService.setColumnWidths([{ key: t, newWidth: i }], false, s, o);
}
function Pp(e, t, i = true, s = "api") {
  e.columnSizeService.setColumnWidths(t, false, i, s);
}
function Ep(e) {
  return e.visibleColsService.getTreeLeft();
}
function Dp(e) {
  return e.visibleColsService.getTreeCenter();
}
function Mp(e) {
  return e.visibleColsService.getTreeRight();
}
function xp(e) {
  return e.visibleColsService.getAllTrees();
}
function Ap(e, t, i) {
  return e.columnAutosizeService.autoSizeCols({ colKeys: [t], skipHeader: i, source: "api" });
}
function Tp(e, t, i) {
  e.columnAutosizeService.autoSizeCols({ colKeys: t, skipHeader: i, source: "api" });
}
function Ip(e, t) {
  e.columnAutosizeService.autoSizeAllColumns("api", t);
}
var Lp = class extends R {
  constructor() {
    super(...arguments), this.beanName = "dataTypeService", this.dataTypeDefinitions = {}, this.isWaitingForRowData = false, this.isColumnTypeOverrideInDataTypeDefinitions = false, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.columnApplyStateService = e.columnApplyStateService, this.filterManager = e.filterManager;
  }
  postConstruct() {
    this.groupHideOpenParents = this.gos.get("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
    }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs(Ct(e.source));
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {}, this.formatValueFuncs = {};
    const t = (s) => (o) => {
      const { column: r, node: n, value: l } = o;
      let a = r.getColDef().valueFormatter;
      return a === s.groupSafeValueFormatter && (a = s.valueFormatter), this.valueService.formatValue(r, n, l, a);
    };
    Object.entries(e).forEach(([s, o]) => {
      const r = { ...o, groupSafeValueFormatter: this.createGroupSafeValueFormatter(o) };
      this.dataTypeDefinitions[s] = r, this.formatValueFuncs[s] = t(r);
    });
    const i = this.gos.get("dataTypeDefinitions") ?? {};
    this.dataTypeMatchers = {}, Object.entries(i).forEach(([s, o]) => {
      const r = this.processDataTypeDefinition(o, i, [s], e);
      r && (this.dataTypeDefinitions[s] = r, o.dataTypeMatcher && (this.dataTypeMatchers[s] = o.dataTypeMatcher), this.formatValueFuncs[s] = t(r));
    }), this.checkObjectValueHandlers(e), ["dateString", "text", "number", "boolean", "date"].forEach((s) => {
      const o = this.dataTypeMatchers[s];
      o && delete this.dataTypeMatchers[s], this.dataTypeMatchers[s] = o ?? e[s].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(e, t) {
    const i = { ...e, ...t };
    return e.columnTypes && t.columnTypes && t.appendColumnTypes && (i.columnTypes = [...Gi(e.columnTypes), ...Gi(t.columnTypes)]), i;
  }
  processDataTypeDefinition(e, t, i, s) {
    let o;
    const r = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = true), e.extendsDataType === e.baseDataType) {
      let n = s[r];
      const l = t[r];
      if (n && l && (n = l), !this.validateDataTypeDefinition(e, n, r)) return;
      o = this.mergeDataTypeDefinitions(n, e);
    } else {
      if (i.includes(r)) {
        F('Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.');
        return;
      }
      const n = t[r];
      if (!this.validateDataTypeDefinition(e, n, r)) return;
      const l = this.processDataTypeDefinition(n, t, [...i, r], s);
      if (!l) return;
      o = this.mergeDataTypeDefinitions(l, e);
    }
    return { ...o, groupSafeValueFormatter: this.createGroupSafeValueFormatter(o) };
  }
  validateDataTypeDefinition(e, t, i) {
    return t ? t.baseDataType !== e.baseDataType ? (F('The "baseDataType" property of a data type definition must match that of its parent.'), false) : true : (F(`The data type definition ${i} does not exist.`), false);
  }
  createGroupSafeValueFormatter(e) {
    if (e.valueFormatter) return (t) => {
      var _a3, _b;
      if ((_a3 = t.node) == null ? void 0 : _a3.group) {
        const i = (t.colDef.pivotValueColumn ?? t.column).getAggFunc();
        if (i) {
          if (i === "first" || i === "last") return e.valueFormatter(t);
          if (e.baseDataType === "number" && i !== "count") {
            if (typeof t.value == "number") return e.valueFormatter(t);
            if (typeof t.value == "object") {
              if (!t.value) return;
              if ("toNumber" in t.value) return e.valueFormatter({ ...t, value: t.value.toNumber() });
              if ("value" in t.value) return e.valueFormatter({ ...t, value: t.value.value });
            }
          }
          return;
        }
        if ((this.gos.get("suppressGroupMaintainValueType") || this.gos.get("groupDisplayType") === "groupRows") && !this.gos.get("treeData")) return;
      } else if (this.groupHideOpenParents && t.column.isRowGroupActive() && typeof t.value == "string" && !((_b = e.dataTypeMatcher) == null ? void 0 : _b.call(e, t.value))) return;
      return e.valueFormatter(t);
    };
  }
  updateColDefAndGetColumnType(e, t, i) {
    let { cellDataType: s } = t;
    const { field: o } = t;
    if (s === void 0 && (s = e.cellDataType), (s == null || s === true) && (s = this.canInferCellDataType(e, t) ? this.inferCellDataType(o, i) : false), !s) {
      e.cellDataType = false;
      return;
    }
    const r = this.dataTypeDefinitions[s];
    if (!r) {
      F(`Missing data type definition - "${s}"`);
      return;
    }
    return e.cellDataType = s, r.groupSafeValueFormatter && (e.valueFormatter = r.groupSafeValueFormatter), r.valueParser && (e.valueParser = r.valueParser), r.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, s, r, i), r.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isWaitingForRowData) return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t) return;
    const i = (s) => {
      t.add(s.key);
    };
    e.addEventListener("columnStateUpdated", i), this.columnStateUpdateListenerDestroyFuncs.push(() => e.removeEventListener("columnStateUpdated", i));
  }
  canInferCellDataType(e, t) {
    if (!Q(this.gos)) return false;
    const i = { cellRenderer: true, valueGetter: true, valueParser: true, refData: true };
    if (this.doColDefPropsPreventInference(t, i)) return false;
    const s = t.type === null ? e.type : t.type;
    if (s) {
      const o = this.gos.get("columnTypes") ?? {};
      if (Gi(s).some((n) => {
        const l = o[n.trim()];
        return l && this.doColDefPropsPreventInference(l, i);
      })) return false;
    }
    return !this.doColDefPropsPreventInference(e, i);
  }
  doColDefPropsPreventInference(e, t) {
    return [["cellRenderer", "agSparklineCellRenderer"], ["valueGetter", void 0], ["valueParser", void 0], ["refData", void 0]].some(([i, s]) => this.doesColDefPropPreventInference(e, t, i, s));
  }
  doesColDefPropPreventInference(e, t, i, s) {
    if (!t[i]) return false;
    const o = e[i];
    return o === null ? (t[i] = false, false) : s === void 0 ? !!o : o === s;
  }
  inferCellDataType(e, t) {
    if (!e) return;
    let i;
    const s = this.getInitialData();
    if (s) {
      const r = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      i = ri(s, e, r);
    } else this.initWaitForRowData(t);
    if (i == null) return;
    const [o] = Object.entries(this.dataTypeMatchers).find(([r, n]) => n(i)) ?? ["object"];
    return o;
  }
  getInitialData() {
    const e = this.gos.get("rowData");
    if (e == null ? void 0 : e.length) return e[0];
    if (this.initialData) return this.initialData;
    {
      const t = this.rowModel.getRootNode().allLeafChildren;
      if (t == null ? void 0 : t.length) return t[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isWaitingForRowData) return;
    this.isWaitingForRowData = true;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions;
    t && this.columnModel.queueResizeOperations();
    const [i] = this.addManagedEventListeners({ rowDataUpdateStarted: (s) => {
      const { firstRowData: o } = s;
      o && (i == null ? void 0 : i(), this.isWaitingForRowData = false, this.processColumnsPendingInference(o, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations(), this.eventService.dispatchEvent({ type: "dataTypesInferred" }));
    } });
  }
  isPendingInference() {
    return this.isWaitingForRowData;
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const i = [];
    this.destroyColumnStateUpdateListeners();
    const s = {}, o = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([r, n]) => {
      const l = this.columnModel.getCol(r);
      if (!l) return;
      const a = l.getColDef();
      if (!this.columnModel.resetColDefIntoCol(l, "cellDataTypeInferred")) return;
      const c = l.getColDef();
      if (t && c.type && c.type !== a.type) {
        const u = this.getUpdatedColumnState(l, n);
        u.rowGroup && u.rowGroupIndex == null && (s[r] = u), u.pivot && u.pivotIndex == null && (o[r] = u), i.push(u);
      }
    }), t && i.push(...this.funcColsService.generateColumnStateForRowGroupAndPivotIndexes(s, o)), i.length && this.columnApplyStateService.applyColumnState({ state: i }, "cellDataTypeInferred"), this.initialData = null;
  }
  getUpdatedColumnState(e, t) {
    const i = this.columnApplyStateService.getColumnStateFromColDef(e);
    return t.forEach((s) => {
      delete i[s], s === "rowGroup" ? delete i.rowGroupIndex : s === "pivot" && delete i.pivotIndex;
    }), i;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, i = e.object;
    this.hasObjectValueParser = t.valueParser !== i.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== i.valueFormatter;
  }
  getDateStringTypeDefinition(e) {
    return e ? this.getDataTypeDefinition(e) ?? this.dataTypeDefinitions.dateString : this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType) return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var _a3;
    return (_a3 = this.getDataTypeDefinition(e)) == null ? void 0 : _a3.baseDataType;
  }
  checkType(e, t) {
    var _a3;
    if (t == null) return true;
    const i = (_a3 = this.getDataTypeDefinition(e)) == null ? void 0 : _a3.dataTypeMatcher;
    return i ? i(t) : true;
  }
  validateColDef(e) {
    const t = (i) => F(`Cell data type is "object" but no Value ${i} has been provided. Please either provide an object data type definition with a Value ${i}, or set "colDef.value${i}"`);
    e.cellDataType === "object" && (e.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter && t("Formatter"), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && t("Parser"));
  }
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  setColDefPropertiesForBaseDataType(e, t, i, s) {
    var _a3;
    const o = this.formatValueFuncs[t];
    switch (i.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor";
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (r) => !!r.colDef.editable && r.event.key === y.SPACE;
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = o;
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = o;
        break;
      }
      case "object": {
        e.cellEditorParams = { useFormatter: true }, e.comparator = (r, n) => {
          const l = this.columnModel.getColDefCol(s), a = l == null ? void 0 : l.getColDef();
          if (!l || !a) return 0;
          const c = r == null ? "" : o({ column: l, node: null, value: r }), u = n == null ? "" : o({ column: l, node: null, value: n });
          return c === u ? 0 : c > u ? 1 : -1;
        }, e.keyCreator = o;
        break;
      }
    }
    (_a3 = this.filterManager) == null ? void 0 : _a3.setColDefPropertiesForDataType(e, i, o);
  }
  getDefaultDataTypes() {
    const e = (i) => !!i.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.localeService.getLocaleTextFunc();
    return { number: { baseDataType: "number", valueParser: (i) => {
      var _a3, _b;
      return ((_b = (_a3 = i.newValue) == null ? void 0 : _a3.trim) == null ? void 0 : _b.call(_a3)) === "" ? null : Number(i.newValue);
    }, valueFormatter: (i) => i.value == null ? "" : typeof i.value != "number" || isNaN(i.value) ? t("invalidNumber", "Invalid Number") : String(i.value), dataTypeMatcher: (i) => typeof i == "number" }, text: { baseDataType: "text", valueParser: (i) => i.newValue === "" ? null : xs(i.newValue), dataTypeMatcher: (i) => typeof i == "string" }, boolean: { baseDataType: "boolean", valueParser: (i) => {
      var _a3, _b;
      return i.newValue == null ? i.newValue : ((_b = (_a3 = i.newValue) == null ? void 0 : _a3.trim) == null ? void 0 : _b.call(_a3)) === "" ? null : String(i.newValue).toLowerCase() === "true";
    }, valueFormatter: (i) => i.value == null ? "" : String(i.value), dataTypeMatcher: (i) => typeof i == "boolean" }, date: { baseDataType: "date", valueParser: (i) => be(i.newValue == null ? null : String(i.newValue)), valueFormatter: (i) => i.value == null ? "" : !(i.value instanceof Date) || isNaN(i.value.getTime()) ? t("invalidDate", "Invalid Date") : Ge(i.value, false) ?? "", dataTypeMatcher: (i) => i instanceof Date }, dateString: { baseDataType: "dateString", dateParser: (i) => be(i) ?? void 0, dateFormatter: (i) => Ge(i ?? null, false) ?? void 0, valueParser: (i) => e(String(i.newValue)) ? i.newValue : null, valueFormatter: (i) => e(String(i.value)) ? i.value : "", dataTypeMatcher: (i) => typeof i == "string" && e(i) }, object: { baseDataType: "object", valueParser: () => null, valueFormatter: (i) => xs(i.value) ?? "" } };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
}, Op = { version: G, moduleName: "@ag-grid-community/data-type", beans: [Lp] }, Gp = { version: G, moduleName: "@ag-grid-community/column-api", apiFunctions: { getColumnDef: Ug, getColumnDefs: Kg, sizeColumnsToFit: $g, setColumnGroupOpened: jg, getColumnGroup: qg, getProvidedColumnGroup: Yg, getDisplayNameForColumn: Qg, getDisplayNameForColumnGroup: Xg, getColumn: Jg, getColumns: Zg, applyColumnState: ep, getColumnState: tp, resetColumnState: ip, getColumnGroupState: sp, setColumnGroupState: op, resetColumnGroupState: rp, isPinning: np, isPinningLeft: lp, isPinningRight: ap, getDisplayedColAfter: cp, getDisplayedColBefore: up, setColumnVisible: dp, setColumnsVisible: hp, setColumnPinned: gp, setColumnsPinned: pp, getAllGridColumns: fp, getDisplayedLeftColumns: mp, getDisplayedCenterColumns: Cp, getDisplayedRightColumns: vp, getAllDisplayedColumns: Sp, getAllDisplayedVirtualColumns: wp, moveColumn: yp, moveColumnByIndex: Rp, moveColumns: Fp, setColumnWidth: bp, setColumnWidths: Pp, getLeftDisplayedColumnGroups: Ep, getCenterDisplayedColumnGroups: Dp, getRightDisplayedColumnGroups: Mp, getAllDisplayedColumnGroups: xp, autoSizeColumn: Ap, autoSizeColumns: Tp, autoSizeAllColumns: Ip } };
function kp(e, t) {
  e.ctrlsService.getGridBodyCtrl().getRowDragFeature().addRowDropZone(t);
}
function Hp(e, t) {
  const i = e.dragAndDropService.findExternalZone(t);
  i && e.dragAndDropService.removeDropTarget(i);
}
function Np(e, t) {
  return e.ctrlsService.getGridBodyCtrl().getRowDragFeature().getRowDropZone(t);
}
var Vp = { version: G, moduleName: "@ag-grid-community/drag-api", apiFunctions: { addRowDropZone: kp, removeRowDropZone: Hp, getRowDropZoneParams: Np } };
function Bp(e) {
  return e.pinnedRowModel.getPinnedTopRowCount();
}
function Wp(e) {
  return e.pinnedRowModel.getPinnedBottomRowCount();
}
function zp(e, t) {
  return e.pinnedRowModel.getPinnedTopRow(t);
}
function _p(e, t) {
  return e.pinnedRowModel.getPinnedBottomRow(t);
}
var Up = { version: G, moduleName: "@ag-grid-community/pinned-row-api", apiFunctions: { getPinnedTopRowCount: Bp, getPinnedBottomRowCount: Wp, getPinnedTopRow: zp, getPinnedBottomRow: _p } };
function Kp(e) {
  e.overlayService.showLoadingOverlay();
}
function $p(e) {
  e.overlayService.showNoRowsOverlay();
}
function jp(e) {
  e.overlayService.hideOverlay();
}
var qp = { version: G, moduleName: "@ag-grid-community/overlay-api", apiFunctions: { showLoadingOverlay: Kp, showNoRowsOverlay: $p, hideOverlay: jp } };
function Yp(e, t, i) {
  if (!t) return;
  const s = e.ctrlsService.getGridBodyCtrl().getGui(), o = `aria-${t}`;
  i === null ? s.removeAttribute(o) : s.setAttribute(o, i);
}
function Qp(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t));
}
function Xp(e, t = {}) {
  const i = (s) => F(`Since v31.1 api.flashCells parameter '${s}Delay' is deprecated. Please use '${s}Duration' instead.`);
  E(t.fadeDelay) && i("fade"), E(t.flashDelay) && i("flash"), e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.flashCells(t));
}
function Jp(e) {
  e.frameworkOverrides.wrapIncoming(() => e.ctrlsService.getHeaderRowContainerCtrls().forEach((t) => t.refresh()));
}
function Zp(e) {
  return e.animationFrameService.isQueueEmpty();
}
function ef(e) {
  e.animationFrameService.flushAllFrames();
}
function tf(e) {
  return { rowHeight: ts(e.gos), headerHeight: e.columnModel.getHeaderHeight() };
}
function sf(e, t = {}) {
  return e.rowRenderer.getCellRendererInstances(t).map(li);
}
var of = { version: G, moduleName: "@ag-grid-community/render-api", apiFunctions: { setGridAriaProperty: Yp, refreshCells: Qp, flashCells: Xp, refreshHeader: Jp, isAnimationFrameQueueEmpty: Zp, flushAllAnimationFrames: ef, getSizesForCurrentTheme: tf, getCellRendererInstances: sf } };
function rf(e) {
  e.valueCache.expire();
}
function nf(e, t, i) {
  return sl(e, { colKey: t, rowNode: i });
}
function sl(e, t) {
  const { colKey: i, rowNode: s, useFormatter: o } = t, r = e.columnModel.getColDefCol(i) ?? e.columnModel.getCol(i);
  if (V(r)) return null;
  const n = e.valueService.getValueForDisplay(r, s);
  return o ? e.valueService.formatValue(r, s, n) ?? Ke(n, true) : n;
}
function lf(e) {
  return e.context.getGridId();
}
function af(e) {
  e.gridDestroyService.destroy();
}
function cf(e) {
  return e.gridDestroyService.isDestroyCalled();
}
function uf(e, t) {
  return e.gos.get(t);
}
function df(e, t, i) {
  ol(e, { [t]: i });
}
function ol(e, t) {
  e.gos.updateGridOptions({ options: t });
}
function hf(e, t, i) {
  e.apiEventService.addEventListener(t, i);
}
function gf(e, t, i) {
  e.apiEventService.removeEventListener(t, i);
}
function pf(e, t) {
  e.apiEventService.addGlobalListener(t);
}
function ff(e, t) {
  e.apiEventService.removeGlobalListener(t);
}
function mf(e) {
  return e.focusService.getFocusedCell();
}
function Cf(e) {
  return e.focusService.clearFocusedCell();
}
function vf(e, t, i, s) {
  e.focusService.setFocusedCell({ rowIndex: t, column: i, rowPinned: s, forceBrowserFocus: true });
}
function Sf(e, t) {
  return e.navigationService.tabToNextCell(false, t);
}
function wf(e, t) {
  return e.navigationService.tabToNextCell(true, t);
}
function yf(e, t, i = false) {
  const s = e.headerNavigationService.getHeaderPositionForColumn(t, i);
  s && e.focusService.focusHeaderPosition({ headerPosition: s });
}
function Rf(e, t, i) {
  const s = e.columnModel.getCol(t);
  e.menuService.showColumnMenu({ column: s, buttonElement: i, positionBy: "button" });
}
function Ff(e, t, i) {
  let s = e.columnModel.getCol(t);
  if (s || (s = e.columnModel.getColDefCol(t)), !s) {
    z(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({ column: s, mouseEvent: i, positionBy: "mouse" });
}
function bf(e, t) {
  const i = e.columnModel.getCol(t);
  if (!i) {
    z(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({ column: i, positionBy: "auto" });
}
function Pf(e) {
  e.menuService.hidePopupMenu();
}
function Ef(e, t = {}) {
  const i = t ? t.rowNodes : void 0;
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(i));
}
function Df(e, t, i, s, o) {
  e.expansionService.setRowNodeExpanded(t, i, s, o);
}
function Mf(e, t) {
  return e.rowModel.getRowNode(t);
}
function xf(e, t, i, s) {
  e.rowRenderer.addRenderedRowListener(t, i, s);
}
function Af(e) {
  return e.rowRenderer.getRenderedNodes();
}
function Tf(e, t, i) {
  e.rowModel.forEachNode(t, i);
}
function If(e) {
  return rl(e);
}
function rl(e) {
  return e.rowRenderer.getFirstVirtualRenderedRow();
}
function Lf(e) {
  return nl(e);
}
function nl(e) {
  return e.rowRenderer.getLastVirtualRenderedRow();
}
function Of(e, t) {
  return e.rowModel.getRow(t);
}
function Gf(e) {
  return e.rowModel.getRowCount();
}
function kf(e) {
  return e.rowModel;
}
function Hf(e, t) {
  if (!t.nodes.every((l) => l.rowPinned ? (F("cannot select pinned rows"), false) : l.id === void 0 ? (F("cannot select node until id for node is known"), false) : true)) return;
  const { nodes: s, source: o, newValue: r } = t, n = s;
  e.selectionService.setNodesSelected({ nodes: n, source: o ?? "api", newValue: r });
}
function Nf(e, t = "apiSelectAll") {
  e.selectionService.selectAllRowNodes({ source: t });
}
function Vf(e, t = "apiSelectAll") {
  e.selectionService.deselectAllRowNodes({ source: t });
}
function Bf(e, t = "apiSelectAllFiltered") {
  e.selectionService.selectAllRowNodes({ source: t, justFiltered: true });
}
function Wf(e, t = "apiSelectAllFiltered") {
  e.selectionService.deselectAllRowNodes({ source: t, justFiltered: true });
}
function zf(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.selectAllRowNodes({ source: t, justCurrentPage: true });
}
function _f(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.deselectAllRowNodes({ source: t, justCurrentPage: true });
}
function Uf(e) {
  return e.selectionService.getSelectedNodes();
}
function Kf(e) {
  return e.selectionService.getSelectedRows();
}
function $f(e) {
  e.sortController.onSortChanged("api");
}
var jf = { version: G, moduleName: "@ag-grid-community/core-api", apiFunctions: { getGridId: lf, destroy: af, isDestroyed: cf, getGridOption: uf, setGridOption: df, updateGridOptions: ol } }, qf = { version: G, moduleName: "@ag-grid-community/row-selection-api", apiFunctions: { setNodesSelected: Hf, selectAll: Nf, deselectAll: Vf, selectAllFiltered: Bf, deselectAllFiltered: Wf, selectAllOnCurrentPage: zf, deselectAllOnCurrentPage: _f, getSelectedNodes: Uf, getSelectedRows: Kf } }, Yf = { version: G, moduleName: "@ag-grid-community/row-api", apiFunctions: { redrawRows: Ef, setRowNodeExpanded: Df, getRowNode: Mf, addRenderedRowListener: xf, getRenderedNodes: Af, forEachNode: Tf, getFirstDisplayedRow: If, getFirstDisplayedRowIndex: rl, getLastDisplayedRow: Lf, getLastDisplayedRowIndex: nl, getDisplayedRowAtIndex: Of, getDisplayedRowCount: Gf, getModel: kf } }, Qf = { version: G, moduleName: "@ag-grid-community/scroll-api", apiFunctions: { getVerticalPixelRange: Hh, getHorizontalPixelRange: Nh, ensureColumnVisible: Xn, ensureIndexVisible: Jn, ensureNodeVisible: Vh } }, Xf = { version: G, moduleName: "@ag-grid-community/keyboard-navigation-api", apiFunctions: { getFocusedCell: mf, clearFocusedCell: Cf, setFocusedCell: vf, setFocusedHeader: yf, tabToNextCell: Sf, tabToPreviousCell: wf } }, Jf = { version: G, moduleName: "@ag-grid-community/event-api", apiFunctions: { addEventListener: hf, addGlobalListener: pf, removeEventListener: gf, removeGlobalListener: ff } }, Zf = { version: G, moduleName: "@ag-grid-community/cell-api", apiFunctions: { expireValueCache: rf, getValue: nf, getCellValue: sl } }, em = { version: G, moduleName: "@ag-grid-community/menu-api", apiFunctions: { showColumnMenuAfterButtonClick: Rf, showColumnMenuAfterMouseClick: Ff, showColumnMenu: bf, hidePopupMenu: Pf } }, tm = { version: G, moduleName: "@ag-grid-community/sort-api", apiFunctions: { onSortChanged: $f } }, im = { version: G, moduleName: "@ag-grid-community/api", dependantModules: [jf, Up, qf, Gp, Yf, Vp, Qf, qp, Xf, Jf, of, Zf, em, tm] };
function sm(e) {
  var _a3;
  return ((_a3 = e.stateService) == null ? void 0 : _a3.getState()) ?? {};
}
function om(e) {
  switch (e = { ...e }, e.version || (e.version = "32.1.0"), e.version) {
    case "32.1.0":
      e = rm(e);
  }
  return e;
}
function rm(e) {
  return e.cellSelection = nm(e, "rangeSelection"), e;
}
function nm(e, t) {
  if (e && typeof e == "object") return e[t];
}
var lm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "stateService", this.suppressEvents = true, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = Re(() => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = Re(() => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), 0), this.onRowSelectedDebounced = Re(() => {
      this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
    }, 0), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.ctrlsService = e.ctrlsService, this.pivotResultColsService = e.pivotResultColsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnGroupStateService = e.columnGroupStateService, this.columnGetStateService = e.columnGetStateService, this.paginationService = e.paginationService, this.selectionService = e.selectionService, this.expansionService = e.expansionService, this.columnAnimationService = e.columnAnimationService, this.columnApplyStateService = e.columnApplyStateService, this.sideBarService = e.sideBarService, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.isClientSideRowModel = Q(this.gos), this.cachedState = this.getInitialState(), this.setCachedStateValue("version", G), this.ctrlsService.whenReady(this, () => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady()));
    const [e, t, i] = this.addManagedEventListeners({ newColumnsLoaded: ({ source: s }) => {
      s === "gridInitializing" && (e(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised()));
    }, rowCountReady: () => {
      t == null ? void 0 : t(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
    }, firstDataRendered: () => {
      i == null ? void 0 : i(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
    } });
  }
  getInitialState() {
    return om(this.gos.get("initialState") ?? {});
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setupStateOnGridReady() {
    this.updateCachedState("sideBar", this.getSideBarState());
    const e = () => this.updateCachedState("sideBar", this.getSideBarState());
    this.addManagedEventListeners({ toolPanelVisibleChanged: e, sideBarUpdated: e });
  }
  setupStateOnColumnsInitialised() {
    const e = this.getInitialState();
    this.setColumnState(e), this.setColumnGroupState(e), this.updateColumnState(["aggregation", "columnOrder", "columnPinning", "columnSizing", "columnVisibility", "pivot", "pivot", "rowGroup", "sort"]), this.updateCachedState("columnGroup", this.getColumnGroupState());
    const t = (i) => () => this.updateColumnState([i]);
    this.addManagedEventListeners({ columnValueChanged: t("aggregation"), columnMoved: t("columnOrder"), columnPinned: t("columnPinning"), columnResized: t("columnSizing"), columnVisible: t("columnVisibility"), columnPivotChanged: t("pivot"), columnPivotModeChanged: t("pivot"), columnRowGroupChanged: t("rowGroup"), sortChanged: t("sort"), newColumnsLoaded: () => this.updateColumnState(["aggregation", "columnOrder", "columnPinning", "columnSizing", "columnVisibility", "pivot", "rowGroup", "sort"]), columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState()) });
  }
  setupStateOnRowCountReady() {
    const { filter: e, rowGroupExpansion: t, rowSelection: i, pagination: s } = this.getInitialState(), o = this.gos.get("advancedFilterModel");
    (e || o) && this.setFilterState(e, o), t && this.setRowGroupExpansionState(t), i && this.setRowSelectionState(i), s && this.setPaginationState(s), this.updateCachedState("filter", this.getFilterState()), this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowSelection", this.getRowSelectionState()), this.updateCachedState("pagination", this.getPaginationState());
    const r = () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
    this.addManagedEventListeners({ filterChanged: () => this.updateCachedState("filter", this.getFilterState()), rowGroupOpened: () => this.onRowGroupOpenedDebounced(), expandOrCollapseAll: r, columnRowGroupChanged: r, rowDataUpdated: () => {
      this.gos.get("groupDefaultExpanded") !== 0 && setTimeout(() => {
        r();
      });
    }, selectionChanged: () => {
      this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
    }, paginationChanged: (n) => {
      (n.newPage || n.newPageSize) && this.updateCachedState("pagination", this.getPaginationState());
    } });
  }
  setupStateOnFirstDataRendered() {
    const { scroll: e, cellSelection: t, focusedCell: i, columnOrder: s } = this.getInitialState();
    i && this.setFocusedCellState(i), t && this.setCellSelectionState(t), e && this.setScrollState(e), this.setColumnPivotState(!!(s == null ? void 0 : s.orderedColIds)), this.updateCachedState("sideBar", this.getSideBarState()), this.updateCachedState("focusedCell", this.getFocusedCellState());
    const o = this.getRangeSelectionState();
    this.updateCachedState("rangeSelection", o), this.updateCachedState("cellSelection", o), this.updateCachedState("scroll", this.getScrollState()), this.addManagedEventListeners({ cellFocused: () => this.updateCachedState("focusedCell", this.getFocusedCellState()), cellSelectionChanged: (r) => {
      if (r.finished) {
        const n = this.getRangeSelectionState();
        this.updateCachedState("rangeSelection", n), this.updateCachedState("cellSelection", n);
      }
    }, bodyScrollEnd: () => this.updateCachedState("scroll", this.getScrollState()) });
  }
  getColumnState() {
    const e = this.columnModel.isPivotMode(), t = [], i = [], s = [], o = [], r = [], n = [], l = [], a = [], c = [];
    let u = 0;
    const d = this.columnGetStateService.getColumnState();
    for (let h = 0; h < d.length; h++) {
      const { colId: g, sort: m, sortIndex: C, rowGroup: f, rowGroupIndex: v, aggFunc: w, pivot: S, pivotIndex: b, pinned: x, hide: M, width: P, flex: A } = d[h];
      c.push(g), m && (t[C ?? u++] = { colId: g, sort: m }), f && (i[v ?? 0] = g), typeof w == "string" && s.push({ colId: g, aggFunc: w }), S && (o[b ?? 0] = g), x && (x === "right" ? n : r).push(g), M && l.push(g), (A || P) && a.push({ colId: g, flex: A ?? void 0, width: P });
    }
    return { sort: t.length ? { sortModel: t } : void 0, rowGroup: i.length ? { groupColIds: i } : void 0, aggregation: s.length ? { aggregationModel: s } : void 0, pivot: o.length || e ? { pivotMode: e, pivotColIds: o } : void 0, columnPinning: r.length || n.length ? { leftColIds: r, rightColIds: n } : void 0, columnVisibility: l.length ? { hiddenColIds: l } : void 0, columnSizing: a.length ? { columnSizingModel: a } : void 0, columnOrder: c.length ? { orderedColIds: c } : void 0 };
  }
  setColumnState(e) {
    const { sort: t, rowGroup: i, aggregation: s, pivot: o, columnPinning: r, columnVisibility: n, columnSizing: l, columnOrder: a, partialColumnState: c } = e, u = {}, d = (f) => {
      let v = u[f];
      return v || (v = { colId: f }, u[f] = v, v);
    }, h = c ? {} : { sort: null, sortIndex: null, rowGroup: null, rowGroupIndex: null, aggFunc: null, pivot: null, pivotIndex: null, pinned: null, hide: null, flex: null };
    t && (t.sortModel.forEach(({ colId: f, sort: v }, w) => {
      const S = d(f);
      S.sort = v, S.sortIndex = w;
    }), h.sort = null, h.sortIndex = null), i && (i.groupColIds.forEach((f, v) => {
      const w = d(f);
      w.rowGroup = true, w.rowGroupIndex = v;
    }), h.rowGroup = null, h.rowGroupIndex = null), s && (s.aggregationModel.forEach(({ colId: f, aggFunc: v }) => {
      d(f).aggFunc = v;
    }), h.aggFunc = null), o && (o.pivotColIds.forEach((f, v) => {
      const w = d(f);
      w.pivot = true, w.pivotIndex = v;
    }), this.gos.updateGridOptions({ options: { pivotMode: o.pivotMode }, source: "gridInitializing" }), h.pivot = null, h.pivotIndex = null), r && (r.leftColIds.forEach((f) => {
      d(f).pinned = "left";
    }), r.rightColIds.forEach((f) => {
      d(f).pinned = "right";
    }), h.pinned = null), n && (n.hiddenColIds.forEach((f) => {
      d(f).hide = true;
    }), h.hide = null), l && (l.columnSizingModel.forEach(({ colId: f, flex: v, width: w }) => {
      const S = d(f);
      S.flex = v ?? null, S.width = w;
    }), h.flex = null);
    const g = a == null ? void 0 : a.orderedColIds, m = !!(g == null ? void 0 : g.length), C = m ? g.map((f) => d(f)) : Object.values(u);
    C.length && (this.columnStates = C, this.columnApplyStateService.applyColumnState({ state: C, applyOrder: m, defaultState: h }, "gridInitializing"));
  }
  setColumnPivotState(e) {
    const t = this.columnStates;
    this.columnStates = void 0;
    const i = this.columnGroupStates;
    if (this.columnGroupStates = void 0, !!this.pivotResultColsService.isPivotResultColsPresent()) {
      if (t) {
        const s = [];
        for (const o of t) this.pivotResultColsService.getPivotResultCol(o.colId) && s.push(o);
        this.columnApplyStateService.applyColumnState({ state: s, applyOrder: e }, "gridInitializing");
      }
      i && this.columnGroupStateService.setColumnGroupState(i, "gridInitializing");
    }
  }
  getColumnGroupState() {
    const e = this.columnGroupStateService.getColumnGroupState(), t = [];
    return e.forEach(({ groupId: i, open: s }) => {
      s && t.push(i);
    }), t.length ? { openColumnGroupIds: t } : void 0;
  }
  setColumnGroupState(e) {
    var _a3;
    if (!Object.prototype.hasOwnProperty.call(e, "columnGroup")) return;
    const t = new Set((_a3 = e.columnGroup) == null ? void 0 : _a3.openColumnGroupIds), s = this.columnGroupStateService.getColumnGroupState().map(({ groupId: o }) => {
      const r = t.has(o);
      return r && t.delete(o), { groupId: o, open: r };
    });
    t.forEach((o) => {
      s.push({ groupId: o, open: true });
    }), s.length && (this.columnGroupStates = s), this.columnGroupStateService.setColumnGroupState(s, "gridInitializing");
  }
  getFilterState() {
    var _a3, _b;
    let e = (_a3 = this.filterManager) == null ? void 0 : _a3.getFilterModel();
    e && Object.keys(e).length === 0 && (e = void 0);
    const t = ((_b = this.filterManager) == null ? void 0 : _b.getAdvancedFilterModel()) ?? void 0;
    return e || t ? { filterModel: e, advancedFilterModel: t } : void 0;
  }
  setFilterState(e, t) {
    var _a3, _b;
    const { filterModel: i, advancedFilterModel: s } = e ?? { advancedFilterModel: t };
    i && ((_a3 = this.filterManager) == null ? void 0 : _a3.setFilterModel(i, "columnFilter")), s && ((_b = this.filterManager) == null ? void 0 : _b.setAdvancedFilterModel(s));
  }
  getRangeSelectionState() {
    var _a3;
    const e = (_a3 = this.rangeService) == null ? void 0 : _a3.getCellRanges().map((t) => {
      const { id: i, type: s, startRow: o, endRow: r, columns: n, startColumn: l } = t;
      return { id: i, type: s, startRow: o, endRow: r, colIds: n.map((a) => a.getColId()), startColId: l.getColId() };
    });
    return (e == null ? void 0 : e.length) ? { cellRanges: e } : void 0;
  }
  setCellSelectionState(e) {
    const { gos: t, rangeService: i, columnModel: s, visibleColsService: o } = this;
    if (!et(t) || !i) return;
    const r = [];
    if (e.cellRanges.forEach((n) => {
      const l = [];
      if (n.colIds.forEach((c) => {
        const u = s.getCol(c);
        u && l.push(u);
      }), !l.length) return;
      let a = s.getCol(n.startColId);
      if (!a) {
        const c = o.getAllCols(), u = new Set(l);
        a = c.find((d) => u.has(d));
      }
      r.push({ ...n, columns: l, startColumn: a });
    }), Vl(t) && Bl(t) && r.length > 1) return F("cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`");
    i.setCellRanges(r);
  }
  getScrollState() {
    var _a3;
    if (!this.isClientSideRowModel) return;
    const e = (_a3 = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : _a3.getScrollFeature(), { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? { left: 0 }, { top: i } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 };
    return i || t ? { top: i, left: t } : void 0;
  }
  setScrollState(e) {
    var _a3;
    if (!this.isClientSideRowModel) return;
    const { top: t, left: i } = e;
    (_a3 = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : _a3.getScrollFeature().setScrollPosition(t, i);
  }
  getSideBarState() {
    var _a3, _b;
    return (_b = (_a3 = this.sideBarService) == null ? void 0 : _a3.getSideBarComp()) == null ? void 0 : _b.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel) return;
    const e = this.focusService.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: i, rowPinned: s } = e;
      return { colId: t.getColId(), rowIndex: i, rowPinned: s };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel) return;
    const { colId: t, rowIndex: i, rowPinned: s } = e;
    this.focusService.setFocusedCell({ column: this.columnModel.getCol(t), rowIndex: i, rowPinned: s, forceBrowserFocus: true, preventScrollOnBrowserFocus: true });
  }
  getPaginationState() {
    if (!this.paginationService) return;
    const e = this.paginationService.getCurrentPage(), t = this.gos.get("paginationAutoPageSize") ? void 0 : this.paginationService.getPageSize();
    if (!(!e && !t)) return { page: e, pageSize: t };
  }
  setPaginationState(e) {
    this.paginationService && (e.pageSize && !this.gos.get("paginationAutoPageSize") && this.paginationService.setPageSize(e.pageSize, "initialState"), typeof e.page == "number" && this.paginationService.setPage(e.page));
  }
  getRowSelectionState() {
    var _a3;
    const e = this.selectionService.getSelectionState();
    return !e || !Array.isArray(e) && (e.selectAll === false || e.selectAllChildren === false) && !((_a3 = e == null ? void 0 : e.toggledNodes) == null ? void 0 : _a3.length) ? void 0 : e;
  }
  setRowSelectionState(e) {
    this.selectionService.setSelectionState(e, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const e = this.expansionService.getExpandedRows();
    return e.length ? { expandedRowGroupIds: e } : void 0;
  }
  setRowGroupExpansionState(e) {
    this.expansionService.expandRows(e.expandedRowGroupIds);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let i = false;
    Object.entries(t).forEach(([s, o]) => {
      Bi(o, this.cachedState[s]) || (i = true);
    }), this.cachedState = { ...this.cachedState, ...t }, i && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const i = this.cachedState[e];
    this.setCachedStateValue(e, t), Bi(t, i) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = { ...this.cachedState, [e]: t };
  }
  refreshStaleState() {
    this.staleStateKeys.forEach((e) => {
      switch (e) {
        case "rowSelection":
          this.setCachedStateValue(e, this.getRowSelectionState());
          break;
      }
    }), this.staleStateKeys.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = Array.from(this.queuedUpdateSources);
    this.queuedUpdateSources.clear(), this.eventService.dispatchEvent({ type: "stateUpdated", sources: e, state: this.cachedState });
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.suppressEvents = true, this.columnAnimationService.setSuppressAnimation(true), e(), setTimeout(() => {
      this.suppressEvents = false, this.queuedUpdateSources.clear(), this.isAlive() && (this.columnAnimationService.setSuppressAnimation(false), this.dispatchStateUpdateEvent(["gridInitializing"]));
    });
  }
}, ll = { version: G, moduleName: "@ag-grid-community/state-core", beans: [lm] }, am = { version: G, moduleName: "@ag-grid-community/state-api", apiFunctions: { getState: sm }, dependantModules: [ll] }, cm = { version: G, moduleName: "@ag-grid-community/state", dependantModules: [ll, am] };
function um(e) {
  return e.rowModel.isLastRowIndexKnown();
}
function dm(e) {
  var _a3;
  return ((_a3 = e.paginationService) == null ? void 0 : _a3.getPageSize()) ?? 100;
}
function hm(e) {
  var _a3;
  return ((_a3 = e.paginationService) == null ? void 0 : _a3.getCurrentPage()) ?? 0;
}
function gm(e) {
  var _a3;
  return ((_a3 = e.paginationService) == null ? void 0 : _a3.getTotalPages()) ?? 1;
}
function pm(e) {
  return e.paginationService ? e.paginationService.getMasterRowCount() : e.rowModel.getRowCount();
}
function fm(e) {
  var _a3;
  (_a3 = e.paginationService) == null ? void 0 : _a3.goToNextPage();
}
function mm(e) {
  var _a3;
  (_a3 = e.paginationService) == null ? void 0 : _a3.goToPreviousPage();
}
function Cm(e) {
  var _a3;
  (_a3 = e.paginationService) == null ? void 0 : _a3.goToFirstPage();
}
function vm(e) {
  var _a3;
  (_a3 = e.paginationService) == null ? void 0 : _a3.goToLastPage();
}
function Sm(e, t) {
  var _a3;
  (_a3 = e.paginationService) == null ? void 0 : _a3.goToPage(t);
}
var wm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "paginationAutoPageSizeService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center;
      const t = this.checkPageSize.bind(this);
      this.addManagedEventListeners({ bodyHeightChanged: t, scrollVisibilityChanged: t }), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.paginationService.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive()) return;
    const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
    if (e > 0) {
      const t = () => {
        const i = Math.max(ts(this.gos), 1), s = Math.floor(e / i);
        this.paginationService.setPageSize(s, "autoCalculated");
      };
      this.isBodyRendered ? Re(() => t(), 50)() : (t(), this.isBodyRendered = true);
    } else this.isBodyRendered = false;
  }
};
function ym(e, t, i) {
  e.addManagedElementListeners(t, { keydown: (s) => {
    if (!s.defaultPrevented && s.key === y.TAB) {
      const o = s.shiftKey;
      i.findNextFocusableElement(t, false, o) || i.focusNextGridCoreContainer(o) && s.preventDefault();
    }
  } });
}
var ti = "paginationPageSizeSelector", Rm = class extends Y {
  constructor() {
    super('<span class="ag-paging-page-size"></span>'), this.hasEmptyOption = false, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp) return;
      const e = this.selectPageSizeComp.getValue();
      if (!e) return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.paginationService.getPageSize() || (this.paginationService.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(true), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  wireBeans(e) {
    this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.addManagedPropertyListener(ti, () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedEventListeners({ paginationChanged: (e) => this.handlePaginationChanged(e) });
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e == null ? void 0 : e.newPageSize)) return;
    const t = this.paginationService.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(true);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && !e && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp);
  }
  reset() {
    xe(this.getGui()), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get(ti) !== false;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.paginationService.getPageSize(), i = !t || !e.includes(t);
    if (i) {
      const o = this.gos.exists("paginationPageSize"), r = this.gos.get(ti) !== true;
      F(`'paginationPageSize=${t}'${o ? "" : " (default value)"}, but ${t} is not included in${r ? "" : " the default"} paginationPageSizeSelector=[${e.join(", ")}].`), r || F(`Either set '${ti}' to an array that includes ${t} or to 'false' to disable the page size selector.`), e.unshift("");
    }
    const s = String(i ? "" : t);
    this.selectPageSizeComp ? (gt(this.pageSizeOptions, e) || (this.selectPageSizeComp.clearOptions().addOptions(this.createPageSizeSelectOptions(e)), this.pageSizeOptions = e), this.selectPageSizeComp.setValue(s, true)) : this.createPageSizeSelectorComp(e, s), this.hasEmptyOption = i;
  }
  createPageSizeSelectOptions(e) {
    return e.map((t) => ({ value: String(t) }));
  }
  createPageSizeSelectorComp(e, t) {
    const i = this.localeService.getLocaleTextFunc(), s = i("pageSizeSelectorLabel", "Page Size:"), o = i("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new So()).addOptions(this.createPageSizeSelectOptions(e)).setValue(t).setAriaLabel(o).setLabel(s).onValueChange(() => this.handlePageSizeItemSelected()), this.appendChild(this.selectPageSizeComp);
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get(ti);
    return !Array.isArray(t) || Me(t) ? e : [...t].sort((i, s) => i - s);
  }
  destroy() {
    this.toggleSelectDisplay(false), super.destroy();
  }
}, Fm = { selector: "AG-PAGE-SIZE-SELECTOR", component: Rm }, bm = class extends hg {
  constructor() {
    super(), this.btFirst = O, this.btPrevious = O, this.btNext = O, this.btLast = O, this.lbRecordCount = O, this.lbFirstRowOnPage = O, this.lbLastRowOnPage = O, this.lbCurrent = O, this.lbTotal = O, this.pageSizeComp = O, this.previousAndFirstButtonsDisabled = false, this.nextButtonDisabled = false, this.lastButtonDisabled = false, this.areListenersSetup = false, this.allowFocusInnerElement = false;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.focusService = e.focusService, this.ariaAnnouncementService = e.ariaAnnouncementService;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [Fm]);
    const { btFirst: t, btPrevious: i, btNext: s, btLast: o } = this;
    this.activateTabIndex([t, i, s, o]), t.insertAdjacentElement("afterbegin", De(e ? "last" : "first", this.gos)), i.insertAdjacentElement("afterbegin", De(e ? "next" : "previous", this.gos)), s.insertAdjacentElement("afterbegin", De(e ? "previous" : "next", this.gos)), o.insertAdjacentElement("afterbegin", De(e ? "first" : "last", this.gos)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"], () => this.onPageSizeRelatedOptionsChange()), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.initialiseTabGuard({ onTabKeyDown: () => {
    }, focusInnerElement: (r) => {
      this.allowFocusInnerElement ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(r) : this.focusService.focusGridInnerElement(r);
    }, forceFocusOutWhenTabGuardsAreEmpty: true }), this.onPaginationChanged();
  }
  setAllowFocus(e) {
    this.allowFocusInnerElement = e;
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) }), [{ el: this.btFirst, fn: this.onBtFirst.bind(this) }, { el: this.btPrevious, fn: this.onBtPrevious.bind(this) }, { el: this.btNext, fn: this.onBtNext.bind(this) }, { el: this.btLast, fn: this.onBtLast.bind(this) }].forEach((e) => {
      const { el: t, fn: i } = e;
      this.addManagedListeners(t, { click: i, keydown: (s) => {
        (s.key === y.ENTER || s.key === y.SPACE) && (s.preventDefault(), i());
      } });
    }), ym(this, this.getGui(), this.focusService), this.areListenersSetup = true);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToFirstPage();
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    if (t) return t({ value: e });
    const i = this.localeService.getLocaleTextFunc(), s = i("thousandSeparator", ","), o = i("decimalSeparator", ".");
    return hu(e, s, o);
  }
  getTemplate() {
    const e = this.localeService.getLocaleTextFunc(), t = e("page", "Page"), i = e("to", "to"), s = e("of", "of"), o = e("firstPage", "First Page"), r = e("previousPage", "Previous Page"), n = e("nextPage", "Next Page"), l = e("lastPage", "Last Page"), a = this.getCompId();
    return `<div class="ag-paging-panel ag-unselectable" id="ag-${a}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel">
                    <span id="ag-${a}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${a}-to">${i}</span>
                    <span id="ag-${a}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${a}-of">${s}</span>
                    <span id="ag-${a}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${r}"></div>
                    <span class="ag-paging-description">
                        <span id="ag-${a}-start-page">${t}</span>
                        <span id="ag-${a}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${a}-of-page">${s}</span>
                        <span id="ag-${a}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${n}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${l}"></div>
                </span>
            </div>`;
  }
  onBtNext() {
    this.nextButtonDisabled || this.paginationService.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.paginationService.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.paginationService.getCurrentPage(), t = this.rowModel.isLastRowIndexKnown(), i = this.paginationService.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const s = this.isZeroPagesToDisplay(), o = e === i - 1;
    this.nextButtonDisabled = o || s, this.lastButtonDisabled = !t || s || e === i - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    Ea(e, t), e.classList.toggle("ag-disabled", t);
  }
  isZeroPagesToDisplay() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages();
    return e && t === 0;
  }
  updateLabels() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages(), i = this.paginationService.getMasterRowCount(), s = e ? i : null;
    if (s === 1) {
      const w = this.rowModel.getRow(0);
      if (w && w.group && !(w.groupData || w.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    const o = this.paginationService.getCurrentPage(), r = this.paginationService.getPageSize();
    let n, l;
    this.isZeroPagesToDisplay() ? n = l = 0 : (n = r * o + 1, l = n + r - 1, e && l > s && (l = s));
    const a = n + r - 1, c = !e && i < a, u = this.formatNumber(n);
    this.lbFirstRowOnPage.textContent = u;
    let d;
    const h = this.localeService.getLocaleTextFunc();
    c ? d = h("pageLastRowUnknown", "?") : d = this.formatNumber(l), this.lbLastRowOnPage.textContent = d;
    const m = t > 0 ? o + 1 : 0, C = this.formatNumber(m);
    this.lbCurrent.textContent = C;
    let f, v;
    if (e) f = this.formatNumber(t), v = this.formatNumber(s);
    else {
      const w = h("more", "more");
      f = w, v = w;
    }
    this.lbTotal.textContent = f, this.lbRecordCount.textContent = v, this.announceAriaStatus(u, d, v, C, f);
  }
  announceAriaStatus(e, t, i, s, o) {
    const r = this.localeService.getLocaleTextFunc(), n = r("page", "Page"), l = r("to", "to"), a = r("of", "of"), c = `${e} ${l} ${t} ${a} ${i}`, u = `${n} ${s} ${a} ${o}`;
    c !== this.ariaRowStatus && (this.ariaRowStatus = c, this.ariaAnnouncementService.announceValue(c, "paginationRow")), u !== this.ariaPageStatus && (this.ariaPageStatus = u, this.ariaAnnouncementService.announceValue(u, "paginationPage"));
  }
  setTotalLabelsToZero() {
    const e = this.formatNumber(0);
    this.lbFirstRowOnPage.textContent = e, this.lbCurrent.textContent = e, this.lbLastRowOnPage.textContent = e, this.lbTotal.textContent = e, this.lbRecordCount.textContent = e, this.announceAriaStatus(e, e, e, e, e);
  }
}, Pm = { selector: "AG-PAGINATION", component: bm }, Em = class extends R {
  constructor() {
    super(...arguments), this.beanName = "paginationService", this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.masterRowCount = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.active = this.gos.get("pagination"), this.pageSizeFromGridOptions = this.gos.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return Pm;
  }
  isPaginateChildRows() {
    return this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren") ? true : this.gos.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages(), this.dispatchPaginationChangedEvent({ keepRenderedRows: true });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    !this.active || this.currentPage === e || typeof this.currentPage != "number" || (this.currentPage = e, this.calculatePages(), this.dispatchPaginationChangedEvent({ newPage: true }));
  }
  isRowPresent(e) {
    return e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex;
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active) return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : true;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return E(this.pageSizeAutoCalculated) && this.gos.get("paginationAutoPageSize") ? this.pageSizeAutoCalculated : E(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : E(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : E(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.pageBoundsService.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0) return;
    const e = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0, this.pageSize !== e && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: true }));
  }
  setPageSize(e, t) {
    const i = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    i !== this.pageSize && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: true, keepRenderedRows: true }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
    const t = this.pageSize * this.currentPage;
    let i = this.pageSize * (this.currentPage + 1) - 1;
    if (i > e && (i = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), i === e) this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    else {
      const s = this.rowModel.getTopLevelRowDisplayedIndex(i + 1);
      this.bottomDisplayedRowIndex = s - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(e) {
    const { keepRenderedRows: t = false, newPage: i = false, newPageSize: s = false } = e;
    this.eventService.dispatchEvent({ type: "paginationChanged", animate: false, newData: false, newPage: i, newPageSize: s, keepRenderedRows: t });
  }
}, al = { version: G, moduleName: "@ag-grid-community/pagination-core", beans: [Em, wm] }, Dm = { version: G, moduleName: "@ag-grid-community/pagination-api", dependantModules: [al], apiFunctions: { paginationIsLastPageFound: um, paginationGetPageSize: dm, paginationGetCurrentPage: hm, paginationGetTotalPages: gm, paginationGetRowCount: pm, paginationGoToNextPage: fm, paginationGoToPreviousPage: mm, paginationGoToFirstPage: Cm, paginationGoToLastPage: vm, paginationGoToPage: Sm } }, Mm = { version: G, moduleName: "@ag-grid-community/pagination", dependantModules: [al, Dm] }, ye = "clientSide", ve = "serverSide", Gt = "infinite", xm = { onGroupExpandedOrCollapsed: [ye], refreshClientSideRowModel: [ye], isRowDataEmpty: [ye], forEachLeafNode: [ye], forEachNodeAfterFilter: [ye], forEachNodeAfterFilterAndSort: [ye], resetRowHeights: [ye], applyTransaction: [ye], applyTransactionAsync: [ye], flushAsyncTransactions: [ye], getBestCostNodeSelection: [ye], getServerSideSelectionState: [ve], setServerSideSelectionState: [ve], applyServerSideTransaction: [ve], applyServerSideTransactionAsync: [ve], applyServerSideRowData: [ve], retryServerSideLoads: [ve], flushServerSideAsyncTransactions: [ve], refreshServerSide: [ve], getServerSideGroupLevelState: [ve], refreshInfiniteCache: [Gt], purgeInfiniteCache: [Gt], getInfiniteRowCount: [Gt], isLastRowIndexKnown: [Gt, ve], expandAll: [ye, ve], collapseAll: [ye, ve], onRowHeightChanged: [ye, ve], setRowCount: [Gt, ve], getCacheBlockState: [Gt, ve] }, Am = { getValue: { version: "v31.3", new: "getCellValue" }, getFirstDisplayedRow: { version: "v31.1", new: "getFirstDisplayedRowIndex" }, getLastDisplayedRow: { version: "v31.1", new: "getLastDisplayedRowIndex" }, getModel: { version: "v31.1", message: "Please use the appropriate grid API methods instead." }, setColumnVisible: { version: "v31.1", old: "setColumnVisible(key,visible)", new: "setColumnsVisible([key],visible)" }, setColumnPinned: { version: "v31.1", old: "setColumnPinned(key,pinned)", new: "setColumnsPinned([key],pinned)" }, moveColumn: { version: "v31.1", old: "moveColumn(key, toIndex)", new: "moveColumns([key], toIndex)" }, setColumnWidth: { version: "v31.1", old: "setColumnWidth(col, width)", new: "setColumnWidths([{key: col, newWidth: width}])" }, autoSizeColumn: { version: "v31.1", old: "autoSizeColumn(key, skipHeader)", new: "autoSizeColumns([key], skipHeader)" }, addAggFunc: { version: "v31.1", old: "addAggFunc(key, func)", new: "addAggFuncs({ key: func })" }, removeValueColumn: { version: "v31.1", old: "removeValueColumn(colKey)", new: "removeValueColumns([colKey])" }, addValueColumn: { version: "v31.1", old: "addValueColumn(colKey)", new: "addValueColumns([colKey])" }, removeRowGroupColumn: { version: "v31.1", old: "removeRowGroupColumn(colKey)", new: "removeRowGroupColumns([colKey])" }, addRowGroupColumn: { version: "v31.1", old: "addRowGroupColumn(colKey)", new: "addRowGroupColumns([colKey])" }, removePivotColumn: { version: "v31.1", old: "removePivotColumn(colKey)", new: "removePivotColumns([colKey])" }, addPivotColumn: { version: "v31.1", old: "addPivotColumn(colKey)", new: "addPivotColumns([colKey])" }, showColumnMenuAfterButtonClick: { version: "v31.1", message: "Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere." }, showColumnMenuAfterMouseClick: { version: "v31.1", message: "Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere." }, getFilterInstance: { version: "v31.1", message: "'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously." }, showLoadingOverlay: { version: "v32", message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).' }, clearRangeSelection: { version: "v32.2", message: "Use `clearCellSelection` instead." }, getInfiniteRowCount: { version: "v32.2", old: "getInfiniteRowCount()", new: "getDisplayedRowCount()" } };
function Tm(e, t, i) {
  const s = Am[e];
  if (s) {
    const { version: r, new: n, old: l, message: a } = s, c = l ?? e;
    return (...u) => {
      const d = n ? `Please use ${n} instead. ` : "";
      return F(`Since ${r} api.${c} is deprecated. ${d}${a ?? ""}`), t.apply(t, u);
    };
  }
  const o = xm[e];
  return o ? (...r) => {
    const n = i.rowModel.getType();
    if (!o.includes(n)) {
      z(`api.${e} can only be called when gridOptions.rowModelType is ${o.join(" or ")}`);
      return;
    }
    return t.apply(t, r);
  } : t;
}
var Im = { columnsMenuParams: { version: "31.1", message: "Use `columnChooserParams` instead." }, suppressMenu: { version: "31.1", message: "Use `suppressHeaderMenuButton` instead." }, suppressCellFlash: { version: "31.2", message: "Use `enableCellChangeFlash={false}` in the ColDef" }, checkboxSelection: { version: "32.2", message: "Use `rowSelection.checkboxes` in `GridOptions` instead." }, headerCheckboxSelection: { version: "32.2", message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead." }, headerCheckboxSelectionFilteredOnly: { version: "32.2", message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.' }, headerCheckboxSelectionCurrentPageOnly: { version: "32.2", message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.' }, showDisabledCheckboxes: { version: "32.2", message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead." } }, rt = (e, t) => {
  const i = t.rowModelType ?? "clientSide";
  return i === "clientSide" || i === "serverSide" ? { module: "@ag-grid-enterprise/row-grouping" } : null;
}, Lm = { enableRowGroup: rt, rowGroup: rt, rowGroupIndex: rt, enablePivot: rt, enableValue: rt, pivot: rt, pivotIndex: rt, aggFunc: rt, cellEditor: (e) => e.cellEditor === "agRichSelect" || e.cellEditor === "agRichSelectCellEditor" ? { module: "@ag-grid-enterprise/rich-select" } : null, menuTabs: (e) => {
  var _a3;
  const t = ["columnsMenuTab", "generalMenuTab"];
  return ((_a3 = e.menuTabs) == null ? void 0 : _a3.some((i) => t.includes(i))) ? { module: "@ag-grid-enterprise/menu" } : null;
}, columnsMenuParams: { module: ["@ag-grid-enterprise/menu", "@ag-grid-enterprise/column-tool-panel"] }, columnChooserParams: { module: ["@ag-grid-enterprise/menu", "@ag-grid-enterprise/column-tool-panel"] }, headerCheckboxSelection: { supportedRowModels: ["clientSide", "serverSide"], validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple" }, headerCheckboxSelectionFilteredOnly: { supportedRowModels: ["clientSide"], validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple" }, headerCheckboxSelectionCurrentPageOnly: { supportedRowModels: ["clientSide"], validate: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple" }, children: () => kt }, Om = { headerName: void 0, columnGroupShow: void 0, headerClass: void 0, toolPanelClass: void 0, headerValueGetter: void 0, pivotKeys: void 0, groupId: void 0, colId: void 0, sort: void 0, initialSort: void 0, field: void 0, type: void 0, cellDataType: void 0, tooltipComponent: void 0, tooltipField: void 0, headerTooltip: void 0, cellClass: void 0, showRowGroup: void 0, filter: void 0, initialAggFunc: void 0, defaultAggFunc: void 0, aggFunc: void 0, pinned: void 0, initialPinned: void 0, chartDataType: void 0, cellAriaRole: void 0, cellEditorPopupPosition: void 0, headerGroupComponent: void 0, headerGroupComponentParams: void 0, cellStyle: void 0, cellRenderer: void 0, cellRendererParams: void 0, cellEditor: void 0, cellEditorParams: void 0, filterParams: void 0, pivotValueColumn: void 0, headerComponent: void 0, headerComponentParams: void 0, floatingFilterComponent: void 0, floatingFilterComponentParams: void 0, tooltipComponentParams: void 0, refData: void 0, columnsMenuParams: void 0, columnChooserParams: void 0, children: void 0, sortingOrder: void 0, allowedAggFuncs: void 0, menuTabs: void 0, pivotTotalColumnIds: void 0, cellClassRules: void 0, icons: void 0, sortIndex: void 0, initialSortIndex: void 0, flex: void 0, initialFlex: void 0, width: void 0, initialWidth: void 0, minWidth: void 0, maxWidth: void 0, rowGroupIndex: void 0, initialRowGroupIndex: void 0, pivotIndex: void 0, initialPivotIndex: void 0, suppressCellFlash: void 0, suppressColumnsToolPanel: void 0, suppressFiltersToolPanel: void 0, openByDefault: void 0, marryChildren: void 0, suppressStickyLabel: void 0, hide: void 0, initialHide: void 0, rowGroup: void 0, initialRowGroup: void 0, pivot: void 0, initialPivot: void 0, checkboxSelection: void 0, showDisabledCheckboxes: void 0, headerCheckboxSelection: void 0, headerCheckboxSelectionFilteredOnly: void 0, headerCheckboxSelectionCurrentPageOnly: void 0, suppressMenu: void 0, suppressHeaderMenuButton: void 0, suppressMovable: void 0, lockPosition: void 0, lockVisible: void 0, lockPinned: void 0, unSortIcon: void 0, suppressSizeToFit: void 0, suppressAutoSize: void 0, enableRowGroup: void 0, enablePivot: void 0, enableValue: void 0, editable: void 0, suppressPaste: void 0, suppressNavigable: void 0, enableCellChangeFlash: void 0, rowDrag: void 0, dndSource: void 0, autoHeight: void 0, wrapText: void 0, sortable: void 0, resizable: void 0, singleClickEdit: void 0, floatingFilter: void 0, cellEditorPopup: void 0, suppressFillHandle: void 0, wrapHeaderText: void 0, autoHeaderHeight: void 0, dndSourceOnRowDrag: void 0, valueGetter: void 0, valueSetter: void 0, filterValueGetter: void 0, keyCreator: void 0, valueFormatter: void 0, valueParser: void 0, comparator: void 0, equals: void 0, pivotComparator: void 0, suppressKeyboardEvent: void 0, suppressHeaderKeyboardEvent: void 0, colSpan: void 0, rowSpan: void 0, getQuickFilterText: void 0, onCellValueChanged: void 0, onCellClicked: void 0, onCellDoubleClicked: void 0, onCellContextMenu: void 0, rowDragText: void 0, tooltipValueGetter: void 0, cellRendererSelector: void 0, cellEditorSelector: void 0, suppressSpanHeaderHeight: void 0, useValueFormatterForExport: void 0, useValueParserForImport: void 0, mainMenuItems: void 0, contextMenuItems: void 0, suppressFloatingFilterButton: void 0, suppressHeaderFilterButton: void 0, suppressHeaderContextMenu: void 0, loadingCellRenderer: void 0, loadingCellRendererParams: void 0, loadingCellRendererSelector: void 0, context: void 0 }, Gm = Object.keys(Om), kt = { objectName: "colDef", allProperties: Gm, docsUrl: "column-properties/", deprecations: Im, validations: Lm }, km = () => ({ advancedFilterModel: { version: "31", message: "Use `initialState.filter.advancedFilterModel` instead." }, suppressAsyncEvents: { version: "31", message: "Events should be handled asynchronously." }, cellFadeDelay: { version: "31.1", renamed: "cellFadeDuration" }, cellFlashDelay: { version: "31.1", renamed: "cellFlashDuration" }, suppressServerSideInfiniteScroll: { version: "31.1" }, serverSideSortOnServer: { version: "31.1" }, serverSideFilterOnServer: { version: "31.1" }, enableCellChangeFlash: { version: "31.2", message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns." }, groupIncludeFooter: { version: "31.3", message: "Use `groupTotalRow` instead." }, groupIncludeTotalFooter: { version: "31.3", message: "Use `grandTotalRow` instead." }, suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." }, enableFillHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." }, enableRangeHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." }, enableRangeSelection: { version: "32.2", message: "Use `cellSelection = true` instead." }, suppressMultiRangeSelection: { version: "32.2", message: "Use `cellSelection.suppressMultiRanges` instead." }, suppressClearOnFillReduction: { version: "32.2", message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead." }, fillHandleDirection: { version: "32.2", message: "Use `cellSelection.handle.direction` instead." }, fillOperation: { version: "32.2", message: "Use `cellSelection.handle.setFillValue` instead." }, suppressRowClickSelection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." }, suppressRowDeselection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." }, rowMultiSelectWithClick: { version: "32.2", message: "Use `rowSelection.enableSelectionWithoutKeys` instead." }, groupSelectsChildren: { version: "32.2", message: 'Use `rowSelection.groupSelects = "descendants"` instead.' }, groupSelectsFiltered: { version: "32.2", message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.' }, isRowSelectable: { version: "32.2", message: "Use `selectionOptions.isRowSelectable` instead." }, suppressCopySingleCellRanges: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." }, suppressCopyRowsToClipboard: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." }, onRangeSelectionChanged: { version: "32.2", message: "Use `onCellSelectionChanged` instead." }, onRangeDeleteStart: { version: "32.2", message: "Use `onCellSelectionDeleteStart` instead." }, onRangeDeleteEnd: { version: "32.2", message: "Use `onCellSelectionDeleteEnd` instead." }, suppressBrowserResizeObserver: { version: "32.2", message: "The grid always uses the browser's ResizeObserver, this grid option has no effect." }, onColumnEverythingChanged: { version: "32.2", message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events." } }), Hm = { suppressContextMenu: false, preventDefaultOnContextMenu: false, allowContextMenuWithControlKey: false, suppressMenuHide: true, enableBrowserTooltips: false, tooltipTrigger: "hover", tooltipShowDelay: 2e3, tooltipHideDelay: 1e4, tooltipMouseTrack: false, tooltipShowMode: "standard", tooltipInteraction: false, copyHeadersToClipboard: false, copyGroupHeadersToClipboard: false, clipboardDelimiter: "	", suppressCopyRowsToClipboard: false, suppressCopySingleCellRanges: false, suppressLastEmptyLineOnPaste: false, suppressClipboardPaste: false, suppressClipboardApi: false, suppressCutToClipboard: false, maintainColumnOrder: false, enableStrictPivotColumnOrder: false, suppressFieldDotNotation: false, allowDragFromColumnsToolPanel: false, suppressMovableColumns: false, suppressColumnMoveAnimation: false, suppressMoveWhenColumnDragging: false, suppressDragLeaveHidesColumns: false, suppressRowGroupHidesColumns: false, suppressAutoSize: false, autoSizePadding: 20, skipHeaderOnAutoSize: false, singleClickEdit: false, suppressClickEdit: false, readOnlyEdit: false, stopEditingWhenCellsLoseFocus: false, enterNavigatesVertically: false, enterNavigatesVerticallyAfterEdit: false, enableCellEditingOnBackspace: false, undoRedoCellEditing: false, undoRedoCellEditingLimit: 10, suppressCsvExport: false, suppressExcelExport: false, cacheQuickFilter: false, includeHiddenColumnsInQuickFilter: false, excludeChildrenWhenTreeDataFiltering: false, enableAdvancedFilter: false, includeHiddenColumnsInAdvancedFilter: false, enableCharts: false, masterDetail: false, keepDetailRows: false, keepDetailRowsCount: 10, detailRowAutoHeight: false, tabIndex: 0, rowBuffer: 10, valueCache: false, valueCacheNeverExpires: false, enableCellExpressions: false, suppressTouch: false, suppressFocusAfterRefresh: false, suppressAsyncEvents: false, suppressBrowserResizeObserver: false, suppressPropertyNamesCheck: false, suppressChangeDetection: false, debug: false, suppressLoadingOverlay: false, suppressNoRowsOverlay: false, pagination: false, paginationPageSize: 100, paginationPageSizeSelector: true, paginationAutoPageSize: false, paginateChildRows: false, suppressPaginationPanel: false, pivotMode: false, pivotPanelShow: "never", pivotDefaultExpanded: 0, pivotSuppressAutoColumn: false, suppressExpandablePivotGroups: false, functionsReadOnly: false, suppressAggFuncInHeader: false, alwaysAggregateAtRootLevel: false, aggregateOnlyChangedColumns: false, suppressAggFilteredOnly: false, removePivotHeaderRowWhenSingleValueColumn: false, animateRows: true, enableCellChangeFlash: false, cellFlashDelay: 500, cellFlashDuration: 500, cellFadeDelay: 1e3, cellFadeDuration: 1e3, allowShowChangeAfterFilter: false, domLayout: "normal", ensureDomOrder: false, enableRtl: false, suppressColumnVirtualisation: false, suppressMaxRenderedRowRestriction: false, suppressRowVirtualisation: false, rowDragManaged: false, suppressRowDrag: false, suppressMoveWhenRowDragging: false, rowDragEntireRow: false, rowDragMultiRow: false, embedFullWidthRows: false, groupDisplayType: "singleColumn", groupDefaultExpanded: 0, groupMaintainOrder: false, groupSelectsChildren: false, groupIncludeTotalFooter: false, groupSuppressBlankHeader: false, groupSelectsFiltered: false, showOpenedGroup: false, groupRemoveSingleChildren: false, groupRemoveLowestSingleChildren: false, groupHideOpenParents: false, groupAllowUnbalanced: false, rowGroupPanelShow: "never", suppressMakeColumnVisibleAfterUnGroup: false, treeData: false, rowGroupPanelSuppressSort: false, suppressGroupRowsSticky: false, rowModelType: "clientSide", asyncTransactionWaitMillis: 50, suppressModelUpdateAfterUpdateTransaction: false, cacheOverflowSize: 1, infiniteInitialRowCount: 1, serverSideInitialRowCount: 1, suppressServerSideInfiniteScroll: false, cacheBlockSize: 100, maxBlocksInCache: -1, maxConcurrentDatasourceRequests: 2, blockLoadDebounceMillis: 0, purgeClosedRowNodes: false, serverSideSortAllLevels: false, serverSideOnlyRefreshFilteredGroups: false, serverSideSortOnServer: false, serverSideFilterOnServer: false, serverSidePivotResultFieldSeparator: "_", viewportRowModelPageSize: 5, viewportRowModelBufferSize: 5, alwaysShowHorizontalScroll: false, alwaysShowVerticalScroll: false, debounceVerticalScrollbar: false, suppressHorizontalScroll: false, suppressScrollOnNewData: false, suppressScrollWhenPopupsAreOpen: false, suppressAnimationFrame: false, suppressMiddleClickScrolls: false, suppressPreventDefaultOnMouseWheel: false, rowMultiSelectWithClick: false, suppressRowDeselection: false, suppressRowClickSelection: false, suppressCellFocus: false, suppressHeaderFocus: false, suppressMultiRangeSelection: false, enableCellTextSelection: false, enableRangeSelection: false, enableRangeHandle: false, enableFillHandle: false, fillHandleDirection: "xy", suppressClearOnFillReduction: false, accentedSort: false, unSortIcon: false, suppressMultiSort: false, alwaysMultiSort: false, suppressMaintainUnsortedOrder: false, suppressRowHoverHighlight: false, suppressRowTransform: false, columnHoverHighlight: false, deltaSort: false, enableGroupEdit: false, suppressGroupMaintainValueType: false, groupLockGroupColumns: 0, serverSideEnableClientSideSort: false, suppressServerSideFullWidthLoadingRow: false, pivotMaxGeneratedColumns: -1, columnMenu: "new", reactiveCustomComponents: true, suppressSetFilterByDefault: false }, Nm = () => ({ sideBar: { module: "@ag-grid-enterprise/side-bar" }, statusBar: { module: "@ag-grid-enterprise/status-bar" }, enableCharts: { module: "@ag-grid-enterprise/charts" }, getMainMenuItems: { module: "@ag-grid-enterprise/menu" }, getContextMenuItems: { module: "@ag-grid-enterprise/menu" }, allowContextMenuWithControlKey: { module: "@ag-grid-enterprise/menu" }, enableAdvancedFilter: { module: "@ag-grid-enterprise/advanced-filter" }, treeData: { supportedRowModels: ["clientSide", "serverSide"], module: "@ag-grid-enterprise/row-grouping", validate: (e) => {
  const t = e.rowModelType ?? "clientSide";
  switch (t) {
    case "clientSide": {
      const i = `treeData requires 'getDataPath' in the ${t} row model.`;
      return e.getDataPath ? null : i;
    }
    case "serverSide": {
      const i = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${t} row model.`;
      return e.isServerSideGroup && e.getServerSideGroupKey ? null : i;
    }
  }
  return null;
} }, masterDetail: { module: "@ag-grid-enterprise/master-detail" }, enableRangeSelection: { module: "@ag-grid-enterprise/range-selection" }, enableRangeHandle: { dependencies: { enableRangeSelection: [true] } }, enableFillHandle: { dependencies: { enableRangeSelection: [true] } }, groupDefaultExpanded: { supportedRowModels: ["clientSide"] }, groupIncludeFooter: { supportedRowModels: ["clientSide", "serverSide"], validate: (e) => {
  switch (e.rowModelType ?? "clientSide") {
    case "clientSide":
      return null;
    case "serverSide":
      return e.suppressServerSideInfiniteScroll ? "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll" : null;
  }
  return null;
} }, groupHideOpenParents: { supportedRowModels: ["clientSide", "serverSide"], dependencies: { groupTotalRow: [void 0, "bottom"] } }, groupIncludeTotalFooter: { supportedRowModels: ["clientSide"] }, groupRemoveSingleChildren: { dependencies: { groupHideOpenParents: [void 0, false], groupRemoveLowestSingleChildren: [void 0, false] } }, groupRemoveLowestSingleChildren: { dependencies: { groupHideOpenParents: [void 0, false], groupRemoveSingleChildren: [void 0, false] } }, groupSelectsChildren: { dependencies: { rowSelection: ["multiple"] } }, viewportDatasource: { supportedRowModels: ["viewport"], module: "@ag-grid-enterprise/viewport-row-model" }, serverSideDatasource: { supportedRowModels: ["serverSide"], module: "@ag-grid-enterprise/server-side-row-model" }, cacheBlockSize: { supportedRowModels: ["serverSide", "infinite"] }, datasource: { supportedRowModels: ["infinite"], module: "@ag-grid-community/infinite-row-model" }, rowData: { supportedRowModels: ["clientSide"], module: "@ag-grid-community/client-side-row-model" }, paginationPageSizeSelector: { validate: (e) => {
  const t = e.paginationPageSizeSelector;
  return typeof t == "boolean" || t == null || t.length ? null : `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
} }, rowSelection: { validate({ rowSelection: e }) {
  return e && typeof e == "string" ? 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.' : e && typeof e != "object" ? "Expected `RowSelectionOptions` object for the `rowSelection` property." : null;
} }, cellSelection: { module: "@ag-grid-enterprise/range-selection" }, columnDefs: () => kt, defaultColDef: () => kt, defaultColGroupDef: () => kt, autoGroupColumnDef: () => kt, selectionColumnDef: () => kt }), Vm = () => ({ objectName: "gridOptions", allProperties: [...hi.ALL_PROPERTIES, ...gi.EVENT_CALLBACKS], propertyExceptions: ["api"], docsUrl: "grid-options/", deprecations: km(), validations: Nm() }), Bm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "validationService";
  }
  wireBeans(e) {
    this.beans = e, this.gridOptions = e.gridOptions;
  }
  postConstruct() {
    this.processGridOptions(this.gridOptions);
  }
  processGridOptions(e) {
    this.processOptions(e, Vm());
  }
  validateApiFunction(e, t) {
    return Tm(e, t, this.beans);
  }
  processOptions(e, t) {
    const { validations: i, deprecations: s, allProperties: o, propertyExceptions: r, objectName: n, docsUrl: l } = t;
    o && this.gridOptions.suppressPropertyNamesCheck !== true && this.checkProperties(e, [...r ?? [], ...Object.keys(s)], o, n, l);
    const a = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((u) => {
      const d = s[u];
      if (d) if ("renamed" in d) {
        const { renamed: S, version: b } = d;
        a.add(`As of v${b}, ${String(u)} is deprecated. Please use ${String(S)} instead.`), e[S] = e[u];
      } else {
        const { message: S, version: b } = d;
        a.add(`As of v${b}, ${String(u)} is deprecated. ${S ?? ""}`);
      }
      const h = e[u];
      if (h == null || h === false) return;
      const g = i[u];
      let m;
      if (g) if (typeof g == "function") {
        const S = g(e, this.gridOptions);
        if (!S) return;
        if ("objectName" in S) {
          const b = e[u];
          if (Array.isArray(b)) {
            b.forEach((x) => {
              this.processOptions(x, S);
            });
            return;
          }
          this.processOptions(e[u], S);
          return;
        }
        m = S;
      } else m = g;
      else return;
      const { module: C, dependencies: f, validate: v, supportedRowModels: w } = m;
      if (w) {
        const S = this.gridOptions.rowModelType ?? "clientSide";
        if (!w.includes(S)) {
          a.add(`${String(u)} is not supported with the '${S}' row model.`);
          return;
        }
      }
      if (C) {
        const S = Array.isArray(C) ? C : [C];
        let b = true;
        if (S.forEach((x) => {
          this.gos.assertModuleRegistered(x, String(u)) || (b = false, a.add(`${String(u)} is only available when ${x} is loaded.`));
        }), !b) return;
      }
      if (f) {
        const S = this.checkForRequiredDependencies(u, f, e);
        if (S) {
          a.add(S);
          return;
        }
      }
      if (v) {
        const S = v(e, this.gridOptions);
        if (S) {
          a.add(S);
          return;
        }
      }
    }), a.size > 0 && a.forEach((u) => {
      F(u);
    });
  }
  checkForRequiredDependencies(e, t, i) {
    const o = Object.entries(t).find(([l, a]) => {
      const c = i[l];
      return !a.includes(c);
    });
    if (!o) return null;
    const [r, n] = o;
    return n.length > 1 ? `'${String(e)}' requires '${r}' to be one of [${n.join(", ")}].` : `'${String(e)}' requires '${r}' to be ${n[0]}.`;
  }
  checkProperties(e, t, i, s, o) {
    const r = ["__ob__", "__v_skip", "__metadata__"], n = Wm(Object.getOwnPropertyNames(e), [...r, ...t, ...i], i);
    if (He(n, (l, a) => {
      let c = `invalid ${s} property '${l}' did you mean any of these: ${a.slice(0, 8).join(", ")}.`;
      i.includes("context") && (c += `
If you are trying to annotate ${s} with application data, use the '${s}.context' property instead.`), F(c);
    }), Object.keys(n).length > 0 && o) {
      const l = this.getFrameworkOverrides().getDocLink(o);
      F(`to see all the valid ${s} properties please check: ${l}`);
    }
  }
};
function Wm(e, t, i) {
  const s = {}, o = e.filter((r) => !t.some((n) => n === r));
  return o.length > 0 && o.forEach((r) => s[r] = cn({ inputValue: r, allSuggestions: i }).values), s;
}
var zm = { version: G, moduleName: "@ag-grid-community/core" }, _m = { version: G, moduleName: "@ag-grid-community/core-validations", beans: [Bm] }, Um = { version: G, moduleName: "@ag-grid-community/core-community-features", dependantModules: [zm, _m, sg, Qu, cm, Op, _g, Mm, im] }, Km = class extends R {
  constructor() {
    super(...arguments), this.beanName = "gridDestroyService", this.destroyCalled = false;
  }
  wireBeans(e) {
    this.beans = e;
  }
  destroy() {
    var _a3, _b;
    this.destroyCalled || (this.eventService.dispatchEvent({ type: "gridPreDestroyed", state: ((_a3 = this.beans.stateService) == null ? void 0 : _a3.getState()) ?? {} }), this.destroyCalled = true, (_b = this.beans.ctrlsService.get("gridCtrl")) == null ? void 0 : _b.destroyGridUi(), this.beans.context.destroy(), super.destroy());
  }
  isDestroyCalled() {
    return this.destroyCalled;
  }
}, Hi = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), $m = (e) => e === "checkboxSelected" || e === "rowClicked" || e === "spaceKey" || e === "uiSelectAll" || e === "uiSelectAllCurrentPage" || e === "uiSelectAllFiltered", jm = new Map([...hi.BOOLEAN_PROPERTIES.map((e) => [e, Ts]), ...hi.NUMBER_PROPERTIES.map((e) => [e, Dn]), ["groupAggFiltering", (e) => typeof e == "function" ? e : Ts(e)], ["pageSize", ze(1)], ["autoSizePadding", ze(0)], ["keepDetailRowsCount", ze(1)], ["rowBuffer", ze(0)], ["infiniteInitialRowCount", ze(1)], ["cacheOverflowSize", ze(1)], ["cacheBlockSize", ze(1)], ["serverSideInitialRowCount", ze(1)], ["viewportRowModelPageSize", ze(1)], ["viewportRowModelBufferSize", ze(0)]]);
function cl(e, t) {
  const i = jm.get(e);
  return i ? i(t) : t;
}
function qm(e) {
  const t = {};
  return Object.entries(e).forEach(([i, s]) => {
    const o = cl(i, s);
    t[i] = o;
  }), t;
}
var ul = class dl extends R {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new Ut(), this.globalEventHandlerFactory = (t) => (i, s) => {
      if (!this.isAlive()) return;
      const o = Hi.has(i);
      if (o && !t || !o && t) return;
      const r = gi.getCallbackForEvent(i), n = this.gridOptions[r];
      typeof n == "function" && this.frameworkOverrides.wrapOutgoing(() => {
        n(s);
      });
    };
  }
  wireBeans(t) {
    this.gridOptions = t.gridOptions, this.eGridDiv = t.eGridDiv, this.validationService = t.validationService, this.environment = t.environment, this.api = t.gridApi, this.gridId = t.context.getGridId();
  }
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    const t = !this.get("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), t), this.eventService.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false), this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides), this.addManagedEventListeners({ gridOptionsChanged: ({ options: i }) => {
      this.updateGridOptions({ options: i, force: true, source: "gridOptionsUpdated" });
    } });
  }
  get(t) {
    return this.gridOptions[t] ?? Hm[t];
  }
  getCallback(t) {
    return this.mergeGridCommonParams(this.gridOptions[t]);
  }
  exists(t) {
    return E(this.gridOptions[t]);
  }
  mergeGridCommonParams(t) {
    return t && ((s) => {
      const o = s;
      return o.api = this.api, o.context = this.gridOptionsContext, t(o);
    });
  }
  updateGridOptions({ options: t, force: i, source: s = "api" }) {
    var _a3;
    const o = { id: dl.changeSetId++, properties: [] }, r = [];
    Object.entries(t).forEach(([n, l]) => {
      s === "api" && Sa[n] && F(`${n} is an initial property and cannot be updated.`);
      const a = cl(n, l), c = i || typeof a == "object" && s === "api", u = this.gridOptions[n];
      if (c || u !== a) {
        this.gridOptions[n] = a;
        const d = { type: n, currentValue: a, previousValue: u, changeSet: o, source: s };
        r.push(d);
      }
    }), (_a3 = this.validationService) == null ? void 0 : _a3.processGridOptions(this.gridOptions), o.properties = r.map((n) => n.type), r.forEach((n) => {
      this.gridOptions.debug && at(`Updated property ${n.type} from`, n.previousValue, " to ", n.currentValue), this.propertyEventService.dispatchEvent(n);
    });
  }
  addPropertyEventListener(t, i) {
    this.propertyEventService.addEventListener(t, i);
  }
  removePropertyEventListener(t, i) {
    this.propertyEventService.removeEventListener(t, i);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  getGridCommonParams() {
    return { api: this.api, context: this.gridOptionsContext };
  }
  addGridCommonParams(t) {
    const i = t;
    return i.api = this.api, i.context = this.gridOptionsContext, i;
  }
  assertModuleRegistered(t, i) {
    return Ue.__assertRegistered(t, i, this.gridId);
  }
  isModuleRegistered(t) {
    return Ue.__isRegistered(t, this.gridId);
  }
};
ul.changeSetId = 0;
var Ym = ul, Qm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "headerPositionUtils";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  findHeader(e, t) {
    let i, s;
    if (ae(e.column) ? i = this.visibleColsService.getGroupAtDirection(e.column, t) : (s = `getCol${t}`, i = this.visibleColsService[s](e.column)), !i) return;
    const { headerRowIndex: o } = e;
    if (this.getHeaderRowType(o) !== "filter") {
      const l = [i];
      for (; i.getParent(); ) i = i.getParent(), l.push(i);
      i = l[l.length - 1 - o];
    }
    const { column: r, headerRowIndex: n } = this.getHeaderIndexToFocus(i, o);
    return { column: r, headerRowIndex: n };
  }
  getHeaderIndexToFocus(e, t) {
    let i;
    if (ae(e) && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
      const s = e;
      i = s.getLeafColumns()[0];
      let o = i;
      for (; o !== s; ) t++, o = o.getParent();
    }
    return { column: i || e, headerRowIndex: t };
  }
  isAnyChildSpanningHeaderHeight(e) {
    return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : false;
  }
  getColumnVisibleParent(e, t) {
    const i = this.getHeaderRowType(t), s = i === "filter", o = i === "column";
    let r = s ? e : e.getParent(), n = t - 1, l = n;
    if (o && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
      for (; r && r.isPadding(); ) r = r.getParent(), n--;
      l = n, n < 0 && (r = e, n = t, l = void 0);
    }
    return { column: r, headerRowIndex: n, headerRowIndexWithoutSpan: l };
  }
  getColumnVisibleChild(e, t, i = "After") {
    const s = this.getHeaderRowType(t);
    let o = e, r = t + 1;
    const n = r;
    if (s === "group") {
      const l = e.getDisplayedLeafColumns(), a = i === "After" ? l[0] : N(l), c = [];
      let u = a;
      for (; u.getParent() !== e; ) u = u.getParent(), c.push(u);
      if (o = a, a.isSpanHeaderHeight()) for (let d = c.length - 1; d >= 0; d--) {
        const h = c[d];
        if (!h.isPadding()) {
          o = h;
          break;
        }
        r++;
      }
      else o = N(c), o || (o = a);
    }
    return { column: o, headerRowIndex: r, headerRowIndexWithoutSpan: n };
  }
  getHeaderRowType(e) {
    const t = this.ctrlsService.getHeaderRowContainerCtrl();
    if (t) return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    var _a3;
    const i = this.visibleColsService.getAllCols(), s = i[t === "start" ? 0 : i.length - 1];
    if (!s) return;
    const r = (_a3 = this.ctrlsService.getHeaderRowContainerCtrl(s.getPinned())) == null ? void 0 : _a3.getRowType(e);
    if (r == "group") {
      const n = this.visibleColsService.getColGroupAtLevel(s, e);
      return { headerRowIndex: e, column: n };
    }
    return { headerRowIndex: r == null ? -1 : e, column: s };
  }
}, Xm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "localeService";
  }
  getLocaleTextFunc() {
    const e = this.gos.getCallback("getLocaleText");
    if (e) return (i, s, o) => e({ key: i, defaultValue: s, variableValues: o });
    const t = this.gos.get("localeText");
    return (i, s, o) => {
      let r = t && t[i];
      if (r && o && o.length) {
        let n = 0;
        for (; !(n >= o.length || r.indexOf("${variable}") === -1); ) r = r.replace("${variable}", o[n++]);
      }
      return r ?? s;
    };
  }
}, Jm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "apiEventService", this.syncEventListeners = /* @__PURE__ */ new Map(), this.asyncEventListeners = /* @__PURE__ */ new Map(), this.syncGlobalEventListeners = /* @__PURE__ */ new Set(), this.globalEventListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.frameworkEventWrappingService = new io(this.getFrameworkOverrides());
  }
  addEventListener(e, t) {
    const i = this.frameworkEventWrappingService.wrap(t), s = zi(this.gos) && !Hi.has(e), o = s ? this.asyncEventListeners : this.syncEventListeners;
    o.has(e) || o.set(e, /* @__PURE__ */ new Set()), o.get(e).add(i), this.eventService.addEventListener(e, i, s);
  }
  removeEventListener(e, t) {
    var _a3, _b;
    const i = this.frameworkEventWrappingService.unwrap(t), o = !!((_a3 = this.asyncEventListeners.get(e)) == null ? void 0 : _a3.delete(i));
    o || ((_b = this.syncEventListeners.get(e)) == null ? void 0 : _b.delete(i)), this.eventService.removeEventListener(e, i, o);
  }
  addGlobalListener(e) {
    const t = this.frameworkEventWrappingService.wrapGlobal(e);
    if (zi(this.gos)) {
      const s = (r, n) => {
        Hi.has(r) && t(r, n);
      }, o = (r, n) => {
        Hi.has(r) || t(r, n);
      };
      this.globalEventListenerPairs.set(e, { syncListener: s, asyncListener: o }), this.eventService.addGlobalListener(s, false), this.eventService.addGlobalListener(o, true);
    } else this.syncGlobalEventListeners.add(t), this.eventService.addGlobalListener(t, false);
  }
  removeGlobalListener(e) {
    const t = this.frameworkEventWrappingService.unwrapGlobal(e);
    if (this.globalEventListenerPairs.has(t)) {
      const { syncListener: s, asyncListener: o } = this.globalEventListenerPairs.get(t);
      this.eventService.removeGlobalListener(s, false), this.eventService.removeGlobalListener(o, true), this.globalEventListenerPairs.delete(e);
    } else this.syncGlobalEventListeners.delete(t), this.eventService.removeGlobalListener(t, false);
  }
  destroyEventListeners(e, t) {
    e.forEach((i, s) => {
      i.forEach((o) => this.eventService.removeEventListener(s, o, t)), i.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((i) => this.eventService.removeGlobalListener(i, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncEventListeners, false), this.destroyEventListeners(this.asyncEventListeners, true), this.destroyGlobalListeners(this.syncGlobalEventListeners, false), this.globalEventListenerPairs.forEach(({ syncListener: e, asyncListener: t }) => {
      this.eventService.removeGlobalListener(e, false), this.eventService.removeGlobalListener(t, true);
    }), this.globalEventListenerPairs.clear();
  }
}, Zm = class extends R {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.addManagedEventListeners({ modelUpdated: this.onModelUpdated.bind(this), recalculateRowBounds: this.calculatePages.bind(this) }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages(), this.eventService.dispatchEvent({ type: "paginationChanged", animate: (e == null ? void 0 : e.animate) ?? false, newData: (e == null ? void 0 : e.newData) ?? false, newPage: (e == null ? void 0 : e.newPage) ?? false, newPageSize: (e == null ? void 0 : e.newPageSize) ?? false, keepRenderedRows: (e == null ? void 0 : e.keepRenderedRows) ?? false });
  }
  calculatePages() {
    this.paginationService ? this.paginationService.calculatePages() : this.pageBoundsService.calculateBounds(0, this.rowModel.getRowCount() - 1);
  }
}, eC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsService", this.pixelOffset = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  getFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getCurrentPageHeight() {
    return V(this.topRowBounds) || V(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const e = this.topRowBounds ? this.topRowBounds.rowTop : 0, t = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel: e, pageLastPixel: t };
  }
  calculateBounds(e, t) {
    this.topRowBounds = this.rowModel.getRowBounds(e), this.topRowBounds && (this.topRowBounds.rowIndex = e), this.bottomRowBounds = this.rowModel.getRowBounds(t), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = t), this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    const e = E(this.topRowBounds) ? this.topRowBounds.rowTop : 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, tC = class extends R {
  constructor() {
    super(), this.beanName = "ariaAnnouncementService", this.descriptionContainer = null, this.pendingAnnouncements = /* @__PURE__ */ new Map(), this.updateAnnouncement = Re(this.updateAnnouncement.bind(this), 200);
  }
  wireBeans(e) {
    this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    const e = re(this.gos), t = this.descriptionContainer = e.createElement("div");
    t.classList.add("ag-aria-description-container"), Ur(t, "polite"), Pa(t, "additions text"), ba(t, true), this.eGridDiv.appendChild(t);
  }
  announceValue(e, t) {
    this.pendingAnnouncements.set(t, e), this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer) return;
    const e = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear(), this.descriptionContainer.textContent = "", setTimeout(() => {
      this.isAlive() && this.descriptionContainer && (this.descriptionContainer.textContent = e);
    }, 50);
  }
  destroy() {
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (xe(e), e.parentElement && e.parentElement.removeChild(e)), this.descriptionContainer = null, this.eGridDiv = null, this.pendingAnnouncements.clear();
  }
}, iC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnAnimationService", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = false, this.activeNext = false, this.suppressAnimation = false, this.animationThreadCount = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    this.active || this.gos.get("suppressColumnMoveAnimation") || this.gos.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = true, this.activeNext = true);
  }
  finish() {
    this.active && this.flush(() => this.activeNext = false, () => this.active = false);
  }
  executeNextVMTurn(e) {
    this.activeNext ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(true), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(false);
    });
  }
  flush(e, t) {
    if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
      e(), t();
      return;
    }
    const i = (s) => {
      for (; s.length; ) {
        const o = s.pop();
        o && o();
      }
    };
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e(), i(this.executeNextFuncs);
      }, 0), window.setTimeout(() => {
        t(), i(this.executeLaterFuncs);
      }, 200);
    });
  }
}, sC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "columnHoverService";
  }
  setMouseOver(e) {
    this.updateState(e);
  }
  clearMouseOver() {
    this.updateState(null);
  }
  isHovered(e) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0;
  }
  updateState(e) {
    this.selectedColumns = e, this.eventService.dispatchEvent({ type: "columnHoverChanged" });
  }
}, oC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "overlayService", this.state = 0, this.showInitialOverlay = true, this.wrapperPadding = 0;
  }
  wireBeans(e) {
    this.userComponentFactory = e.userComponentFactory, this.rowModel = e.rowModel, this.columnModel = e.columnModel, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.isClientSide = Q(this.gos);
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({ newColumnsLoaded: e, rowDataUpdated: e, gridSizeChanged: this.onGridSizeChanged.bind(this), rowCountReady: () => {
      this.showInitialOverlay = false, this.updateOverlayVisibility();
    } }), this.addManagedPropertyListener("loading", e);
  }
  setOverlayWrapperComp(e) {
    this.overlayWrapperComp = e, this.updateOverlayVisibility();
  }
  isVisible() {
    return this.state !== 0 && !!this.overlayWrapperComp;
  }
  isExclusive() {
    return this.state === 1 && !!this.overlayWrapperComp;
  }
  getOverlayWrapper() {
    return this.overlayWrapperComp;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = false;
    const e = this.gos.get("loading");
    !e && (e !== void 0 || this.gos.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = false, !(this.gos.get("loading") || this.gos.get("suppressNoRowsOverlay")) && this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    if (this.showInitialOverlay = false, this.gos.get("loading")) {
      F("Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.");
      return;
    }
    this.doHideOverlay();
  }
  updateOverlayVisibility() {
    if (!this.overlayWrapperComp) {
      this.state = 0;
      return;
    }
    let e = this.gos.get("loading");
    this.showInitialOverlay && e === void 0 && !this.gos.get("suppressLoadingOverlay") && (e = !this.gos.get("columnDefs") || !this.columnModel.isReady() || !this.gos.get("rowData") && this.isClientSide), e ? this.state !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = false, this.rowModel.isEmpty() && !this.gos.get("suppressNoRowsOverlay") && this.isClientSide ? this.state !== 2 && this.doShowNoRowsOverlay() : this.state !== 0 && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.overlayWrapperComp && (this.state = 1, this.showOverlay(this.userComponentFactory.getLoadingOverlayCompDetails({}), "ag-overlay-loading-wrapper", "loadingOverlayComponentParams"), this.updateExclusive());
  }
  doShowNoRowsOverlay() {
    this.overlayWrapperComp && (this.state = 2, this.showOverlay(this.userComponentFactory.getNoRowsOverlayCompDetails({}), "ag-overlay-no-rows-wrapper", "noRowsOverlayComponentParams"), this.updateExclusive());
  }
  doHideOverlay() {
    this.overlayWrapperComp && (this.state = 0, this.overlayWrapperComp.hideOverlay(), this.updateExclusive());
  }
  showOverlay(e, t, i) {
    var _a3;
    const s = e.newAgStackInstance();
    (_a3 = this.overlayWrapperComp) == null ? void 0 : _a3.showOverlay(s, t, this.isExclusive(), i), this.refreshWrapperPadding();
  }
  updateExclusive() {
    const e = this.exclusive;
    this.exclusive = this.isExclusive(), this.exclusive !== e && this.eventService.dispatchEvent({ type: "overlayExclusiveChanged" });
  }
  onGridSizeChanged() {
    this.refreshWrapperPadding();
  }
  refreshWrapperPadding() {
    var _a3;
    if (!this.overlayWrapperComp) return;
    let e = 0;
    this.state === 2 ? e = ((_a3 = this.ctrlsService.get("gridHeaderCtrl")) == null ? void 0 : _a3.getHeaderHeight()) || 0 : this.wrapperPadding !== 0 && (e = 0), this.wrapperPadding !== e && (this.wrapperPadding = e, this.overlayWrapperComp.updateOverlayWrapperPaddingTop(e));
  }
}, rC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowCssClassCalculator";
  }
  wireBeans(e) {
    this.stylingService = e.stylingService;
  }
  getInitialRowClasses(e) {
    const t = [];
    return E(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), Uo(t, this.processClassesFromGridOptions(e.rowNode)), Uo(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === "left" && t.push("ag-cell-last-left-pinned"), e.pinned === "right" && t.push("ag-cell-first-right-pinned")), t;
  }
  processClassesFromGridOptions(e) {
    const t = [], i = (r) => {
      typeof r == "string" ? t.push(r) : Array.isArray(r) && r.forEach((n) => t.push(n));
    }, s = this.gos.get("rowClass");
    if (s) {
      if (typeof s == "function") return F("rowClass should not be a function, please use getRowClass instead"), [];
      i(s);
    }
    const o = this.gos.getCallback("getRowClass");
    if (o) {
      const r = { data: e.data, node: e, rowIndex: e.rowIndex }, n = o(r);
      i(n);
    }
    return t;
  }
  preProcessRowClassRules(e) {
    const t = [];
    return this.processRowClassRules(e, (i) => {
      t.push(i);
    }, () => {
    }), t;
  }
  processRowClassRules(e, t, i) {
    const s = this.gos.addGridCommonParams({ data: e.data, node: e, rowIndex: e.rowIndex });
    this.stylingService.processClassRules(void 0, this.gos.get("rowClassRules"), s, t, i);
  }
  calculateRowLevel(e) {
    return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
  }
}, nC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeightService", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = ka(), this.gos.get("debug") && at("RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching) return;
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top, i = this.getUiBodyHeight();
    (t !== this.scrollY || i !== this.uiBodyHeight) && (this.scrollY = t, this.uiBodyHeight = i, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    this.gos.get("debug") && at(`RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
    return t.bottom - t.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0) return e;
    const t = this.modelHeight - this.getUiBodyHeight(), i = e / t;
    return this.maxScrollY * i;
  }
}, lC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  postConstruct() {
    this.isAccentedSort = this.gos.get("accentedSort"), this.primaryColumnsSortGroups = _e(this.gos), this.addManagedPropertyListener("accentedSort", (e) => this.isAccentedSort = e.currentValue), this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = _e(this.gos));
  }
  doFullSort(e, t) {
    const i = (o, r) => ({ currentPos: r, rowNode: o }), s = e.map(i);
    return s.sort(this.compareRowNodes.bind(this, t)), s.map((o) => o.rowNode);
  }
  compareRowNodes(e, t, i) {
    const s = t.rowNode, o = i.rowNode;
    for (let r = 0, n = e.length; r < n; r++) {
      const l = e[r], a = l.sort === "desc", c = this.getValue(s, l.column), u = this.getValue(o, l.column);
      let d;
      const h = this.getComparator(l, s);
      if (h ? d = h(c, u, s, o, a) : d = Ol(c, u, this.isAccentedSort), !isNaN(d) && d !== 0) return l.sort === "asc" ? d : d * -1;
    }
    return t.currentPos - i.currentPos;
  }
  getComparator(e, t) {
    const i = e.column, s = i.getColDef().comparator;
    if (s != null) return s;
    if (!i.getColDef().showRowGroup) return;
    const o = !t.group && i.getColDef().field;
    if (!o) return;
    const r = this.columnModel.getColDefCol(o);
    if (r) return r.getColDef().comparator;
  }
  getValue(e, t) {
    var _a3, _b, _c2;
    if (!this.primaryColumnsSortGroups) return this.valueService.getValue(t, e, false, false);
    if (e.rowGroupColumn === t) {
      if (ss(this.gos, this.columnModel.isPivotActive())) {
        const r = (_a3 = e.allLeafChildren) == null ? void 0 : _a3[0];
        return r ? this.valueService.getValue(t, r, false, false) : void 0;
      }
      const o = (_b = this.showRowGroupColsService) == null ? void 0 : _b.getShowRowGroupCol(t.getId());
      return o ? (_c2 = e.groupData) == null ? void 0 : _c2[o.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup)) return this.valueService.getValue(t, e, false, false);
  }
}, cs = class {
  constructor(e, t) {
    this.active = true, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = { rowNode: t, children: null }, this.mapToItems[t.id] = this.pathRoot;
  }
  setInactive() {
    this.active = false;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(e, t) {
    if (e.children) for (let i = 0; i < e.children.length; i++) this.depthFirstSearchChangedPath(e.children[i], t);
    t(e.rowNode);
  }
  depthFirstSearchEverything(e, t, i) {
    if (e.childrenAfterGroup) for (let s = 0; s < e.childrenAfterGroup.length; s++) {
      const o = e.childrenAfterGroup[s];
      o.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[s], t, i) : i && t(o);
    }
    t(e);
  }
  forEachChangedNodeDepthFirst(e, t = false, i = false) {
    this.active && !i ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, i = 0;
    for (; !this.mapToItems[t.id]; ) {
      const s = { rowNode: t, children: null };
      this.mapToItems[t.id] = s, i++, t = t.parent;
    }
    return i;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t) return;
    let i = e;
    for (; i; ) this.nodeIdsToColumns[i.id] || (this.nodeIdsToColumns[i.id] = {}), t.forEach((s) => this.nodeIdsToColumns[i.id][s.getId()] = true), i = i.parent;
  }
  linkPathItems(e, t) {
    let i = e;
    for (let s = 0; s < t; s++) {
      const o = this.mapToItems[i.id], r = this.mapToItems[i.parent.id];
      r.children || (r.children = []), r.children.push(o), i = i.parent;
    }
  }
  addParentNode(e, t) {
    if (!e || e.isRowPinned()) return;
    const i = this.createPathItems(e);
    this.linkPathItems(e, i), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns) return t;
    const i = this.nodeIdsToColumns[e.id];
    return t.filter((o) => i[o.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns) return null;
    const i = this.nodeIdsToColumns[e.id];
    return t.filter((o) => !i[o.getId()]);
  }
}, hl = class extends R {
  constructor() {
    super(...arguments), this.beanName = "selectionService", this.selectedNodes = /* @__PURE__ */ new Map(), this.selectionCtx = new cg(), this.rowSelectionMode = void 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    const { gos: e, rowModel: t, onRowSelected: i } = this;
    this.selectionCtx.init(t), this.rowSelectionMode = Ui(e), this.groupSelectsChildren = Dt(e), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      const s = Dt(e), o = Ui(e);
      (s !== this.groupSelectsChildren || o !== this.rowSelectionMode) && (this.groupSelectsChildren = s, this.rowSelectionMode = o, this.deselectAllRowNodes({ source: "api" }));
    }), this.addManagedEventListeners({ rowSelected: i.bind(this) });
  }
  destroy() {
    super.destroy(), this.resetNodes(), this.selectionCtx.reset();
  }
  isMultiSelect() {
    return this.rowSelectionMode === "multiRow";
  }
  overrideSelectionValue(e, t) {
    if (!$m(t)) return e;
    const i = this.selectionCtx.getRoot();
    return i ? i.isSelected() ?? false : true;
  }
  setNodesSelected(e) {
    var _a3;
    const { newValue: t, clearSelection: i, suppressFinishActions: s, rangeSelect: o, nodes: r, event: n, source: l } = e;
    if (r.length === 0) return 0;
    if (r.length > 1 && !this.isMultiSelect()) return F("cannot multi select unless selection mode is 'multiRow'"), 0;
    const a = this.groupSelectsChildren && e.groupSelectsFiltered === true, c = r.map((d) => d.footer ? d.sibling : d);
    if (o) {
      if (c.length > 1) return F("cannot range select while selecting multiple rows"), 0;
      const d = c[0], h = this.overrideSelectionValue(t, l);
      if (this.isMultiSelect()) {
        if (this.selectionCtx.isInRange(d)) {
          const g = this.selectionCtx.truncate(d);
          return h && this.selectRange(g.discard, false, l), this.selectRange(g.keep, h, l);
        } else if (this.selectionCtx.getRoot() !== d) {
          const C = this.selectionCtx.extend(d, this.groupSelectsChildren);
          return h && this.selectRange(C.discard, false, l), this.selectRange(C.keep, h, l);
        }
      }
    }
    s || this.selectionCtx.setRoot(c[0]);
    let u = 0;
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a && h.group || h.selectThisNode(t, n, l) && u++, this.groupSelectsChildren && ((_a3 = h.childrenAfterGroup) == null ? void 0 : _a3.length) && (u += this.selectChildren(h, t, a, l));
    }
    return s || (t && (i || !this.isMultiSelect()) && (u += this.clearOtherNodes(c[0], l)), u > 0 && (this.updateGroupsFromChildrenSelections(l), this.dispatchSelectionChanged(l))), u;
  }
  selectRange(e, t, i) {
    let s = 0;
    return e.forEach((o) => {
      if (o.group && this.groupSelectsChildren) return;
      o.selectThisNode(t, void 0, i) && s++;
    }), s > 0 && (this.updateGroupsFromChildrenSelections(i), this.dispatchSelectionChanged(i)), s;
  }
  selectChildren(e, t, i, s) {
    const o = i ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return V(o) ? 0 : this.setNodesSelected({ newValue: t, clearSelection: false, suppressFinishActions: true, groupSelectsFiltered: i, source: s, nodes: o });
  }
  getSelectedNodes() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && e.push(t);
    }), e;
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && t.data && e.push(t.data);
    }), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((i, s) => {
      i && e(i) && t.set(s, i);
    }), this.selectedNodes = t;
  }
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsChildren || !Q(this.gos)) return false;
    const s = this.rowModel.getRootNode();
    t || (t = new cs(true, s), t.setInactive());
    let o = false;
    return t.forEachChangedNodeDepthFirst((r) => {
      if (r !== s) {
        const n = r.calculateSelectedFromChildren();
        o = r.selectThisNode(n === null ? false : n, void 0, e) || o;
      }
    }), o;
  }
  clearOtherNodes(e, t) {
    const i = /* @__PURE__ */ new Map();
    let s = 0;
    return this.selectedNodes.forEach((o) => {
      if (o && o.id !== e.id) {
        const r = this.selectedNodes.get(o.id);
        s += r.setSelectedParams({ newValue: false, clearSelection: false, suppressFinishActions: true, source: t }), this.groupSelectsChildren && o.parent && i.set(o.parent.id, o.parent);
      }
    }), i.forEach((o) => {
      const r = o.calculateSelectedFromChildren();
      o.selectThisNode(r === null ? false : r, void 0, t);
    }), s;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  syncInOldRowNode(e, t) {
    if (E(t) && e.id !== t.id && t) {
      const s = t.id;
      this.selectedNodes.get(s) == e && this.selectedNodes.set(t.id, t);
    }
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.setSelectedInitialValue(true), this.selectedNodes.set(e.id, e)) : e.setSelectedInitialValue(false);
  }
  reset(e) {
    const t = this.getSelectionCount();
    this.resetNodes(), t && this.dispatchSelectionChanged(e);
  }
  resetNodes() {
    var _a3;
    (_a3 = this.selectedNodes) == null ? void 0 : _a3.clear();
  }
  getBestCostNodeSelection() {
    if (!Q(this.gos)) return;
    const t = this.rowModel.getTopLevelNodes();
    if (t === null) return;
    const i = [];
    function s(o) {
      for (let r = 0, n = o.length; r < n; r++) {
        const l = o[r];
        if (l.isSelected()) i.push(l);
        else {
          const a = l;
          a.group && a.children && s(a.children);
        }
      }
    }
    return s(t), i;
  }
  isEmpty() {
    let e = 0;
    return this.selectedNodes.forEach((t) => {
      t && e++;
    }), e === 0;
  }
  deselectAllRowNodes(e) {
    const t = (n) => n.selectThisNode(false, void 0, s), i = Q(this.gos), { source: s, justFiltered: o, justCurrentPage: r } = e;
    if (r || o) {
      if (!i) {
        z("selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(o, r).forEach(t);
    } else this.selectedNodes.forEach((n) => {
      n && t(n);
    }), this.reset(s);
    this.selectionCtx.reset(), i && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(s), this.dispatchSelectionChanged(s);
  }
  getSelectedCounts(e, t) {
    let i = 0, s = 0;
    const o = (r) => {
      this.groupSelectsChildren && r.group || (r.isSelected() ? i++ : r.selectable && s++);
    };
    return this.getNodesToSelect(e, t).forEach(o), { selectedCount: i, notSelectedCount: s };
  }
  getSelectAllState(e, t) {
    const { selectedCount: i, notSelectedCount: s } = this.getSelectedCounts(e, t);
    return i === 0 && s === 0 ? false : i > 0 && s > 0 ? null : i > 0;
  }
  hasNodesToSelect(e = false, t = false) {
    return this.getNodesToSelect(e, t).filter((i) => i.selectable).length > 0;
  }
  getNodesToSelect(e = false, t = false) {
    this.validateSelectAllType();
    const i = [];
    if (t) return this.forEachNodeOnPage((o) => {
      if (!o.group) {
        i.push(o);
        return;
      }
      if (!o.expanded) {
        const r = (n) => {
          var _a3;
          i.push(n), ((_a3 = n.childrenAfterFilter) == null ? void 0 : _a3.length) && n.childrenAfterFilter.forEach(r);
        };
        r(o);
        return;
      }
      this.groupSelectsChildren || i.push(o);
    }), i;
    const s = this.rowModel;
    return e ? (s.forEachNodeAfterFilter((o) => {
      i.push(o);
    }), i) : (s.forEachNode((o) => {
      i.push(o);
    }), i);
  }
  forEachNodeOnPage(e) {
    const t = this.pageBoundsService.getFirstRow(), i = this.pageBoundsService.getLastRow();
    for (let s = t; s <= i; s++) {
      const o = this.rowModel.getRow(s);
      o && e(o);
    }
  }
  selectAllRowNodes(e) {
    if (Nl(this.gos) && !Ar(this.gos)) return F("cannot multi select unless selection mode is 'multiRow'");
    this.validateSelectAllType();
    const { source: t, justFiltered: i, justCurrentPage: s } = e, o = this.getNodesToSelect(i, s);
    o.forEach((r) => r.selectThisNode(true, void 0, t)), this.selectionCtx.setRoot(o[0] ?? null), this.selectionCtx.setEndRange(N(o) ?? null), Q(this.gos) && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t), this.dispatchSelectionChanged(t);
  }
  getSelectionState() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      (t == null ? void 0 : t.id) && e.push(t.id);
    }), e.length ? e : null;
  }
  setSelectionState(e, t) {
    if (!Array.isArray(e)) return z("Invalid selection state. When using client-side row model, the state must conform to `string[]`.");
    const i = new Set(e), s = [];
    this.rowModel.forEachNode((o) => {
      i.has(o.id) && s.push(o);
    }), this.setNodesSelected({ newValue: true, nodes: s, source: t });
  }
  dispatchSelectionChanged(e) {
    this.eventService.dispatchEvent({ type: "selectionChanged", source: e });
  }
  validateSelectAllType() {
    if (!Q(this.gos)) throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
  }
}, aC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "selectableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => this.updateSelectable());
  }
  updateSelectableAfterGrouping() {
    this.updateSelectable(true);
  }
  updateSelectable(e = false) {
    const { gos: t } = this, i = Wi(t), s = Zs(t);
    if (!i || !s) return;
    const o = Dt(t), r = Q(t) && o, n = [], l = (a) => {
      if (e && !a.group) return;
      if (r && a.group) {
        const u = a.childrenAfterGroup.some((d) => d.selectable === true);
        a.setRowSelectable(u, true);
        return;
      }
      const c = (s == null ? void 0 : s(a)) ?? true;
      a.setRowSelectable(c, true), !c && a.isSelected() && n.push(a);
    };
    if (r) {
      const a = this.rowModel;
      new cs(false, a.getRootNode()).forEachChangedNodeDepthFirst(l, true, true);
    } else this.rowModel.forEachNode(l);
    n.length && this.selectionService.setNodesSelected({ nodes: n, newValue: false, source: "selectableChanged" }), r && this.selectionService instanceof hl && this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
  }
}, pr = ["asc", "desc", null], cC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "sortController";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  progressSort(e, t, i) {
    const s = this.getNextSortDirection(e);
    this.setSortForColumn(e, s, t, i);
  }
  setSortForColumn(e, t, i, s) {
    var _a3;
    t !== "asc" && t !== "desc" && (t = null);
    const o = _e(this.gos);
    let r = [e];
    if (o && e.getColDef().showRowGroup) {
      const c = (_a3 = this.funcColsService.getSourceColumnsForGroupColumn(e)) == null ? void 0 : _a3.filter((u) => u.isSortable());
      c && (r = [e, ...c]);
    }
    r.forEach((a) => a.setSort(t, s));
    const n = (i || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort"), l = [];
    if (!n) {
      const a = this.clearSortBarTheseColumns(r, s);
      l.push(...a);
    }
    this.updateSortIndex(e), l.push(...r), this.dispatchSortChangedEvents(s, l);
  }
  updateSortIndex(e) {
    var _a3;
    const t = _e(this.gos), i = (_a3 = this.showRowGroupColsService) == null ? void 0 : _a3.getShowRowGroupCol(e.getId()), s = t && i || e, o = this.getColumnsWithSortingOrdered();
    this.columnModel.getAllCols().forEach((l) => l.setSortIndex(null));
    const r = o.filter((l) => t && l.getColDef().showRowGroup ? false : l !== s);
    (s.getSort() ? [...r, s] : r).forEach((l, a) => {
      l.setSortIndex(a);
    });
  }
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    const t = this.columnModel.getAllCols().filter((i) => !!i.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e, t) {
    const i = { type: "sortChanged", source: e };
    t && (i.columns = t), this.eventService.dispatchEvent(i);
  }
  clearSortBarTheseColumns(e, t) {
    const i = [];
    return this.columnModel.getAllCols().forEach((s) => {
      e.includes(s) || (s.getSort() && i.push(s), s.setSort(void 0, t));
    }), i;
  }
  getNextSortDirection(e) {
    let t;
    if (e.getColDef().sortingOrder ? t = e.getColDef().sortingOrder : this.gos.get("sortingOrder") ? t = this.gos.get("sortingOrder") : t = pr, !Array.isArray(t) || t.length <= 0) return F(`sortingOrder must be an array with at least one element, currently it's ${t}`), null;
    const i = t.indexOf(e.getSort()), s = i < 0, o = i == t.length - 1;
    let r;
    return s || o ? r = t[0] : r = t[i + 1], pr.indexOf(r) < 0 ? (F("invalid sort type ", r), null) : r;
  }
  getIndexedSortMap() {
    let e = this.columnModel.getAllCols().filter((r) => !!r.getSort());
    if (this.columnModel.isPivotMode()) {
      const r = _e(this.gos);
      e = e.filter((n) => {
        var _a3;
        const l = !!n.getAggFunc(), a = !n.isPrimary(), c = r ? (_a3 = this.showRowGroupColsService) == null ? void 0 : _a3.getShowRowGroupCol(n.getId()) : n.getColDef().showRowGroup;
        return l || a || c;
      });
    }
    const t = this.funcColsService.getRowGroupColumns().filter((r) => !!r.getSort()), i = {};
    e.forEach((r, n) => i[r.getId()] = n), e.sort((r, n) => {
      const l = r.getSortIndex(), a = n.getSortIndex();
      if (l != null && a != null) return l - a;
      if (l == null && a == null) {
        const c = i[r.getId()], u = i[n.getId()];
        return c > u ? 1 : -1;
      } else return a == null ? -1 : 1;
    });
    const s = _e(this.gos) && !!t.length;
    s && (e = [...new Set(e.map((r) => {
      var _a3;
      return ((_a3 = this.showRowGroupColsService) == null ? void 0 : _a3.getShowRowGroupCol(r.getId())) ?? r;
    }))]);
    const o = /* @__PURE__ */ new Map();
    return e.forEach((r, n) => o.set(r, n)), s && t.forEach((r) => {
      const n = this.showRowGroupColsService.getShowRowGroupCol(r.getId());
      o.set(r, o.get(n));
    }), o;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [i, s]) => t - s).map(([e]) => e);
  }
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({ sort: e.getSort(), colId: e.getId() }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({ sort: e.getSort(), column: e }));
  }
  canColumnDisplayMixedSort(e) {
    const t = _e(this.gos), i = !!e.getColDef().showRowGroup;
    return t && i;
  }
  getDisplaySortForColumn(e) {
    const t = this.funcColsService.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t == null ? void 0 : t.length)) return e.getSort();
    const s = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, o = s[0].getSort();
    return s.every((n) => n.getSort() == o) ? o : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
}, uC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "syncService", this.waitingForColumns = false;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.ctrlsService.whenReady(this, () => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = true, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    this.columnModel.setColumnDefs(e ?? [], "gridInitializing"), this.rowModel.start();
  }
  gridReady() {
    this.eventService.dispatchEvent({ type: "gridReady" });
    const e = this.gos.isModuleRegistered("@ag-grid-enterprise/core");
    this.gos.get("debug") && at(`initialised successfully, enterprise = ${e}`);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = false, this.setColumnsAndData(t);
        return;
      }
      this.columnModel.setColumnDefs(t, Ct(e.source));
    }
  }
}, dC = "paste", hC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    Q(this.gos) && (this.clientSideRowModel = this.rowModel), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    e.source !== dC && this.doChangeDetection(e.node, e.column);
  }
  doChangeDetection(e, t) {
    if (this.gos.get("suppressChangeDetection")) return;
    const i = [e];
    if (this.clientSideRowModel && !e.isRowPinned()) {
      const s = this.gos.get("aggregateOnlyChangedColumns"), o = new cs(s, this.clientSideRowModel.getRootNode());
      o.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(o), o.forEachChangedNodeDepthFirst((r) => {
        i.push(r);
      });
    }
    this.rowRenderer.refreshCells({ rowNodes: i });
  }
}, gC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "expressionService", this.expressionToFunctionCache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string") return this.evaluateExpression(e, t);
    z("value should be either a string or a function", e);
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(t.value, t.context, t.oldValue, t.newValue, t.value, t.node, t.data, t.colDef, t.rowIndex, t.api, t.getValue, t.column, t.columnGroup);
    } catch (i) {
      return at("Processing of the expression failed"), at("Expression = ", e), at("Params = ", t), at("Exception = ", i), null;
    }
  }
  createExpressionFunction(e) {
    if (this.expressionToFunctionCache[e]) return this.expressionToFunctionCache[e];
    const t = this.createFunctionBody(e), i = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup", t);
    return this.expressionToFunctionCache[e] = i, i;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, pC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "valueCache", this.cacheVersion = 0;
  }
  postConstruct() {
    this.active = this.gos.get("valueCache"), this.neverExpires = this.gos.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, i) {
    this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = i);
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion)) return e.__cacheData[t];
  }
}, fC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "valueService", this.initialised = false, this.isSsrm = false;
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.columnModel = e.columnModel, this.valueCache = e.valueCache, this.dataTypeService = e.dataTypeService;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.isSsrm = it(this.gos), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = true;
    const e = (i) => this.callColumnCellValueChangedHandler(i), t = zi(this.gos);
    this.eventService.addEventListener("cellValueChanged", e, t), this.addDestroyFunc(() => this.eventService.removeEventListener("cellValueChanged", e, t)), this.addManagedPropertyListener("treeData", (i) => this.isTreeData = i.currentValue);
  }
  getValueForDisplay(e, t) {
    const i = t.leafGroup && this.columnModel.isPivotMode(), s = t.group && t.expanded && !t.footer && !i, o = this.gos.get("groupSuppressBlankHeader");
    if (!s || o) return this.getValue(e, t);
    let r = false;
    const n = this.gos.get("groupTotalRow") ?? this.gos.get("groupIncludeFooter");
    typeof n != "function" ? r = !!n : r = !!(this.gos.getCallback("groupTotalRow") ?? this.gos.getCallback("groupIncludeFooter"))({ node: this });
    const l = s && r;
    return this.getValue(e, t, false, l);
  }
  getValue(e, t, i = false, s = false) {
    if (this.initialised || this.init(), !t) return;
    const o = e.getColDef(), r = o.field, n = e.getColId(), l = t.data;
    let a;
    const c = t.groupData && t.groupData[n] !== void 0, u = !s && t.aggData && t.aggData[n] !== void 0, d = this.isSsrm && s && !!e.getColDef().aggFunc, h = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === true || e.getColDef().showRowGroup === t.field);
    if (i && o.filterValueGetter ? a = this.executeFilterValueGetter(o.filterValueGetter, l, e, t) : this.isTreeData && u ? a = t.aggData[n] : this.isTreeData && o.valueGetter ? a = this.executeValueGetter(o.valueGetter, l, e, t) : this.isTreeData && r && l ? a = ri(l, r, e.isFieldContainsDots()) : c ? a = t.groupData[n] : u ? a = t.aggData[n] : o.valueGetter ? a = this.executeValueGetter(o.valueGetter, l, e, t) : h ? a = ri(l, t.field, e.isFieldContainsDots()) : r && l && !d && (a = ri(l, r, e.isFieldContainsDots())), this.cellExpressions && typeof a == "string" && a.indexOf("=") === 0) {
      const g = a.substring(1);
      a = this.executeValueGetter(g, l, e, t);
    }
    if (a == null) {
      const g = this.getOpenedGroup(t, e);
      if (g != null) return g;
    }
    return a;
  }
  parseValue(e, t, i, s) {
    const o = e.getColDef(), r = o.valueParser;
    if (E(r)) {
      const n = this.gos.addGridCommonParams({ node: t, data: t == null ? void 0 : t.data, oldValue: s, newValue: i, colDef: o, column: e });
      return typeof r == "function" ? r(n) : this.expressionService.evaluate(r, n);
    }
    return i;
  }
  getDeleteValue(e, t) {
    return E(e.getColDef().valueParser) ? this.parseValue(e, t, "", this.getValueForDisplay(e, t)) ?? null : null;
  }
  formatValue(e, t, i, s, o = true) {
    let r = null, n;
    const l = e.getColDef();
    if (s ? n = s : o && (n = l.valueFormatter), n) {
      const a = this.gos.addGridCommonParams({ value: i, node: t, data: t ? t.data : null, colDef: l, column: e });
      typeof n == "function" ? r = n(a) : r = this.expressionService.evaluate(n, a);
    } else if (l.refData) return l.refData[i] || "";
    return r == null && Array.isArray(i) && (r = i.join(", ")), r;
  }
  getOpenedGroup(e, t) {
    if (!this.gos.get("showOpenedGroup") || !t.getColDef().showRowGroup) return;
    const s = t.getColDef().showRowGroup;
    let o = e.parent;
    for (; o != null; ) {
      if (o.rowGroupColumn && (s === true || s === o.rowGroupColumn.getColId())) return o.key;
      o = o.parent;
    }
  }
  setValue(e, t, i, s) {
    const o = this.columnModel.getColDefCol(t);
    if (!e || !o) return false;
    V(e.data) && (e.data = {});
    const { field: r, valueSetter: n } = o.getColDef();
    if (V(r) && V(n)) return F("you need either field or valueSetter set on colDef for editing to work"), false;
    if (this.dataTypeService && !this.dataTypeService.checkType(o, i)) return F("Data type of the new value does not match the cell data type of the column"), false;
    const l = this.gos.addGridCommonParams({ node: e, data: e.data, oldValue: this.getValue(o, e), newValue: i, colDef: o.getColDef(), column: o });
    l.newValue = i;
    let a;
    if (E(n) ? typeof n == "function" ? a = n(l) : a = this.expressionService.evaluate(n, l) : a = this.setValueUsingField(e.data, r, i, o.isFieldContainsDots()), a === void 0 && (a = true), !a) return false;
    e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged();
    const c = this.getValue(o, e);
    return this.eventService.dispatchEvent({ type: "cellValueChanged", event: null, rowIndex: e.rowIndex, rowPinned: e.rowPinned, column: l.column, colDef: l.colDef, data: e.data, node: e, oldValue: l.oldValue, newValue: c, value: c, source: s }), true;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.getFrameworkOverrides().wrapOutgoing(() => {
      t({ node: e.node, data: e.data, oldValue: e.oldValue, newValue: e.newValue, colDef: e.colDef, column: e.column, api: e.api, context: e.context });
    });
  }
  setValueUsingField(e, t, i, s) {
    if (!t) return false;
    let o = false;
    if (!s) o = e[t] === i, o || (e[t] = i);
    else {
      const r = t.split(".");
      let n = e;
      for (; r.length > 0 && n; ) {
        const l = r.shift();
        r.length === 0 ? (o = n[l] === i, o || (n[l] = i)) : n = n[l];
      }
    }
    return !o;
  }
  executeFilterValueGetter(e, t, i, s) {
    const o = this.gos.addGridCommonParams({ data: t, node: s, column: i, colDef: i.getColDef(), getValue: this.getValueCallback.bind(this, s) });
    return typeof e == "function" ? e(o) : this.expressionService.evaluate(e, o);
  }
  executeValueGetter(e, t, i, s) {
    const o = i.getColId(), r = this.valueCache.getValue(s, o);
    if (r !== void 0) return r;
    const n = this.gos.addGridCommonParams({ data: t, node: s, column: i, colDef: i.getColDef(), getValue: this.getValueCallback.bind(this, s) });
    let l;
    return typeof e == "function" ? l = e(n) : l = this.expressionService.evaluate(e, n), this.valueCache.setValue(s, o, l), l;
  }
  getValueCallback(e, t) {
    const i = this.columnModel.getColDefCol(t);
    return i ? this.getValue(i, e) : null;
  }
  getKeyForNode(e, t) {
    const i = this.getValue(e, t), s = e.getColDef().keyCreator;
    let o = i;
    if (s) {
      const r = this.gos.addGridCommonParams({ value: i, colDef: e.getColDef(), column: e, node: t, data: t.data });
      o = s(r);
    }
    return typeof o == "string" || o == null || (o = String(o), o === "[object Object]" && F("a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key")), o;
  }
}, Ao = class mt {
  static applyGlobalGridOptions(t) {
    if (!mt.gridOptions) return t;
    let i = {};
    return we(i, mt.gridOptions, true, true), mt.mergeStrategy === "deep" ? we(i, t, true, true) : i = { ...i, ...t }, mt.gridOptions.context && (i.context = mt.gridOptions.context), t.context && (mt.mergeStrategy === "deep" && i.context && we(t.context, i.context, true, true), i.context = t.context), i;
  }
};
Ao.gridOptions = void 0;
Ao.mergeStrategy = "shallow";
var gl = Ao;
function mC(e) {
  var _a3;
  return (_a3 = gl.gridOptions) == null ? void 0 : _a3[e];
}
var CC = 1, vC = class {
  create(e, t, i, s, o) {
    const r = gl.applyGlobalGridOptions(t), n = qm(r), l = n.gridId ?? String(CC++), a = this.getRegisteredModules(o, l), c = this.createBeansList(n.rowModelType, a, l), u = this.createProvidedBeans(e, n, o);
    if (!c) {
      z("Failed to create grid.");
      return;
    }
    const d = { providedBeanInstances: u, beanClasses: c, gridId: l, beanInitComparator: xg, beanDestroyComparator: Ag, derivedBeans: [wg] }, h = new kc(d);
    return this.registerModuleUserComponents(h, a), this.registerControllers(h, a), this.registerModuleApiFunctions(h, a), i(h), h.getBean("syncService").start(), s && s(h), h.getBean("gridApi");
  }
  registerControllers(e, t) {
    const i = e.getBean("ctrlsFactory");
    t.forEach((s) => {
      s.controllers && s.controllers.forEach((o) => i.register(o));
    });
  }
  getRegisteredModules(e, t) {
    const i = e ? e.modules : null, s = Ue.__getRegisteredModules(t), o = [], r = {}, n = (l, a, c) => {
      ((d) => {
        r[d.moduleName] || (r[d.moduleName] = true, o.push(d), Ue.__register(d, l, c));
      })(a), a.dependantModules && a.dependantModules.forEach((d) => n(l, d, c));
    };
    return n(!!(i == null ? void 0 : i.length) || !Ue.__isPackageBased(), Um, void 0), i && i.forEach((l) => n(true, l, t)), s && s.forEach((l) => n(!Ue.__isPackageBased(), l, void 0)), o;
  }
  registerModuleUserComponents(e, t) {
    const i = this.extractModuleEntity(t, (o) => o.userComponents ? o.userComponents : []), s = e.getBean("userComponentRegistry");
    i.forEach(({ name: o, classImp: r, params: n }) => {
      s.registerDefaultComponent(o, r, n);
    });
  }
  registerModuleApiFunctions(e, t) {
    const i = e.getBean("apiFunctionService");
    t.forEach((s) => {
      const o = s.apiFunctions;
      o && Object.keys(o).forEach((n) => {
        i == null ? void 0 : i.addFunction(n, o[n]);
      });
    });
  }
  createProvidedBeans(e, t, i) {
    let s = i ? i.frameworkOverrides : null;
    V(s) && (s = new tl());
    const o = { gridOptions: t, eGridDiv: e, globalEventListener: i ? i.globalEventListener : null, globalSyncEventListener: i ? i.globalSyncEventListener : null, frameworkOverrides: s };
    return i && i.providedBeanInstances && Object.assign(o, i.providedBeanInstances), o;
  }
  createBeansList(e = "clientSide", t, i) {
    const s = t.filter((a) => !a.rowModel || a.rowModel === e), o = { clientSide: "@ag-grid-community/client-side-row-model", infinite: "@ag-grid-community/infinite-row-model", serverSide: "@ag-grid-enterprise/server-side-row-model", viewport: "@ag-grid-enterprise/viewport-row-model" };
    if (!o[e]) {
      z("Could not find row model for rowModelType = ", e);
      return;
    }
    if (!Ue.__assertRegistered(o[e], `rowModelType = '${e}'`, i)) return;
    const r = [Gg, Lg, Qm, Km, Sg, mc, Eg, Dg, Ch, un, nC, fh, Xm, ag, Bc, ma, Ng, Ym, fg, hl, ra, Xu, eC, Zm, ng, gC, oa, ph, pC, fC, og, mh, Hc, Vg, gh, kg, Cg, ug, hh, cC, sC, iC, aC, hC, vh, yg, rC, lC, Ig, Bg, Og, Tg, uC, oC, Sh, Jm, tC, wh, aa, Rg, ca, na, Fg, bg, fa, la, ga, Pg, pa, Zl], n = this.extractModuleEntity(s, (a) => a.beans ? a.beans : []);
    r.push(...n);
    const l = [];
    return r.forEach((a) => {
      l.indexOf(a) < 0 && l.push(a);
    }), l;
  }
  extractModuleEntity(e, t) {
    return [].concat(...e.map(t));
  }
}, SC = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowModelHelperService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    const e = this.rowModel;
    switch (e.getType()) {
      case "clientSide":
        this.clientSideRowModel = e;
        break;
      case "infinite":
        this.infiniteRowModel = e;
        break;
      case "serverSide":
        this.serverSideRowModel = e;
        break;
    }
  }
  getClientSideRowModel() {
    return this.clientSideRowModel;
  }
  getInfiniteRowModel() {
    return this.infiniteRowModel;
  }
  getServerSideRowModel() {
    return this.serverSideRowModel;
  }
};
function wC(e) {
  e.expansionService.expandAll(true);
}
function yC(e) {
  e.expansionService.expandAll(false);
}
function RC(e) {
  var _a3, _b;
  const t = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel(), i = (_b = e.rowModelHelperService) == null ? void 0 : _b.getServerSideRowModel();
  t ? t.onRowHeightChanged() : i && i.onRowHeightChanged();
}
var FC = { version: G, moduleName: "@ag-grid-community/csrm-ssrm-shared-api", apiFunctions: { expandAll: wC, collapseAll: yC, onRowHeightChanged: RC } }, bC = class {
  wrap(e, t, i = [], s) {
    const o = this.createWrapper(e, s);
    return t.forEach((r) => {
      this.createMethod(o, r, true);
    }), i.forEach((r) => {
      this.createMethod(o, r, false);
    }), o;
  }
  createMethod(e, t, i) {
    e.addMethod(t, this.createMethodProxy(e, t, i));
  }
  createMethodProxy(e, t, i) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (i && F("Framework component is missing the method " + t + "()"), null);
    };
  }
}, qt = typeof global > "u" ? {} : global;
qt.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
qt.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
qt.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
qt.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
qt.Node = typeof Node > "u" ? {} : Node;
qt.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
var me = D.createContext({}), Fi = (e, t, i, s) => {
  if (!e || e.componentFromFramework || t.isDestroyed()) return;
  const r = e.newAgStackInstance();
  if (r == null) return;
  let n, l, a = false;
  return r.then((c) => {
    if (a) {
      t.destroyBean(c);
      return;
    }
    n = c, l = n.getGui(), i.appendChild(l), fr(s, n);
  }), () => {
    var _a3;
    a = true, n && ((_a3 = l == null ? void 0 : l.parentElement) == null ? void 0 : _a3.removeChild(l), t.destroyBean(n), s && fr(s, void 0));
  };
}, fr = (e, t) => {
  if (e) if (e instanceof Function) e(t);
  else {
    const i = e;
    i.current = t;
  }
}, ke = (...e) => e.filter((i) => i != null && i !== "").join(" "), Ie = class pl {
  constructor(...t) {
    this.classesMap = {}, t.forEach((i) => {
      this.classesMap[i] = true;
    });
  }
  setClass(t, i) {
    if (!!this.classesMap[t] == i) return this;
    const o = new pl();
    return o.classesMap = { ...this.classesMap }, o.classesMap[t] = i, o;
  }
  toString() {
    return Object.keys(this.classesMap).filter((i) => this.classesMap[i]).join(" ");
  }
}, Yt = (e) => {
  const t = () => typeof Symbol == "function" && Symbol.for, i = () => t() ? Symbol.for("react.memo") : 60115;
  return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === i();
}, Qs = (_a2 = D.version) == null ? void 0 : _a2.split(".")[0], PC = Qs === "16" || Qs === "17";
function EC() {
  return Qs === "19";
}
var Ni = false;
function DC(e) {
  return Ni || setTimeout(() => Ni = false, 0), Ni = true, e();
}
var To = (e, t) => {
  !PC && e && !Ni ? bl.flushSync(t) : t();
};
function Io(e, t, i) {
  if (t == null || e == null) return t;
  if (e === t || t.length === 0 && e.length === 0) return e;
  if (i || e.length === 0 && t.length > 0 || e.length > 0 && t.length === 0) return t;
  const s = [], o = [], r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  for (let l = 0; l < t.length; l++) {
    const a = t[l];
    n.set(a.instanceId, a);
  }
  for (let l = 0; l < e.length; l++) {
    const a = e[l];
    r.set(a.instanceId, a), n.has(a.instanceId) && s.push(a);
  }
  for (let l = 0; l < t.length; l++) {
    const a = t[l], c = a.instanceId;
    r.has(c) || o.push(a);
  }
  return s.length === e.length && o.length === 0 ? e : s.length === 0 && o.length === t.length ? t : s.length === 0 ? o : o.length === 0 ? s : [...s, ...o];
}
var fl = p.forwardRef((e, t) => {
  var _a3;
  const { ctrlsFactory: i, context: s } = p.useContext(me), o = p.useRef(null), r = p.useRef(null), n = p.useRef(null), l = p.useRef(null), a = p.useRef(null), c = p.useRef(), [u, d] = p.useState(), [h, g] = p.useState(), [m, C] = p.useState(), [f, v] = p.useState(() => new Ie()), [w, S] = p.useState(() => new Ie("ag-hidden")), [b, x] = p.useState(() => new Ie("ag-hidden")), [M, P] = p.useState(() => new Ie("ag-invisible"));
  p.useImperativeHandle(t, () => ({ refresh() {
    return false;
  } })), p.useLayoutEffect(() => Fi(u, s, r.current), [u]);
  const A = p.useCallback((U) => {
    if (o.current = U, !U) {
      c.current = s.destroyBean(c.current);
      return;
    }
    const K = { setInnerRenderer: ($, J) => {
      d($), C(J);
    }, setChildCount: ($) => g($), addOrRemoveCssClass: ($, J) => v((X) => X.setClass($, J)), setContractedDisplayed: ($) => x((J) => J.setClass("ag-hidden", !$)), setExpandedDisplayed: ($) => S((J) => J.setClass("ag-hidden", !$)), setCheckboxVisible: ($) => P((J) => J.setClass("ag-invisible", !$)) }, se = i.getInstance("groupCellRendererCtrl");
    se && (c.current = s.createBean(se), c.current.init(K, U, n.current, l.current, a.current, fl, e));
  }, []), I = p.useMemo(() => `ag-cell-wrapper ${f.toString()}`, [f]), T = p.useMemo(() => `ag-group-expanded ${w.toString()}`, [w]), L = p.useMemo(() => `ag-group-contracted ${b.toString()}`, [b]), W = p.useMemo(() => `ag-group-checkbox ${M.toString()}`, [M]), ge = u && u.componentFromFramework, j = ge ? u.componentClass : void 0, ie = u == null && m != null, _ = Ke(m, true);
  return D.createElement("span", { className: I, ref: A, ...e.colDef ? {} : { role: (_a3 = c.current) == null ? void 0 : _a3.getCellAriaRole() } }, D.createElement("span", { className: T, ref: l }), D.createElement("span", { className: L, ref: a }), D.createElement("span", { className: W, ref: n }), D.createElement("span", { className: "ag-group-value", ref: r }, ie && D.createElement(D.Fragment, null, _), ge && D.createElement(j, { ...u.params })), D.createElement("span", { className: "ag-group-child-count" }, h));
}), mr = fl, Lo = p.createContext({ setMethods: () => {
} }), MC = (e) => {
  const { initialProps: t, addUpdateCallback: i, CustomComponentClass: s, setMethods: o } = e, [{ key: r, ...n }, l] = p.useState(t);
  return p.useEffect(() => {
    i((a) => l(a));
  }, []), D.createElement(Lo.Provider, { value: { setMethods: o } }, D.createElement(s, { key: r, ...n }));
}, xC = p.memo(MC), AC = 0;
function Cr() {
  return `agPortalKey_${++AC}`;
}
var ml = class {
  constructor(e, t, i, s) {
    this.portal = null, this.oldPortal = null, this.reactComponent = e, this.portalManager = t, this.componentType = i, this.suppressFallbackMethods = !!s, this.statelessComponent = this.isStateless(this.reactComponent), this.key = Cr(), this.portalKey = Cr(), this.instanceCreated = this.isStatelessComponent() ? oe.resolve(false) : new oe((o) => {
      this.resolveInstanceCreated = o;
    });
  }
  getGui() {
    return this.eParentElement;
  }
  getRootElement() {
    return this.eParentElement.firstChild;
  }
  destroy() {
    this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy();
    const e = this.portal;
    e && this.portalManager.destroyPortal(e);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), i = document.createElement(t || "div");
    return i.classList.add("ag-react-container"), e.reactContainer = i, i;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && (F('Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.'), Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle())), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && (F('Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.'), this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t))));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] != null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const i = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent()) return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!i) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const s = i[e];
    if (s) return s.apply(i, t);
    if (this.fallbackMethodAvailable(e)) return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.createOrUpdatePortal(e), new oe((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (this.ref = (t) => {
      var _a3;
      this.componentInstance = t, this.addParentContainerStyleAndClasses(), (_a3 = this.resolveInstanceCreated) == null ? void 0 : _a3.call(this, true), this.resolveInstanceCreated = void 0;
    }, e.ref = this.ref), this.reactElement = this.createElement(this.reactComponent, { ...e, key: this.key }), this.portal = yr.createPortal(this.reactElement, this.eParentElement, this.portalKey);
  }
  createElement(e, t) {
    return p.createElement(e, t);
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, e);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const i = this[`${e}Component`];
    if (!this.suppressFallbackMethods && i) return i.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return this.suppressFallbackMethods ? false : !!this[`${e}Component`];
  }
};
function Oo(e, t, i) {
  e.forEach((s) => {
    const o = t[s];
    o && (i[s] = o);
  });
}
var Ye = class extends ml {
  constructor() {
    super(...arguments), this.awaitUpdateCallback = new oe((e) => {
      this.resolveUpdateCallback = e;
    }), this.wrapperComponent = xC;
  }
  init(e) {
    return this.sourceParams = e, super.init(this.getProps());
  }
  addMethod() {
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  getFrameworkComponentInstance() {
    return this;
  }
  createElement(e, t) {
    return super.createElement(this.wrapperComponent, { initialProps: t, CustomComponentClass: e, setMethods: (i) => this.setMethods(i), addUpdateCallback: (i) => {
      this.updateCallback = () => (i(this.getProps()), new oe((s) => {
        setTimeout(() => {
          s();
        });
      })), this.resolveUpdateCallback();
    } });
  }
  setMethods(e) {
    this.providedMethods = e, Oo(this.getOptionalMethods(), this.providedMethods, this);
  }
  getOptionalMethods() {
    return [];
  }
  getProps() {
    return { ...this.sourceParams, key: this.key, ref: this.ref };
  }
  refreshProps() {
    return this.updateCallback ? this.updateCallback() : new oe((e) => this.awaitUpdateCallback.then(() => {
      this.updateCallback().then(() => e());
    }));
  }
}, TC = class extends Ye {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), true;
  }
}, IC = class extends Ye {
  constructor() {
    super(...arguments), this.date = null, this.onDateChange = (e) => this.updateDate(e);
  }
  getDate() {
    return this.date;
  }
  setDate(e) {
    this.date = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled"];
  }
  updateDate(e) {
    this.setDate(e), this.sourceParams.onDateChanged();
  }
  getProps() {
    const e = super.getProps();
    return e.date = this.date, e.onDateChange = this.onDateChange, delete e.onDateChanged, e;
  }
}, LC = class extends Ye {
  constructor() {
    super(...arguments), this.label = "", this.icon = null, this.shake = false;
  }
  setIcon(e, t) {
    this.icon = e, this.shake = t, this.refreshProps();
  }
  setLabel(e) {
    this.label = e, this.refreshProps();
  }
  getProps() {
    const e = super.getProps(), { label: t, icon: i, shake: s } = this;
    return e.label = t, e.icon = i, e.shake = s, e;
  }
}, OC = class extends Ye {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e), this.onUiChange = () => this.sourceParams.filterChangedCallback(), this.expectingNewMethods = true, this.hasBeenActive = false;
  }
  isFilterActive() {
    return this.model != null;
  }
  doesFilterPass(e) {
    return this.providedMethods.doesFilterPass(e);
  }
  getModel() {
    return this.model;
  }
  setModel(e) {
    return this.expectingNewMethods = true, this.model = e, this.hasBeenActive || (this.hasBeenActive = this.isFilterActive()), this.refreshProps();
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), true;
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onAnyFilterChanged"];
  }
  setMethods(e) {
    var _a3;
    this.expectingNewMethods === false && this.hasBeenActive && ((_a3 = this.providedMethods) == null ? void 0 : _a3.doesFilterPass) !== (e == null ? void 0 : e.doesFilterPass) && setTimeout(() => {
      this.sourceParams.filterChangedCallback();
    }), this.expectingNewMethods = false, super.setMethods(e);
  }
  updateModel(e) {
    this.setModel(e).then(() => this.sourceParams.filterChangedCallback());
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e.onUiChange = this.onUiChange, delete e.filterChangedCallback, delete e.filterModifiedCallback, delete e.valueGetter, e;
  }
};
function Cl(e, t) {
  e.parentFilterInstance((i) => {
    (i.setModel(t) || oe.resolve()).then(() => {
      e.filterParams.filterChangedCallback();
    });
  });
}
var GC = class {
  constructor(e, t) {
    this.floatingFilterParams = e, this.refreshProps = t, this.model = null, this.onModelChange = (i) => this.updateModel(i);
  }
  getProps() {
    return { ...this.floatingFilterParams, model: this.model, onModelChange: this.onModelChange };
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.floatingFilterParams = e, this.refreshProps();
  }
  setMethods(e) {
    Oo(this.getOptionalMethods(), e, this);
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), Cl(this.floatingFilterParams, e);
  }
}, kC = class extends Ye {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e);
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), Cl(this.sourceParams, e);
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e;
  }
}, HC = class extends Ye {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, NC = class extends Ye {
  constructor() {
    super(...arguments), this.active = false, this.expanded = false, this.onActiveChange = (e) => this.updateActive(e);
  }
  setActive(e) {
    this.awaitSetActive(e);
  }
  setExpanded(e) {
    this.expanded = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["select", "configureDefaults"];
  }
  awaitSetActive(e) {
    return this.active = e, this.refreshProps();
  }
  updateActive(e) {
    const t = this.awaitSetActive(e);
    e && t.then(() => this.sourceParams.onItemActivated());
  }
  getProps() {
    const e = super.getProps();
    return e.active = this.active, e.expanded = this.expanded, e.onActiveChange = this.onActiveChange, delete e.onItemActivated, e;
  }
}, VC = class extends Ye {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, BC = class extends Ye {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), true;
  }
}, WC = class extends Ye {
  constructor() {
    super(...arguments), this.onStateChange = (e) => this.updateState(e);
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), true;
  }
  getState() {
    return this.state;
  }
  updateState(e) {
    this.state = e, this.refreshProps(), this.sourceParams.onStateUpdated();
  }
  getProps() {
    const e = super.getProps();
    return e.state = this.state, e.onStateChange = this.onStateChange, e;
  }
};
function Go() {
  F("As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.");
}
var zC = 1e3, _C = class {
  constructor(e, t, i) {
    this.destroyed = false, this.portals = [], this.hasPendingPortalUpdate = false, this.wrappingElement = t || "div", this.refresher = e, this.maxComponentCreationTimeMs = i || zC;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = true;
  }
  destroyPortal(e) {
    this.portals = this.portals.filter((t) => t !== e), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(e, t, i) {
    this.portals = [...this.portals, e], this.waitForInstance(t, i), this.batchUpdate();
  }
  updateReactPortal(e, t) {
    this.portals[this.portals.indexOf(e)] = t, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || (this.refresher(), this.hasPendingPortalUpdate = false);
    }), this.hasPendingPortalUpdate = true);
  }
  waitForInstance(e, t, i = Date.now()) {
    if (this.destroyed) {
      t(null);
      return;
    }
    if (e.rendered()) t(e);
    else {
      if (Date.now() - i >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) return;
      window.setTimeout(() => {
        this.waitForInstance(e, t, i);
      });
    }
  }
}, UC = ({ ctrl: e }) => {
  const t = e.isAlive(), { context: i } = p.useContext(me), s = t ? e.getColId() : void 0, [o, r] = p.useState(), n = p.useRef(), l = p.useRef(null), a = p.useRef(null), c = p.useRef(null), u = p.useRef(), d = p.useRef();
  t && !d.current && (d.current = new wi(() => l.current));
  const h = p.useCallback((f) => {
    var _a3;
    if (l.current = f, n.current = f ? i.createBean(new Kt()) : i.destroyBean(n.current), !f || !t) return;
    const v = { setWidth: (S) => {
      l.current && (l.current.style.width = S);
    }, addOrRemoveCssClass: (S, b) => d.current.addOrRemoveCssClass(S, b), setAriaSort: (S) => {
      l.current && (S ? La(l.current, S) : Oa(l.current));
    }, setUserCompDetails: (S) => r(S), getUserCompInstance: () => u.current || void 0 };
    e.setComp(v, f, a.current, c.current, n.current);
    const w = e.getSelectAllGui();
    (_a3 = a.current) == null ? void 0 : _a3.insertAdjacentElement("afterend", w), n.current.addDestroyFunc(() => w.remove());
  }, []);
  p.useLayoutEffect(() => Fi(o, i, c.current, u), [o]), p.useEffect(() => {
    e.setDragSource(l.current);
  }, [o]);
  const g = p.useMemo(() => !!((o == null ? void 0 : o.componentFromFramework) && Yt(o.componentClass)), [o]), m = o && o.componentFromFramework, C = o && o.componentClass;
  return D.createElement("div", { ref: h, className: "ag-header-cell", "col-id": s, role: "columnheader" }, D.createElement("div", { ref: a, className: "ag-header-cell-resize", role: "presentation" }), D.createElement("div", { ref: c, className: "ag-header-cell-comp-wrapper", role: "presentation" }, m && g && D.createElement(C, { ...o.params }), m && !g && D.createElement(C, { ...o.params, ref: u })));
}, KC = p.memo(UC), $C = ({ ctrl: e }) => {
  const { context: t, gos: i } = p.useContext(me), [s, o] = p.useState(() => new Ie("ag-header-cell", "ag-floating-filter")), [r, n] = p.useState(() => new Ie()), [l, a] = p.useState(() => new Ie("ag-floating-filter-button", "ag-hidden")), [c, u] = p.useState("false"), [d, h] = p.useState(), [, g] = p.useState(1), m = p.useRef(), C = p.useRef(null), f = p.useRef(null), v = p.useRef(null), w = p.useRef(null), S = p.useRef(), b = p.useRef(), x = (_) => {
    _ != null && S.current && S.current(_);
  }, M = p.useCallback((_) => {
    if (C.current = _, m.current = _ ? t.createBean(new Kt()) : t.destroyBean(m.current), !_) return;
    b.current = new oe((K) => {
      S.current = K;
    });
    const U = { addOrRemoveCssClass: (K, se) => o(($) => $.setClass(K, se)), addOrRemoveBodyCssClass: (K, se) => n(($) => $.setClass(K, se)), setButtonWrapperDisplayed: (K) => {
      a((se) => se.setClass("ag-hidden", !K)), u(K ? "false" : "true");
    }, setWidth: (K) => {
      C.current && (C.current.style.width = K);
    }, setCompDetails: (K) => h(K), getFloatingFilterComp: () => b.current ? b.current : null, setMenuIcon: (K) => {
      var _a3;
      return (_a3 = w.current) == null ? void 0 : _a3.appendChild(K);
    } };
    e.setComp(U, _, w.current, f.current, m.current);
  }, []);
  p.useLayoutEffect(() => Fi(d, t, f.current, x), [d]);
  const P = p.useMemo(() => s.toString(), [s]), A = p.useMemo(() => r.toString(), [r]), I = p.useMemo(() => l.toString(), [l]), T = p.useMemo(() => !!(d && d.componentFromFramework && Yt(d.componentClass)), [d]), L = p.useMemo(() => i.get("reactiveCustomComponents"), []), W = p.useMemo(() => {
    if (d) if (L) {
      const _ = new GC(d.params, () => g((U) => U + 1));
      return x(_), _;
    } else d.componentFromFramework && Go();
  }, [d]), ge = W == null ? void 0 : W.getProps(), j = d && d.componentFromFramework, ie = d && d.componentClass;
  return D.createElement("div", { ref: M, className: P, role: "gridcell" }, D.createElement("div", { ref: f, className: A, role: "presentation" }, j && !L && D.createElement(ie, { ...d.params, ref: T ? () => {
  } : x }), j && L && D.createElement(Lo.Provider, { value: { setMethods: (_) => W.setMethods(_) } }, D.createElement(ie, { ...ge }))), D.createElement("div", { ref: v, "aria-hidden": c, className: I, role: "presentation" }, D.createElement("button", { ref: w, type: "button", className: "ag-button ag-floating-filter-button-button", tabIndex: -1 })));
}, jC = p.memo($C), qC = ({ ctrl: e }) => {
  const { context: t } = p.useContext(me), [i, s] = p.useState(() => new Ie()), [o, r] = p.useState(() => new Ie()), [n, l] = p.useState("false"), [a, c] = p.useState(), [u, d] = p.useState(), h = p.useMemo(() => e.getColId(), []), g = p.useRef(), m = p.useRef(null), C = p.useRef(null), f = p.useRef(null), v = p.useRef(), w = p.useCallback((A) => {
    if (m.current = A, g.current = A ? t.createBean(new Kt()) : t.destroyBean(g.current), !A) return;
    const I = { setWidth: (T) => {
      m.current && (m.current.style.width = T);
    }, addOrRemoveCssClass: (T, L) => s((W) => W.setClass(T, L)), setHeaderWrapperHidden: (T) => {
      const L = f.current;
      L && (T ? L.style.setProperty("display", "none") : L.style.removeProperty("display"));
    }, setHeaderWrapperMaxHeight: (T) => {
      const L = f.current;
      L && (T != null ? L.style.setProperty("max-height", `${T}px`) : L.style.removeProperty("max-height"), L.classList.toggle("ag-header-cell-comp-wrapper-limited-height", T != null));
    }, setUserCompDetails: (T) => d(T), setResizableDisplayed: (T) => {
      r((L) => L.setClass("ag-hidden", !T)), l(T ? "false" : "true");
    }, setAriaExpanded: (T) => c(T), getUserCompInstance: () => v.current || void 0 };
    e.setComp(I, A, C.current, f.current, g.current);
  }, []);
  p.useLayoutEffect(() => Fi(u, t, f.current), [u]), p.useEffect(() => {
    m.current && e.setDragSource(m.current);
  }, [u]);
  const S = p.useMemo(() => !!((u == null ? void 0 : u.componentFromFramework) && Yt(u.componentClass)), [u]), b = p.useMemo(() => "ag-header-group-cell " + i.toString(), [i]), x = p.useMemo(() => "ag-header-cell-resize " + o.toString(), [o]), M = u && u.componentFromFramework, P = u && u.componentClass;
  return D.createElement("div", { ref: w, className: b, "col-id": h, role: "columnheader", "aria-expanded": a }, D.createElement("div", { ref: f, className: "ag-header-cell-comp-wrapper", role: "presentation" }, M && S && D.createElement(P, { ...u.params }), M && !S && D.createElement(P, { ...u.params, ref: v })), D.createElement("div", { ref: C, "aria-hidden": n, className: x }));
}, YC = p.memo(qC), QC = ({ ctrl: e }) => {
  const { context: t } = p.useContext(me), { topOffset: i, rowHeight: s } = p.useMemo(() => e.getTopAndHeight(), []), o = e.getAriaRowIndex(), r = e.getHeaderRowClass(), [n, l] = p.useState(() => s + "px"), [a, c] = p.useState(() => i + "px"), u = p.useRef(null), d = p.useRef(null), [h, g] = p.useState(() => e.getHeaderCtrls()), m = p.useRef(), C = p.useRef(null), f = p.useCallback((S) => {
    if (C.current = S, m.current = S ? t.createBean(new Kt()) : t.destroyBean(m.current), !S) return;
    const b = { setHeight: (x) => l(x), setTop: (x) => c(x), setHeaderCtrls: (x, M, P) => {
      d.current = u.current, u.current = x;
      const A = Io(d.current, x, M);
      A !== d.current && To(P, () => g(A));
    }, setWidth: (x) => {
      C.current && (C.current.style.width = x);
    } };
    e.setComp(b, m.current, false);
  }, []), v = p.useMemo(() => ({ height: n, top: a }), [n, a]), w = p.useCallback((S) => {
    switch (e.getType()) {
      case Ks.COLUMN_GROUP:
        return D.createElement(YC, { ctrl: S, key: S.instanceId });
      case Ks.FLOATING_FILTER:
        return D.createElement(jC, { ctrl: S, key: S.instanceId });
      default:
        return D.createElement(KC, { ctrl: S, key: S.instanceId });
    }
  }, []);
  return D.createElement("div", { ref: f, className: r, role: "row", style: v, "aria-rowindex": o }, h.map(w));
}, XC = p.memo(QC), JC = ({ pinned: e }) => {
  const [t, i] = p.useState(true), [s, o] = p.useState([]), { context: r } = p.useContext(me), n = p.useRef(null), l = p.useRef(null), a = p.useRef(), c = e === "left", u = e === "right", d = !c && !u, h = p.useCallback((C) => {
    if (n.current = C, a.current = C ? r.createBean(new fd(e)) : r.destroyBean(a.current), !C) return;
    const f = { setDisplayed: i, setCtrls: (v) => o(v), setCenterWidth: (v) => {
      l.current && (l.current.style.width = v);
    }, setViewportScrollLeft: (v) => {
      n.current && (n.current.scrollLeft = v);
    }, setPinnedContainerWidth: (v) => {
      n.current && (n.current.style.width = v, n.current.style.minWidth = v, n.current.style.maxWidth = v);
    } };
    a.current.setComp(f, n.current);
  }, []), g = t ? "" : "ag-hidden", m = () => s.map((C) => D.createElement(XC, { ctrl: C, key: C.instanceId }));
  return D.createElement(D.Fragment, null, c && D.createElement("div", { ref: h, className: "ag-pinned-left-header " + g, "aria-hidden": !t, role: "rowgroup" }, m()), u && D.createElement("div", { ref: h, className: "ag-pinned-right-header " + g, "aria-hidden": !t, role: "rowgroup" }, m()), d && D.createElement("div", { ref: h, className: "ag-header-viewport " + g, role: "presentation" }, D.createElement("div", { ref: l, className: "ag-header-container", role: "rowgroup" }, m())));
}, Ds = p.memo(JC), ZC = () => {
  const [e, t] = p.useState(() => new Ie()), [i, s] = p.useState(), { context: o } = p.useContext(me), r = p.useRef(null), n = p.useRef(), l = p.useCallback((u) => {
    if (r.current = u, n.current = u ? o.createBean(new Ju()) : o.destroyBean(n.current), !u) return;
    const d = { addOrRemoveCssClass: (h, g) => t((m) => m.setClass(h, g)), setHeightAndMinHeight: (h) => s(h) };
    n.current.setComp(d, u, u);
  }, []), a = p.useMemo(() => "ag-header " + e.toString(), [e]), c = p.useMemo(() => ({ height: i, minHeight: i }), [i]);
  return D.createElement("div", { ref: l, className: a, style: c, role: "presentation" }, D.createElement(Ds, { pinned: "left" }), D.createElement(Ds, { pinned: null }), D.createElement(Ds, { pinned: "right" }));
}, ev = p.memo(ZC), tv = (e, t) => {
  p.useEffect(() => {
    const i = t.current;
    if (i) {
      const s = i.parentElement;
      if (s) {
        const o = document.createComment(e);
        return s.insertBefore(o, i), () => {
          s.removeChild(o);
        };
      }
    }
  }, [e]);
}, St = tv, iv = class {
  constructor(e, t) {
    this.cellEditorParams = e, this.refreshProps = t, this.instanceCreated = new oe((i) => {
      this.resolveInstanceCreated = i;
    }), this.onValueChange = (i) => this.updateValue(i), this.value = e.value;
  }
  getProps() {
    return { ...this.cellEditorParams, initialValue: this.cellEditorParams.value, value: this.value, onValueChange: this.onValueChange };
  }
  getValue() {
    return this.value;
  }
  refresh(e) {
    this.cellEditorParams = e, this.refreshProps();
  }
  setMethods(e) {
    Oo(this.getOptionalMethods(), e, this);
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  setRef(e) {
    var _a3;
    this.componentInstance = e, (_a3 = this.resolveInstanceCreated) == null ? void 0 : _a3.call(this), this.resolveInstanceCreated = void 0;
  }
  getOptionalMethods() {
    return ["isCancelBeforeStart", "isCancelAfterEnd", "focusIn", "focusOut", "afterGuiAttached"];
  }
  updateValue(e) {
    this.value = e, this.refreshProps();
  }
}, sv = (e) => {
  const t = p.useRef(e), i = p.useRef(), s = p.useRef(false), o = p.useRef(false), [, r] = p.useState(0);
  s.current && (o.current = true), p.useEffect(() => (s.current || (i.current = t.current(), s.current = true), r((n) => n + 1), () => {
    var _a3;
    o.current && ((_a3 = i.current) == null ? void 0 : _a3.call(i));
  }), []);
}, ov = (e) => {
  const [t, i] = p.useState(), { context: s, popupService: o, localeService: r, gos: n, editService: l } = p.useContext(me);
  return sv(() => {
    var _a3, _b;
    const { editDetails: a, cellCtrl: c, eParentCell: u } = e, { compDetails: d } = a, h = n.get("stopEditingWhenCellsLoseFocus"), g = s.createBean(l.createPopupEditorWrapper(d.params)), m = g.getGui();
    if (e.jsChildComp) {
      const b = e.jsChildComp.getGui();
      b && m.appendChild(b);
    }
    const C = { column: c.getColumn(), rowNode: c.getRowNode(), type: "popupCellEditor", eventSource: u, ePopup: m, position: a.popupPosition, keepWithinBounds: true }, f = o.positionPopupByComponent.bind(o, C), v = r.getLocaleTextFunc(), w = o.addPopup({ modal: h, eChild: m, closeOnEsc: true, closedCallback: () => {
      c.onPopupEditorClosed();
    }, anchorToElement: u, positionCallback: f, ariaLabel: v("ariaLabelCellEditor", "Cell Editor") }), S = w ? w.hideFunc : void 0;
    return i(g), (_b = (_a3 = e.jsChildComp) == null ? void 0 : _a3.afterGuiAttached) == null ? void 0 : _b.call(_a3), () => {
      S == null ? void 0 : S(), s.destroyBean(g);
    };
  }), D.createElement(D.Fragment, null, t && e.wrappedContent && yr.createPortal(e.wrappedContent, t.getGui()));
}, vr = p.memo(ov), rv = (e, t, i, s, o, r) => {
  const { context: n } = p.useContext(me), l = p.useCallback(() => {
    const a = o.current;
    if (!a) return;
    const c = a.getGui();
    c && c.parentElement && c.parentElement.removeChild(c), n.destroyBean(a), o.current = void 0;
  }, []);
  p.useEffect(() => {
    const a = e != null, c = (e == null ? void 0 : e.compDetails) && !e.compDetails.componentFromFramework, u = t && i == null;
    if (!(a && c && !u)) {
      l();
      return;
    }
    const h = e.compDetails;
    if (o.current) {
      const m = o.current, f = m.refresh != null && e.force == false ? m.refresh(h.params) : false;
      if (f === true || f === void 0) return;
      l();
    }
    const g = h.newAgStackInstance();
    g == null ? void 0 : g.then((m) => {
      if (!m) return;
      const C = m.getGui();
      if (!C) return;
      (t ? i : r.current).appendChild(C), o.current = m;
    });
  }, [e, t, s]), p.useEffect(() => l, []);
}, nv = rv, lv = (e, t, i) => {
  const { compProxy: s } = e;
  i(s);
  const o = s.getProps(), r = Yt(t);
  return D.createElement(Lo.Provider, { value: { setMethods: (n) => s.setMethods(n) } }, r ? D.createElement(t, { ...o }) : D.createElement(t, { ...o, ref: (n) => s.setRef(n) }));
}, Sr = (e, t, i) => {
  const s = e.compProxy;
  return D.createElement(D.Fragment, null, s ? lv(e, t, i) : D.createElement(t, { ...e.compDetails.params, ref: i }));
}, av = (e, t, i, s, o) => {
  const r = e.compDetails, n = r.componentClass, l = r.componentFromFramework && !e.popup, a = r.componentFromFramework && e.popup, c = !r.componentFromFramework && e.popup;
  return D.createElement(D.Fragment, null, l && Sr(e, n, t), a && D.createElement(vr, { editDetails: e, cellCtrl: s, eParentCell: i, wrappedContent: Sr(e, n, t) }), c && o && D.createElement(vr, { editDetails: e, cellCtrl: s, eParentCell: i, jsChildComp: o }));
}, cv = (e, t, i, s, o, r, n) => {
  const { compDetails: l, value: a } = e, c = !l, u = l && l.componentFromFramework, d = l && l.componentClass, h = (a == null ? void 0 : a.toString) ? a.toString() : a, g = () => D.createElement(D.Fragment, null, c && D.createElement(D.Fragment, null, h), u && !r && D.createElement(d, { ...l.params, key: t, ref: s }), u && r && D.createElement(d, { ...l.params, key: t }));
  return D.createElement(D.Fragment, null, o ? D.createElement("span", { role: "presentation", id: `cell-${i}`, className: "ag-cell-value", ref: n }, g()) : g());
}, uv = ({ cellCtrl: e, printLayout: t, editingRow: i }) => {
  const { context: s } = p.useContext(me), { colIdSanitised: o, instanceId: r } = e, n = p.useRef(), [l, a] = p.useState(() => e.isCellRenderer() ? void 0 : { compDetails: void 0, value: e.getValueToDisplay(), force: false }), [c, u] = p.useState(), [d, h] = p.useState(1), [g, m] = p.useState(), [C, f] = p.useState(false), [v, w] = p.useState(false), [S, b] = p.useState(false), [x, M] = p.useState(), P = p.useMemo(() => e.isForceWrapper(), [e]), A = p.useMemo(() => e.getCellAriaRole(), [e]), I = p.useRef(null), T = p.useRef(null), L = p.useRef(), W = p.useRef(), ge = p.useRef(), j = p.useRef([]), ie = p.useRef(), [_, U] = p.useState(0), K = p.useCallback((Z) => {
    ie.current = Z, U((de) => de + 1);
  }, []), se = l != null && (C || S || v), $ = P || se, J = p.useCallback((Z) => {
    if (W.current = Z, Z) {
      const de = Z.isCancelBeforeStart && Z.isCancelBeforeStart();
      setTimeout(() => {
        de ? (e.stopEditing(true), e.focusCell(true)) : e.cellEditorAttached();
      });
    }
  }, [e]), X = p.useRef();
  X.current || (X.current = new wi(() => I.current)), nv(l, $, ie.current, _, L, I);
  const Ae = p.useRef();
  p.useLayoutEffect(() => {
    var _a3;
    const Z = Ae.current, de = l;
    if (Ae.current = l, Z == null || Z.compDetails == null || de == null || de.compDetails == null) return;
    const pe = Z.compDetails, q = de.compDetails;
    if (pe.componentClass != q.componentClass || ((_a3 = T.current) == null ? void 0 : _a3.refresh) == null) return;
    T.current.refresh(q.params) != true && h((Pe) => Pe + 1);
  }, [l]), p.useLayoutEffect(() => {
    if (!(c && !c.compDetails.componentFromFramework)) return;
    const de = c.compDetails, pe = c.popup === true, q = de.newAgStackInstance();
    return q.then((ue) => {
      var _a3;
      if (!ue) return;
      const Pe = ue.getGui();
      J(ue), pe || ((_a3 = (P ? ge : I).current) == null ? void 0 : _a3.appendChild(Pe), ue.afterGuiAttached && ue.afterGuiAttached()), M(ue);
    }), () => {
      q.then((ue) => {
        var _a3;
        const Pe = ue.getGui();
        s.destroyBean(ue), J(void 0), M(void 0), (_a3 = Pe == null ? void 0 : Pe.parentElement) == null ? void 0 : _a3.removeChild(Pe);
      });
    };
  }, [c]);
  const k = p.useCallback((Z) => {
    if (ge.current = Z, !Z) {
      j.current.forEach((pe) => pe()), j.current = [];
      return;
    }
    const de = (pe) => {
      if (pe) {
        const q = pe.getGui();
        Z.insertAdjacentElement("afterbegin", q), j.current.push(() => {
          s.destroyBean(pe), Mt(q);
        });
      }
      return pe;
    };
    if (C) {
      const pe = e.createSelectionCheckbox();
      de(pe);
    }
    S && de(e.createDndSource()), v && de(e.createRowDragComp());
  }, [e, s, S, v, C]), ce = p.useCallback((Z) => {
    if (I.current = Z, n.current = Z ? s.createBean(new Kt()) : s.destroyBean(n.current), !Z || !e) return;
    const de = { addOrRemoveCssClass: (q, ue) => X.current.addOrRemoveCssClass(q, ue), setUserStyles: (q) => m(q), getFocusableElement: () => I.current, setIncludeSelection: (q) => f(q), setIncludeRowDrag: (q) => w(q), setIncludeDndSource: (q) => b(q), getCellEditor: () => W.current || null, getCellRenderer: () => T.current ?? L.current, getParentOfValue: () => ie.current ?? ge.current ?? I.current, setRenderDetails: (q, ue, Pe) => {
      a((Qe) => (Qe == null ? void 0 : Qe.compDetails) !== q || (Qe == null ? void 0 : Qe.value) !== ue || (Qe == null ? void 0 : Qe.force) !== Pe ? { value: ue, compDetails: q, force: Pe } : Qe);
    }, setEditDetails: (q, ue, Pe, Qe) => {
      if (q) {
        let Ot;
        Qe ? Ot = new iv(q.params, () => h((us) => us + 1)) : q.componentFromFramework && Go(), u({ compDetails: q, popup: ue, popupPosition: Pe, compProxy: Ot }), ue || a(void 0);
      } else u((Ot) => {
        (Ot == null ? void 0 : Ot.compProxy) && (W.current = void 0);
      });
    } }, pe = ge.current || void 0;
    e.setComp(de, Z, pe, t, i, n.current);
  }, []), ne = p.useMemo(() => {
    var _a3;
    return !!(((_a3 = l == null ? void 0 : l.compDetails) == null ? void 0 : _a3.componentFromFramework) && Yt(l.compDetails.componentClass));
  }, [l]);
  p.useLayoutEffect(() => {
    var _a3;
    I.current && (X.current.addOrRemoveCssClass("ag-cell-value", !$), X.current.addOrRemoveCssClass("ag-cell-inline-editing", !!c && !c.popup), X.current.addOrRemoveCssClass("ag-cell-popup-editing", !!c && !!c.popup), X.current.addOrRemoveCssClass("ag-cell-not-inline-editing", !c || !!c.popup), (_a3 = e.getRowCtrl()) == null ? void 0 : _a3.setInlineEditingCss(), e.shouldRestoreFocus() && !e.isEditing() && I.current.focus({ preventScroll: true }));
  });
  const Be = () => D.createElement(D.Fragment, null, l != null && cv(l, d, r, T, $, ne, K), c != null && av(c, J, I.current, e, x)), Lt = p.useCallback(() => e.onFocusOut(), []);
  return D.createElement("div", { ref: ce, style: g, role: A, "col-id": o, onBlur: Lt }, $ ? D.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: k }, Be()) : Be());
}, dv = p.memo(uv), hv = ({ rowCtrl: e, containerType: t }) => {
  const { context: i, gos: s } = p.useContext(me), o = p.useRef(), r = p.useRef(e.getDomOrder()), n = e.isFullWidth(), l = e.getRowNode().displayed, [a, c] = p.useState(() => l ? e.getRowIndex() : null), [u, d] = p.useState(() => e.getRowId()), [h, g] = p.useState(() => e.getBusinessKey()), [m, C] = p.useState(() => e.getRowStyles()), f = p.useRef(null), v = p.useRef(null), [w, S] = p.useState(() => null), [b, x] = p.useState(), [M, P] = p.useState(() => l ? e.getInitialRowTop(t) : void 0), [A, I] = p.useState(() => l ? e.getInitialTransform(t) : void 0), T = p.useRef(null), L = p.useRef(), W = p.useRef(false), [ge, j] = p.useState(0);
  p.useEffect(() => {
    var _a3;
    if (W.current || !b || ge > 10) return;
    const k = (_a3 = T.current) == null ? void 0 : _a3.firstChild;
    k ? (e.setupDetailRowAutoHeight(k), W.current = true) : j((ce) => ce + 1);
  }, [b, ge]);
  const ie = p.useRef();
  ie.current || (ie.current = new wi(() => T.current));
  const _ = p.useCallback((k) => {
    if (T.current = k, o.current = k ? i.createBean(new Kt()) : i.destroyBean(o.current), !k) {
      e.unsetComp(t);
      return;
    }
    if (!e.isAlive()) return;
    const ce = { setTop: P, setTransform: I, addOrRemoveCssClass: (ne, Be) => ie.current.addOrRemoveCssClass(ne, Be), setDomOrder: (ne) => r.current = ne, setRowIndex: c, setRowId: d, setRowBusinessKey: g, setUserStyles: C, setCellCtrls: (ne, Be) => {
      v.current = f.current, f.current = ne;
      const Lt = Io(v.current, ne, r.current);
      Lt !== v.current && To(Be, () => S(Lt));
    }, showFullWidth: (ne) => x(ne), getFullWidthCellRenderer: () => L.current, refreshFullWidth: (ne) => J.current ? (x((Be) => ({ ...Be, params: ne() })), true) : !L.current || !L.current.refresh ? false : L.current.refresh(ne()) };
    e.setComp(ce, k, t, o.current);
  }, []);
  p.useLayoutEffect(() => Fi(b, i, T.current, L), [b]);
  const U = p.useMemo(() => {
    const k = { top: M, transform: A };
    return Object.assign(k, m), k;
  }, [M, A, m]), K = n && (b == null ? void 0 : b.componentFromFramework), se = !n && w != null, $ = p.useMemo(() => !!((b == null ? void 0 : b.componentFromFramework) && Yt(b.componentClass)), [b]), J = p.useRef(false);
  p.useEffect(() => {
    J.current = $ && !!b && !!s.get("reactiveCustomComponents");
  }, [$, b]);
  const X = () => w == null ? void 0 : w.map((k) => D.createElement(dv, { cellCtrl: k, editingRow: e.isEditing(), printLayout: e.isPrintLayout(), key: k.instanceId })), Ae = () => {
    const k = b.componentClass;
    return D.createElement(D.Fragment, null, $ ? D.createElement(k, { ...b.params }) : D.createElement(k, { ...b.params, ref: L }));
  };
  return D.createElement("div", { ref: _, role: "row", style: U, "row-index": a, "row-id": u, "row-business-key": h }, se && X(), K && Ae());
}, gv = p.memo(hv), pv = ({ name: e }) => {
  const { context: t } = p.useContext(me), i = p.useMemo(() => Ht(e), [e]), s = p.useRef(null), o = p.useRef(null), r = p.useRef([]), n = p.useRef([]), [l, a] = p.useState(() => []), c = p.useRef(false), u = p.useRef(), d = p.useMemo(() => ke(i.viewport), [i]), h = p.useMemo(() => ke(i.container), [i]), g = i.type === "center", m = g ? s : o;
  St(" AG Row Container " + e + " ", m);
  const C = p.useCallback(() => g ? s.current != null && o.current != null : o.current != null, []), f = p.useCallback(() => g ? s.current == null && o.current == null : o.current == null, []), v = p.useCallback(() => {
    if (f() && (u.current = t.destroyBean(u.current)), C()) {
      const x = (P) => {
        const A = Io(n.current, r.current, c.current);
        A !== n.current && (n.current = A, To(P, () => a(A)));
      }, M = { setHorizontalScroll: (P) => {
        s.current && (s.current.scrollLeft = P);
      }, setViewportHeight: (P) => {
        s.current && (s.current.style.height = P);
      }, setRowCtrls: ({ rowCtrls: P, useFlushSync: A }) => {
        const I = !!A && r.current.length > 0 && P.length > 0;
        r.current = P, x(I);
      }, setDomOrder: (P) => {
        c.current != P && (c.current = P, x(false));
      }, setContainerWidth: (P) => {
        o.current && (o.current.style.width = P);
      }, setOffsetTop: (P) => {
        o.current && (o.current.style.transform = `translateY(${P})`);
      } };
      u.current = t.createBean(new lh(e)), u.current.setComp(M, o.current, s.current);
    }
  }, [C, f]), w = p.useCallback((x) => {
    o.current = x, v();
  }, [v]), S = p.useCallback((x) => {
    s.current = x, v();
  }, [v]), b = () => D.createElement("div", { className: h, ref: w, role: "rowgroup" }, l.map((x) => D.createElement(gv, { rowCtrl: x, containerType: i.type, key: x.instanceId })));
  return D.createElement(D.Fragment, null, g ? D.createElement("div", { className: d, ref: S, role: "presentation" }, b()) : b());
}, fv = p.memo(pv), mv = () => {
  const { context: e, resizeObserverService: t } = p.useContext(me), [i, s] = p.useState(""), [o, r] = p.useState(0), [n, l] = p.useState(0), [a, c] = p.useState("0px"), [u, d] = p.useState("0px"), [h, g] = p.useState("100%"), [m, C] = p.useState("0px"), [f, v] = p.useState("0px"), [w, S] = p.useState("100%"), [b, x] = p.useState(""), [M, P] = p.useState(""), [A, I] = p.useState(null), [T, L] = p.useState(""), [W, ge] = p.useState(null), [j, ie] = p.useState("ag-layout-normal"), _ = p.useRef();
  _.current || (_.current = new wi(() => U.current));
  const U = p.useRef(null), K = p.useRef(null), se = p.useRef(null), $ = p.useRef(null), J = p.useRef(null), X = p.useRef(null), Ae = p.useRef(null), k = p.useRef([]), ce = p.useRef([]);
  St(" AG Grid Body ", U), St(" AG Pinned Top ", K), St(" AG Sticky Top ", se), St(" AG Middle ", X), St(" AG Pinned Bottom ", Ae);
  const ne = p.useCallback((We) => {
    if (U.current = We, !We) {
      k.current = e.destroyBeans(k.current), ce.current.forEach((le) => le()), ce.current = [];
      return;
    }
    if (!e) return;
    const bi = (le, Ee) => {
      le.appendChild(Ee), ce.current.push(() => le.removeChild(Ee));
    }, ds = (le) => {
      const Ee = e.createBean(new le());
      return k.current.push(Ee), Ee;
    }, Xt = (le, Ee, Fl) => {
      bi(le, document.createComment(Fl)), bi(le, ds(Ee).getGui());
    };
    Xt(We, Cd, " AG Fake Horizontal Scroll "), Xt(We, md, " AG Overlay Wrapper "), J.current && Xt(J.current, vd, " AG Fake Vertical Scroll ");
    const Rl = { setRowAnimationCssOnBodyViewport: s, setColumnCount: (le) => {
      U.current && Ta(U.current, le);
    }, setRowCount: (le) => {
      U.current && xa(U.current, le);
    }, setTopHeight: r, setBottomHeight: l, setStickyTopHeight: c, setStickyTopTop: d, setStickyTopWidth: g, setTopDisplay: x, setBottomDisplay: P, setColumnMovingCss: (le, Ee) => _.current.addOrRemoveCssClass(le, Ee), updateLayoutClasses: ie, setAlwaysVerticalScrollClass: I, setPinnedTopBottomOverflowY: L, setCellSelectableCss: (le, Ee) => ge(Ee ? le : null), setBodyViewportWidth: (le) => {
      X.current && (X.current.style.width = le);
    }, registerBodyViewportResizeListener: (le) => {
      if (X.current) {
        const Ee = t.observeResize(X.current, le);
        ce.current.push(() => Ee());
      }
    }, setStickyBottomHeight: C, setStickyBottomBottom: v, setStickyBottomWidth: S }, No = e.createBean(new dh());
    k.current.push(No), No.setComp(Rl, We, X.current, K.current, Ae.current, se.current, $.current);
  }, []), Be = p.useMemo(() => ke("ag-root", "ag-unselectable", j), [j]), Lt = p.useMemo(() => ke("ag-body-viewport", i, j, A, W), [i, j, A, W]), Z = p.useMemo(() => ke("ag-body", j), [j]), de = p.useMemo(() => ke("ag-floating-top", W), [W]), pe = p.useMemo(() => ke("ag-sticky-top", W), [W]), q = p.useMemo(() => ke("ag-sticky-bottom", m === "0px" ? "ag-hidden" : null, W), [W, m]), ue = p.useMemo(() => ke("ag-floating-bottom", W), [W]), Pe = p.useMemo(() => ({ height: o, minHeight: o, display: b, overflowY: T }), [o, b, T]), Qe = p.useMemo(() => ({ height: a, top: u, width: h }), [a, u, h]), Ot = p.useMemo(() => ({ height: m, bottom: f, width: w }), [m, f, w]), us = p.useMemo(() => ({ height: n, minHeight: n, display: M, overflowY: T }), [n, M, T]), yl = (We) => D.createElement(fv, { name: We, key: `${We}-container` }), Qt = ({ section: We, children: bi, className: ds, style: Xt }) => D.createElement("div", { ref: We, className: ds, role: "presentation", style: Xt }, bi.map(yl));
  return D.createElement("div", { ref: ne, className: Be, role: "treegrid" }, D.createElement(ev, null), Qt({ section: K, className: de, style: Pe, children: ["topLeft", "topCenter", "topRight", "topFullWidth"] }), D.createElement("div", { className: Z, ref: J, role: "presentation" }, Qt({ section: X, className: Lt, children: ["left", "center", "right", "fullWidth"] })), Qt({ section: se, className: pe, style: Qe, children: ["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"] }), Qt({ section: $, className: q, style: Ot, children: ["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"] }), Qt({ section: Ae, className: ue, style: us, children: ["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"] }));
}, Cv = p.memo(mv), vv = (e, t) => {
  const { children: i, eFocusableElement: s, onTabKeyDown: o, gridCtrl: r, forceFocusOutWhenTabGuardsAreEmpty: n } = e, { context: l } = p.useContext(me), a = p.useRef(null), c = p.useRef(null), u = p.useRef(), d = (f) => {
    const v = f == null ? void 0 : parseInt(f, 10).toString();
    [a, c].forEach((w) => {
      var _a3, _b;
      v === void 0 ? (_a3 = w.current) == null ? void 0 : _a3.removeAttribute("tabindex") : (_b = w.current) == null ? void 0 : _b.setAttribute("tabindex", v);
    });
  };
  p.useImperativeHandle(t, () => ({ forceFocusOutOfContainer(f) {
    var _a3;
    (_a3 = u.current) == null ? void 0 : _a3.forceFocusOutOfContainer(f);
  } }));
  const h = p.useCallback(() => {
    const f = a.current, v = c.current;
    if (!f && !v) {
      u.current = l.destroyBean(u.current);
      return;
    }
    if (f && v) {
      const w = { setTabIndex: d };
      u.current = l.createBean(new el({ comp: w, eTopGuard: f, eBottomGuard: v, eFocusableElement: s, onTabKeyDown: o, forceFocusOutWhenTabGuardsAreEmpty: n, focusInnerElement: (S) => r.focusInnerElement(S) }));
    }
  }, []), g = p.useCallback((f) => {
    a.current = f, h();
  }, [h]), m = p.useCallback((f) => {
    c.current = f, h();
  }, [h]), C = (f) => {
    const v = f === "top" ? ki.TAB_GUARD_TOP : ki.TAB_GUARD_BOTTOM;
    return D.createElement("div", { className: `${ki.TAB_GUARD} ${v}`, role: "presentation", ref: f === "top" ? g : m });
  };
  return D.createElement(D.Fragment, null, C("top"), i, C("bottom"));
}, Sv = p.forwardRef(vv), wv = p.memo(Sv), yv = ({ context: e }) => {
  const [t, i] = p.useState(""), [s, o] = p.useState(""), [r, n] = p.useState(""), [l, a] = p.useState(null), [c, u] = p.useState(null), [d, h] = p.useState(false), [g, m] = p.useState(), C = p.useRef(), f = p.useRef(null), v = p.useRef(), [w, S] = p.useState(null), b = p.useRef(() => {
  }), x = p.useRef(), M = p.useRef([]), P = p.useCallback(() => {
  }, []), A = p.useMemo(() => e.isDestroyed() ? null : e.getBeans(), [e]);
  St(" AG Grid ", f);
  const I = p.useCallback((j) => {
    if (f.current = j, C.current = j ? e.createBean(new Wg()) : e.destroyBean(C.current), !j || e.isDestroyed()) return;
    const ie = C.current;
    b.current = ie.focusInnerElement.bind(ie);
    const _ = { destroyGridUi: () => {
    }, setRtlClass: i, setGridThemeClass: o, forceFocusOutOfContainer: (U) => {
      var _a3, _b;
      if (!U && ((_a3 = x.current) == null ? void 0 : _a3.isDisplayed())) {
        x.current.forceFocusOutOfContainer(U);
        return;
      }
      (_b = v.current) == null ? void 0 : _b.forceFocusOutOfContainer(U);
    }, updateLayoutClasses: n, getFocusableContainers: () => {
      var _a3;
      const U = [], K = (_a3 = f.current) == null ? void 0 : _a3.querySelector(".ag-root");
      return K && U.push({ getGui: () => K }), M.current.forEach((se) => {
        se.isDisplayed() && U.push(se);
      }), U;
    }, setCursor: a, setUserSelect: u };
    ie.setComp(_, j, j), h(true);
  }, []);
  p.useEffect(() => {
    const j = C.current, ie = f.current;
    if (!g || !A || !j || !w || !ie) return;
    const _ = [], { watermarkSelector: U, paginationSelector: K, sideBarSelector: se, statusBarSelector: $, gridHeaderDropZonesSelector: J } = j.getOptionalSelectors(), X = [];
    if (J) {
      const k = e.createBean(new J.component()), ce = k.getGui();
      ie.insertAdjacentElement("afterbegin", ce), X.push(ce), _.push(k);
    }
    if (se) {
      const k = e.createBean(new se.component()), ce = k.getGui(), ne = w.querySelector(".ag-tab-guard-bottom");
      ne && (ne.insertAdjacentElement("beforebegin", ce), X.push(ce)), _.push(k), M.current.push(k);
    }
    const Ae = (k) => {
      const ce = e.createBean(new k()), ne = ce.getGui();
      return ie.insertAdjacentElement("beforeend", ne), X.push(ne), _.push(ce), ce;
    };
    if ($ && Ae($.component), K) {
      const k = Ae(K.component);
      x.current = k, M.current.push(k);
    }
    return U && Ae(U.component), () => {
      e.destroyBeans(_), X.forEach((k) => {
        var _a3;
        (_a3 = k.parentElement) == null ? void 0 : _a3.removeChild(k);
      });
    };
  }, [g, w, A]);
  const T = p.useMemo(() => ke("ag-root-wrapper", t, s, r), [t, s, r]), L = p.useMemo(() => ke("ag-root-wrapper-body", "ag-focus-managed", r), [r]), W = p.useMemo(() => ({ userSelect: c ?? "", WebkitUserSelect: c ?? "", cursor: l ?? "" }), [c, l]), ge = p.useCallback((j) => {
    v.current = j, m(j !== null);
  }, []);
  return D.createElement("div", { ref: I, className: T, style: W, role: "presentation" }, D.createElement("div", { className: L, ref: S, role: "presentation" }, d && w && A && D.createElement(me.Provider, { value: A }, D.createElement(wv, { ref: ge, eFocusableElement: w, onTabKeyDown: P, gridCtrl: C.current, forceFocusOutWhenTabGuardsAreEmpty: true }, D.createElement(Cv, null)))));
}, Rv = p.memo(yv), Fv = class extends R {
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  areHeaderCellsRendered() {
    return this.ctrlsService.getHeaderRowContainerCtrls().every((e) => e.getAllCtrls().every((t) => t.areCellsRendered()));
  }
}, vl = (e) => {
  var _a3;
  const t = p.useRef(), i = p.useRef(null), s = p.useRef(null), o = p.useRef([]), r = p.useRef([]), n = p.useRef(e), l = p.useRef(), a = p.useRef(), c = p.useRef(false), [u, d] = p.useState(void 0), [, h] = p.useState(0), g = p.useCallback((f) => {
    if (i.current = f, !f) {
      o.current.forEach((T) => T()), o.current.length = 0;
      return;
    }
    const v = e.modules || [];
    s.current || (s.current = new _C(() => h((T) => T + 1), e.componentWrappingElement, e.maxComponentCreationTimeMs), o.current.push(() => {
      var _a4;
      (_a4 = s.current) == null ? void 0 : _a4.destroy(), s.current = null;
    }));
    const w = wa(e.gridOptions, e), S = () => {
      if (c.current) {
        const T = () => {
          var _a4;
          return ((_a4 = l.current) == null ? void 0 : _a4.shouldQueueUpdates()) ? void 0 : r.current.shift();
        };
        let L = T();
        for (; L; ) L(), L = T();
      }
    }, b = new Dv(S);
    l.current = b;
    const x = new Fv(), M = { providedBeanInstances: { frameworkComponentWrapper: new Pv(s.current, w.reactiveCustomComponents ?? mC("reactiveCustomComponents") ?? true), renderStatusService: x }, modules: v, frameworkOverrides: b }, P = (T) => {
      d(T), T.createBean(x), o.current.push(() => {
        T.destroy();
      }), T.getBean("ctrlsService").whenReady({ addDestroyFunc: (L) => {
        o.current.push(L);
      } }, () => {
        var _a4;
        if (T.isDestroyed()) return;
        const L = t.current;
        L && ((_a4 = e.setGridApi) == null ? void 0 : _a4.call(e, L));
      });
    }, A = (T) => {
      T.getBean("ctrlsService").whenReady({ addDestroyFunc: (L) => {
        o.current.push(L);
      } }, () => {
        r.current.forEach((L) => L()), r.current.length = 0, c.current = true;
      });
    }, I = new vC();
    w.gridId ?? (w.gridId = a.current), t.current = I.create(f, w, P, A, M), o.current.push(() => {
      t.current = void 0;
    }), t.current && (a.current = t.current.getGridId());
  }, []), m = p.useMemo(() => ({ height: "100%", ...e.containerStyle || {} }), [e.containerStyle]), C = p.useCallback((f) => {
    var _a4;
    c.current && !((_a4 = l.current) == null ? void 0 : _a4.shouldQueueUpdates()) ? f() : r.current.push(f);
  }, []);
  return p.useEffect(() => {
    const f = bv(n.current, e);
    n.current = e, C(() => {
      t.current && ya(f, t.current);
    });
  }, [e]), D.createElement("div", { style: m, className: e.className, ref: g }, u && !u.isDestroyed() ? D.createElement(Rv, { context: u }) : null, ((_a3 = s.current) == null ? void 0 : _a3.getPortals()) ?? null);
};
function bv(e, t) {
  const i = {};
  return Object.keys(t).forEach((s) => {
    const o = t[s];
    e[s] !== o && (i[s] = o);
  }), i;
}
var Pv = class extends bC {
  constructor(e, t) {
    super(), this.parent = e, this.reactiveCustomComponents = t;
  }
  createWrapper(e, t) {
    if (this.reactiveCustomComponents) {
      const o = ((r) => {
        switch (r) {
          case "filter":
            return OC;
          case "floatingFilterComponent":
            return kC;
          case "dateComponent":
            return IC;
          case "dragAndDropImageComponent":
            return LC;
          case "loadingOverlayComponent":
            return HC;
          case "noRowsOverlayComponent":
            return VC;
          case "statusPanel":
            return BC;
          case "toolPanel":
            return WC;
          case "menuItem":
            return NC;
          case "cellRenderer":
            return TC;
        }
      })(t.propertyName);
      if (o) return new o(e, this.parent, t);
    } else switch (t.propertyName) {
      case "filter":
      case "floatingFilterComponent":
      case "dateComponent":
      case "dragAndDropImageComponent":
      case "loadingOverlayComponent":
      case "noRowsOverlayComponent":
      case "statusPanel":
      case "toolPanel":
      case "menuItem":
      case "cellRenderer":
        Go();
        break;
    }
    const i = !t.cellRenderer && t.propertyName !== "toolPanel";
    return new ml(e, this.parent, t, i);
  }
}, Ev = p.forwardRef((e, t) => {
  const { ctrlsFactory: i, context: s, gos: o, resizeObserverService: r, rowModel: n } = p.useContext(me), [l, a] = p.useState(() => new Ie()), [c, u] = p.useState(() => new Ie()), [d, h] = p.useState(), [g, m] = p.useState(), C = p.useRef(), f = p.useRef(null), v = p.useRef(), w = p.useMemo(() => Ue.__getGridRegisteredModules(e.api.getGridId()), [e]), S = p.useMemo(() => l.toString() + " ag-details-row", [l]), b = p.useMemo(() => c.toString() + " ag-details-grid", [c]);
  t && p.useImperativeHandle(t, () => ({ refresh() {
    var _a3;
    return ((_a3 = C.current) == null ? void 0 : _a3.refresh()) ?? false;
  } })), e.template && F("detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/");
  const x = p.useCallback((P) => {
    var _a3;
    if (f.current = P, !P) {
      C.current = s.destroyBean(C.current), (_a3 = v.current) == null ? void 0 : _a3.call(v);
      return;
    }
    const A = { addOrRemoveCssClass: (T, L) => a((W) => W.setClass(T, L)), addOrRemoveDetailGridCssClass: (T, L) => u((W) => W.setClass(T, L)), setDetailGrid: (T) => h(T), setRowData: (T) => m(T), getGui: () => f.current }, I = i.getInstance("detailCellRenderer");
    if (I && (s.createBean(I), I.init(A, e), C.current = I, o.get("detailRowAutoHeight"))) {
      const T = () => {
        if (f.current == null) return;
        const L = f.current.clientHeight;
        L != null && L > 0 && setTimeout(() => {
          e.node.setRowHeight(L), (Q(o) || it(o)) && n.onRowHeightChanged();
        }, 0);
      };
      v.current = r.observeResize(P, T), T();
    }
  }, []), M = p.useCallback((P) => {
    var _a3;
    (_a3 = C.current) == null ? void 0 : _a3.registerDetailWithMaster(P);
  }, []);
  return D.createElement("div", { className: S, ref: x }, d && D.createElement(vl, { className: b, ...d, modules: w, rowData: g, setGridApi: M }));
}), Dv = class extends tl {
  constructor(e) {
    super("react"), this.processQueuedUpdates = e, this.queueUpdates = false, this.frameworkComponents = { agGroupCellRenderer: mr, agGroupRowRenderer: mr, agDetailCellRenderer: Ev }, this.wrapIncoming = (t, i) => i === "ensureVisible" ? DC(t) : t(), this.renderingEngine = "react";
  }
  frameworkComponent(e) {
    return this.frameworkComponents[e];
  }
  isFrameworkComponent(e) {
    if (!e) return false;
    const t = e.prototype;
    return !(t && "getGui" in t);
  }
  getLockOnRefresh() {
    this.queueUpdates = true;
  }
  releaseLockOnRefresh() {
    this.queueUpdates = false, this.processQueuedUpdates();
  }
  shouldQueueUpdates() {
    return this.queueUpdates;
  }
  runWhenReadyAsync() {
    return EC();
  }
}, Mv = class extends p.Component {
  constructor() {
    super(...arguments), this.apiListeners = [], this.setGridApi = (e) => {
      this.api = e, this.apiListeners.forEach((t) => t(e));
    };
  }
  registerApiListener(e) {
    this.apiListeners.push(e);
  }
  componentWillUnmount() {
    this.apiListeners.length = 0;
  }
  render() {
    return D.createElement(vl, { ...this.props, setGridApi: this.setGridApi });
  }
}, xv = "ROOT_NODE_ID", Ms = 0, Av = class {
  constructor(e, t, i, s, o, r) {
    this.nextId = 0, this.rowCountReady = false, this.allNodesMap = {}, this.rootNode = e, this.gos = t, this.eventService = i, this.funcColsService = s, this.beans = r, this.selectionService = o, this.rootNode.group = true, this.rootNode.level = -1, this.rootNode.id = xv, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = [];
  }
  getCopyOfNodesMap() {
    return kr(this.allNodesMap);
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  setRowData(e) {
    if (typeof e == "string") {
      F("rowData must be an array.");
      return;
    }
    this.rowCountReady = true, this.dispatchRowDataUpdateStartedEvent(e);
    const t = this.rootNode, i = this.rootNode.sibling;
    t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, e ? t.allLeafChildren = e.map((s, o) => this.createNode(s, this.rootNode, Ms, o)) : (t.allLeafChildren = [], t.childrenAfterGroup = []), i && (i.childrenAfterFilter = t.childrenAfterFilter, i.childrenAfterGroup = t.childrenAfterGroup, i.childrenAfterAggFilter = t.childrenAfterAggFilter, i.childrenAfterSort = t.childrenAfterSort, i.childrenMapped = t.childrenMapped, i.allLeafChildren = t.allLeafChildren);
  }
  updateRowData(e) {
    this.rowCountReady = true, this.dispatchRowDataUpdateStartedEvent(e.add);
    const t = { rowNodeTransaction: { remove: [], update: [], add: [] }, rowsInserted: false }, i = [];
    return this.executeRemove(e, t, i), this.executeUpdate(e, t, i), this.executeAdd(e, t), this.updateSelection(i, "rowDataChanged"), t;
  }
  updateRowOrderFromRowData(e) {
    const t = this.rootNode.allLeafChildren, i = (t == null ? void 0 : t.length) ?? 0, s = /* @__PURE__ */ new Map();
    let o = -1, r = -1;
    for (let n = 0; n < i; ++n) {
      const l = t[n], a = l.data;
      a !== e[n] && (r < 0 && (o = n), r = n, s.set(a, l));
    }
    if (o < 0) return false;
    for (let n = o; n <= r; ++n) {
      const l = s.get(e[n]);
      l !== void 0 && (t[n] = l, l.sourceRowIndex = n);
    }
    return true;
  }
  isRowCountReady() {
    return this.rowCountReady;
  }
  dispatchRowDataUpdateStartedEvent(e) {
    this.eventService.dispatchEvent({ type: "rowDataUpdateStarted", firstRowData: (e == null ? void 0 : e.length) ? e[0] : null });
  }
  updateSelection(e, t) {
    const i = e.length > 0;
    i && this.selectionService.setNodesSelected({ newValue: false, nodes: e, suppressFinishActions: true, source: t }), this.selectionService.updateGroupsFromChildrenSelections(t), i && this.eventService.dispatchEvent({ type: "selectionChanged", source: t });
  }
  executeAdd(e, t) {
    var _a3;
    const i = e.add;
    if (Me(i)) return;
    const s = this.rootNode.allLeafChildren;
    let o = s.length;
    if (typeof e.addIndex == "number" && (o = this.sanitizeAddIndex(e.addIndex), o > 0 && this.gos.get("treeData"))) {
      for (let a = 0; a < s.length; a++) if (((_a3 = s[a]) == null ? void 0 : _a3.rowIndex) == o - 1) {
        o = a + 1;
        break;
      }
    }
    const r = i.map((l, a) => this.createNode(l, this.rootNode, Ms, o + a));
    if (o < s.length) {
      const l = s.slice(0, o), a = s.slice(o, s.length), c = l.length + r.length;
      for (let u = 0, d = a.length; u < d; ++u) a[u].sourceRowIndex = c + u;
      this.rootNode.allLeafChildren = [...l, ...r, ...a], t.rowsInserted = true;
    } else this.rootNode.allLeafChildren = s.concat(r);
    const n = this.rootNode.sibling;
    n && (n.allLeafChildren = s), t.rowNodeTransaction.add = r;
  }
  sanitizeAddIndex(e) {
    var _a3;
    const t = ((_a3 = this.rootNode.allLeafChildren) == null ? void 0 : _a3.length) ?? 0;
    return e < 0 || e >= t || Number.isNaN(e) ? t : Math.ceil(e);
  }
  executeRemove(e, { rowNodeTransaction: t }, i) {
    var _a3, _b;
    const { remove: s } = e;
    if (Me(s)) return;
    const o = {};
    s.forEach((n) => {
      const l = this.lookupRowNode(n);
      l && (l.isSelected() && i.push(l), l.clearRowTopAndRowIndex(), o[l.id] = true, delete this.allNodesMap[l.id], t.remove.push(l));
    }), this.rootNode.allLeafChildren = ((_a3 = this.rootNode.allLeafChildren) == null ? void 0 : _a3.filter((n) => !o[n.id])) ?? null, (_b = this.rootNode.allLeafChildren) == null ? void 0 : _b.forEach((n, l) => {
      n.sourceRowIndex = l;
    });
    const r = this.rootNode.sibling;
    r && (r.allLeafChildren = this.rootNode.allLeafChildren);
  }
  executeUpdate(e, { rowNodeTransaction: t }, i) {
    const { update: s } = e;
    Me(s) || s.forEach((o) => {
      const r = this.lookupRowNode(o);
      r && (r.updateData(o), !r.selectable && r.isSelected() && i.push(r), this.setMasterForRow(r, o, Ms, false), t.update.push(r));
    });
  }
  lookupRowNode(e) {
    var _a3;
    const t = Ci(this.gos);
    let i;
    if (t) {
      const s = t({ data: e, level: 0 });
      if (i = this.allNodesMap[s], !i) return z(`could not find row id=${s}, data item was not found for this id`), null;
    } else if (i = (_a3 = this.rootNode.allLeafChildren) == null ? void 0 : _a3.find((s) => s.data === e), !i) return z("could not find data item as object was not found", e), z("Consider using getRowId to help the Grid find matching row data"), null;
    return i || null;
  }
  createNode(e, t, i, s) {
    const o = new Ft(this.beans);
    return o.sourceRowIndex = s, o.group = false, this.setMasterForRow(o, e, i, true), t && (o.parent = t), o.level = i, o.setDataAndId(e, this.nextId.toString()), this.allNodesMap[o.id] && F(`duplicate node id '${o.id}' detected from getRowId callback, this could cause issues in your grid.`), this.allNodesMap[o.id] = o, this.nextId++, o;
  }
  setMasterForRow(e, t, i, s) {
    if (this.gos.get("treeData")) e.setMaster(false), s && (e.expanded = false);
    else {
      if (this.gos.get("masterDetail")) {
        const n = this.gos.get("isRowMaster");
        n ? e.setMaster(n(t)) : e.setMaster(true);
      } else e.setMaster(false);
      if (s) {
        const n = this.funcColsService.getRowGroupColumns(), l = n ? n.length : 0, a = i + l;
        e.expanded = e.master ? this.isExpanded(a) : false;
      }
    }
  }
  isExpanded(e) {
    const t = this.gos.get("groupDefaultExpanded");
    return t === -1 ? true : e < t;
  }
}, Tv = class extends R {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.onRowHeightChanged_debounced = Re(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [], this.hasStarted = false, this.shouldSkipSettingDataOnStart = false, this.isRefreshingModel = false, this.rowCountReady = false;
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.selectionService = e.selectionService, this.valueCache = e.valueCache, this.environment = e.environment, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggregationStage = e.aggregationStage, this.pivotStage = e.pivotStage, this.filterAggregatesStage = e.filterAggregatesStage;
  }
  postConstruct() {
    const e = this.refreshModel.bind(this, { step: H.EVERYTHING }), t = !this.gos.get("suppressAnimationFrame"), i = this.refreshModel.bind(this, { step: H.EVERYTHING, afterColumnsChanged: true, keepRenderedRows: true, animate: t });
    this.addManagedEventListeners({ newColumnsLoaded: i, columnRowGroupChanged: e, columnValueChanged: this.onValueChanged.bind(this), columnPivotChanged: this.refreshModel.bind(this, { step: H.PIVOT }), filterChanged: this.onFilterChanged.bind(this), sortChanged: this.onSortChanged.bind(this), columnPivotModeChanged: e, gridStylesChanged: this.onGridStylesChanges.bind(this), gridReady: this.onGridReady.bind(this) }), this.addPropertyListeners(), this.rootNode = new Ft(this.beans), this.nodeManager = new Av(this.rootNode, this.gos, this.eventService, this.funcColsService, this.selectionService, this.beans);
  }
  addPropertyListeners() {
    const e = /* @__PURE__ */ new Set(["treeData", "masterDetail"]), t = /* @__PURE__ */ new Set(["groupDefaultExpanded", "groupAllowUnbalanced", "initialGroupOrderComparator", "groupHideOpenParents", "groupDisplayType"]), i = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), s = /* @__PURE__ */ new Set(["removePivotHeaderRowWhenSingleValueColumn", "pivotRowTotals", "pivotColumnGroupTotals", "suppressExpandablePivotGroups"]), o = /* @__PURE__ */ new Set(["getGroupRowAgg", "alwaysAggregateAtRootLevel", "groupIncludeTotalFooter", "suppressAggFilteredOnly", "grandTotalRow"]), r = /* @__PURE__ */ new Set(["postSortRows", "groupDisplayType", "accentedSort"]), n = /* @__PURE__ */ new Set([]), l = /* @__PURE__ */ new Set(["groupRemoveSingleChildren", "groupRemoveLowestSingleChildren", "groupIncludeFooter", "groupTotalRow"]), a = [...e, ...t, ...i, ...s, ...s, ...o, ...r, ...n, ...l];
    this.addManagedPropertyListeners(a, (c) => {
      var _a3;
      const u = (_a3 = c.changeSet) == null ? void 0 : _a3.properties;
      if (!u) return;
      const d = (h) => u.some((g) => h.has(g));
      if (d(e)) {
        this.setRowData(this.rootNode.allLeafChildren.map((h) => h.data));
        return;
      }
      if (d(t)) {
        this.refreshModel({ step: H.EVERYTHING });
        return;
      }
      if (d(i)) {
        this.refreshModel({ step: H.FILTER });
        return;
      }
      if (d(s)) {
        this.refreshModel({ step: H.PIVOT });
        return;
      }
      if (d(o)) {
        this.refreshModel({ step: H.AGGREGATE });
        return;
      }
      if (d(r)) {
        this.refreshModel({ step: H.SORT });
        return;
      }
      if (d(n)) {
        this.refreshModel({ step: H.FILTER_AGGREGATES });
        return;
      }
      d(l) && this.refreshModel({ step: H.MAP });
    }), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.hasStarted = true, this.shouldSkipSettingDataOnStart ? this.dispatchUpdateEventsAndRefresh() : this.setInitialData();
  }
  setInitialData() {
    const e = this.gos.get("rowData");
    e && (this.shouldSkipSettingDataOnStart = true, this.setRowData(e));
  }
  ensureRowHeightsValid(e, t, i, s) {
    let o, r = false;
    do {
      o = false;
      const n = this.getRowIndexAtPixel(e), l = this.getRowIndexAtPixel(t), a = Math.max(n, i), c = Math.min(l, s);
      for (let u = a; u <= c; u++) {
        const d = this.getRow(u);
        if (d.rowHeightEstimated) {
          const h = ut(this.gos, d);
          d.setRowHeight(h.height), o = true, r = true;
        }
      }
      o && this.setRowTopAndRowIndex();
    } while (o);
    return r;
  }
  setRowTopAndRowIndex() {
    const e = this.environment.getDefaultRowHeight();
    let t = 0;
    const i = /* @__PURE__ */ new Set(), s = he(this.gos, "normal");
    for (let o = 0; o < this.rowsToDisplay.length; o++) {
      const r = this.rowsToDisplay[o];
      if (r.id != null && i.add(r.id), r.rowHeight == null) {
        const n = ut(this.gos, r, s, e);
        r.setRowHeight(n.height, n.estimated);
      }
      r.setRowTop(t), r.setRowIndex(o), t += r.rowHeight;
    }
    return i;
  }
  clearRowTopAndRowIndex(e, t) {
    const i = e.isActive(), s = (r) => {
      r && r.id != null && !t.has(r.id) && r.clearRowTopAndRowIndex();
    }, o = (r) => {
      if (s(r), s(r.detailNode), s(r.sibling), r.hasChildren() && r.childrenAfterGroup) {
        const n = r.level == -1;
        i && !n && !r.expanded || r.childrenAfterGroup.forEach(o);
      }
    };
    o(this.rootNode);
  }
  ensureRowsAtPixel(e, t, i = 0) {
    const s = this.getRowIndexAtPixel(t), o = this.getRow(s), r = !this.gos.get("suppressAnimationFrame");
    if (o === e[0]) return false;
    const n = this.rootNode.allLeafChildren;
    return e.forEach((l) => {
      Fe(n, l);
    }), e.forEach((l, a) => {
      Ki(n, l, Math.max(s + i, 0) + a);
    }), e.forEach((l, a) => {
      l.sourceRowIndex = a;
    }), this.refreshModel({ step: H.EVERYTHING, keepRenderedRows: true, keepEditingRows: true, animate: r, rowNodesOrderChanged: true }), true;
  }
  highlightRowAtPixel(e, t) {
    const i = t != null ? this.getRowIndexAtPixel(t) : null, s = i != null ? this.getRow(i) : null;
    if (!s || !e || t == null) {
      this.clearHighlightedRow();
      return;
    }
    const o = this.getHighlightPosition(t, s), r = this.isHighlightingCurrentPosition(e, s, o), n = this.lastHighlightedRow != null && this.lastHighlightedRow !== s;
    (r || n) && (this.clearHighlightedRow(), r) || (s.setHighlighted(o), this.lastHighlightedRow = s);
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const o = this.getRowIndexAtPixel(e);
      if (t = this.getRow(o || 0), !t) return si.Below;
    }
    const { rowTop: i, rowHeight: s } = t;
    return e - i < s / 2 ? si.Above : si.Below;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isHighlightingCurrentPosition(e, t, i) {
    if (e === t) return true;
    const s = i === si.Above ? -1 : 1;
    return this.getRow(t.rowIndex + s) === e;
  }
  clearHighlightedRow() {
    this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null);
  }
  isLastRowIndexKnown() {
    return true;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  getTopLevelRowCount() {
    if (this.rowsToDisplay.length === 0) return 0;
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode) return 1;
    const t = this.rootNode.childrenAfterAggFilter, i = this.rootNode.sibling ? 1 : 0;
    return (t ? t.length : 0) + i;
  }
  getTopLevelRowDisplayedIndex(e) {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode) return e;
    let i = e;
    if (this.rowsToDisplay[0].footer) {
      if (e === 0) return 0;
      i -= 1;
    }
    const s = this.rowsToDisplay[this.rowsToDisplay.length - 1], o = i >= this.rootNode.childrenAfterSort.length;
    if (s.footer && o) return s.rowIndex;
    let r = this.rootNode.childrenAfterSort[i];
    if (this.gos.get("groupHideOpenParents")) for (; r.expanded && r.childrenAfterSort && r.childrenAfterSort.length > 0; ) r = r.childrenAfterSort[0];
    return r.rowIndex;
  }
  getRowBounds(e) {
    if (V(this.rowsToDisplay)) return null;
    const t = this.rowsToDisplay[e];
    return t ? { rowTop: t.rowTop, rowHeight: t.rowHeight } : null;
  }
  onRowGroupOpened() {
    const e = Nt(this.gos);
    this.refreshModel({ step: H.MAP, keepRenderedRows: true, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange) return;
    const t = Nt(this.gos), s = e.columns.length === 0 || e.columns.some((o) => o.isPrimary()) ? H.FILTER : H.FILTER_AGGREGATES;
    this.refreshModel({ step: s, keepRenderedRows: true, animate: t });
  }
  onSortChanged() {
    const e = Nt(this.gos);
    this.refreshModel({ step: H.SORT, keepRenderedRows: true, animate: e, keepEditingRows: true });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.columnModel.isPivotActive() ? this.refreshModel({ step: H.PIVOT }) : this.refreshModel({ step: H.AGGREGATE });
  }
  createChangePath(e) {
    const t = Me(e), i = new cs(false, this.rootNode);
    return t && i.setInactive(), i;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction") || e.rowNodeTransactions == null) return false;
    const t = e.rowNodeTransactions.filter((s) => s.add != null && s.add.length > 0 || s.remove != null && s.remove.length > 0);
    return t == null || t.length == 0;
  }
  buildRefreshModelParams(e) {
    let t = H.EVERYTHING;
    const i = { everything: H.EVERYTHING, group: H.EVERYTHING, filter: H.FILTER, map: H.MAP, aggregate: H.AGGREGATE, filter_aggregates: H.FILTER_AGGREGATES, sort: H.SORT, pivot: H.PIVOT, nothing: H.NOTHING };
    if (E(e) && (t = i[e]), V(t)) {
      z(`invalid step ${e}, available steps are ${Object.keys(i).join(", ")}`);
      return;
    }
    const s = !this.gos.get("suppressAnimationFrame");
    return { step: t, keepRenderedRows: true, keepEditingRows: true, animate: s };
  }
  refreshModel(e) {
    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching()) return;
    const t = typeof e == "object" && "step" in e ? e : this.buildRefreshModelParams(e);
    if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t)) return;
    const i = this.createChangePath(t.rowNodeTransactions);
    switch (this.isRefreshingModel = true, t.step) {
      case H.EVERYTHING:
        this.doRowGrouping(t.rowNodeTransactions, i, !!t.rowNodesOrderChanged, !!t.afterColumnsChanged);
      case H.FILTER:
        this.doFilter(i);
      case H.PIVOT:
        this.doPivot(i);
      case H.AGGREGATE:
        this.doAggregate(i);
      case H.FILTER_AGGREGATES:
        this.doFilterAggregates(i);
      case H.SORT:
        this.doSort(t.rowNodeTransactions, i);
      case H.MAP:
        this.doRowsToDisplay();
    }
    const s = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(i, s), this.isRefreshingModel = false, this.eventService.dispatchEvent({ type: "modelUpdated", animate: t.animate, keepRenderedRows: t.keepRenderedRows, newData: t.newData, newPage: false, keepUndoRedoStack: t.keepUndoRedoStack });
  }
  isEmpty() {
    const e = V(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return V(this.rootNode) || e || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return E(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let i = false, s = false;
    const o = [], r = Dt(this.gos);
    return this.forEachNodeAfterFilterAndSort((n) => {
      if (s) return;
      if (i && (n === t || n === e) && (s = true, n.group && r)) {
        o.push(...n.allLeafChildren);
        return;
      }
      if (!i) {
        if (n !== t && n !== e) return;
        i = true;
      }
      if (!n.group || !r) {
        o.push(n);
        return;
      }
    }), o;
  }
  setDatasource(e) {
    z("should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0) return -1;
    let t = 0, i = this.rowsToDisplay.length - 1;
    if (e <= 0) return 0;
    if (N(this.rowsToDisplay).rowTop <= e) return this.rowsToDisplay.length - 1;
    let o = -1, r = -1;
    for (; ; ) {
      const n = Math.floor((t + i) / 2), l = this.rowsToDisplay[n];
      if (this.isRowInPixel(l, e) || (l.rowTop < e ? t = n + 1 : l.rowTop > e && (i = n - 1), o === t && r === i)) return n;
      o = t, r = i;
    }
  }
  isRowInPixel(e, t) {
    const i = e.rowTop, s = e.rowTop + e.rowHeight;
    return i <= t && s > t;
  }
  forEachLeafNode(e) {
    this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, i) => e(t, i));
  }
  forEachNode(e, t = false) {
    this.recursivelyWalkNodesAndCallback({ nodes: [...this.rootNode.childrenAfterGroup || []], callback: e, recursionType: 0, index: 0, includeFooterNodes: t });
  }
  forEachNodeAfterFilter(e, t = false) {
    this.recursivelyWalkNodesAndCallback({ nodes: [...this.rootNode.childrenAfterAggFilter || []], callback: e, recursionType: 1, index: 0, includeFooterNodes: t });
  }
  forEachNodeAfterFilterAndSort(e, t = false) {
    this.recursivelyWalkNodesAndCallback({ nodes: [...this.rootNode.childrenAfterSort || []], callback: e, recursionType: 2, index: 0, includeFooterNodes: t });
  }
  forEachPivotNode(e, t = false) {
    this.recursivelyWalkNodesAndCallback({ nodes: [this.rootNode], callback: e, recursionType: 3, index: 0, includeFooterNodes: t });
  }
  recursivelyWalkNodesAndCallback(e) {
    const { nodes: t, callback: i, recursionType: s, includeFooterNodes: o } = e;
    let { index: r } = e;
    const n = (l) => {
      var _a3;
      const a = (_a3 = t[0]) == null ? void 0 : _a3.parent;
      if (!a) return;
      const c = o && Er(this.gos), u = Dr(this.gos), d = o && u({ node: a });
      if (a === this.rootNode) {
        c === l && (a.createFooter(), i(a.sibling, r++));
        return;
      }
      d === l && (a.createFooter(), i(a.sibling, r++));
    };
    n("top");
    for (let l = 0; l < t.length; l++) {
      const a = t[l];
      if (i(a, r++), a.hasChildren() && !a.footer) {
        let c = null;
        switch (s) {
          case 0:
            c = a.childrenAfterGroup;
            break;
          case 1:
            c = a.childrenAfterAggFilter;
            break;
          case 2:
            c = a.childrenAfterSort;
            break;
          case 3:
            c = a.leafGroup ? null : a.childrenAfterSort;
            break;
        }
        c && (r = this.recursivelyWalkNodesAndCallback({ nodes: [...c], callback: i, recursionType: s, index: r, includeFooterNodes: o }));
      }
    }
    return n("bottom"), r;
  }
  doAggregate(e) {
    var _a3;
    (_a3 = this.aggregationStage) == null ? void 0 : _a3.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doFilterAggregates(e) {
    this.filterAggregatesStage ? this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: e }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
  }
  expandOrCollapseAll(e) {
    const t = this.gos.get("treeData"), i = this.columnModel.isPivotActive(), s = (o) => {
      o && o.forEach((r) => {
        const n = () => {
          r.expanded = e, s(r.childrenAfterGroup);
        };
        if (t) {
          E(r.childrenAfterGroup) && n();
          return;
        }
        if (i) {
          !r.leafGroup && n();
          return;
        }
        r.group && n();
      });
    };
    this.rootNode && s(this.rootNode.childrenAfterGroup), this.refreshModel({ step: H.MAP }), this.eventService.dispatchEvent({ type: "expandOrCollapseAll", source: e ? "expandAll" : "collapseAll" });
  }
  doSort(e, t) {
    this.sortStage.execute({ rowNode: this.rootNode, rowNodeTransactions: e, changedPath: t });
  }
  doRowGrouping(e, t, i, s) {
    if (this.groupStage) e ? this.groupStage.execute({ rowNode: this.rootNode, rowNodeTransactions: e, rowNodesOrderChanged: i, changedPath: t }) : this.groupStage.execute({ rowNode: this.rootNode, changedPath: t, afterColumnsChanged: s }), Dt(this.gos) && this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", t) && this.eventService.dispatchEvent({ type: "selectionChanged", source: "rowGroupChanged" });
    else {
      const o = this.rootNode, r = o.sibling;
      o.childrenAfterGroup = o.allLeafChildren, r && (r.childrenAfterGroup = o.childrenAfterGroup), this.rootNode.updateHasChildren();
    }
    this.nodeManager.isRowCountReady() && (this.rowCountReady = true, this.eventService.dispatchEventOnce({ type: "rowCountReady" }));
  }
  doFilter(e) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doPivot(e) {
    var _a3;
    (_a3 = this.pivotStage) == null ? void 0 : _a3.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getNodeManager() {
    return this.nodeManager;
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(Ft.ID_PREFIX_ROW_GROUP) == 0) {
      let i;
      return this.forEachNode((s) => {
        s.id === e && (i = s);
      }), i;
    }
    return this.nodeManager.getRowNode(e);
  }
  setRowData(e) {
    this.selectionService.reset("rowDataChanged"), this.nodeManager.setRowData(e), this.hasStarted && this.dispatchUpdateEventsAndRefresh();
  }
  dispatchUpdateEventsAndRefresh() {
    this.eventService.dispatchEvent({ type: "rowDataUpdated" }), this.refreshModel({ step: H.EVERYTHING, newData: true });
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const i = this.gos.get("asyncTransactionWaitMillis");
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.isAlive() && this.executeBatchUpdateRowData();
      }, i);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    var _a3;
    this.valueCache.onDataChanged();
    const e = [], t = [];
    let i = false;
    (_a3 = this.rowDataTransactionBatch) == null ? void 0 : _a3.forEach((s) => {
      const { rowNodeTransaction: o, rowsInserted: r } = this.nodeManager.updateRowData(s.rowDataTransaction);
      r && (i = true), t.push(o), s.callback && e.push(s.callback.bind(null, o));
    }), this.commonUpdateRowData(t, i), e.length > 0 && window.setTimeout(() => {
      e.forEach((s) => s());
    }, 0), t.length > 0 && this.eventService.dispatchEvent({ type: "asyncTransactionsFlushed", results: t }), this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  updateRowData(e) {
    this.valueCache.onDataChanged();
    const { rowNodeTransaction: t, rowsInserted: i } = this.nodeManager.updateRowData(e);
    return this.commonUpdateRowData([t], i), t;
  }
  afterImmutableDataChange(e, t) {
    this.commonUpdateRowData([e], t);
  }
  commonUpdateRowData(e, t) {
    if (!this.hasStarted) return;
    const i = !this.gos.get("suppressAnimationFrame");
    this.eventService.dispatchEvent({ type: "rowDataUpdated" }), this.refreshModel({ step: H.EVERYTHING, rowNodeTransactions: e, rowNodesOrderChanged: t, keepRenderedRows: true, keepEditingRows: true, animate: i });
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({ step: H.MAP, keepRenderedRows: true, keepEditingRows: true, keepUndoRedoStack: true });
  }
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, true), this.rootNode.sibling && this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true), e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = false;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, true);
      const i = t.detailNode;
      i && i.setRowHeight(i.rowHeight, true), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, true), e = true;
    }), e;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      if (this.columnModel.isAutoRowHeightActive()) return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.hasStarted || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
  destroy() {
    super.destroy(), this.clearHighlightedRow();
  }
};
function Iv(e) {
  e.expansionService.onGroupExpandedOrCollapsed();
}
function Lv(e, t) {
  var _a3, _b;
  (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.refreshModel(t);
}
function Ov(e) {
  var _a3, _b;
  return ((_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.isEmpty()) ?? true;
}
function Gv(e, t) {
  var _a3, _b;
  (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.forEachLeafNode(t);
}
function kv(e, t) {
  var _a3, _b;
  (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.forEachNodeAfterFilter(t);
}
function Hv(e, t) {
  var _a3, _b;
  (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.forEachNodeAfterFilterAndSort(t);
}
function Nv(e) {
  var _a3, _b;
  if (e.columnModel.isAutoRowHeightActive()) {
    F("calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
    return;
  }
  (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.resetRowHeights();
}
function Vv(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var _a3, _b;
    return (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.updateRowData(t);
  });
}
function Bv(e, t, i) {
  e.frameworkOverrides.wrapIncoming(() => {
    var _a3, _b;
    return (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.batchUpdateRowData(t, i);
  });
}
function Wv(e) {
  e.frameworkOverrides.wrapIncoming(() => {
    var _a3, _b;
    return (_b = (_a3 = e.rowModelHelperService) == null ? void 0 : _a3.getClientSideRowModel()) == null ? void 0 : _b.flushAsyncTransactions();
  });
}
function zv(e) {
  return e.selectionService.getBestCostNodeSelection();
}
var _v = class extends R {
  constructor() {
    super(...arguments), this.beanName = "filterStage";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var _a3;
    const t = !!((_a3 = this.filterManager) == null ? void 0 : _a3.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const i = (s, o) => {
      s.hasChildren() && e && !o ? s.childrenAfterFilter = s.childrenAfterGroup.filter((r) => {
        const n = r.childrenAfterFilter && r.childrenAfterFilter.length > 0, l = r.data && this.filterManager.doesRowPassFilter({ rowNode: r });
        return n || l;
      }) : s.childrenAfterFilter = s.childrenAfterGroup, s.sibling && (s.sibling.childrenAfterFilter = s.childrenAfterFilter);
    };
    if (this.doingTreeDataFiltering()) {
      const s = (r, n) => {
        if (r.childrenAfterGroup) for (let l = 0; l < r.childrenAfterGroup.length; l++) {
          const a = r.childrenAfterGroup[l], c = n || this.filterManager.doesRowPassFilter({ rowNode: a });
          a.childrenAfterGroup ? s(r.childrenAfterGroup[l], c) : i(a, c);
        }
        i(r, n);
      }, o = (r) => s(r, false);
      t.executeFromRootNode(o);
    } else {
      const s = (o) => i(o, false);
      t.forEachChangedNodeDepthFirst(s, true);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, Uv = class extends R {
  constructor() {
    super(...arguments), this.beanName = "flattenStage";
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel;
  }
  execute(e) {
    const t = e.rowNode, i = [], s = this.columnModel.isPivotMode(), o = s && t.leafGroup, r = o ? [t] : t.childrenAfterSort, n = this.getFlattenDetails();
    this.recursivelyAddToRowsToDisplay(n, r, i, s, 0);
    const l = i.length > 0;
    if (!o && l && n.grandTotalRow) {
      t.createFooter();
      const c = n.grandTotalRow === "top";
      this.addRowNodeToRowsToDisplay(n, t.sibling, i, 0, c);
    }
    return i;
  }
  getFlattenDetails() {
    const e = this.gos.get("groupRemoveSingleChildren");
    return { groupRemoveLowestSingleChildren: !e && this.gos.get("groupRemoveLowestSingleChildren"), groupRemoveSingleChildren: e, isGroupMultiAutoColumn: Mr(this.gos), hideOpenParents: this.gos.get("groupHideOpenParents"), grandTotalRow: Er(this.gos), groupTotalRow: Dr(this.gos) };
  }
  recursivelyAddToRowsToDisplay(e, t, i, s, o) {
    if (!Me(t)) for (let r = 0; r < t.length; r++) {
      const n = t[r], l = n.hasChildren(), a = s && !l, c = e.groupRemoveSingleChildren && l && n.childrenAfterGroup.length === 1, u = e.groupRemoveLowestSingleChildren && l && n.leafGroup && n.childrenAfterGroup.length === 1, d = s && n.leafGroup, h = e.hideOpenParents && n.expanded && !n.master && !d;
      if (!a && !h && !c && !u && this.addRowNodeToRowsToDisplay(e, n, i, o), !(s && n.leafGroup)) {
        if (l) {
          const m = c || u;
          if (n.expanded || m) {
            const C = e.groupTotalRow({ node: n });
            C || n.destroyFooter();
            const f = m ? o : o + 1;
            C === "top" && (n.createFooter(), this.addRowNodeToRowsToDisplay(e, n.sibling, i, f)), this.recursivelyAddToRowsToDisplay(e, n.childrenAfterSort, i, s, f), C === "bottom" && (n.createFooter(), this.addRowNodeToRowsToDisplay(e, n.sibling, i, f));
          }
        } else if (n.master && n.expanded) {
          const m = this.createDetailNode(n);
          this.addRowNodeToRowsToDisplay(e, m, i, o);
        }
      }
    }
  }
  addRowNodeToRowsToDisplay(e, t, i, s, o) {
    o ? i.unshift(t) : i.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : s);
  }
  createDetailNode(e) {
    if (E(e.detailNode)) return e.detailNode;
    const t = new Ft(this.beans);
    return t.detail = true, t.selectable = false, t.parent = e, E(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t;
  }
}, Kv = class extends R {
  constructor() {
    super(...arguments), this.beanName = "immutableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    Q(this.gos) && (this.clientSideRowModel = this.rowModel, this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated()));
  }
  isActive() {
    const e = this.gos.exists("getRowId");
    return this.gos.get("resetRowDataOnUpdate") ? false : e;
  }
  setRowData(e) {
    const t = this.createTransactionForRowData(e);
    if (!t) return;
    const i = this.clientSideRowModel.getNodeManager(), { rowNodeTransaction: s, rowsInserted: o } = i.updateRowData(t);
    let r = false;
    this.gos.get("suppressMaintainUnsortedOrder") || (r = i.updateRowOrderFromRowData(e)), this.clientSideRowModel.afterImmutableDataChange(s, r || o);
  }
  createTransactionForRowData(e) {
    if (!Q(this.gos)) return z("ImmutableService only works with ClientSideRowModel"), null;
    const t = Ci(this.gos);
    if (t == null) return z("ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!"), null;
    const i = this.clientSideRowModel.getNodeManager().getCopyOfNodesMap(), s = [], o = [], r = [];
    return E(e) && e.forEach((n) => {
      const l = t({ data: n, level: 0 }), a = i[l];
      a ? (a.data !== n && o.push(n), i[l] = void 0) : r.push(n);
    }), He(i, (n, l) => {
      l && s.push(l.data);
    }), { remove: s, update: o, add: r };
  }
  onRowDataUpdated() {
    const e = this.gos.get("rowData");
    e && (this.isActive() ? this.setRowData(e) : (this.selectionService.reset("rowDataChanged"), this.clientSideRowModel.setRowData(e)));
  }
}, $v = class extends R {
  constructor() {
    super(...arguments), this.beanName = "sortService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.rowNodeSorter = e.rowNodeSorter, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  sort(e, t, i, s, o, r) {
    const n = this.gos.get("groupMaintainOrder"), l = this.columnModel.getCols().some((h) => h.isRowGroupActive());
    let a = {};
    i && s && (a = this.calculateDirtyNodes(s));
    const c = this.columnModel.isPivotMode(), u = this.gos.getCallback("postSortRows"), d = (h) => {
      var _a3, _b;
      this.pullDownGroupDataForHideOpenParents(h.childrenAfterAggFilter, true);
      const g = c && h.leafGroup;
      if (n && l && !h.leafGroup && !r) {
        const f = ((_b = (_a3 = this.funcColsService.getRowGroupColumns()) == null ? void 0 : _a3[h.level + 1]) == null ? void 0 : _b.getSort()) === null, v = h.childrenAfterAggFilter.slice(0);
        if (h.childrenAfterSort && !f) {
          const w = {};
          h.childrenAfterSort.forEach((S, b) => {
            w[S.id] = b;
          }), v.sort((S, b) => (w[S.id] ?? 0) - (w[b.id] ?? 0));
        }
        h.childrenAfterSort = v;
      } else !t || g ? h.childrenAfterSort = h.childrenAfterAggFilter.slice(0) : i ? h.childrenAfterSort = this.doDeltaSort(h, a, o, e) : h.childrenAfterSort = this.rowNodeSorter.doFullSort(h.childrenAfterAggFilter, e);
      if (h.sibling && (h.sibling.childrenAfterSort = h.childrenAfterSort), this.updateChildIndexes(h), u) {
        const C = { nodes: h.childrenAfterSort };
        u(C);
      }
    };
    o && o.forEachChangedNodeDepthFirst(d), this.updateGroupDataForHideOpenParents(o);
  }
  calculateDirtyNodes(e) {
    const t = {}, i = (s) => {
      s && s.forEach((o) => t[o.id] = true);
    };
    return e && e.forEach((s) => {
      i(s.add), i(s.update), i(s.remove);
    }), t;
  }
  doDeltaSort(e, t, i, s) {
    const o = e.childrenAfterAggFilter, r = e.childrenAfterSort;
    if (!r) return this.rowNodeSorter.doFullSort(o, s);
    const n = {}, l = [];
    o.forEach((d) => {
      t[d.id] || !i.canSkip(d) ? l.push(d) : n[d.id] = true;
    });
    const a = r.filter((d) => n[d.id]), c = (d, h) => ({ currentPos: h, rowNode: d }), u = l.map(c).sort((d, h) => this.rowNodeSorter.compareRowNodes(s, d, h));
    return this.mergeSortedArrays(s, u, a.map(c)).map(({ rowNode: d }) => d);
  }
  mergeSortedArrays(e, t, i) {
    const s = [];
    let o = 0, r = 0;
    for (; o < t.length && r < i.length; ) this.rowNodeSorter.compareRowNodes(e, t[o], i[r]) < 0 ? s.push(t[o++]) : s.push(i[r++]);
    for (; o < t.length; ) s.push(t[o++]);
    for (; r < i.length; ) s.push(i[r++]);
    return s;
  }
  updateChildIndexes(e) {
    if (V(e.childrenAfterSort)) return;
    const t = e.childrenAfterSort;
    for (let i = 0; i < t.length; i++) {
      const s = t[i], o = i === 0, r = i === e.childrenAfterSort.length - 1;
      s.setFirstChild(o), s.setLastChild(r), s.setChildIndex(i);
    }
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gos.get("groupHideOpenParents")) return;
    if (this.gos.get("treeData")) return F("The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."), false;
    const t = (i) => {
      this.pullDownGroupDataForHideOpenParents(i.childrenAfterSort, false), i.childrenAfterSort.forEach((s) => {
        s.hasChildren() && t(s);
      });
    };
    e && e.executeFromRootNode((i) => t(i));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    !this.gos.get("groupHideOpenParents") || V(e) || e.forEach((i) => {
      var _a3;
      (((_a3 = this.showRowGroupColsService) == null ? void 0 : _a3.getShowRowGroupCols()) ?? []).forEach((o) => {
        const r = o.getColDef().showRowGroup;
        if (typeof r != "string") {
          z("groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
          return;
        }
        const n = r, l = this.columnModel.getColDefCol(n);
        if (l !== i.rowGroupColumn) if (t) i.setGroupValue(o.getId(), void 0);
        else {
          const c = this.getFirstChildOfFirstChild(i, l);
          c && i.setGroupValue(o.getId(), c.key);
        }
      });
    });
  }
  getFirstChildOfFirstChild(e, t) {
    let i = e;
    for (; i; ) {
      const s = i.parent;
      if (s && i.firstChild) {
        if (s.rowGroupColumn === t) return s;
      } else return null;
      i = s;
    }
    return null;
  }
}, jv = class extends R {
  constructor() {
    super(...arguments), this.beanName = "sortStage";
  }
  wireBeans(e) {
    this.sortService = e.sortService, this.sortController = e.sortController;
  }
  execute(e) {
    const t = this.sortController.getSortOptions(), i = E(t) && t.length > 0, s = i && E(e.rowNodeTransactions) && this.gos.get("deltaSort"), o = t.some((r) => _e(this.gos) ? r.column.isPrimary() && r.column.isRowGroupActive() : !!r.column.getColDef().showRowGroup);
    this.sortService.sort(t, i, s, e.rowNodeTransactions, e.changedPath, o);
  }
}, ko = "32.3.4", Sl = { version: ko, moduleName: `${ht.ClientSideRowModelModule}-core`, rowModel: "clientSide", beans: [Tv, _v, jv, Uv, $v, Kv] }, qv = { version: ko, moduleName: `${ht.ClientSideRowModelModule}-api`, beans: [SC], apiFunctions: { onGroupExpandedOrCollapsed: Iv, refreshClientSideRowModel: Lv, isRowDataEmpty: Ov, forEachLeafNode: Gv, forEachNodeAfterFilter: kv, forEachNodeAfterFilterAndSort: Hv, resetRowHeights: Nv, applyTransaction: Vv, applyTransactionAsync: Bv, flushAsyncTransactions: Wv, getBestCostNodeSelection: zv }, dependantModules: [Sl, FC] }, Yv = { version: ko, moduleName: ht.ClientSideRowModelModule, dependantModules: [Sl, qv] }, Qv = class extends R {
  setBeans(e) {
    this.beans = e;
  }
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
}, Xv = class {
  constructor(e) {
    this.groupColumns = [];
    const { columnModel: t, funcColsService: i, columnNameService: s, valueService: o, gos: r, processCellCallback: n, processHeaderCallback: l, processGroupHeaderCallback: a, processRowGroupCallback: c } = e;
    this.columnModel = t, this.funcColsService = i, this.columnNameService = s, this.valueService = o, this.gos = r, this.processCellCallback = n, this.processHeaderCallback = l, this.processGroupHeaderCallback = a, this.processRowGroupCallback = c;
  }
  prepare(e) {
    this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup);
  }
  extractHeaderValue(e) {
    return this.getHeaderName(this.processHeaderCallback, e) ?? "";
  }
  extractRowCellValue(e, t, i, s, o) {
    const n = (!this.gos.get("groupHideOpenParents") || o.footer) && this.shouldRenderGroupSummaryCell(o, e, t) ? this.createValueForGroupNode(e, o) : this.valueService.getValue(e, o);
    return this.processCell({ accumulatedRowIndex: i, rowNode: o, column: e, value: n, processCellCallback: this.processCellCallback, type: s });
  }
  shouldRenderGroupSummaryCell(e, t, i) {
    var _a3;
    if (!(e && e.group)) return false;
    if (this.groupColumns.indexOf(t) !== -1) {
      const n = (_a3 = e.groupData) == null ? void 0 : _a3[t.getId()], l = this.gos.get("suppressGroupMaintainValueType");
      if (l && n != null || !l && n !== void 0 || it(this.gos) && e.group) return true;
      if (e.footer && e.level === -1) {
        const a = t.getColDef();
        return a == null || a.showRowGroup === true || a.showRowGroup === this.funcColsService.getRowGroupColumns()[0].getId();
      }
    }
    const r = ss(this.gos, this.columnModel.isPivotMode());
    return i === 0 && r;
  }
  getHeaderName(e, t) {
    return e ? e(this.gos.addGridCommonParams({ column: t })) : this.columnNameService.getDisplayNameForColumn(t, "csv", true);
  }
  createValueForGroupNode(e, t) {
    if (this.processRowGroupCallback) return this.processRowGroupCallback(this.gos.addGridCommonParams({ column: e, node: t }));
    const i = this.gos.get("treeData"), s = this.gos.get("suppressGroupMaintainValueType"), o = (a) => {
      var _a3;
      if (i || s) return a.key;
      const c = (_a3 = a.groupData) == null ? void 0 : _a3[e.getId()];
      return !c || !a.rowGroupColumn || a.rowGroupColumn.getColDef().useValueFormatterForExport === false ? c : this.valueService.formatValue(a.rowGroupColumn, a, c) ?? c;
    }, r = t.footer, n = [o(t)];
    if (!Mr(this.gos)) for (; t.parent; ) t = t.parent, n.push(o(t));
    const l = n.reverse().join(" -> ");
    return r ? `Total ${l}` : l;
  }
  processCell(e) {
    const { accumulatedRowIndex: t, rowNode: i, column: s, value: o, processCellCallback: r, type: n } = e;
    return r ? { value: r(this.gos.addGridCommonParams({ accumulatedRowIndex: t, column: s, node: i, value: o, type: n, parseValue: (l) => this.valueService.parseValue(s, i, l, this.valueService.getValue(s, i)), formatValue: (l) => this.valueService.formatValue(s, i, l) ?? l })) ?? "" } : s.getColDef().useValueFormatterForExport !== false ? { value: o ?? "", valueFormatted: this.valueService.formatValue(s, i, o) } : { value: o ?? "" };
  }
}, Jv = class {
  static download(e, t) {
    const i = document.defaultView || window;
    if (!i) {
      F("There is no `window` associated with the current `document`");
      return;
    }
    const s = document.createElement("a"), o = i.URL.createObjectURL(t);
    s.setAttribute("href", o), s.setAttribute("download", e), s.style.display = "none", document.body.appendChild(s), s.dispatchEvent(new MouseEvent("click", { bubbles: false, cancelable: true, view: i })), document.body.removeChild(s), i.setTimeout(() => {
      i.URL.revokeObjectURL(o);
    }, 0);
  }
}, wr = `\r
`, Zv = class extends Xv {
  constructor(e) {
    super(e), this.isFirstLine = true, this.result = "";
    const { suppressQuotes: t, columnSeparator: i } = e;
    this.suppressQuotes = t, this.columnSeparator = i;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, wr), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((i, s) => {
        s !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(i.data.value || ""), i.mergeAcross && this.appendEmptyCells(i.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), { onColumn: this.onNewHeaderGroupingRowColumn.bind(this) };
  }
  onNewHeaderGroupingRowColumn(e, t, i, s) {
    i != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(s);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++) this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), { onColumn: this.onNewHeaderRowColumn.bind(this) };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), { onColumn: this.onNewBodyRowColumn.bind(this) };
  }
  onNewBodyRowColumn(e, t, i) {
    t != 0 && (this.result += this.columnSeparator);
    const s = this.extractRowCellValue(e, t, t, "csv", i);
    this.result += this.putInQuotes(s.valueFormatted ?? s.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes) return e;
    if (e == null) return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (F("unknown value type during csv conversion"), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += wr), this.isFirstLine = false;
  }
}, eS = class extends Qv {
  constructor() {
    super(...arguments), this.beanName = "csvCreator";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnNameService = e.columnNameService, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.gridSerializer = e.gridSerializer;
  }
  postConstruct() {
    this.setBeans({ gridSerializer: this.gridSerializer, gos: this.gos });
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      F("Export cancelled. Export is not allowed as per your configuration.");
      return;
    }
    const t = this.getMergedParams(e), i = this.getData(t), s = new Blob(["\uFEFF", i], { type: "text/plain" }), o = typeof t.fileName == "function" ? t.fileName(this.gos.getGridCommonParams()) : t.fileName;
    Jv.download(this.getFileName(o), s);
  }
  exportDataAsCsv(e) {
    this.export(e);
  }
  getDataAsCsv(e, t = false) {
    const i = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(i);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { columnModel: t, columnNameService: i, funcColsService: s, valueService: o, gos: r } = this, { processCellCallback: n, processHeaderCallback: l, processGroupHeaderCallback: a, processRowGroupCallback: c, suppressQuotes: u, columnSeparator: d } = e;
    return new Zv({ columnModel: t, columnNameService: i, funcColsService: s, valueService: o, gos: r, processCellCallback: n || void 0, processHeaderCallback: l || void 0, processGroupHeaderCallback: a || void 0, processRowGroupCallback: c || void 0, suppressQuotes: u || false, columnSeparator: d || "," });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};
function tS(e, t) {
  var _a3;
  return (_a3 = e.csvCreator) == null ? void 0 : _a3.getDataAsCsv(t);
}
function iS(e, t) {
  var _a3;
  (_a3 = e.csvCreator) == null ? void 0 : _a3.exportDataAsCsv(t);
}
var sS = class extends R {
  constructor() {
    super(...arguments), this.beanName = "gridSerializer";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.columnNameService = e.columnNameService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.selectionService = e.selectionService, this.rowNodeSorter = e.rowNodeSorter, this.sortController = e.sortController;
  }
  serialize(e, t = {}) {
    const { allColumns: i, columnKeys: s, skipRowGroups: o } = t, r = this.getColumnsToExport(i, o, s);
    return Ll(this.prepareSession(r), this.prependContent(t), this.exportColumnGroups(t, r), this.exportHeaders(t, r), this.processPinnedTopRows(t, r), this.processRows(t, r), this.processPinnedBottomRows(t, r), this.appendContent(t))(e).parse();
  }
  processRow(e, t, i, s) {
    var _a3;
    const o = t.shouldRowBeSkipped || (() => false), r = this.gos.get("groupRemoveSingleChildren"), n = this.gos.get("groupRemoveLowestSingleChildren"), a = t.rowPositions != null || !!t.onlySelected, c = this.gos.get("groupHideOpenParents") && !a, u = this.columnModel.isPivotMode() ? s.leafGroup : !s.group, d = !!s.footer, h = n && s.leafGroup, g = s.allChildrenCount === 1 && ((_a3 = s.childrenAfterGroup) == null ? void 0 : _a3.length) === 1 && (r || h);
    if (!u && !d && (t.skipRowGroups || g || c) || t.onlySelected && !s.isSelected() || t.skipPinnedTop && s.rowPinned === "top" || t.skipPinnedBottom && s.rowPinned === "bottom" || s.level === -1 && !u && !d || o(this.gos.addGridCommonParams({ node: s }))) return;
    const f = e.onNewBodyRow(s);
    if (i.forEach((v, w) => {
      f.onColumn(v, w, s);
    }), t.getCustomContentBelowRow) {
      const v = t.getCustomContentBelowRow(this.gos.addGridCommonParams({ node: s }));
      v && e.addCustomContent(v);
    }
  }
  appendContent(e) {
    return (t) => {
      const i = e.appendContent;
      return i && t.addCustomContent(i), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const i = e.prependContent;
      return i && t.addCustomContent(i), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (i) => {
      if (!e.skipColumnGroupHeaders) {
        const s = new Br(), o = this.visibleColsService.createGroups({ columns: t, idCreator: s, pinned: null, isStandaloneStructure: true });
        this.recursivelyAddHeaderGroups(o, i, e.processGroupHeaderCallback);
      }
      return i;
    };
  }
  exportHeaders(e, t) {
    return (i) => {
      if (!e.skipColumnHeaders) {
        const s = i.onNewHeaderRow();
        t.forEach((o, r) => {
          s.onColumn(o, r, void 0);
        });
      }
      return i;
    };
  }
  processPinnedTopRows(e, t) {
    return (i) => {
      const s = this.processRow.bind(this, i, e, t);
      return e.rowPositions ? e.rowPositions.filter((o) => o.rowPinned === "top").sort((o, r) => o.rowIndex - r.rowIndex).map((o) => this.pinnedRowModel.getPinnedTopRow(o.rowIndex)).forEach(s) : this.pinnedRowModel.forEachPinnedRow("top", s), i;
    };
  }
  processRows(e, t) {
    return (i) => {
      const s = this.rowModel, o = Q(this.gos), r = it(this.gos), n = !o && e.onlySelected, l = this.processRow.bind(this, i, e, t), { exportedRows: a = "filteredAndSorted" } = e;
      if (e.rowPositions) e.rowPositions.filter((c) => c.rowPinned == null).sort((c, u) => c.rowIndex - u.rowIndex).map((c) => s.getRow(c.rowIndex)).forEach(l);
      else if (this.columnModel.isPivotMode()) o ? s.forEachPivotNode(l, true) : r ? s.forEachNodeAfterFilterAndSort(l, true) : s.forEachNode(l);
      else if (e.onlySelectedAllPages || n) {
        const c = this.selectionService.getSelectedNodes();
        this.replicateSortedOrder(c), c.forEach(l);
      } else a === "all" ? s.forEachNode(l) : o || r ? s.forEachNodeAfterFilterAndSort(l, true) : s.forEachNode(l);
      return i;
    };
  }
  replicateSortedOrder(e) {
    const t = this.sortController.getSortOptions(), i = (s, o) => {
      var _a3, _b;
      return s.rowIndex != null && o.rowIndex != null ? s.rowIndex - o.rowIndex : s.level === o.level ? ((_a3 = s.parent) == null ? void 0 : _a3.id) === ((_b = o.parent) == null ? void 0 : _b.id) ? this.rowNodeSorter.compareRowNodes(t, { rowNode: s, currentPos: s.rowIndex ?? -1 }, { rowNode: o, currentPos: o.rowIndex ?? -1 }) : i(s.parent, o.parent) : s.level > o.level ? i(s.parent, o) : i(s, o.parent);
    };
    e.sort(i);
  }
  processPinnedBottomRows(e, t) {
    return (i) => {
      const s = this.processRow.bind(this, i, e, t);
      return e.rowPositions ? e.rowPositions.filter((o) => o.rowPinned === "bottom").sort((o, r) => o.rowIndex - r.rowIndex).map((o) => this.pinnedRowModel.getPinnedBottomRow(o.rowIndex)).forEach(s) : this.pinnedRowModel.forEachPinnedRow("bottom", s), i;
    };
  }
  getColumnsToExport(e = false, t = false, i) {
    const s = this.columnModel.isPivotMode();
    if (i && i.length) return this.columnModel.getColsForKeys(i);
    const o = this.gos.get("treeData");
    let r = [];
    return e && !s ? r = this.columnModel.getCols() : r = this.visibleColsService.getAllCols(), t && !o && (r = r.filter((n) => !Gs(n) && !vi(n))), r;
  }
  recursivelyAddHeaderGroups(e, t, i) {
    const s = [];
    e.forEach((o) => {
      const r = o;
      r.getChildren && r.getChildren().forEach((n) => s.push(n));
    }), e.length > 0 && ae(e[0]) && this.doAddHeaderHeader(t, e, i), s && s.length > 0 && this.recursivelyAddHeaderGroups(s, t, i);
  }
  doAddHeaderHeader(e, t, i) {
    const s = e.onNewHeaderGroupingRow();
    let o = 0;
    t.forEach((r) => {
      const n = r;
      let l;
      i ? l = i(this.gos.addGridCommonParams({ columnGroup: n })) : l = this.columnNameService.getDisplayNameForColumnGroup(n, "header");
      const a = n.getLeafColumns().reduce((c, u, d, h) => {
        let g = N(c);
        return u.getColumnGroupShow() === "open" ? (!g || g[1] != null) && (g = [d], c.push(g)) : g && g[1] == null && (g[1] = d - 1), d === h.length - 1 && g && g[1] == null && (g[1] = d), c;
      }, []);
      s.onColumn(n, l || "", o++, n.getLeafColumns().length - 1, a);
    });
  }
}, Ho = "32.3.4", wl = { version: Ho, moduleName: `${ht.CsvExportModule}-core`, beans: [eS, sS] }, oS = { version: Ho, moduleName: `${ht.CsvExportModule}-api`, apiFunctions: { getDataAsCsv: tS, exportDataAsCsv: iS }, dependantModules: [wl] }, rS = { version: Ho, moduleName: ht.CsvExportModule, dependantModules: [wl, oS] };
const nS = "_grid_9qncm_1", lS = { grid: nS };
Ue.registerModules([Yv, rS]);
function aS(e) {
  return e.data.pubkey;
}
function cS(e) {
  var _a3, _b;
  const t = e.vote.find((i) => i.activated_stake > 0);
  return { pubkey: e.identity_pubkey, name: (_a3 = e.info) == null ? void 0 : _a3.name, description: (_b = e.info) == null ? void 0 : _b.details, stake: t == null ? void 0 : t.activated_stake, delinquent: t == null ? void 0 : t.delinquent, lastVote: t == null ? void 0 : t.last_vote, rootSlot: t == null ? void 0 : t.root_slot };
}
const uS = [{ field: "pubkey", initialWidth: 300, cellStyle: (e) => {
  var _a3;
  return { color: ((_a3 = e.data) == null ? void 0 : _a3.delinquent) ? Dl : Ml };
}, filter: true }, { field: "name", initialWidth: 300, filter: true }, { field: "description", initialWidth: 500, filter: true }, { field: "stake", initialSort: "desc", initialWidth: 180, filter: true, valueFormatter: (e) => {
  var _a3;
  return ((_a3 = e.value) == null ? void 0 : _a3.toString()) ?? "";
} }, { field: "delinquent", initialWidth: 110, filter: true }, { field: "lastVote", initialWidth: 110, filter: true }, { field: "rootSlot", initialWidth: 110, filter: true }];
function dS() {
  const e = Pl(El), t = p.useMemo(() => Object.values(e).map(cS), [e]);
  return Vi.jsx("div", { className: `ag-theme-quartz-dark ${lS.grid}`, style: { height: "100%" }, children: Vi.jsx(Mv, { rowData: t, columnDefs: uS, getRowId: aS }) });
}
function mS() {
  return Vi.jsx(xl, { direction: "column", gap: "4", style: { padding: "4px 12px" }, height: "calc(100vh - var(--header-height))", children: Vi.jsx(dS, {}) });
}
export {
  mS as default
};
