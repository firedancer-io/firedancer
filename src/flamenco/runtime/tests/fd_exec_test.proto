syntax = "proto3";
package org.solana.sealevel.v1;

// Source:
// https://github.com/solana-foundation/specs/blob/main/runtime/compat/v1/context.proto

// Regenerate: "make -C src/flamenco/runtime/tests" (requires nanopb)

import "nanopb.proto";
option (nanopb_fileopt).package = "fd_exec_test";
option (nanopb_fileopt).include = "../../nanopb/pb_firedancer.h";

// A set of feature flags.
message FeatureSet {
    // Every item in this list marks an enabled feature.  The value of
    // each item is the first 8 bytes of the feature ID as a little-
    // endian integer.
    repeated fixed64 features = 1
        [(nanopb).type = FT_POINTER];
}

// The complete state of an account excluding its public key.
message AcctState {
    // The account key. Can be ommitted if obvious from the context.
    optional bytes address = 1
        [(nanopb).max_size = 32, (nanopb).fixed_length = true];

    optional uint64 lamports = 2;
    optional bytes data = 3
        [(nanopb).type = FT_POINTER];
    optional bool executable = 4;
    optional uint64 rent_epoch = 5;
    optional bytes owner = 6
        [(nanopb).max_size = 32, (nanopb).fixed_length = true];
}

// EpochContext includes context scoped to an epoch.
// On "real" ledgers, it is created during the epoch boundary.
message EpochContext {
  FeatureSet features = 1;
}

// SlotContext includes context scoped to a block.
// On "real" ledgers, it is created during the slot boundary.
message SlotContext {}

message TxnContext {}

message InstrAcct {
    // Selects an account in an external list
    optional uint32 index = 1;
    optional bool is_writable = 2;
    optional bool is_signer = 3;
}

// The execution context of a program invocation (aka instruction).
// Contains all information to independently replay an instruction.
// Also includes partial transaction context.
message InstrContext {
    // The address of the program invoked.  (32 bytes)
    optional bytes program_id = 1
        [(nanopb).max_size = 32, (nanopb).fixed_length = true];

    // The address of the program loader if the invoked program is a user
    // deployed program.
    optional bytes loader_id = 2
        [(nanopb).max_size = 32, (nanopb).fixed_length = true];

    // Account state accessed by the instruction.
    repeated AcctState accounts = 3
        [(nanopb).type = FT_POINTER];

    // Account access list for this instruction (refers to above accounts list)
    repeated InstrAcct instr_accounts = 4
        [(nanopb).type = FT_POINTER];

    // The input data passed to program execution.
    optional bytes data = 5
        [(nanopb).type = FT_POINTER];

    optional uint64 cu_avail = 6;

    optional TxnContext txn_context = 7;
    optional SlotContext slot_context = 8;
    optional EpochContext epoch_context = 9;
}

// The results of executing an InstrContext.
message InstrEffects {
    // result is zero if the instruction executed succesfully.
    // Otherwise, a non-zero error code.  Error codes are implementation
    // defined.
    int32 result = 1;

    // Some error cases additionally have a custom error code.  Unlike
    // the expected_result, this is stable across clients.
    optional uint32 custom_err = 2;

    // Copies of accounts that were changed.  May be in an arbitrary
    // order.  The pubkey of each account is unique in this list.  Each
    // account address modified here must also be in the
    // InstrContext.
    repeated AcctState modified_accounts = 3
        [(nanopb).type = FT_POINTER];

    uint64 cu_avail = 4;
}

// An instruction processing test fixture.
message InstrFixture {
    InstrContext input = 1;
    InstrEffects output = 2;
}

// Describes an input data region. Agave's memory mapping sets up a series of
// memory mapped regions, which combine to make the input data region.
message InputDataRegion {
  // Offset from the start of the input data segment (0x400000000)
  uint64 offset = 1;
  // Content of the memory region
  bytes content = 2
      [(nanopb).type = FT_POINTER];
  // If the memory region is writable or not
  bool is_writable = 3;
}

// TODO: investigate make this an overlay not a context, and let each target set up the 
// vm context from the instruction context.

// Information sufficient to allow the fuzzer to generate a fd_vm_t context for 
// execution inside the VM (excluding the instruction context).
//
// TODO: this currently only includes fields necessary for executing syscalls,
// executing sBPF code will require the rest of the fields in fd_vm_t to be set.
message VmContext {
    // Maximum heap size in bytes
    uint64 heap_max = 1;

    // Program read-only data
    bytes rodata = 2
        [(nanopb).type = FT_POINTER];
    // Offset of the text section from the start of the program rodata segment
    // (0x100000000)
    uint64 rodata_text_section_offset = 3;
    // Length of the text section in the program rodata region, in bytes.
    uint64 rodata_text_section_length = 4;
    
    // The input data regions
    repeated InputDataRegion input_data_regions = 5
        [(nanopb).type = FT_POINTER];

    // Registers
    uint64 r0 = 6;
    uint64 r1 = 7;
    uint64 r2 = 8;
    uint64 r3 = 9;
    uint64 r4 = 10;
    uint64 r5 = 11;
    uint64 r6 = 12;
    uint64 r7 = 13;
    uint64 r8 = 14;
    uint64 r9 = 15;
    uint64 r10 = 16;
    uint64 r11 = 17;

    // TODO: extend this to support the rest of the vm fields, needed for
    // full coverage of the vm interpreter code.
}

// TODO: use structured types for syscall implementation to improve fuzz coverage
// We should seperate out the engine protos from the target protos to make implementation
// of the targets easier.

// TODO: for CPI syscalls, consider generating effects in protobufs vs full cpi
// execution

// A single invocation of a syscall
message SyscallInvocation {
    // The sBPF function name of the syscall
    string function_name = 1
        [(nanopb).max_size = 1400];
}

// Execution context for a VM Syscall execution.
message SyscallContext {
    VmContext vm_ctx = 1;
    // InflightInstruction - contain temporary fields that live for the duration of an instructions execution, and is needed if we have overhanging context from a previous instruction
    InstrContext instr_ctx = 2;
    SyscallInvocation syscall_invocation = 3;
}

// The effects of executing a SyscallContext.
message SyscallEffects {
    // EBPF error code, if the invocation was unsuccessful
    int64 error = 1;
    
    // Registers
    uint64 r0 = 2; // Result of a successful execution

    // CU's remaining
    uint64 cu_avail = 3;

    // Memory regions
    bytes heap = 4
        [(nanopb).type = FT_POINTER];
    bytes stack = 5
        [(nanopb).type = FT_POINTER];
    bytes inputdata = 6
        [(nanopb).type = FT_POINTER];

    // Current number of stack frames pushed
    uint64 frame_count = 7;

    // Syscall log
    bytes log = 8
        [(nanopb).type = FT_POINTER];
}
