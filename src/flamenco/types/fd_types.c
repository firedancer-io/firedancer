// This is an auto-generated file. To add entries, edit fd_types.json
#include "fd_types.h"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#define SOURCE_fd_src_flamenco_types_fd_types_c
#include "fd_types_custom.c"
void fd_hash_new( fd_hash_t * self ) { }
void fd_hash_destroy( fd_hash_t * self ) { }
ulong fd_hash_footprint( void ) { return sizeof(fd_hash_t); }
ulong fd_hash_align( void ) { return alignof(fd_hash_t); }
ulong fd_hash_size( fd_hash_t const * self ) { (void)self; return sizeof(fd_hash_t); }
int fd_hash_encode( fd_hash_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  return fd_bincode_bytes_encode( (uchar const *)self, sizeof(fd_hash_t), ctx );
}
void fd_hash_walk( void * w, fd_hash_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, (uchar const *)self, name, FD_FLAMENCO_TYPE_HASH256, name, level );
}
int fd_hash_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_hash_t);
  void const * start_data = ctx->data;
  int err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_hash_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  return fd_bincode_bytes_decode_footprint( sizeof(fd_hash_t), ctx );
}
void * fd_hash_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_hash_t), ctx );
  return mem;
}
void fd_hash_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_hash_t), ctx );
  return;
}
void * fd_hash_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_hash_t), ctx );
  return mem;
}
void fd_hash_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_hash_t), ctx );
  return;
}
int fd_hash_convert_global_to_local( void const * global_self, fd_hash_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_memcpy( self, global_self, sizeof(fd_hash_t) );
  return FD_BINCODE_SUCCESS;
}

void fd_signature_new( fd_signature_t * self ) { }
void fd_signature_destroy( fd_signature_t * self ) { }
ulong fd_signature_footprint( void ) { return sizeof(fd_signature_t); }
ulong fd_signature_align( void ) { return alignof(fd_signature_t); }
ulong fd_signature_size( fd_signature_t const * self ) { (void)self; return sizeof(fd_signature_t); }
int fd_signature_encode( fd_signature_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  return fd_bincode_bytes_encode( (uchar const *)self, sizeof(fd_signature_t), ctx );
}
void fd_signature_walk( void * w, fd_signature_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, (uchar const *)self, name, FD_FLAMENCO_TYPE_SIG512, name, level );
}
int fd_signature_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_signature_t);
  void const * start_data = ctx->data;
  int err = fd_signature_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_signature_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  return fd_bincode_bytes_decode_footprint( sizeof(fd_signature_t), ctx );
}
void * fd_signature_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_signature_t), ctx );
  return mem;
}
void fd_signature_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_signature_t), ctx );
  return;
}
void * fd_signature_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_signature_t), ctx );
  return mem;
}
void fd_signature_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_signature_t), ctx );
  return;
}
int fd_signature_convert_global_to_local( void const * global_self, fd_signature_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_memcpy( self, global_self, sizeof(fd_signature_t) );
  return FD_BINCODE_SUCCESS;
}

void fd_gossip_ip4_addr_new( fd_gossip_ip4_addr_t * self ) { }
void fd_gossip_ip4_addr_destroy( fd_gossip_ip4_addr_t * self ) { }
ulong fd_gossip_ip4_addr_footprint( void ) { return sizeof(fd_gossip_ip4_addr_t); }
ulong fd_gossip_ip4_addr_align( void ) { return alignof(fd_gossip_ip4_addr_t); }
ulong fd_gossip_ip4_addr_size( fd_gossip_ip4_addr_t const * self ) { (void)self; return sizeof(fd_gossip_ip4_addr_t); }
int fd_gossip_ip4_addr_encode( fd_gossip_ip4_addr_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  return fd_bincode_bytes_encode( (uchar const *)self, sizeof(fd_gossip_ip4_addr_t), ctx );
}
int fd_gossip_ip4_addr_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_ip4_addr_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_ip4_addr_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_ip4_addr_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  return fd_bincode_bytes_decode_footprint( sizeof(fd_gossip_ip4_addr_t), ctx );
}
void * fd_gossip_ip4_addr_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_gossip_ip4_addr_t), ctx );
  return mem;
}
void fd_gossip_ip4_addr_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_gossip_ip4_addr_t), ctx );
  return;
}
void * fd_gossip_ip4_addr_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_gossip_ip4_addr_t), ctx );
  return mem;
}
void fd_gossip_ip4_addr_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_gossip_ip4_addr_t), ctx );
  return;
}
int fd_gossip_ip4_addr_convert_global_to_local( void const * global_self, fd_gossip_ip4_addr_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_memcpy( self, global_self, sizeof(fd_gossip_ip4_addr_t) );
  return FD_BINCODE_SUCCESS;
}

void fd_gossip_ip6_addr_new( fd_gossip_ip6_addr_t * self ) { }
void fd_gossip_ip6_addr_destroy( fd_gossip_ip6_addr_t * self ) { }
ulong fd_gossip_ip6_addr_footprint( void ) { return sizeof(fd_gossip_ip6_addr_t); }
ulong fd_gossip_ip6_addr_align( void ) { return alignof(fd_gossip_ip6_addr_t); }
ulong fd_gossip_ip6_addr_size( fd_gossip_ip6_addr_t const * self ) { (void)self; return sizeof(fd_gossip_ip6_addr_t); }
int fd_gossip_ip6_addr_encode( fd_gossip_ip6_addr_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  return fd_bincode_bytes_encode( (uchar const *)self, sizeof(fd_gossip_ip6_addr_t), ctx );
}
int fd_gossip_ip6_addr_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_ip6_addr_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_ip6_addr_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_ip6_addr_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  return fd_bincode_bytes_decode_footprint( sizeof(fd_gossip_ip6_addr_t), ctx );
}
void * fd_gossip_ip6_addr_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_gossip_ip6_addr_t), ctx );
  return mem;
}
void fd_gossip_ip6_addr_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_gossip_ip6_addr_t), ctx );
  return;
}
void * fd_gossip_ip6_addr_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( mem, sizeof(fd_gossip_ip6_addr_t), ctx );
  return mem;
}
void fd_gossip_ip6_addr_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bincode_bytes_decode_unsafe( struct_mem, sizeof(fd_gossip_ip6_addr_t), ctx );
  return;
}
int fd_gossip_ip6_addr_convert_global_to_local( void const * global_self, fd_gossip_ip6_addr_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_memcpy( self, global_self, sizeof(fd_gossip_ip6_addr_t) );
  return FD_BINCODE_SUCCESS;
}

int fd_feature_encode( fd_feature_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_bool_encode( self->has_activated_at, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_activated_at ) {
    err = fd_bincode_uint64_encode( self->activated_at, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_feature_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_feature_t);
  void const * start_data = ctx->data;
  int err = fd_feature_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_feature_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_feature_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_t * self = (fd_feature_t *)mem;
  fd_feature_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_feature_t);
  void * * alloc_mem = &alloc_region;
  fd_feature_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_feature_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_t * self = (fd_feature_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_activated_at = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->activated_at, ctx );
    }
  }
}
void * fd_feature_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_global_t * self = (fd_feature_global_t *)mem;
  fd_feature_new( (fd_feature_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_feature_global_t);
  void * * alloc_mem = &alloc_region;
  fd_feature_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_feature_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_global_t * self = (fd_feature_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_activated_at = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->activated_at, ctx );
    }
  }
}
int fd_feature_convert_global_to_local( void const * global_self, fd_feature_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_feature_global_t const * mem = (fd_feature_global_t const *)global_self;
  self->activated_at = mem->activated_at;
  self->has_activated_at = mem->has_activated_at;
  return FD_BINCODE_SUCCESS;
}
void fd_feature_new(fd_feature_t * self) {
  fd_memset( self, 0, sizeof(fd_feature_t) );
}
void fd_feature_destroy( fd_feature_t * self ) {
  if( self->has_activated_at ) {
    self->has_activated_at = 0;
  }
}

ulong fd_feature_footprint( void ){ return FD_FEATURE_FOOTPRINT; }
ulong fd_feature_align( void ){ return FD_FEATURE_ALIGN; }

void fd_feature_walk( void * w, fd_feature_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_feature", level++ );
  if( !self->has_activated_at ) {
    fun( w, NULL, "activated_at", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->activated_at, "activated_at", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_feature", level-- );
}
ulong fd_feature_size( fd_feature_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( self->has_activated_at ) {
    size += sizeof(ulong);
  }
  return size;
}

int fd_fee_calculator_encode( fd_fee_calculator_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_fee_calculator_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_fee_calculator_t);
  void const * start_data = ctx->data;
  int err = fd_fee_calculator_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_fee_calculator_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_fee_calculator_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_calculator_t * self = (fd_fee_calculator_t *)mem;
  fd_fee_calculator_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_fee_calculator_t);
  void * * alloc_mem = &alloc_region;
  fd_fee_calculator_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_fee_calculator_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_calculator_t * self = (fd_fee_calculator_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
}
void * fd_fee_calculator_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_calculator_global_t * self = (fd_fee_calculator_global_t *)mem;
  fd_fee_calculator_new( (fd_fee_calculator_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_fee_calculator_global_t);
  void * * alloc_mem = &alloc_region;
  fd_fee_calculator_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_fee_calculator_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_calculator_global_t * self = (fd_fee_calculator_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
}
int fd_fee_calculator_convert_global_to_local( void const * global_self, fd_fee_calculator_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_fee_calculator_global_t const * mem = (fd_fee_calculator_global_t const *)global_self;
  self->lamports_per_signature = mem->lamports_per_signature;
  return FD_BINCODE_SUCCESS;
}
void fd_fee_calculator_new(fd_fee_calculator_t * self) {
  fd_memset( self, 0, sizeof(fd_fee_calculator_t) );
}
void fd_fee_calculator_destroy( fd_fee_calculator_t * self ) {
}

ulong fd_fee_calculator_footprint( void ){ return FD_FEE_CALCULATOR_FOOTPRINT; }
ulong fd_fee_calculator_align( void ){ return FD_FEE_CALCULATOR_ALIGN; }

void fd_fee_calculator_walk( void * w, fd_fee_calculator_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_fee_calculator", level++ );
  fun( w, &self->lamports_per_signature, "lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_fee_calculator", level-- );
}
ulong fd_fee_calculator_size( fd_fee_calculator_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  return size;
}

int fd_hash_age_encode( fd_hash_age_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_fee_calculator_encode( &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->hash_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_hash_age_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_hash_age_t);
  void const * start_data = ctx->data;
  int err = fd_hash_age_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_hash_age_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_fee_calculator_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_hash_age_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_age_t * self = (fd_hash_age_t *)mem;
  fd_hash_age_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_hash_age_t);
  void * * alloc_mem = &alloc_region;
  fd_hash_age_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_hash_age_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_age_t * self = (fd_hash_age_t *)struct_mem;
  fd_fee_calculator_decode_inner( &self->fee_calculator, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hash_index, ctx );
  fd_bincode_uint64_decode_unsafe( &self->timestamp, ctx );
}
void * fd_hash_age_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_age_global_t * self = (fd_hash_age_global_t *)mem;
  fd_hash_age_new( (fd_hash_age_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_hash_age_global_t);
  void * * alloc_mem = &alloc_region;
  fd_hash_age_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_hash_age_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_age_global_t * self = (fd_hash_age_global_t *)struct_mem;
  fd_fee_calculator_decode_inner_global( &self->fee_calculator, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hash_index, ctx );
  fd_bincode_uint64_decode_unsafe( &self->timestamp, ctx );
}
int fd_hash_age_convert_global_to_local( void const * global_self, fd_hash_age_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_hash_age_global_t const * mem = (fd_hash_age_global_t const *)global_self;
  err = fd_fee_calculator_convert_global_to_local( &mem->fee_calculator, &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->hash_index = mem->hash_index;
  self->timestamp = mem->timestamp;
  return FD_BINCODE_SUCCESS;
}
void fd_hash_age_new(fd_hash_age_t * self) {
  fd_memset( self, 0, sizeof(fd_hash_age_t) );
  fd_fee_calculator_new( &self->fee_calculator );
}
void fd_hash_age_destroy( fd_hash_age_t * self ) {
  fd_fee_calculator_destroy( &self->fee_calculator );
}

ulong fd_hash_age_footprint( void ){ return FD_HASH_AGE_FOOTPRINT; }
ulong fd_hash_age_align( void ){ return FD_HASH_AGE_ALIGN; }

void fd_hash_age_walk( void * w, fd_hash_age_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_hash_age", level++ );
  fd_fee_calculator_walk( w, &self->fee_calculator, fun, "fee_calculator", level );
  fun( w, &self->hash_index, "hash_index", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_hash_age", level-- );
}
ulong fd_hash_age_size( fd_hash_age_t const * self ) {
  ulong size = 0;
  size += fd_fee_calculator_size( &self->fee_calculator );
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_hash_hash_age_pair_encode( fd_hash_hash_age_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_hash_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_age_encode( &self->val, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_hash_hash_age_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_hash_hash_age_pair_t);
  void const * start_data = ctx->data;
  int err = fd_hash_hash_age_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_hash_hash_age_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_age_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_hash_hash_age_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_hash_age_pair_t * self = (fd_hash_hash_age_pair_t *)mem;
  fd_hash_hash_age_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_hash_hash_age_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_hash_hash_age_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_hash_hash_age_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_hash_age_pair_t * self = (fd_hash_hash_age_pair_t *)struct_mem;
  fd_hash_decode_inner( &self->key, alloc_mem, ctx );
  fd_hash_age_decode_inner( &self->val, alloc_mem, ctx );
}
void * fd_hash_hash_age_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_hash_age_pair_global_t * self = (fd_hash_hash_age_pair_global_t *)mem;
  fd_hash_hash_age_pair_new( (fd_hash_hash_age_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_hash_hash_age_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_hash_hash_age_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_hash_hash_age_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hash_hash_age_pair_global_t * self = (fd_hash_hash_age_pair_global_t *)struct_mem;
  fd_hash_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_hash_age_decode_inner_global( &self->val, alloc_mem, ctx );
}
int fd_hash_hash_age_pair_convert_global_to_local( void const * global_self, fd_hash_hash_age_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_hash_hash_age_pair_global_t const * mem = (fd_hash_hash_age_pair_global_t const *)global_self;
  err = fd_hash_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_age_convert_global_to_local( &mem->val, &self->val, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_hash_hash_age_pair_new(fd_hash_hash_age_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_hash_hash_age_pair_t) );
  fd_hash_new( &self->key );
  fd_hash_age_new( &self->val );
}
void fd_hash_hash_age_pair_destroy( fd_hash_hash_age_pair_t * self ) {
  fd_hash_destroy( &self->key );
  fd_hash_age_destroy( &self->val );
}

ulong fd_hash_hash_age_pair_footprint( void ){ return FD_HASH_HASH_AGE_PAIR_FOOTPRINT; }
ulong fd_hash_hash_age_pair_align( void ){ return FD_HASH_HASH_AGE_PAIR_ALIGN; }

void fd_hash_hash_age_pair_walk( void * w, fd_hash_hash_age_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_hash_hash_age_pair", level++ );
  fd_hash_walk( w, &self->key, fun, "key", level );
  fd_hash_age_walk( w, &self->val, fun, "val", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_hash_hash_age_pair", level-- );
}
ulong fd_hash_hash_age_pair_size( fd_hash_hash_age_pair_t const * self ) {
  ulong size = 0;
  size += fd_hash_size( &self->key );
  size += fd_hash_age_size( &self->val );
  return size;
}

int fd_block_hash_vec_encode( fd_block_hash_vec_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->last_hash_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->last_hash != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_hash_encode( self->last_hash, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->ages_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->ages_len ) {
    for( ulong i=0; i < self->ages_len; i++ ) {
      err = fd_hash_hash_age_pair_encode( self->ages + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->max_age, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_block_hash_vec_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_block_hash_vec_t);
  void const * start_data = ctx->data;
  int err = fd_block_hash_vec_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_block_hash_vec_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_HASH_ALIGN + FD_HASH_FOOTPRINT;
      err = fd_hash_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong ages_len;
  err = fd_bincode_uint64_decode( &ages_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( ages_len ) {
    *total_sz += FD_HASH_HASH_AGE_PAIR_ALIGN + FD_HASH_HASH_AGE_PAIR_FOOTPRINT*ages_len;
    for( ulong i=0; i < ages_len; i++ ) {
      err = fd_hash_hash_age_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_block_hash_vec_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_vec_t * self = (fd_block_hash_vec_t *)mem;
  fd_block_hash_vec_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_block_hash_vec_t);
  void * * alloc_mem = &alloc_region;
  fd_block_hash_vec_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_block_hash_vec_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_vec_t * self = (fd_block_hash_vec_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->last_hash_index, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_HASH_ALIGN );
      self->last_hash = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_HASH_FOOTPRINT;
      fd_hash_new( self->last_hash );
      fd_hash_decode_inner( self->last_hash, alloc_mem, ctx );
    } else {
      self->last_hash = NULL;
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->ages_len, ctx );
  if( self->ages_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_HASH_HASH_AGE_PAIR_ALIGN );
    self->ages = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_HASH_HASH_AGE_PAIR_FOOTPRINT*self->ages_len;
    for( ulong i=0; i < self->ages_len; i++ ) {
      fd_hash_hash_age_pair_new( self->ages + i );
      fd_hash_hash_age_pair_decode_inner( self->ages + i, alloc_mem, ctx );
    }
  } else
    self->ages = NULL;
  fd_bincode_uint64_decode_unsafe( &self->max_age, ctx );
}
void * fd_block_hash_vec_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_vec_global_t * self = (fd_block_hash_vec_global_t *)mem;
  fd_block_hash_vec_new( (fd_block_hash_vec_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_block_hash_vec_global_t);
  void * * alloc_mem = &alloc_region;
  fd_block_hash_vec_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_block_hash_vec_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_vec_global_t * self = (fd_block_hash_vec_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->last_hash_index, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_HASH_ALIGN );
      self->last_hash_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_hash_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_HASH_FOOTPRINT;
      fd_hash_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->last_hash_gaddr ), alloc_mem, ctx );
    } else {
      self->last_hash_gaddr = 0UL;
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->ages_len, ctx );
  if( self->ages_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_HASH_HASH_AGE_PAIR_ALIGN );
    self->ages_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_HASH_HASH_AGE_PAIR_FOOTPRINT*self->ages_len;
    for( ulong i=0; i < self->ages_len; i++ ) {
      fd_hash_hash_age_pair_new( (fd_hash_hash_age_pair_t *)(cur_mem + FD_HASH_HASH_AGE_PAIR_FOOTPRINT * i) );
      fd_hash_hash_age_pair_decode_inner_global( cur_mem + FD_HASH_HASH_AGE_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->ages_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->max_age, ctx );
}
int fd_block_hash_vec_convert_global_to_local( void const * global_self, fd_block_hash_vec_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_block_hash_vec_global_t const * mem = (fd_block_hash_vec_global_t const *)global_self;
  self->last_hash_index = mem->last_hash_index;
  self->last_hash = fd_wksp_laddr_fast( ctx->wksp, mem->last_hash_gaddr );
  self->ages_len = mem->ages_len;
  self->ages     = fd_wksp_laddr_fast( ctx->wksp, mem->ages_gaddr );
  self->max_age = mem->max_age;
  return FD_BINCODE_SUCCESS;
}
void fd_block_hash_vec_new(fd_block_hash_vec_t * self) {
  fd_memset( self, 0, sizeof(fd_block_hash_vec_t) );
}
void fd_block_hash_vec_destroy( fd_block_hash_vec_t * self ) {
  if( self->last_hash ) {
    fd_hash_destroy( self->last_hash );
    self->last_hash = NULL;
  }
  if( self->ages ) {
    for( ulong i=0; i < self->ages_len; i++ )
      fd_hash_hash_age_pair_destroy( self->ages + i );
    self->ages = NULL;
  }
}

ulong fd_block_hash_vec_footprint( void ){ return FD_BLOCK_HASH_VEC_FOOTPRINT; }
ulong fd_block_hash_vec_align( void ){ return FD_BLOCK_HASH_VEC_ALIGN; }

void fd_block_hash_vec_walk( void * w, fd_block_hash_vec_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_block_hash_vec", level++ );
  fun( w, &self->last_hash_index, "last_hash_index", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->last_hash ) {
    fun( w, NULL, "last_hash", FD_FLAMENCO_TYPE_NULL, "hash", level );
  } else {
    fd_hash_walk( w, self->last_hash, fun, "last_hash", level );
  }
  if( self->ages_len ) {
    fun( w, NULL, "ages", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->ages_len; i++ )
      fd_hash_hash_age_pair_walk(w, self->ages + i, fun, "hash_hash_age_pair", level );
    fun( w, NULL, "ages", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->max_age, "max_age", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_block_hash_vec", level-- );
}
ulong fd_block_hash_vec_size( fd_block_hash_vec_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(char);
  if( NULL !=  self->last_hash ) {
    size += fd_hash_size( self->last_hash );
  }
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->ages_len; i++ )
      size += fd_hash_hash_age_pair_size( self->ages + i );
  } while(0);
  size += sizeof(ulong);
  return size;
}

int fd_block_hash_queue_encode( fd_block_hash_queue_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->last_hash_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->last_hash != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_hash_encode( self->last_hash, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  if( self->ages_root ) {
    ulong ages_len = fd_hash_hash_age_pair_t_map_size( self->ages_pool, self->ages_root );
    err = fd_bincode_uint64_encode( ages_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_hash_hash_age_pair_t_mapnode_t * n = fd_hash_hash_age_pair_t_map_minimum( self->ages_pool, self->ages_root ); n; n = fd_hash_hash_age_pair_t_map_successor( self->ages_pool, n ) ) {
      err = fd_hash_hash_age_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong ages_len = 0;
    err = fd_bincode_uint64_encode( ages_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->max_age, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_block_hash_queue_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_block_hash_queue_t);
  void const * start_data = ctx->data;
  int err = fd_block_hash_queue_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_block_hash_queue_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_HASH_ALIGN + FD_HASH_FOOTPRINT;
      err = fd_hash_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong ages_len = 0UL;
  err = fd_bincode_uint64_decode( &ages_len, ctx );
  ulong ages_cnt = fd_ulong_max( ages_len, 400 );
  *total_sz += fd_hash_hash_age_pair_t_map_align() + fd_hash_hash_age_pair_t_map_footprint( ages_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < ages_len; i++ ) {
    err = fd_hash_hash_age_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_block_hash_queue_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_queue_t * self = (fd_block_hash_queue_t *)mem;
  fd_block_hash_queue_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_block_hash_queue_t);
  void * * alloc_mem = &alloc_region;
  fd_block_hash_queue_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_block_hash_queue_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_queue_t * self = (fd_block_hash_queue_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->last_hash_index, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_HASH_ALIGN );
      self->last_hash = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_HASH_FOOTPRINT;
      fd_hash_new( self->last_hash );
      fd_hash_decode_inner( self->last_hash, alloc_mem, ctx );
    } else {
      self->last_hash = NULL;
    }
  }
  ulong ages_len;
  fd_bincode_uint64_decode_unsafe( &ages_len, ctx );
  self->ages_pool = fd_hash_hash_age_pair_t_map_join_new( alloc_mem, fd_ulong_max( ages_len, 400 ) );
  self->ages_root = NULL;
  for( ulong i=0; i < ages_len; i++ ) {
    fd_hash_hash_age_pair_t_mapnode_t * node = fd_hash_hash_age_pair_t_map_acquire( self->ages_pool );
    fd_hash_hash_age_pair_new( &node->elem );
    fd_hash_hash_age_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_hash_hash_age_pair_t_map_insert( self->ages_pool, &self->ages_root, node );
  }
  fd_bincode_uint64_decode_unsafe( &self->max_age, ctx );
}
void * fd_block_hash_queue_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_queue_global_t * self = (fd_block_hash_queue_global_t *)mem;
  fd_block_hash_queue_new( (fd_block_hash_queue_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_block_hash_queue_global_t);
  void * * alloc_mem = &alloc_region;
  fd_block_hash_queue_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_block_hash_queue_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_hash_queue_global_t * self = (fd_block_hash_queue_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->last_hash_index, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_HASH_ALIGN );
      self->last_hash_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_hash_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_HASH_FOOTPRINT;
      fd_hash_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->last_hash_gaddr ), alloc_mem, ctx );
    } else {
      self->last_hash_gaddr = 0UL;
    }
  }
  ulong ages_len;
  fd_bincode_uint64_decode_unsafe( &ages_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_hash_hash_age_pair_t_map_align() );
  fd_hash_hash_age_pair_t_mapnode_t * ages_pool = fd_hash_hash_age_pair_t_map_join_new( alloc_mem, fd_ulong_max( ages_len, 400 ) );
  fd_hash_hash_age_pair_t_mapnode_t * ages_root = NULL;
  self->ages_root_gaddr = 0UL;
  for( ulong i=0; i < ages_len; i++ ) {
    fd_hash_hash_age_pair_t_mapnode_t * node = fd_hash_hash_age_pair_t_map_acquire( ages_pool );
    fd_hash_hash_age_pair_new( &node->elem );
    fd_hash_hash_age_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_hash_hash_age_pair_t_map_insert( ages_pool, &ages_root, node );
  }
  self->ages_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, ages_pool );
  self->ages_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, ages_root );
  fd_bincode_uint64_decode_unsafe( &self->max_age, ctx );
}
int fd_block_hash_queue_convert_global_to_local( void const * global_self, fd_block_hash_queue_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_block_hash_queue_global_t const * mem = (fd_block_hash_queue_global_t const *)global_self;
  self->last_hash_index = mem->last_hash_index;
  self->last_hash = fd_wksp_laddr_fast( ctx->wksp, mem->last_hash_gaddr );
  self->ages_pool = fd_wksp_laddr_fast( ctx->wksp, mem->ages_pool_gaddr );
  self->ages_root = fd_wksp_laddr_fast( ctx->wksp, mem->ages_root_gaddr );
  self->max_age = mem->max_age;
  return FD_BINCODE_SUCCESS;
}
void fd_block_hash_queue_new(fd_block_hash_queue_t * self) {
  fd_memset( self, 0, sizeof(fd_block_hash_queue_t) );
}
void fd_block_hash_queue_destroy( fd_block_hash_queue_t * self ) {
  if( self->last_hash ) {
    fd_hash_destroy( self->last_hash );
    self->last_hash = NULL;
  }
  for( fd_hash_hash_age_pair_t_mapnode_t * n = fd_hash_hash_age_pair_t_map_minimum(self->ages_pool, self->ages_root ); n; n = fd_hash_hash_age_pair_t_map_successor(self->ages_pool, n) ) {
    fd_hash_hash_age_pair_destroy( &n->elem );
  }
  self->ages_pool = NULL;
  self->ages_root = NULL;
}

ulong fd_block_hash_queue_footprint( void ){ return FD_BLOCK_HASH_QUEUE_FOOTPRINT; }
ulong fd_block_hash_queue_align( void ){ return FD_BLOCK_HASH_QUEUE_ALIGN; }

void fd_block_hash_queue_walk( void * w, fd_block_hash_queue_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_block_hash_queue", level++ );
  fun( w, &self->last_hash_index, "last_hash_index", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->last_hash ) {
    fun( w, NULL, "last_hash", FD_FLAMENCO_TYPE_NULL, "hash", level );
  } else {
    fd_hash_walk( w, self->last_hash, fun, "last_hash", level );
  }
  if( self->ages_root ) {
    for( fd_hash_hash_age_pair_t_mapnode_t * n = fd_hash_hash_age_pair_t_map_minimum(self->ages_pool, self->ages_root ); n; n = fd_hash_hash_age_pair_t_map_successor( self->ages_pool, n ) ) {
      fd_hash_hash_age_pair_walk(w, &n->elem, fun, "ages", level );
    }
  }
  fun( w, &self->max_age, "max_age", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_block_hash_queue", level-- );
}
ulong fd_block_hash_queue_size( fd_block_hash_queue_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(char);
  if( NULL !=  self->last_hash ) {
    size += fd_hash_size( self->last_hash );
  }
  if( self->ages_root ) {
    size += sizeof(ulong);
    for( fd_hash_hash_age_pair_t_mapnode_t * n = fd_hash_hash_age_pair_t_map_minimum( self->ages_pool, self->ages_root ); n; n = fd_hash_hash_age_pair_t_map_successor( self->ages_pool, n ) ) {
      size += fd_hash_hash_age_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(ulong);
  return size;
}

int fd_fee_rate_governor_encode( fd_fee_rate_governor_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->target_lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->target_signatures_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->min_lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->max_lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->burn_percent), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_fee_rate_governor_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_fee_rate_governor_t);
  void const * start_data = ctx->data;
  int err = fd_fee_rate_governor_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_fee_rate_governor_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_fee_rate_governor_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_rate_governor_t * self = (fd_fee_rate_governor_t *)mem;
  fd_fee_rate_governor_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_fee_rate_governor_t);
  void * * alloc_mem = &alloc_region;
  fd_fee_rate_governor_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_fee_rate_governor_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_rate_governor_t * self = (fd_fee_rate_governor_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->target_lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->target_signatures_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->min_lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_lamports_per_signature, ctx );
  fd_bincode_uint8_decode_unsafe( &self->burn_percent, ctx );
}
void * fd_fee_rate_governor_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_rate_governor_global_t * self = (fd_fee_rate_governor_global_t *)mem;
  fd_fee_rate_governor_new( (fd_fee_rate_governor_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_fee_rate_governor_global_t);
  void * * alloc_mem = &alloc_region;
  fd_fee_rate_governor_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_fee_rate_governor_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_fee_rate_governor_global_t * self = (fd_fee_rate_governor_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->target_lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->target_signatures_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->min_lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_lamports_per_signature, ctx );
  fd_bincode_uint8_decode_unsafe( &self->burn_percent, ctx );
}
int fd_fee_rate_governor_convert_global_to_local( void const * global_self, fd_fee_rate_governor_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_fee_rate_governor_global_t const * mem = (fd_fee_rate_governor_global_t const *)global_self;
  self->target_lamports_per_signature = mem->target_lamports_per_signature;
  self->target_signatures_per_slot = mem->target_signatures_per_slot;
  self->min_lamports_per_signature = mem->min_lamports_per_signature;
  self->max_lamports_per_signature = mem->max_lamports_per_signature;
  self->burn_percent = mem->burn_percent;
  return FD_BINCODE_SUCCESS;
}
void fd_fee_rate_governor_new(fd_fee_rate_governor_t * self) {
  fd_memset( self, 0, sizeof(fd_fee_rate_governor_t) );
}
void fd_fee_rate_governor_destroy( fd_fee_rate_governor_t * self ) {
}

ulong fd_fee_rate_governor_footprint( void ){ return FD_FEE_RATE_GOVERNOR_FOOTPRINT; }
ulong fd_fee_rate_governor_align( void ){ return FD_FEE_RATE_GOVERNOR_ALIGN; }

void fd_fee_rate_governor_walk( void * w, fd_fee_rate_governor_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_fee_rate_governor", level++ );
  fun( w, &self->target_lamports_per_signature, "target_lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->target_signatures_per_slot, "target_signatures_per_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->min_lamports_per_signature, "min_lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->max_lamports_per_signature, "max_lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->burn_percent, "burn_percent", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_fee_rate_governor", level-- );
}
ulong fd_fee_rate_governor_size( fd_fee_rate_governor_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(char);
  return size;
}

int fd_slot_pair_encode( fd_slot_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->val, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_pair_t);
  void const * start_data = ctx->data;
  int err = fd_slot_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_slot_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_pair_t * self = (fd_slot_pair_t *)mem;
  fd_slot_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_pair_t * self = (fd_slot_pair_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->val, ctx );
}
void * fd_slot_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_pair_global_t * self = (fd_slot_pair_global_t *)mem;
  fd_slot_pair_new( (fd_slot_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_pair_global_t * self = (fd_slot_pair_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->val, ctx );
}
int fd_slot_pair_convert_global_to_local( void const * global_self, fd_slot_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_pair_global_t const * mem = (fd_slot_pair_global_t const *)global_self;
  self->slot = mem->slot;
  self->val = mem->val;
  return FD_BINCODE_SUCCESS;
}
void fd_slot_pair_new(fd_slot_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_pair_t) );
}
void fd_slot_pair_destroy( fd_slot_pair_t * self ) {
}

ulong fd_slot_pair_footprint( void ){ return FD_SLOT_PAIR_FOOTPRINT; }
ulong fd_slot_pair_align( void ){ return FD_SLOT_PAIR_ALIGN; }

void fd_slot_pair_walk( void * w, fd_slot_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_pair", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->val, "val", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_pair", level-- );
}
ulong fd_slot_pair_size( fd_slot_pair_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_hard_forks_encode( fd_hard_forks_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->hard_forks_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->hard_forks_len ) {
    for( ulong i=0; i < self->hard_forks_len; i++ ) {
      err = fd_slot_pair_encode( self->hard_forks + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_hard_forks_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_hard_forks_t);
  void const * start_data = ctx->data;
  int err = fd_hard_forks_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_hard_forks_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong hard_forks_len;
  err = fd_bincode_uint64_decode( &hard_forks_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( hard_forks_len ) {
    *total_sz += FD_SLOT_PAIR_ALIGN + FD_SLOT_PAIR_FOOTPRINT*hard_forks_len;
    for( ulong i=0; i < hard_forks_len; i++ ) {
      err = fd_slot_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_hard_forks_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hard_forks_t * self = (fd_hard_forks_t *)mem;
  fd_hard_forks_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_hard_forks_t);
  void * * alloc_mem = &alloc_region;
  fd_hard_forks_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_hard_forks_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hard_forks_t * self = (fd_hard_forks_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->hard_forks_len, ctx );
  if( self->hard_forks_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_PAIR_ALIGN );
    self->hard_forks = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_PAIR_FOOTPRINT*self->hard_forks_len;
    for( ulong i=0; i < self->hard_forks_len; i++ ) {
      fd_slot_pair_new( self->hard_forks + i );
      fd_slot_pair_decode_inner( self->hard_forks + i, alloc_mem, ctx );
    }
  } else
    self->hard_forks = NULL;
}
void * fd_hard_forks_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hard_forks_global_t * self = (fd_hard_forks_global_t *)mem;
  fd_hard_forks_new( (fd_hard_forks_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_hard_forks_global_t);
  void * * alloc_mem = &alloc_region;
  fd_hard_forks_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_hard_forks_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_hard_forks_global_t * self = (fd_hard_forks_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->hard_forks_len, ctx );
  if( self->hard_forks_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_PAIR_ALIGN );
    self->hard_forks_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_PAIR_FOOTPRINT*self->hard_forks_len;
    for( ulong i=0; i < self->hard_forks_len; i++ ) {
      fd_slot_pair_new( (fd_slot_pair_t *)(cur_mem + FD_SLOT_PAIR_FOOTPRINT * i) );
      fd_slot_pair_decode_inner_global( cur_mem + FD_SLOT_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->hard_forks_gaddr = 0UL;
}
int fd_hard_forks_convert_global_to_local( void const * global_self, fd_hard_forks_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_hard_forks_global_t const * mem = (fd_hard_forks_global_t const *)global_self;
  self->hard_forks_len = mem->hard_forks_len;
  self->hard_forks     = fd_wksp_laddr_fast( ctx->wksp, mem->hard_forks_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_hard_forks_new(fd_hard_forks_t * self) {
  fd_memset( self, 0, sizeof(fd_hard_forks_t) );
}
void fd_hard_forks_destroy( fd_hard_forks_t * self ) {
  if( self->hard_forks ) {
    for( ulong i=0; i < self->hard_forks_len; i++ )
      fd_slot_pair_destroy( self->hard_forks + i );
    self->hard_forks = NULL;
  }
}

ulong fd_hard_forks_footprint( void ){ return FD_HARD_FORKS_FOOTPRINT; }
ulong fd_hard_forks_align( void ){ return FD_HARD_FORKS_ALIGN; }

void fd_hard_forks_walk( void * w, fd_hard_forks_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_hard_forks", level++ );
  if( self->hard_forks_len ) {
    fun( w, NULL, "hard_forks", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->hard_forks_len; i++ )
      fd_slot_pair_walk(w, self->hard_forks + i, fun, "slot_pair", level );
    fun( w, NULL, "hard_forks", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_hard_forks", level-- );
}
ulong fd_hard_forks_size( fd_hard_forks_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->hard_forks_len; i++ )
      size += fd_slot_pair_size( self->hard_forks + i );
  } while(0);
  return size;
}

int fd_inflation_encode( fd_inflation_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_double_encode( self->initial, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->terminal, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->taper, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->foundation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->foundation_term, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->unused, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_inflation_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_inflation_t);
  void const * start_data = ctx->data;
  int err = fd_inflation_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_inflation_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_inflation_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_inflation_t * self = (fd_inflation_t *)mem;
  fd_inflation_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_inflation_t);
  void * * alloc_mem = &alloc_region;
  fd_inflation_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_inflation_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_inflation_t * self = (fd_inflation_t *)struct_mem;
  fd_bincode_double_decode_unsafe( &self->initial, ctx );
  fd_bincode_double_decode_unsafe( &self->terminal, ctx );
  fd_bincode_double_decode_unsafe( &self->taper, ctx );
  fd_bincode_double_decode_unsafe( &self->foundation, ctx );
  fd_bincode_double_decode_unsafe( &self->foundation_term, ctx );
  fd_bincode_double_decode_unsafe( &self->unused, ctx );
}
void * fd_inflation_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_inflation_global_t * self = (fd_inflation_global_t *)mem;
  fd_inflation_new( (fd_inflation_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_inflation_global_t);
  void * * alloc_mem = &alloc_region;
  fd_inflation_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_inflation_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_inflation_global_t * self = (fd_inflation_global_t *)struct_mem;
  fd_bincode_double_decode_unsafe( &self->initial, ctx );
  fd_bincode_double_decode_unsafe( &self->terminal, ctx );
  fd_bincode_double_decode_unsafe( &self->taper, ctx );
  fd_bincode_double_decode_unsafe( &self->foundation, ctx );
  fd_bincode_double_decode_unsafe( &self->foundation_term, ctx );
  fd_bincode_double_decode_unsafe( &self->unused, ctx );
}
int fd_inflation_convert_global_to_local( void const * global_self, fd_inflation_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_inflation_global_t const * mem = (fd_inflation_global_t const *)global_self;
  self->initial = mem->initial;
  self->terminal = mem->terminal;
  self->taper = mem->taper;
  self->foundation = mem->foundation;
  self->foundation_term = mem->foundation_term;
  self->unused = mem->unused;
  return FD_BINCODE_SUCCESS;
}
void fd_inflation_new(fd_inflation_t * self) {
  fd_memset( self, 0, sizeof(fd_inflation_t) );
}
void fd_inflation_destroy( fd_inflation_t * self ) {
}

ulong fd_inflation_footprint( void ){ return FD_INFLATION_FOOTPRINT; }
ulong fd_inflation_align( void ){ return FD_INFLATION_ALIGN; }

void fd_inflation_walk( void * w, fd_inflation_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_inflation", level++ );
  fun( w, &self->initial, "initial", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->terminal, "terminal", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->taper, "taper", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->foundation, "foundation", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->foundation_term, "foundation_term", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->unused, "unused", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_inflation", level-- );
}
ulong fd_inflation_size( fd_inflation_t const * self ) {
  ulong size = 0;
  size += sizeof(double);
  size += sizeof(double);
  size += sizeof(double);
  size += sizeof(double);
  size += sizeof(double);
  size += sizeof(double);
  return size;
}

int fd_rent_encode( fd_rent_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->lamports_per_uint8_year, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->exemption_threshold, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->burn_percent), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_rent_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_rent_t);
  void const * start_data = ctx->data;
  int err = fd_rent_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_rent_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_rent_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_t * self = (fd_rent_t *)mem;
  fd_rent_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_t * self = (fd_rent_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_uint8_year, ctx );
  fd_bincode_double_decode_unsafe( &self->exemption_threshold, ctx );
  fd_bincode_uint8_decode_unsafe( &self->burn_percent, ctx );
}
void * fd_rent_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_global_t * self = (fd_rent_global_t *)mem;
  fd_rent_new( (fd_rent_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_global_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_global_t * self = (fd_rent_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_uint8_year, ctx );
  fd_bincode_double_decode_unsafe( &self->exemption_threshold, ctx );
  fd_bincode_uint8_decode_unsafe( &self->burn_percent, ctx );
}
int fd_rent_convert_global_to_local( void const * global_self, fd_rent_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_rent_global_t const * mem = (fd_rent_global_t const *)global_self;
  self->lamports_per_uint8_year = mem->lamports_per_uint8_year;
  self->exemption_threshold = mem->exemption_threshold;
  self->burn_percent = mem->burn_percent;
  return FD_BINCODE_SUCCESS;
}
void fd_rent_new(fd_rent_t * self) {
  fd_memset( self, 0, sizeof(fd_rent_t) );
}
void fd_rent_destroy( fd_rent_t * self ) {
}

ulong fd_rent_footprint( void ){ return FD_RENT_FOOTPRINT; }
ulong fd_rent_align( void ){ return FD_RENT_ALIGN; }

void fd_rent_walk( void * w, fd_rent_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_rent", level++ );
  fun( w, &self->lamports_per_uint8_year, "lamports_per_uint8_year", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->exemption_threshold, "exemption_threshold", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->burn_percent, "burn_percent", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_rent", level-- );
}
ulong fd_rent_size( fd_rent_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(double);
  size += sizeof(char);
  return size;
}

int fd_epoch_schedule_encode( fd_epoch_schedule_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slots_per_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->leader_schedule_slot_offset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->warmup), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->first_normal_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->first_normal_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_epoch_schedule_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_epoch_schedule_t);
  void const * start_data = ctx->data;
  int err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_epoch_schedule_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_epoch_schedule_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_schedule_t * self = (fd_epoch_schedule_t *)mem;
  fd_epoch_schedule_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_schedule_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_schedule_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_schedule_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_schedule_t * self = (fd_epoch_schedule_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slots_per_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->leader_schedule_slot_offset, ctx );
  fd_bincode_bool_decode_unsafe( &self->warmup, ctx );
  fd_bincode_uint64_decode_unsafe( &self->first_normal_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->first_normal_slot, ctx );
}
void * fd_epoch_schedule_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_schedule_global_t * self = (fd_epoch_schedule_global_t *)mem;
  fd_epoch_schedule_new( (fd_epoch_schedule_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_schedule_global_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_schedule_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_schedule_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_schedule_global_t * self = (fd_epoch_schedule_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slots_per_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->leader_schedule_slot_offset, ctx );
  fd_bincode_bool_decode_unsafe( &self->warmup, ctx );
  fd_bincode_uint64_decode_unsafe( &self->first_normal_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->first_normal_slot, ctx );
}
int fd_epoch_schedule_convert_global_to_local( void const * global_self, fd_epoch_schedule_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_epoch_schedule_global_t const * mem = (fd_epoch_schedule_global_t const *)global_self;
  self->slots_per_epoch = mem->slots_per_epoch;
  self->leader_schedule_slot_offset = mem->leader_schedule_slot_offset;
  self->warmup = mem->warmup;
  self->first_normal_epoch = mem->first_normal_epoch;
  self->first_normal_slot = mem->first_normal_slot;
  return FD_BINCODE_SUCCESS;
}
void fd_epoch_schedule_new(fd_epoch_schedule_t * self) {
  fd_memset( self, 0, sizeof(fd_epoch_schedule_t) );
}
void fd_epoch_schedule_destroy( fd_epoch_schedule_t * self ) {
}

ulong fd_epoch_schedule_footprint( void ){ return FD_EPOCH_SCHEDULE_FOOTPRINT; }
ulong fd_epoch_schedule_align( void ){ return FD_EPOCH_SCHEDULE_ALIGN; }

void fd_epoch_schedule_walk( void * w, fd_epoch_schedule_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_epoch_schedule", level++ );
  fun( w, &self->slots_per_epoch, "slots_per_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->leader_schedule_slot_offset, "leader_schedule_slot_offset", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->warmup, "warmup", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, &self->first_normal_epoch, "first_normal_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->first_normal_slot, "first_normal_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_epoch_schedule", level-- );
}
ulong fd_epoch_schedule_size( fd_epoch_schedule_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(char);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_rent_collector_encode( fd_rent_collector_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_encode( &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->slots_per_year, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_encode( &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_rent_collector_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_rent_collector_t);
  void const * start_data = ctx->data;
  int err = fd_rent_collector_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_rent_collector_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_rent_collector_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_collector_t * self = (fd_rent_collector_t *)mem;
  fd_rent_collector_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_collector_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_collector_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_collector_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_collector_t * self = (fd_rent_collector_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_epoch_schedule_decode_inner( &self->epoch_schedule, alloc_mem, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_rent_decode_inner( &self->rent, alloc_mem, ctx );
}
void * fd_rent_collector_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_collector_global_t * self = (fd_rent_collector_global_t *)mem;
  fd_rent_collector_new( (fd_rent_collector_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_collector_global_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_collector_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_collector_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_collector_global_t * self = (fd_rent_collector_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_epoch_schedule_decode_inner_global( &self->epoch_schedule, alloc_mem, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_rent_decode_inner_global( &self->rent, alloc_mem, ctx );
}
int fd_rent_collector_convert_global_to_local( void const * global_self, fd_rent_collector_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_rent_collector_global_t const * mem = (fd_rent_collector_global_t const *)global_self;
  self->epoch = mem->epoch;
  err = fd_epoch_schedule_convert_global_to_local( &mem->epoch_schedule, &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slots_per_year = mem->slots_per_year;
  err = fd_rent_convert_global_to_local( &mem->rent, &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_rent_collector_new(fd_rent_collector_t * self) {
  fd_memset( self, 0, sizeof(fd_rent_collector_t) );
  fd_epoch_schedule_new( &self->epoch_schedule );
  fd_rent_new( &self->rent );
}
void fd_rent_collector_destroy( fd_rent_collector_t * self ) {
  fd_epoch_schedule_destroy( &self->epoch_schedule );
  fd_rent_destroy( &self->rent );
}

ulong fd_rent_collector_footprint( void ){ return FD_RENT_COLLECTOR_FOOTPRINT; }
ulong fd_rent_collector_align( void ){ return FD_RENT_COLLECTOR_ALIGN; }

void fd_rent_collector_walk( void * w, fd_rent_collector_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_rent_collector", level++ );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_epoch_schedule_walk( w, &self->epoch_schedule, fun, "epoch_schedule", level );
  fun( w, &self->slots_per_year, "slots_per_year", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fd_rent_walk( w, &self->rent, fun, "rent", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_rent_collector", level-- );
}
ulong fd_rent_collector_size( fd_rent_collector_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_epoch_schedule_size( &self->epoch_schedule );
  size += sizeof(double);
  size += fd_rent_size( &self->rent );
  return size;
}

int fd_stake_history_entry_encode( fd_stake_history_entry_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->effective, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->activating, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->deactivating, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_history_entry_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_history_entry_t);
  void const * start_data = ctx->data;
  int err = fd_stake_history_entry_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_history_entry_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_stake_history_entry_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_entry_t * self = (fd_stake_history_entry_t *)mem;
  fd_stake_history_entry_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_history_entry_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_history_entry_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_history_entry_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_entry_t * self = (fd_stake_history_entry_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->effective, ctx );
  fd_bincode_uint64_decode_unsafe( &self->activating, ctx );
  fd_bincode_uint64_decode_unsafe( &self->deactivating, ctx );
}
void * fd_stake_history_entry_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_entry_global_t * self = (fd_stake_history_entry_global_t *)mem;
  fd_stake_history_entry_new( (fd_stake_history_entry_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_history_entry_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_history_entry_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_history_entry_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_entry_global_t * self = (fd_stake_history_entry_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->effective, ctx );
  fd_bincode_uint64_decode_unsafe( &self->activating, ctx );
  fd_bincode_uint64_decode_unsafe( &self->deactivating, ctx );
}
int fd_stake_history_entry_convert_global_to_local( void const * global_self, fd_stake_history_entry_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_history_entry_global_t const * mem = (fd_stake_history_entry_global_t const *)global_self;
  self->epoch = mem->epoch;
  self->effective = mem->effective;
  self->activating = mem->activating;
  self->deactivating = mem->deactivating;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_history_entry_new(fd_stake_history_entry_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_history_entry_t) );
}
void fd_stake_history_entry_destroy( fd_stake_history_entry_t * self ) {
}

ulong fd_stake_history_entry_footprint( void ){ return FD_STAKE_HISTORY_ENTRY_FOOTPRINT; }
ulong fd_stake_history_entry_align( void ){ return FD_STAKE_HISTORY_ENTRY_ALIGN; }

void fd_stake_history_entry_walk( void * w, fd_stake_history_entry_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_history_entry", level++ );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->effective, "effective", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->activating, "activating", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->deactivating, "deactivating", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_history_entry", level-- );
}
ulong fd_stake_history_entry_size( fd_stake_history_entry_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_stake_history_encode( fd_stake_history_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->fd_stake_history_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( FD_UNLIKELY( 0 == self->fd_stake_history_len ) ) return FD_BINCODE_SUCCESS;
  for( ulong i=0; i<self->fd_stake_history_len; i++ ) {
    ulong idx = ( i + self->fd_stake_history_offset ) & (512 - 1);
    err = fd_stake_history_entry_encode( self->fd_stake_history + idx, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_history_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_history_t);
  void const * start_data = ctx->data;
  int err = fd_stake_history_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_history_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong fd_stake_history_len;
  err = fd_bincode_uint64_decode( &fd_stake_history_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( fd_stake_history_len ) {
    for( ulong i=0; i < fd_stake_history_len; i++ ) {
      err = fd_stake_history_entry_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_stake_history_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_t * self = (fd_stake_history_t *)mem;
  fd_stake_history_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_history_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_history_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_history_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_t * self = (fd_stake_history_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->fd_stake_history_len, ctx );
  self->fd_stake_history_size = 512;
  self->fd_stake_history_offset = 0;
  for( ulong i=0; i<self->fd_stake_history_len; i++ ) {
    fd_stake_history_entry_decode_inner( self->fd_stake_history + i, alloc_mem, ctx );
  }
}
void * fd_stake_history_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_global_t * self = (fd_stake_history_global_t *)mem;
  fd_stake_history_new( (fd_stake_history_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_history_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_history_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_history_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_history_global_t * self = (fd_stake_history_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->fd_stake_history_len, ctx );
  self->fd_stake_history_size = 512;
  self->fd_stake_history_offset = 0;
  for( ulong i=0; i<self->fd_stake_history_len; i++ ) {
    fd_stake_history_entry_decode_inner_global( self->fd_stake_history + i, alloc_mem, ctx );
  }
}
int fd_stake_history_convert_global_to_local( void const * global_self, fd_stake_history_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_history_global_t const * mem = (fd_stake_history_global_t const *)global_self;
  self->fd_stake_history_len    = mem->fd_stake_history_len;
  self->fd_stake_history_size   = mem->fd_stake_history_size;
  self->fd_stake_history_offset = mem->fd_stake_history_offset;
  for( ulong i=0; i<self->fd_stake_history_len; i++ ) {
    err = fd_stake_history_entry_convert_global_to_local( &mem->fd_stake_history[i], &self->fd_stake_history[i], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
void fd_stake_history_new(fd_stake_history_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_history_t) );
  self->fd_stake_history_size = 512;
  for( ulong i=0; i<512; i++ )
    fd_stake_history_entry_new( self->fd_stake_history + i );
}
void fd_stake_history_destroy( fd_stake_history_t * self ) {
  for( ulong i=0; i<512; i++ )
    fd_stake_history_entry_destroy( self->fd_stake_history + i );
}

ulong fd_stake_history_footprint( void ){ return FD_STAKE_HISTORY_FOOTPRINT; }
ulong fd_stake_history_align( void ){ return FD_STAKE_HISTORY_ALIGN; }

void fd_stake_history_walk( void * w, fd_stake_history_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_history", level++ );
  fun( w, NULL, "fd_stake_history", FD_FLAMENCO_TYPE_ARR, "stake_history_entry[]", level++ );
  for( ulong i=0; i<self->fd_stake_history_len; i++ ) {
    ulong idx = ( i + self->fd_stake_history_offset ) & (512 - 1);
    fd_stake_history_entry_walk( w, self->fd_stake_history + idx, fun, "stake_history_entry", level );
  }
  fun( w, NULL, "fd_stake_history", FD_FLAMENCO_TYPE_ARR_END, "stake_history_entry[]", level-- );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_history", level-- );
}
ulong fd_stake_history_size( fd_stake_history_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  for( ulong i=0; i<self->fd_stake_history_len; i++ )
    size += fd_stake_history_entry_size( self->fd_stake_history + i );
  return size;
}

int fd_solana_account_encode( fd_solana_account_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->lamports, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->data_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->data_len ) {
    err = fd_bincode_bytes_encode( self->data, self->data_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->executable), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->rent_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_solana_account_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_solana_account_t);
  void const * start_data = ctx->data;
  int err = fd_solana_account_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_solana_account_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong data_len;
  err = fd_bincode_uint64_decode( &data_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( data_len ) {
    *total_sz += 8UL + data_len;
    err = fd_bincode_bytes_decode_footprint( data_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_solana_account_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_account_t * self = (fd_solana_account_t *)mem;
  fd_solana_account_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_solana_account_t);
  void * * alloc_mem = &alloc_region;
  fd_solana_account_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_solana_account_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_account_t * self = (fd_solana_account_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->data_len, ctx );
  if( self->data_len ) {
    self->data = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->data, self->data_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->data_len;
  } else
    self->data = NULL;
  fd_pubkey_decode_inner( &self->owner, alloc_mem, ctx );
  fd_bincode_bool_decode_unsafe( &self->executable, ctx );
  fd_bincode_uint64_decode_unsafe( &self->rent_epoch, ctx );
}
void * fd_solana_account_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_account_global_t * self = (fd_solana_account_global_t *)mem;
  fd_solana_account_new( (fd_solana_account_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_solana_account_global_t);
  void * * alloc_mem = &alloc_region;
  fd_solana_account_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_solana_account_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_account_global_t * self = (fd_solana_account_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->data_len, ctx );
  if( self->data_len ) {
    self->data_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->data_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->data_len;
  } else
    self->data_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->owner, alloc_mem, ctx );
  fd_bincode_bool_decode_unsafe( &self->executable, ctx );
  fd_bincode_uint64_decode_unsafe( &self->rent_epoch, ctx );
}
int fd_solana_account_convert_global_to_local( void const * global_self, fd_solana_account_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_solana_account_global_t const * mem = (fd_solana_account_global_t const *)global_self;
  self->lamports = mem->lamports;
  self->data_len = mem->data_len;
  self->data     = fd_wksp_laddr_fast( ctx->wksp, mem->data_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->owner, &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->executable = mem->executable;
  self->rent_epoch = mem->rent_epoch;
  return FD_BINCODE_SUCCESS;
}
void fd_solana_account_new(fd_solana_account_t * self) {
  fd_memset( self, 0, sizeof(fd_solana_account_t) );
  fd_pubkey_new( &self->owner );
}
void fd_solana_account_destroy( fd_solana_account_t * self ) {
  if( self->data ) {
    self->data = NULL;
  }
  fd_pubkey_destroy( &self->owner );
}

ulong fd_solana_account_footprint( void ){ return FD_SOLANA_ACCOUNT_FOOTPRINT; }
ulong fd_solana_account_align( void ){ return FD_SOLANA_ACCOUNT_ALIGN; }

void fd_solana_account_walk( void * w, fd_solana_account_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_solana_account", level++ );
  fun( w, &self->lamports, "lamports", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun(w, self->data, "data", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->owner, fun, "owner", level );
  fun( w, &self->executable, "executable", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, &self->rent_epoch, "rent_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_solana_account", level-- );
}
ulong fd_solana_account_size( fd_solana_account_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    size += self->data_len;
  } while(0);
  size += fd_pubkey_size( &self->owner );
  size += sizeof(char);
  size += sizeof(ulong);
  return size;
}

int fd_vote_accounts_pair_encode( fd_vote_accounts_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_account_encode( &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_accounts_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_accounts_pair_t);
  void const * start_data = ctx->data;
  int err = fd_vote_accounts_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_accounts_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_solana_account_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_accounts_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_pair_t * self = (fd_vote_accounts_pair_t *)mem;
  fd_vote_accounts_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_accounts_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_accounts_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_accounts_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_pair_t * self = (fd_vote_accounts_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->stake, ctx );
  fd_solana_account_decode_inner( &self->value, alloc_mem, ctx );
}
void * fd_vote_accounts_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_pair_global_t * self = (fd_vote_accounts_pair_global_t *)mem;
  fd_vote_accounts_pair_new( (fd_vote_accounts_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_accounts_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_accounts_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_accounts_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_pair_global_t * self = (fd_vote_accounts_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->stake, ctx );
  fd_solana_account_decode_inner_global( &self->value, alloc_mem, ctx );
}
int fd_vote_accounts_pair_convert_global_to_local( void const * global_self, fd_vote_accounts_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_accounts_pair_global_t const * mem = (fd_vote_accounts_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->stake = mem->stake;
  err = fd_solana_account_convert_global_to_local( &mem->value, &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_accounts_pair_new(fd_vote_accounts_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_accounts_pair_t) );
  fd_pubkey_new( &self->key );
  fd_solana_account_new( &self->value );
}
void fd_vote_accounts_pair_destroy( fd_vote_accounts_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
  fd_solana_account_destroy( &self->value );
}

ulong fd_vote_accounts_pair_footprint( void ){ return FD_VOTE_ACCOUNTS_PAIR_FOOTPRINT; }
ulong fd_vote_accounts_pair_align( void ){ return FD_VOTE_ACCOUNTS_PAIR_ALIGN; }

void fd_vote_accounts_pair_walk( void * w, fd_vote_accounts_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_accounts_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fun( w, &self->stake, "stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_solana_account_walk( w, &self->value, fun, "value", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_accounts_pair", level-- );
}
ulong fd_vote_accounts_pair_size( fd_vote_accounts_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += sizeof(ulong);
  size += fd_solana_account_size( &self->value );
  return size;
}

int fd_vote_accounts_encode( fd_vote_accounts_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->vote_accounts_root ) {
    ulong vote_accounts_len = fd_vote_accounts_pair_t_map_size( self->vote_accounts_pool, self->vote_accounts_root );
    err = fd_bincode_uint64_encode( vote_accounts_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_vote_accounts_pair_t_mapnode_t * n = fd_vote_accounts_pair_t_map_minimum( self->vote_accounts_pool, self->vote_accounts_root ); n; n = fd_vote_accounts_pair_t_map_successor( self->vote_accounts_pool, n ) ) {
      err = fd_vote_accounts_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong vote_accounts_len = 0;
    err = fd_bincode_uint64_encode( vote_accounts_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_accounts_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_accounts_t);
  void const * start_data = ctx->data;
  int err = fd_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_accounts_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong vote_accounts_len = 0UL;
  err = fd_bincode_uint64_decode( &vote_accounts_len, ctx );
  ulong vote_accounts_cnt = fd_ulong_max( vote_accounts_len, 15000 );
  *total_sz += fd_vote_accounts_pair_t_map_align() + fd_vote_accounts_pair_t_map_footprint( vote_accounts_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < vote_accounts_len; i++ ) {
    err = fd_vote_accounts_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_vote_accounts_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_t * self = (fd_vote_accounts_t *)mem;
  fd_vote_accounts_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_accounts_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_accounts_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_accounts_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_t * self = (fd_vote_accounts_t *)struct_mem;
  ulong vote_accounts_len;
  fd_bincode_uint64_decode_unsafe( &vote_accounts_len, ctx );
  self->vote_accounts_pool = fd_vote_accounts_pair_t_map_join_new( alloc_mem, fd_ulong_max( vote_accounts_len, 15000 ) );
  self->vote_accounts_root = NULL;
  for( ulong i=0; i < vote_accounts_len; i++ ) {
    fd_vote_accounts_pair_t_mapnode_t * node = fd_vote_accounts_pair_t_map_acquire( self->vote_accounts_pool );
    fd_vote_accounts_pair_new( &node->elem );
    fd_vote_accounts_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_vote_accounts_pair_t_map_insert( self->vote_accounts_pool, &self->vote_accounts_root, node );
  }
}
void * fd_vote_accounts_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_global_t * self = (fd_vote_accounts_global_t *)mem;
  fd_vote_accounts_new( (fd_vote_accounts_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_accounts_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_accounts_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_accounts_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_accounts_global_t * self = (fd_vote_accounts_global_t *)struct_mem;
  ulong vote_accounts_len;
  fd_bincode_uint64_decode_unsafe( &vote_accounts_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_vote_accounts_pair_t_map_align() );
  fd_vote_accounts_pair_t_mapnode_t * vote_accounts_pool = fd_vote_accounts_pair_t_map_join_new( alloc_mem, fd_ulong_max( vote_accounts_len, 15000 ) );
  fd_vote_accounts_pair_t_mapnode_t * vote_accounts_root = NULL;
  self->vote_accounts_root_gaddr = 0UL;
  for( ulong i=0; i < vote_accounts_len; i++ ) {
    fd_vote_accounts_pair_t_mapnode_t * node = fd_vote_accounts_pair_t_map_acquire( vote_accounts_pool );
    fd_vote_accounts_pair_new( &node->elem );
    fd_vote_accounts_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_vote_accounts_pair_t_map_insert( vote_accounts_pool, &vote_accounts_root, node );
  }
  self->vote_accounts_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, vote_accounts_pool );
  self->vote_accounts_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, vote_accounts_root );
}
int fd_vote_accounts_convert_global_to_local( void const * global_self, fd_vote_accounts_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_accounts_global_t const * mem = (fd_vote_accounts_global_t const *)global_self;
  self->vote_accounts_pool = fd_wksp_laddr_fast( ctx->wksp, mem->vote_accounts_pool_gaddr );
  self->vote_accounts_root = fd_wksp_laddr_fast( ctx->wksp, mem->vote_accounts_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_accounts_new(fd_vote_accounts_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_accounts_t) );
}
void fd_vote_accounts_destroy( fd_vote_accounts_t * self ) {
  for( fd_vote_accounts_pair_t_mapnode_t * n = fd_vote_accounts_pair_t_map_minimum(self->vote_accounts_pool, self->vote_accounts_root ); n; n = fd_vote_accounts_pair_t_map_successor(self->vote_accounts_pool, n) ) {
    fd_vote_accounts_pair_destroy( &n->elem );
  }
  self->vote_accounts_pool = NULL;
  self->vote_accounts_root = NULL;
}

ulong fd_vote_accounts_footprint( void ){ return FD_VOTE_ACCOUNTS_FOOTPRINT; }
ulong fd_vote_accounts_align( void ){ return FD_VOTE_ACCOUNTS_ALIGN; }

void fd_vote_accounts_walk( void * w, fd_vote_accounts_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_accounts", level++ );
  if( self->vote_accounts_root ) {
    for( fd_vote_accounts_pair_t_mapnode_t * n = fd_vote_accounts_pair_t_map_minimum(self->vote_accounts_pool, self->vote_accounts_root ); n; n = fd_vote_accounts_pair_t_map_successor( self->vote_accounts_pool, n ) ) {
      fd_vote_accounts_pair_walk(w, &n->elem, fun, "vote_accounts", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_accounts", level-- );
}
ulong fd_vote_accounts_size( fd_vote_accounts_t const * self ) {
  ulong size = 0;
  if( self->vote_accounts_root ) {
    size += sizeof(ulong);
    for( fd_vote_accounts_pair_t_mapnode_t * n = fd_vote_accounts_pair_t_map_minimum( self->vote_accounts_pool, self->vote_accounts_root ); n; n = fd_vote_accounts_pair_t_map_successor( self->vote_accounts_pool, n ) ) {
      size += fd_vote_accounts_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_account_keys_pair_encode( fd_account_keys_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->exists), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_account_keys_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_account_keys_pair_t);
  void const * start_data = ctx->data;
  int err = fd_account_keys_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_account_keys_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_account_keys_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_pair_t * self = (fd_account_keys_pair_t *)mem;
  fd_account_keys_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_keys_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_account_keys_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_account_keys_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_pair_t * self = (fd_account_keys_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->exists, ctx );
}
void * fd_account_keys_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_pair_global_t * self = (fd_account_keys_pair_global_t *)mem;
  fd_account_keys_pair_new( (fd_account_keys_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_keys_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_account_keys_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_account_keys_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_pair_global_t * self = (fd_account_keys_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->exists, ctx );
}
int fd_account_keys_pair_convert_global_to_local( void const * global_self, fd_account_keys_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_account_keys_pair_global_t const * mem = (fd_account_keys_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->exists = mem->exists;
  return FD_BINCODE_SUCCESS;
}
void fd_account_keys_pair_new(fd_account_keys_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_account_keys_pair_t) );
  fd_pubkey_new( &self->key );
}
void fd_account_keys_pair_destroy( fd_account_keys_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
}

ulong fd_account_keys_pair_footprint( void ){ return FD_ACCOUNT_KEYS_PAIR_FOOTPRINT; }
ulong fd_account_keys_pair_align( void ){ return FD_ACCOUNT_KEYS_PAIR_ALIGN; }

void fd_account_keys_pair_walk( void * w, fd_account_keys_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_account_keys_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fun( w, &self->exists, "exists", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_account_keys_pair", level-- );
}
ulong fd_account_keys_pair_size( fd_account_keys_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += sizeof(char);
  return size;
}

int fd_account_keys_encode( fd_account_keys_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->account_keys_root ) {
    ulong account_keys_len = fd_account_keys_pair_t_map_size( self->account_keys_pool, self->account_keys_root );
    err = fd_bincode_uint64_encode( account_keys_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_account_keys_pair_t_mapnode_t * n = fd_account_keys_pair_t_map_minimum( self->account_keys_pool, self->account_keys_root ); n; n = fd_account_keys_pair_t_map_successor( self->account_keys_pool, n ) ) {
      err = fd_account_keys_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong account_keys_len = 0;
    err = fd_bincode_uint64_encode( account_keys_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_account_keys_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_account_keys_t);
  void const * start_data = ctx->data;
  int err = fd_account_keys_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_account_keys_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong account_keys_len = 0UL;
  err = fd_bincode_uint64_decode( &account_keys_len, ctx );
  ulong account_keys_cnt = fd_ulong_max( account_keys_len, 100000 );
  *total_sz += fd_account_keys_pair_t_map_align() + fd_account_keys_pair_t_map_footprint( account_keys_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < account_keys_len; i++ ) {
    err = fd_account_keys_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_account_keys_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_t * self = (fd_account_keys_t *)mem;
  fd_account_keys_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_keys_t);
  void * * alloc_mem = &alloc_region;
  fd_account_keys_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_account_keys_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_t * self = (fd_account_keys_t *)struct_mem;
  ulong account_keys_len;
  fd_bincode_uint64_decode_unsafe( &account_keys_len, ctx );
  self->account_keys_pool = fd_account_keys_pair_t_map_join_new( alloc_mem, fd_ulong_max( account_keys_len, 100000 ) );
  self->account_keys_root = NULL;
  for( ulong i=0; i < account_keys_len; i++ ) {
    fd_account_keys_pair_t_mapnode_t * node = fd_account_keys_pair_t_map_acquire( self->account_keys_pool );
    fd_account_keys_pair_new( &node->elem );
    fd_account_keys_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_account_keys_pair_t_map_insert( self->account_keys_pool, &self->account_keys_root, node );
  }
}
void * fd_account_keys_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_global_t * self = (fd_account_keys_global_t *)mem;
  fd_account_keys_new( (fd_account_keys_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_keys_global_t);
  void * * alloc_mem = &alloc_region;
  fd_account_keys_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_account_keys_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_keys_global_t * self = (fd_account_keys_global_t *)struct_mem;
  ulong account_keys_len;
  fd_bincode_uint64_decode_unsafe( &account_keys_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_account_keys_pair_t_map_align() );
  fd_account_keys_pair_t_mapnode_t * account_keys_pool = fd_account_keys_pair_t_map_join_new( alloc_mem, fd_ulong_max( account_keys_len, 100000 ) );
  fd_account_keys_pair_t_mapnode_t * account_keys_root = NULL;
  self->account_keys_root_gaddr = 0UL;
  for( ulong i=0; i < account_keys_len; i++ ) {
    fd_account_keys_pair_t_mapnode_t * node = fd_account_keys_pair_t_map_acquire( account_keys_pool );
    fd_account_keys_pair_new( &node->elem );
    fd_account_keys_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_account_keys_pair_t_map_insert( account_keys_pool, &account_keys_root, node );
  }
  self->account_keys_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, account_keys_pool );
  self->account_keys_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, account_keys_root );
}
int fd_account_keys_convert_global_to_local( void const * global_self, fd_account_keys_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_account_keys_global_t const * mem = (fd_account_keys_global_t const *)global_self;
  self->account_keys_pool = fd_wksp_laddr_fast( ctx->wksp, mem->account_keys_pool_gaddr );
  self->account_keys_root = fd_wksp_laddr_fast( ctx->wksp, mem->account_keys_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_account_keys_new(fd_account_keys_t * self) {
  fd_memset( self, 0, sizeof(fd_account_keys_t) );
}
void fd_account_keys_destroy( fd_account_keys_t * self ) {
  for( fd_account_keys_pair_t_mapnode_t * n = fd_account_keys_pair_t_map_minimum(self->account_keys_pool, self->account_keys_root ); n; n = fd_account_keys_pair_t_map_successor(self->account_keys_pool, n) ) {
    fd_account_keys_pair_destroy( &n->elem );
  }
  self->account_keys_pool = NULL;
  self->account_keys_root = NULL;
}

ulong fd_account_keys_footprint( void ){ return FD_ACCOUNT_KEYS_FOOTPRINT; }
ulong fd_account_keys_align( void ){ return FD_ACCOUNT_KEYS_ALIGN; }

void fd_account_keys_walk( void * w, fd_account_keys_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_account_keys", level++ );
  if( self->account_keys_root ) {
    for( fd_account_keys_pair_t_mapnode_t * n = fd_account_keys_pair_t_map_minimum(self->account_keys_pool, self->account_keys_root ); n; n = fd_account_keys_pair_t_map_successor( self->account_keys_pool, n ) ) {
      fd_account_keys_pair_walk(w, &n->elem, fun, "account_keys", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_account_keys", level-- );
}
ulong fd_account_keys_size( fd_account_keys_t const * self ) {
  ulong size = 0;
  if( self->account_keys_root ) {
    size += sizeof(ulong);
    for( fd_account_keys_pair_t_mapnode_t * n = fd_account_keys_pair_t_map_minimum( self->account_keys_pool, self->account_keys_root ); n; n = fd_account_keys_pair_t_map_successor( self->account_keys_pool, n ) ) {
      size += fd_account_keys_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_stake_weight_encode( fd_stake_weight_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_weight_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_weight_t);
  void const * start_data = ctx->data;
  int err = fd_stake_weight_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_weight_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_stake_weight_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weight_t * self = (fd_stake_weight_t *)mem;
  fd_stake_weight_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_weight_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_weight_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_weight_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weight_t * self = (fd_stake_weight_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->stake, ctx );
}
void * fd_stake_weight_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weight_global_t * self = (fd_stake_weight_global_t *)mem;
  fd_stake_weight_new( (fd_stake_weight_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_weight_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_weight_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_weight_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weight_global_t * self = (fd_stake_weight_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->stake, ctx );
}
int fd_stake_weight_convert_global_to_local( void const * global_self, fd_stake_weight_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_weight_global_t const * mem = (fd_stake_weight_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->stake = mem->stake;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_weight_new(fd_stake_weight_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_weight_t) );
  fd_pubkey_new( &self->key );
}
void fd_stake_weight_destroy( fd_stake_weight_t * self ) {
  fd_pubkey_destroy( &self->key );
}

ulong fd_stake_weight_footprint( void ){ return FD_STAKE_WEIGHT_FOOTPRINT; }
ulong fd_stake_weight_align( void ){ return FD_STAKE_WEIGHT_ALIGN; }

void fd_stake_weight_walk( void * w, fd_stake_weight_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_weight", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fun( w, &self->stake, "stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_weight", level-- );
}
ulong fd_stake_weight_size( fd_stake_weight_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += sizeof(ulong);
  return size;
}

int fd_stake_weights_encode( fd_stake_weights_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->stake_weights_root ) {
    ulong stake_weights_len = fd_stake_weight_t_map_size( self->stake_weights_pool, self->stake_weights_root );
    err = fd_bincode_uint64_encode( stake_weights_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_stake_weight_t_mapnode_t * n = fd_stake_weight_t_map_minimum( self->stake_weights_pool, self->stake_weights_root ); n; n = fd_stake_weight_t_map_successor( self->stake_weights_pool, n ) ) {
      err = fd_stake_weight_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong stake_weights_len = 0;
    err = fd_bincode_uint64_encode( stake_weights_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_weights_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_weights_t);
  void const * start_data = ctx->data;
  int err = fd_stake_weights_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_weights_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong stake_weights_len = 0UL;
  err = fd_bincode_uint64_decode( &stake_weights_len, ctx );
  ulong stake_weights_cnt = stake_weights_len;
  *total_sz += fd_stake_weight_t_map_align() + fd_stake_weight_t_map_footprint( stake_weights_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < stake_weights_len; i++ ) {
    err = fd_stake_weight_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_stake_weights_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weights_t * self = (fd_stake_weights_t *)mem;
  fd_stake_weights_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_weights_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_weights_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_weights_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weights_t * self = (fd_stake_weights_t *)struct_mem;
  ulong stake_weights_len;
  fd_bincode_uint64_decode_unsafe( &stake_weights_len, ctx );
  self->stake_weights_pool = fd_stake_weight_t_map_join_new( alloc_mem, stake_weights_len );
  self->stake_weights_root = NULL;
  for( ulong i=0; i < stake_weights_len; i++ ) {
    fd_stake_weight_t_mapnode_t * node = fd_stake_weight_t_map_acquire( self->stake_weights_pool );
    fd_stake_weight_new( &node->elem );
    fd_stake_weight_decode_inner( &node->elem, alloc_mem, ctx );
    fd_stake_weight_t_map_insert( self->stake_weights_pool, &self->stake_weights_root, node );
  }
}
void * fd_stake_weights_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weights_global_t * self = (fd_stake_weights_global_t *)mem;
  fd_stake_weights_new( (fd_stake_weights_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_weights_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_weights_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_weights_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_weights_global_t * self = (fd_stake_weights_global_t *)struct_mem;
  ulong stake_weights_len;
  fd_bincode_uint64_decode_unsafe( &stake_weights_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_stake_weight_t_map_align() );
  fd_stake_weight_t_mapnode_t * stake_weights_pool = fd_stake_weight_t_map_join_new( alloc_mem, stake_weights_len );
  fd_stake_weight_t_mapnode_t * stake_weights_root = NULL;
  self->stake_weights_root_gaddr = 0UL;
  for( ulong i=0; i < stake_weights_len; i++ ) {
    fd_stake_weight_t_mapnode_t * node = fd_stake_weight_t_map_acquire( stake_weights_pool );
    fd_stake_weight_new( &node->elem );
    fd_stake_weight_decode_inner( &node->elem, alloc_mem, ctx );
    fd_stake_weight_t_map_insert( stake_weights_pool, &stake_weights_root, node );
  }
  self->stake_weights_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, stake_weights_pool );
  self->stake_weights_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, stake_weights_root );
}
int fd_stake_weights_convert_global_to_local( void const * global_self, fd_stake_weights_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_weights_global_t const * mem = (fd_stake_weights_global_t const *)global_self;
  self->stake_weights_pool = fd_wksp_laddr_fast( ctx->wksp, mem->stake_weights_pool_gaddr );
  self->stake_weights_root = fd_wksp_laddr_fast( ctx->wksp, mem->stake_weights_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_stake_weights_new(fd_stake_weights_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_weights_t) );
}
void fd_stake_weights_destroy( fd_stake_weights_t * self ) {
  for( fd_stake_weight_t_mapnode_t * n = fd_stake_weight_t_map_minimum(self->stake_weights_pool, self->stake_weights_root ); n; n = fd_stake_weight_t_map_successor(self->stake_weights_pool, n) ) {
    fd_stake_weight_destroy( &n->elem );
  }
  self->stake_weights_pool = NULL;
  self->stake_weights_root = NULL;
}

ulong fd_stake_weights_footprint( void ){ return FD_STAKE_WEIGHTS_FOOTPRINT; }
ulong fd_stake_weights_align( void ){ return FD_STAKE_WEIGHTS_ALIGN; }

void fd_stake_weights_walk( void * w, fd_stake_weights_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_weights", level++ );
  if( self->stake_weights_root ) {
    for( fd_stake_weight_t_mapnode_t * n = fd_stake_weight_t_map_minimum(self->stake_weights_pool, self->stake_weights_root ); n; n = fd_stake_weight_t_map_successor( self->stake_weights_pool, n ) ) {
      fd_stake_weight_walk(w, &n->elem, fun, "stake_weights", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_weights", level-- );
}
ulong fd_stake_weights_size( fd_stake_weights_t const * self ) {
  ulong size = 0;
  if( self->stake_weights_root ) {
    size += sizeof(ulong);
    for( fd_stake_weight_t_mapnode_t * n = fd_stake_weight_t_map_minimum( self->stake_weights_pool, self->stake_weights_root ); n; n = fd_stake_weight_t_map_successor( self->stake_weights_pool, n ) ) {
      size += fd_stake_weight_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_delegation_encode( fd_delegation_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->voter_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->activation_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->deactivation_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->warmup_cooldown_rate, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_delegation_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_delegation_t);
  void const * start_data = ctx->data;
  int err = fd_delegation_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_delegation_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_delegation_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_t * self = (fd_delegation_t *)mem;
  fd_delegation_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_delegation_t);
  void * * alloc_mem = &alloc_region;
  fd_delegation_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_delegation_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_t * self = (fd_delegation_t *)struct_mem;
  fd_pubkey_decode_inner( &self->voter_pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->stake, ctx );
  fd_bincode_uint64_decode_unsafe( &self->activation_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->deactivation_epoch, ctx );
  fd_bincode_double_decode_unsafe( &self->warmup_cooldown_rate, ctx );
}
void * fd_delegation_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_global_t * self = (fd_delegation_global_t *)mem;
  fd_delegation_new( (fd_delegation_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_delegation_global_t);
  void * * alloc_mem = &alloc_region;
  fd_delegation_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_delegation_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_global_t * self = (fd_delegation_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->voter_pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->stake, ctx );
  fd_bincode_uint64_decode_unsafe( &self->activation_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->deactivation_epoch, ctx );
  fd_bincode_double_decode_unsafe( &self->warmup_cooldown_rate, ctx );
}
int fd_delegation_convert_global_to_local( void const * global_self, fd_delegation_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_delegation_global_t const * mem = (fd_delegation_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->voter_pubkey, &self->voter_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->stake = mem->stake;
  self->activation_epoch = mem->activation_epoch;
  self->deactivation_epoch = mem->deactivation_epoch;
  self->warmup_cooldown_rate = mem->warmup_cooldown_rate;
  return FD_BINCODE_SUCCESS;
}
void fd_delegation_new(fd_delegation_t * self) {
  fd_memset( self, 0, sizeof(fd_delegation_t) );
  fd_pubkey_new( &self->voter_pubkey );
}
void fd_delegation_destroy( fd_delegation_t * self ) {
  fd_pubkey_destroy( &self->voter_pubkey );
}

ulong fd_delegation_footprint( void ){ return FD_DELEGATION_FOOTPRINT; }
ulong fd_delegation_align( void ){ return FD_DELEGATION_ALIGN; }

void fd_delegation_walk( void * w, fd_delegation_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_delegation", level++ );
  fd_pubkey_walk( w, &self->voter_pubkey, fun, "voter_pubkey", level );
  fun( w, &self->stake, "stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->activation_epoch, "activation_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->deactivation_epoch, "deactivation_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->warmup_cooldown_rate, "warmup_cooldown_rate", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_delegation", level-- );
}
ulong fd_delegation_size( fd_delegation_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->voter_pubkey );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(double);
  return size;
}

int fd_delegation_pair_encode( fd_delegation_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_delegation_encode( &self->delegation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_delegation_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_delegation_pair_t);
  void const * start_data = ctx->data;
  int err = fd_delegation_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_delegation_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_delegation_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_delegation_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_pair_t * self = (fd_delegation_pair_t *)mem;
  fd_delegation_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_delegation_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_delegation_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_delegation_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_pair_t * self = (fd_delegation_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->account, alloc_mem, ctx );
  fd_delegation_decode_inner( &self->delegation, alloc_mem, ctx );
}
void * fd_delegation_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_pair_global_t * self = (fd_delegation_pair_global_t *)mem;
  fd_delegation_pair_new( (fd_delegation_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_delegation_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_delegation_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_delegation_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_delegation_pair_global_t * self = (fd_delegation_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->account, alloc_mem, ctx );
  fd_delegation_decode_inner_global( &self->delegation, alloc_mem, ctx );
}
int fd_delegation_pair_convert_global_to_local( void const * global_self, fd_delegation_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_delegation_pair_global_t const * mem = (fd_delegation_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->account, &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_delegation_convert_global_to_local( &mem->delegation, &self->delegation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_delegation_pair_new(fd_delegation_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_delegation_pair_t) );
  fd_pubkey_new( &self->account );
  fd_delegation_new( &self->delegation );
}
void fd_delegation_pair_destroy( fd_delegation_pair_t * self ) {
  fd_pubkey_destroy( &self->account );
  fd_delegation_destroy( &self->delegation );
}

ulong fd_delegation_pair_footprint( void ){ return FD_DELEGATION_PAIR_FOOTPRINT; }
ulong fd_delegation_pair_align( void ){ return FD_DELEGATION_PAIR_ALIGN; }

void fd_delegation_pair_walk( void * w, fd_delegation_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_delegation_pair", level++ );
  fd_pubkey_walk( w, &self->account, fun, "account", level );
  fd_delegation_walk( w, &self->delegation, fun, "delegation", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_delegation_pair", level-- );
}
ulong fd_delegation_pair_size( fd_delegation_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->account );
  size += fd_delegation_size( &self->delegation );
  return size;
}

int fd_stake_encode( fd_stake_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_delegation_encode( &self->delegation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->credits_observed, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_t);
  void const * start_data = ctx->data;
  int err = fd_stake_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_delegation_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_stake_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_t * self = (fd_stake_t *)mem;
  fd_stake_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_t * self = (fd_stake_t *)struct_mem;
  fd_delegation_decode_inner( &self->delegation, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->credits_observed, ctx );
}
void * fd_stake_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_global_t * self = (fd_stake_global_t *)mem;
  fd_stake_new( (fd_stake_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_global_t * self = (fd_stake_global_t *)struct_mem;
  fd_delegation_decode_inner_global( &self->delegation, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->credits_observed, ctx );
}
int fd_stake_convert_global_to_local( void const * global_self, fd_stake_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_global_t const * mem = (fd_stake_global_t const *)global_self;
  err = fd_delegation_convert_global_to_local( &mem->delegation, &self->delegation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->credits_observed = mem->credits_observed;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_new(fd_stake_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_t) );
  fd_delegation_new( &self->delegation );
}
void fd_stake_destroy( fd_stake_t * self ) {
  fd_delegation_destroy( &self->delegation );
}

ulong fd_stake_footprint( void ){ return FD_STAKE_FOOTPRINT; }
ulong fd_stake_align( void ){ return FD_STAKE_ALIGN; }

void fd_stake_walk( void * w, fd_stake_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake", level++ );
  fd_delegation_walk( w, &self->delegation, fun, "delegation", level );
  fun( w, &self->credits_observed, "credits_observed", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake", level-- );
}
ulong fd_stake_size( fd_stake_t const * self ) {
  ulong size = 0;
  size += fd_delegation_size( &self->delegation );
  size += sizeof(ulong);
  return size;
}

int fd_stake_pair_encode( fd_stake_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_encode( &self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_pair_t);
  void const * start_data = ctx->data;
  int err = fd_stake_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_pair_t * self = (fd_stake_pair_t *)mem;
  fd_stake_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_pair_t * self = (fd_stake_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->account, alloc_mem, ctx );
  fd_stake_decode_inner( &self->stake, alloc_mem, ctx );
}
void * fd_stake_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_pair_global_t * self = (fd_stake_pair_global_t *)mem;
  fd_stake_pair_new( (fd_stake_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_pair_global_t * self = (fd_stake_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->account, alloc_mem, ctx );
  fd_stake_decode_inner_global( &self->stake, alloc_mem, ctx );
}
int fd_stake_pair_convert_global_to_local( void const * global_self, fd_stake_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_pair_global_t const * mem = (fd_stake_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->account, &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_convert_global_to_local( &mem->stake, &self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_pair_new(fd_stake_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_pair_t) );
  fd_pubkey_new( &self->account );
  fd_stake_new( &self->stake );
}
void fd_stake_pair_destroy( fd_stake_pair_t * self ) {
  fd_pubkey_destroy( &self->account );
  fd_stake_destroy( &self->stake );
}

ulong fd_stake_pair_footprint( void ){ return FD_STAKE_PAIR_FOOTPRINT; }
ulong fd_stake_pair_align( void ){ return FD_STAKE_PAIR_ALIGN; }

void fd_stake_pair_walk( void * w, fd_stake_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_pair", level++ );
  fd_pubkey_walk( w, &self->account, fun, "account", level );
  fd_stake_walk( w, &self->stake, fun, "stake", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_pair", level-- );
}
ulong fd_stake_pair_size( fd_stake_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->account );
  size += fd_stake_size( &self->stake );
  return size;
}

int fd_stakes_encode( fd_stakes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_vote_accounts_encode( &self->vote_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->stake_delegations_root ) {
    ulong stake_delegations_len = fd_delegation_pair_t_map_size( self->stake_delegations_pool, self->stake_delegations_root );
    err = fd_bincode_uint64_encode( stake_delegations_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_delegation_pair_t_mapnode_t * n = fd_delegation_pair_t_map_minimum( self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_delegation_pair_t_map_successor( self->stake_delegations_pool, n ) ) {
      err = fd_delegation_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong stake_delegations_len = 0;
    err = fd_bincode_uint64_encode( stake_delegations_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->unused, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_history_encode( &self->stake_history, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stakes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stakes_t);
  void const * start_data = ctx->data;
  int err = fd_stakes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stakes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong stake_delegations_len = 0UL;
  err = fd_bincode_uint64_decode( &stake_delegations_len, ctx );
  ulong stake_delegations_cnt = stake_delegations_len;
  *total_sz += fd_delegation_pair_t_map_align() + fd_delegation_pair_t_map_footprint( stake_delegations_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < stake_delegations_len; i++ ) {
    err = fd_delegation_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_stake_history_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stakes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_t * self = (fd_stakes_t *)mem;
  fd_stakes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stakes_t);
  void * * alloc_mem = &alloc_region;
  fd_stakes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stakes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_t * self = (fd_stakes_t *)struct_mem;
  fd_vote_accounts_decode_inner( &self->vote_accounts, alloc_mem, ctx );
  ulong stake_delegations_len;
  fd_bincode_uint64_decode_unsafe( &stake_delegations_len, ctx );
  self->stake_delegations_pool = fd_delegation_pair_t_map_join_new( alloc_mem, stake_delegations_len );
  self->stake_delegations_root = NULL;
  for( ulong i=0; i < stake_delegations_len; i++ ) {
    fd_delegation_pair_t_mapnode_t * node = fd_delegation_pair_t_map_acquire( self->stake_delegations_pool );
    fd_delegation_pair_new( &node->elem );
    fd_delegation_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_delegation_pair_t_map_insert( self->stake_delegations_pool, &self->stake_delegations_root, node );
  }
  fd_bincode_uint64_decode_unsafe( &self->unused, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_stake_history_decode_inner( &self->stake_history, alloc_mem, ctx );
}
void * fd_stakes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_global_t * self = (fd_stakes_global_t *)mem;
  fd_stakes_new( (fd_stakes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stakes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stakes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stakes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_global_t * self = (fd_stakes_global_t *)struct_mem;
  fd_vote_accounts_decode_inner_global( &self->vote_accounts, alloc_mem, ctx );
  ulong stake_delegations_len;
  fd_bincode_uint64_decode_unsafe( &stake_delegations_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_delegation_pair_t_map_align() );
  fd_delegation_pair_t_mapnode_t * stake_delegations_pool = fd_delegation_pair_t_map_join_new( alloc_mem, stake_delegations_len );
  fd_delegation_pair_t_mapnode_t * stake_delegations_root = NULL;
  self->stake_delegations_root_gaddr = 0UL;
  for( ulong i=0; i < stake_delegations_len; i++ ) {
    fd_delegation_pair_t_mapnode_t * node = fd_delegation_pair_t_map_acquire( stake_delegations_pool );
    fd_delegation_pair_new( &node->elem );
    fd_delegation_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_delegation_pair_t_map_insert( stake_delegations_pool, &stake_delegations_root, node );
  }
  self->stake_delegations_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, stake_delegations_pool );
  self->stake_delegations_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, stake_delegations_root );
  fd_bincode_uint64_decode_unsafe( &self->unused, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_stake_history_decode_inner_global( &self->stake_history, alloc_mem, ctx );
}
int fd_stakes_convert_global_to_local( void const * global_self, fd_stakes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stakes_global_t const * mem = (fd_stakes_global_t const *)global_self;
  err = fd_vote_accounts_convert_global_to_local( &mem->vote_accounts, &self->vote_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->stake_delegations_pool = fd_wksp_laddr_fast( ctx->wksp, mem->stake_delegations_pool_gaddr );
  self->stake_delegations_root = fd_wksp_laddr_fast( ctx->wksp, mem->stake_delegations_root_gaddr );
  self->unused = mem->unused;
  self->epoch = mem->epoch;
  err = fd_stake_history_convert_global_to_local( &mem->stake_history, &self->stake_history, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stakes_new(fd_stakes_t * self) {
  fd_memset( self, 0, sizeof(fd_stakes_t) );
  fd_vote_accounts_new( &self->vote_accounts );
  fd_stake_history_new( &self->stake_history );
}
void fd_stakes_destroy( fd_stakes_t * self ) {
  fd_vote_accounts_destroy( &self->vote_accounts );
  for( fd_delegation_pair_t_mapnode_t * n = fd_delegation_pair_t_map_minimum(self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_delegation_pair_t_map_successor(self->stake_delegations_pool, n) ) {
    fd_delegation_pair_destroy( &n->elem );
  }
  self->stake_delegations_pool = NULL;
  self->stake_delegations_root = NULL;
  fd_stake_history_destroy( &self->stake_history );
}

ulong fd_stakes_footprint( void ){ return FD_STAKES_FOOTPRINT; }
ulong fd_stakes_align( void ){ return FD_STAKES_ALIGN; }

void fd_stakes_walk( void * w, fd_stakes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stakes", level++ );
  fd_vote_accounts_walk( w, &self->vote_accounts, fun, "vote_accounts", level );
  if( self->stake_delegations_root ) {
    for( fd_delegation_pair_t_mapnode_t * n = fd_delegation_pair_t_map_minimum(self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_delegation_pair_t_map_successor( self->stake_delegations_pool, n ) ) {
      fd_delegation_pair_walk(w, &n->elem, fun, "stake_delegations", level );
    }
  }
  fun( w, &self->unused, "unused", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_stake_history_walk( w, &self->stake_history, fun, "stake_history", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stakes", level-- );
}
ulong fd_stakes_size( fd_stakes_t const * self ) {
  ulong size = 0;
  size += fd_vote_accounts_size( &self->vote_accounts );
  if( self->stake_delegations_root ) {
    size += sizeof(ulong);
    for( fd_delegation_pair_t_mapnode_t * n = fd_delegation_pair_t_map_minimum( self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_delegation_pair_t_map_successor( self->stake_delegations_pool, n ) ) {
      size += fd_delegation_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_stake_history_size( &self->stake_history );
  return size;
}

int fd_stakes_stake_encode( fd_stakes_stake_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_vote_accounts_encode( &self->vote_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->stake_delegations_root ) {
    ulong stake_delegations_len = fd_stake_pair_t_map_size( self->stake_delegations_pool, self->stake_delegations_root );
    err = fd_bincode_uint64_encode( stake_delegations_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_stake_pair_t_mapnode_t * n = fd_stake_pair_t_map_minimum( self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_stake_pair_t_map_successor( self->stake_delegations_pool, n ) ) {
      err = fd_stake_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong stake_delegations_len = 0;
    err = fd_bincode_uint64_encode( stake_delegations_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->unused, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_history_encode( &self->stake_history, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stakes_stake_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stakes_stake_t);
  void const * start_data = ctx->data;
  int err = fd_stakes_stake_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stakes_stake_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong stake_delegations_len = 0UL;
  err = fd_bincode_uint64_decode( &stake_delegations_len, ctx );
  ulong stake_delegations_cnt = stake_delegations_len;
  *total_sz += fd_stake_pair_t_map_align() + fd_stake_pair_t_map_footprint( stake_delegations_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < stake_delegations_len; i++ ) {
    err = fd_stake_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_stake_history_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stakes_stake_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_stake_t * self = (fd_stakes_stake_t *)mem;
  fd_stakes_stake_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stakes_stake_t);
  void * * alloc_mem = &alloc_region;
  fd_stakes_stake_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stakes_stake_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_stake_t * self = (fd_stakes_stake_t *)struct_mem;
  fd_vote_accounts_decode_inner( &self->vote_accounts, alloc_mem, ctx );
  ulong stake_delegations_len;
  fd_bincode_uint64_decode_unsafe( &stake_delegations_len, ctx );
  self->stake_delegations_pool = fd_stake_pair_t_map_join_new( alloc_mem, stake_delegations_len );
  self->stake_delegations_root = NULL;
  for( ulong i=0; i < stake_delegations_len; i++ ) {
    fd_stake_pair_t_mapnode_t * node = fd_stake_pair_t_map_acquire( self->stake_delegations_pool );
    fd_stake_pair_new( &node->elem );
    fd_stake_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_stake_pair_t_map_insert( self->stake_delegations_pool, &self->stake_delegations_root, node );
  }
  fd_bincode_uint64_decode_unsafe( &self->unused, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_stake_history_decode_inner( &self->stake_history, alloc_mem, ctx );
}
void * fd_stakes_stake_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_stake_global_t * self = (fd_stakes_stake_global_t *)mem;
  fd_stakes_stake_new( (fd_stakes_stake_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stakes_stake_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stakes_stake_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stakes_stake_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stakes_stake_global_t * self = (fd_stakes_stake_global_t *)struct_mem;
  fd_vote_accounts_decode_inner_global( &self->vote_accounts, alloc_mem, ctx );
  ulong stake_delegations_len;
  fd_bincode_uint64_decode_unsafe( &stake_delegations_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_stake_pair_t_map_align() );
  fd_stake_pair_t_mapnode_t * stake_delegations_pool = fd_stake_pair_t_map_join_new( alloc_mem, stake_delegations_len );
  fd_stake_pair_t_mapnode_t * stake_delegations_root = NULL;
  self->stake_delegations_root_gaddr = 0UL;
  for( ulong i=0; i < stake_delegations_len; i++ ) {
    fd_stake_pair_t_mapnode_t * node = fd_stake_pair_t_map_acquire( stake_delegations_pool );
    fd_stake_pair_new( &node->elem );
    fd_stake_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_stake_pair_t_map_insert( stake_delegations_pool, &stake_delegations_root, node );
  }
  self->stake_delegations_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, stake_delegations_pool );
  self->stake_delegations_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, stake_delegations_root );
  fd_bincode_uint64_decode_unsafe( &self->unused, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_stake_history_decode_inner_global( &self->stake_history, alloc_mem, ctx );
}
int fd_stakes_stake_convert_global_to_local( void const * global_self, fd_stakes_stake_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stakes_stake_global_t const * mem = (fd_stakes_stake_global_t const *)global_self;
  err = fd_vote_accounts_convert_global_to_local( &mem->vote_accounts, &self->vote_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->stake_delegations_pool = fd_wksp_laddr_fast( ctx->wksp, mem->stake_delegations_pool_gaddr );
  self->stake_delegations_root = fd_wksp_laddr_fast( ctx->wksp, mem->stake_delegations_root_gaddr );
  self->unused = mem->unused;
  self->epoch = mem->epoch;
  err = fd_stake_history_convert_global_to_local( &mem->stake_history, &self->stake_history, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stakes_stake_new(fd_stakes_stake_t * self) {
  fd_memset( self, 0, sizeof(fd_stakes_stake_t) );
  fd_vote_accounts_new( &self->vote_accounts );
  fd_stake_history_new( &self->stake_history );
}
void fd_stakes_stake_destroy( fd_stakes_stake_t * self ) {
  fd_vote_accounts_destroy( &self->vote_accounts );
  for( fd_stake_pair_t_mapnode_t * n = fd_stake_pair_t_map_minimum(self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_stake_pair_t_map_successor(self->stake_delegations_pool, n) ) {
    fd_stake_pair_destroy( &n->elem );
  }
  self->stake_delegations_pool = NULL;
  self->stake_delegations_root = NULL;
  fd_stake_history_destroy( &self->stake_history );
}

ulong fd_stakes_stake_footprint( void ){ return FD_STAKES_STAKE_FOOTPRINT; }
ulong fd_stakes_stake_align( void ){ return FD_STAKES_STAKE_ALIGN; }

void fd_stakes_stake_walk( void * w, fd_stakes_stake_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stakes_stake", level++ );
  fd_vote_accounts_walk( w, &self->vote_accounts, fun, "vote_accounts", level );
  if( self->stake_delegations_root ) {
    for( fd_stake_pair_t_mapnode_t * n = fd_stake_pair_t_map_minimum(self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_stake_pair_t_map_successor( self->stake_delegations_pool, n ) ) {
      fd_stake_pair_walk(w, &n->elem, fun, "stake_delegations", level );
    }
  }
  fun( w, &self->unused, "unused", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_stake_history_walk( w, &self->stake_history, fun, "stake_history", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stakes_stake", level-- );
}
ulong fd_stakes_stake_size( fd_stakes_stake_t const * self ) {
  ulong size = 0;
  size += fd_vote_accounts_size( &self->vote_accounts );
  if( self->stake_delegations_root ) {
    size += sizeof(ulong);
    for( fd_stake_pair_t_mapnode_t * n = fd_stake_pair_t_map_minimum( self->stake_delegations_pool, self->stake_delegations_root ); n; n = fd_stake_pair_t_map_successor( self->stake_delegations_pool, n ) ) {
      size += fd_stake_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_stake_history_size( &self->stake_history );
  return size;
}

int fd_bank_incremental_snapshot_persistence_encode( fd_bank_incremental_snapshot_persistence_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->full_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->full_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->full_capitalization, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->incremental_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->incremental_capitalization, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_bank_incremental_snapshot_persistence_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bank_incremental_snapshot_persistence_t);
  void const * start_data = ctx->data;
  int err = fd_bank_incremental_snapshot_persistence_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bank_incremental_snapshot_persistence_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_bank_incremental_snapshot_persistence_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_incremental_snapshot_persistence_t * self = (fd_bank_incremental_snapshot_persistence_t *)mem;
  fd_bank_incremental_snapshot_persistence_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_incremental_snapshot_persistence_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_incremental_snapshot_persistence_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_incremental_snapshot_persistence_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_incremental_snapshot_persistence_t * self = (fd_bank_incremental_snapshot_persistence_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->full_slot, ctx );
  fd_hash_decode_inner( &self->full_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->full_capitalization, ctx );
  fd_hash_decode_inner( &self->incremental_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->incremental_capitalization, ctx );
}
void * fd_bank_incremental_snapshot_persistence_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_incremental_snapshot_persistence_global_t * self = (fd_bank_incremental_snapshot_persistence_global_t *)mem;
  fd_bank_incremental_snapshot_persistence_new( (fd_bank_incremental_snapshot_persistence_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_incremental_snapshot_persistence_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_incremental_snapshot_persistence_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_incremental_snapshot_persistence_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_incremental_snapshot_persistence_global_t * self = (fd_bank_incremental_snapshot_persistence_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->full_slot, ctx );
  fd_hash_decode_inner_global( &self->full_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->full_capitalization, ctx );
  fd_hash_decode_inner_global( &self->incremental_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->incremental_capitalization, ctx );
}
int fd_bank_incremental_snapshot_persistence_convert_global_to_local( void const * global_self, fd_bank_incremental_snapshot_persistence_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bank_incremental_snapshot_persistence_global_t const * mem = (fd_bank_incremental_snapshot_persistence_global_t const *)global_self;
  self->full_slot = mem->full_slot;
  err = fd_hash_convert_global_to_local( &mem->full_hash, &self->full_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->full_capitalization = mem->full_capitalization;
  err = fd_hash_convert_global_to_local( &mem->incremental_hash, &self->incremental_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->incremental_capitalization = mem->incremental_capitalization;
  return FD_BINCODE_SUCCESS;
}
void fd_bank_incremental_snapshot_persistence_new(fd_bank_incremental_snapshot_persistence_t * self) {
  fd_memset( self, 0, sizeof(fd_bank_incremental_snapshot_persistence_t) );
  fd_hash_new( &self->full_hash );
  fd_hash_new( &self->incremental_hash );
}
void fd_bank_incremental_snapshot_persistence_destroy( fd_bank_incremental_snapshot_persistence_t * self ) {
  fd_hash_destroy( &self->full_hash );
  fd_hash_destroy( &self->incremental_hash );
}

ulong fd_bank_incremental_snapshot_persistence_footprint( void ){ return FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_FOOTPRINT; }
ulong fd_bank_incremental_snapshot_persistence_align( void ){ return FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_ALIGN; }

void fd_bank_incremental_snapshot_persistence_walk( void * w, fd_bank_incremental_snapshot_persistence_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bank_incremental_snapshot_persistence", level++ );
  fun( w, &self->full_slot, "full_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->full_hash, fun, "full_hash", level );
  fun( w, &self->full_capitalization, "full_capitalization", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->incremental_hash, fun, "incremental_hash", level );
  fun( w, &self->incremental_capitalization, "incremental_capitalization", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bank_incremental_snapshot_persistence", level-- );
}
ulong fd_bank_incremental_snapshot_persistence_size( fd_bank_incremental_snapshot_persistence_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_hash_size( &self->full_hash );
  size += sizeof(ulong);
  size += fd_hash_size( &self->incremental_hash );
  size += sizeof(ulong);
  return size;
}

int fd_node_vote_accounts_encode( fd_node_vote_accounts_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->vote_accounts_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->vote_accounts_len ) {
    for( ulong i=0; i < self->vote_accounts_len; i++ ) {
      err = fd_pubkey_encode( self->vote_accounts + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->total_stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_node_vote_accounts_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_node_vote_accounts_t);
  void const * start_data = ctx->data;
  int err = fd_node_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_node_vote_accounts_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong vote_accounts_len;
  err = fd_bincode_uint64_decode( &vote_accounts_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( vote_accounts_len ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT*vote_accounts_len;
    for( ulong i=0; i < vote_accounts_len; i++ ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_node_vote_accounts_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_node_vote_accounts_t * self = (fd_node_vote_accounts_t *)mem;
  fd_node_vote_accounts_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_node_vote_accounts_t);
  void * * alloc_mem = &alloc_region;
  fd_node_vote_accounts_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_node_vote_accounts_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_node_vote_accounts_t * self = (fd_node_vote_accounts_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->vote_accounts_len, ctx );
  if( self->vote_accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->vote_accounts = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->vote_accounts_len;
    for( ulong i=0; i < self->vote_accounts_len; i++ ) {
      fd_pubkey_new( self->vote_accounts + i );
      fd_pubkey_decode_inner( self->vote_accounts + i, alloc_mem, ctx );
    }
  } else
    self->vote_accounts = NULL;
  fd_bincode_uint64_decode_unsafe( &self->total_stake, ctx );
}
void * fd_node_vote_accounts_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_node_vote_accounts_global_t * self = (fd_node_vote_accounts_global_t *)mem;
  fd_node_vote_accounts_new( (fd_node_vote_accounts_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_node_vote_accounts_global_t);
  void * * alloc_mem = &alloc_region;
  fd_node_vote_accounts_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_node_vote_accounts_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_node_vote_accounts_global_t * self = (fd_node_vote_accounts_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->vote_accounts_len, ctx );
  if( self->vote_accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->vote_accounts_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->vote_accounts_len;
    for( ulong i=0; i < self->vote_accounts_len; i++ ) {
      fd_pubkey_new( (fd_pubkey_t *)(cur_mem + FD_PUBKEY_FOOTPRINT * i) );
      fd_pubkey_decode_inner_global( cur_mem + FD_PUBKEY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->vote_accounts_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->total_stake, ctx );
}
int fd_node_vote_accounts_convert_global_to_local( void const * global_self, fd_node_vote_accounts_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_node_vote_accounts_global_t const * mem = (fd_node_vote_accounts_global_t const *)global_self;
  self->vote_accounts_len = mem->vote_accounts_len;
  self->vote_accounts     = fd_wksp_laddr_fast( ctx->wksp, mem->vote_accounts_gaddr );
  self->total_stake = mem->total_stake;
  return FD_BINCODE_SUCCESS;
}
void fd_node_vote_accounts_new(fd_node_vote_accounts_t * self) {
  fd_memset( self, 0, sizeof(fd_node_vote_accounts_t) );
}
void fd_node_vote_accounts_destroy( fd_node_vote_accounts_t * self ) {
  if( self->vote_accounts ) {
    for( ulong i=0; i < self->vote_accounts_len; i++ )
      fd_pubkey_destroy( self->vote_accounts + i );
    self->vote_accounts = NULL;
  }
}

ulong fd_node_vote_accounts_footprint( void ){ return FD_NODE_VOTE_ACCOUNTS_FOOTPRINT; }
ulong fd_node_vote_accounts_align( void ){ return FD_NODE_VOTE_ACCOUNTS_ALIGN; }

void fd_node_vote_accounts_walk( void * w, fd_node_vote_accounts_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_node_vote_accounts", level++ );
  if( self->vote_accounts_len ) {
    fun( w, NULL, "vote_accounts", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->vote_accounts_len; i++ )
      fd_pubkey_walk(w, self->vote_accounts + i, fun, "pubkey", level );
    fun( w, NULL, "vote_accounts", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->total_stake, "total_stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_node_vote_accounts", level-- );
}
ulong fd_node_vote_accounts_size( fd_node_vote_accounts_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->vote_accounts_len; i++ )
      size += fd_pubkey_size( self->vote_accounts + i );
  } while(0);
  size += sizeof(ulong);
  return size;
}

int fd_pubkey_node_vote_accounts_pair_encode( fd_pubkey_node_vote_accounts_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_node_vote_accounts_encode( &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_pubkey_node_vote_accounts_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_pubkey_node_vote_accounts_pair_t);
  void const * start_data = ctx->data;
  int err = fd_pubkey_node_vote_accounts_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_pubkey_node_vote_accounts_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_node_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_pubkey_node_vote_accounts_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_vote_accounts_pair_t * self = (fd_pubkey_node_vote_accounts_pair_t *)mem;
  fd_pubkey_node_vote_accounts_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_node_vote_accounts_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_node_vote_accounts_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_node_vote_accounts_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_vote_accounts_pair_t * self = (fd_pubkey_node_vote_accounts_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_node_vote_accounts_decode_inner( &self->value, alloc_mem, ctx );
}
void * fd_pubkey_node_vote_accounts_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_vote_accounts_pair_global_t * self = (fd_pubkey_node_vote_accounts_pair_global_t *)mem;
  fd_pubkey_node_vote_accounts_pair_new( (fd_pubkey_node_vote_accounts_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_node_vote_accounts_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_node_vote_accounts_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_node_vote_accounts_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_vote_accounts_pair_global_t * self = (fd_pubkey_node_vote_accounts_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_node_vote_accounts_decode_inner_global( &self->value, alloc_mem, ctx );
}
int fd_pubkey_node_vote_accounts_pair_convert_global_to_local( void const * global_self, fd_pubkey_node_vote_accounts_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_pubkey_node_vote_accounts_pair_global_t const * mem = (fd_pubkey_node_vote_accounts_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_node_vote_accounts_convert_global_to_local( &mem->value, &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_pubkey_node_vote_accounts_pair_new(fd_pubkey_node_vote_accounts_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_pubkey_node_vote_accounts_pair_t) );
  fd_pubkey_new( &self->key );
  fd_node_vote_accounts_new( &self->value );
}
void fd_pubkey_node_vote_accounts_pair_destroy( fd_pubkey_node_vote_accounts_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
  fd_node_vote_accounts_destroy( &self->value );
}

ulong fd_pubkey_node_vote_accounts_pair_footprint( void ){ return FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT; }
ulong fd_pubkey_node_vote_accounts_pair_align( void ){ return FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN; }

void fd_pubkey_node_vote_accounts_pair_walk( void * w, fd_pubkey_node_vote_accounts_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_pubkey_node_vote_accounts_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fd_node_vote_accounts_walk( w, &self->value, fun, "value", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_pubkey_node_vote_accounts_pair", level-- );
}
ulong fd_pubkey_node_vote_accounts_pair_size( fd_pubkey_node_vote_accounts_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += fd_node_vote_accounts_size( &self->value );
  return size;
}

int fd_pubkey_pubkey_pair_encode( fd_pubkey_pubkey_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_pubkey_pubkey_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_pubkey_pubkey_pair_t);
  void const * start_data = ctx->data;
  int err = fd_pubkey_pubkey_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_pubkey_pubkey_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_pubkey_pubkey_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_pubkey_pair_t * self = (fd_pubkey_pubkey_pair_t *)mem;
  fd_pubkey_pubkey_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_pubkey_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_pubkey_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_pubkey_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_pubkey_pair_t * self = (fd_pubkey_pubkey_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->value, alloc_mem, ctx );
}
void * fd_pubkey_pubkey_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_pubkey_pair_global_t * self = (fd_pubkey_pubkey_pair_global_t *)mem;
  fd_pubkey_pubkey_pair_new( (fd_pubkey_pubkey_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_pubkey_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_pubkey_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_pubkey_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_pubkey_pair_global_t * self = (fd_pubkey_pubkey_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->value, alloc_mem, ctx );
}
int fd_pubkey_pubkey_pair_convert_global_to_local( void const * global_self, fd_pubkey_pubkey_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_pubkey_pubkey_pair_global_t const * mem = (fd_pubkey_pubkey_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->value, &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_pubkey_pubkey_pair_new(fd_pubkey_pubkey_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_pubkey_pubkey_pair_t) );
  fd_pubkey_new( &self->key );
  fd_pubkey_new( &self->value );
}
void fd_pubkey_pubkey_pair_destroy( fd_pubkey_pubkey_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
  fd_pubkey_destroy( &self->value );
}

ulong fd_pubkey_pubkey_pair_footprint( void ){ return FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT; }
ulong fd_pubkey_pubkey_pair_align( void ){ return FD_PUBKEY_PUBKEY_PAIR_ALIGN; }

void fd_pubkey_pubkey_pair_walk( void * w, fd_pubkey_pubkey_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_pubkey_pubkey_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fd_pubkey_walk( w, &self->value, fun, "value", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_pubkey_pubkey_pair", level-- );
}
ulong fd_pubkey_pubkey_pair_size( fd_pubkey_pubkey_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += fd_pubkey_size( &self->value );
  return size;
}

int fd_epoch_stakes_encode( fd_epoch_stakes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stakes_encode( &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->total_stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->node_id_to_vote_accounts_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->node_id_to_vote_accounts_len ) {
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ ) {
      err = fd_pubkey_node_vote_accounts_pair_encode( self->node_id_to_vote_accounts + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->epoch_authorized_voters_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->epoch_authorized_voters_len ) {
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ ) {
      err = fd_pubkey_pubkey_pair_encode( self->epoch_authorized_voters + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_epoch_stakes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_epoch_stakes_t);
  void const * start_data = ctx->data;
  int err = fd_epoch_stakes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_epoch_stakes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stakes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong node_id_to_vote_accounts_len;
  err = fd_bincode_uint64_decode( &node_id_to_vote_accounts_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( node_id_to_vote_accounts_len ) {
    *total_sz += FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT*node_id_to_vote_accounts_len;
    for( ulong i=0; i < node_id_to_vote_accounts_len; i++ ) {
      err = fd_pubkey_node_vote_accounts_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong epoch_authorized_voters_len;
  err = fd_bincode_uint64_decode( &epoch_authorized_voters_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( epoch_authorized_voters_len ) {
    *total_sz += FD_PUBKEY_PUBKEY_PAIR_ALIGN + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT*epoch_authorized_voters_len;
    for( ulong i=0; i < epoch_authorized_voters_len; i++ ) {
      err = fd_pubkey_pubkey_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_epoch_stakes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_stakes_t * self = (fd_epoch_stakes_t *)mem;
  fd_epoch_stakes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_stakes_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_stakes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_stakes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_stakes_t * self = (fd_epoch_stakes_t *)struct_mem;
  fd_stakes_decode_inner( &self->stakes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_stake, ctx );
  fd_bincode_uint64_decode_unsafe( &self->node_id_to_vote_accounts_len, ctx );
  if( self->node_id_to_vote_accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN );
    self->node_id_to_vote_accounts = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT*self->node_id_to_vote_accounts_len;
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ ) {
      fd_pubkey_node_vote_accounts_pair_new( self->node_id_to_vote_accounts + i );
      fd_pubkey_node_vote_accounts_pair_decode_inner( self->node_id_to_vote_accounts + i, alloc_mem, ctx );
    }
  } else
    self->node_id_to_vote_accounts = NULL;
  fd_bincode_uint64_decode_unsafe( &self->epoch_authorized_voters_len, ctx );
  if( self->epoch_authorized_voters_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_PUBKEY_PAIR_ALIGN );
    self->epoch_authorized_voters = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT*self->epoch_authorized_voters_len;
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ ) {
      fd_pubkey_pubkey_pair_new( self->epoch_authorized_voters + i );
      fd_pubkey_pubkey_pair_decode_inner( self->epoch_authorized_voters + i, alloc_mem, ctx );
    }
  } else
    self->epoch_authorized_voters = NULL;
}
void * fd_epoch_stakes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_stakes_global_t * self = (fd_epoch_stakes_global_t *)mem;
  fd_epoch_stakes_new( (fd_epoch_stakes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_stakes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_stakes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_stakes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_stakes_global_t * self = (fd_epoch_stakes_global_t *)struct_mem;
  fd_stakes_decode_inner_global( &self->stakes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_stake, ctx );
  fd_bincode_uint64_decode_unsafe( &self->node_id_to_vote_accounts_len, ctx );
  if( self->node_id_to_vote_accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN );
    self->node_id_to_vote_accounts_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT*self->node_id_to_vote_accounts_len;
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ ) {
      fd_pubkey_node_vote_accounts_pair_new( (fd_pubkey_node_vote_accounts_pair_t *)(cur_mem + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT * i) );
      fd_pubkey_node_vote_accounts_pair_decode_inner_global( cur_mem + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->node_id_to_vote_accounts_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->epoch_authorized_voters_len, ctx );
  if( self->epoch_authorized_voters_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_PUBKEY_PAIR_ALIGN );
    self->epoch_authorized_voters_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT*self->epoch_authorized_voters_len;
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ ) {
      fd_pubkey_pubkey_pair_new( (fd_pubkey_pubkey_pair_t *)(cur_mem + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT * i) );
      fd_pubkey_pubkey_pair_decode_inner_global( cur_mem + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->epoch_authorized_voters_gaddr = 0UL;
}
int fd_epoch_stakes_convert_global_to_local( void const * global_self, fd_epoch_stakes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_epoch_stakes_global_t const * mem = (fd_epoch_stakes_global_t const *)global_self;
  err = fd_stakes_convert_global_to_local( &mem->stakes, &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->total_stake = mem->total_stake;
  self->node_id_to_vote_accounts_len = mem->node_id_to_vote_accounts_len;
  self->node_id_to_vote_accounts     = fd_wksp_laddr_fast( ctx->wksp, mem->node_id_to_vote_accounts_gaddr );
  self->epoch_authorized_voters_len = mem->epoch_authorized_voters_len;
  self->epoch_authorized_voters     = fd_wksp_laddr_fast( ctx->wksp, mem->epoch_authorized_voters_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_epoch_stakes_new(fd_epoch_stakes_t * self) {
  fd_memset( self, 0, sizeof(fd_epoch_stakes_t) );
  fd_stakes_new( &self->stakes );
}
void fd_epoch_stakes_destroy( fd_epoch_stakes_t * self ) {
  fd_stakes_destroy( &self->stakes );
  if( self->node_id_to_vote_accounts ) {
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ )
      fd_pubkey_node_vote_accounts_pair_destroy( self->node_id_to_vote_accounts + i );
    self->node_id_to_vote_accounts = NULL;
  }
  if( self->epoch_authorized_voters ) {
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ )
      fd_pubkey_pubkey_pair_destroy( self->epoch_authorized_voters + i );
    self->epoch_authorized_voters = NULL;
  }
}

ulong fd_epoch_stakes_footprint( void ){ return FD_EPOCH_STAKES_FOOTPRINT; }
ulong fd_epoch_stakes_align( void ){ return FD_EPOCH_STAKES_ALIGN; }

void fd_epoch_stakes_walk( void * w, fd_epoch_stakes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_epoch_stakes", level++ );
  fd_stakes_walk( w, &self->stakes, fun, "stakes", level );
  fun( w, &self->total_stake, "total_stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->node_id_to_vote_accounts_len ) {
    fun( w, NULL, "node_id_to_vote_accounts", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ )
      fd_pubkey_node_vote_accounts_pair_walk(w, self->node_id_to_vote_accounts + i, fun, "pubkey_node_vote_accounts_pair", level );
    fun( w, NULL, "node_id_to_vote_accounts", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->epoch_authorized_voters_len ) {
    fun( w, NULL, "epoch_authorized_voters", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ )
      fd_pubkey_pubkey_pair_walk(w, self->epoch_authorized_voters + i, fun, "pubkey_pubkey_pair", level );
    fun( w, NULL, "epoch_authorized_voters", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_epoch_stakes", level-- );
}
ulong fd_epoch_stakes_size( fd_epoch_stakes_t const * self ) {
  ulong size = 0;
  size += fd_stakes_size( &self->stakes );
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ )
      size += fd_pubkey_node_vote_accounts_pair_size( self->node_id_to_vote_accounts + i );
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ )
      size += fd_pubkey_pubkey_pair_size( self->epoch_authorized_voters + i );
  } while(0);
  return size;
}

int fd_epoch_epoch_stakes_pair_encode( fd_epoch_epoch_stakes_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_stakes_encode( &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_epoch_epoch_stakes_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_epoch_epoch_stakes_pair_t);
  void const * start_data = ctx->data;
  int err = fd_epoch_epoch_stakes_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_epoch_epoch_stakes_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_epoch_stakes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_epoch_epoch_stakes_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_epoch_stakes_pair_t * self = (fd_epoch_epoch_stakes_pair_t *)mem;
  fd_epoch_epoch_stakes_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_epoch_stakes_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_epoch_stakes_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_epoch_stakes_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_epoch_stakes_pair_t * self = (fd_epoch_epoch_stakes_pair_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->key, ctx );
  fd_epoch_stakes_decode_inner( &self->value, alloc_mem, ctx );
}
void * fd_epoch_epoch_stakes_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_epoch_stakes_pair_global_t * self = (fd_epoch_epoch_stakes_pair_global_t *)mem;
  fd_epoch_epoch_stakes_pair_new( (fd_epoch_epoch_stakes_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_epoch_stakes_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_epoch_stakes_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_epoch_stakes_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_epoch_stakes_pair_global_t * self = (fd_epoch_epoch_stakes_pair_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->key, ctx );
  fd_epoch_stakes_decode_inner_global( &self->value, alloc_mem, ctx );
}
int fd_epoch_epoch_stakes_pair_convert_global_to_local( void const * global_self, fd_epoch_epoch_stakes_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_epoch_epoch_stakes_pair_global_t const * mem = (fd_epoch_epoch_stakes_pair_global_t const *)global_self;
  self->key = mem->key;
  err = fd_epoch_stakes_convert_global_to_local( &mem->value, &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_epoch_epoch_stakes_pair_new(fd_epoch_epoch_stakes_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_epoch_epoch_stakes_pair_t) );
  fd_epoch_stakes_new( &self->value );
}
void fd_epoch_epoch_stakes_pair_destroy( fd_epoch_epoch_stakes_pair_t * self ) {
  fd_epoch_stakes_destroy( &self->value );
}

ulong fd_epoch_epoch_stakes_pair_footprint( void ){ return FD_EPOCH_EPOCH_STAKES_PAIR_FOOTPRINT; }
ulong fd_epoch_epoch_stakes_pair_align( void ){ return FD_EPOCH_EPOCH_STAKES_PAIR_ALIGN; }

void fd_epoch_epoch_stakes_pair_walk( void * w, fd_epoch_epoch_stakes_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_epoch_epoch_stakes_pair", level++ );
  fun( w, &self->key, "key", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_epoch_stakes_walk( w, &self->value, fun, "value", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_epoch_epoch_stakes_pair", level-- );
}
ulong fd_epoch_epoch_stakes_pair_size( fd_epoch_epoch_stakes_pair_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_epoch_stakes_size( &self->value );
  return size;
}

int fd_pubkey_u64_pair_encode( fd_pubkey_u64_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->_0, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->_1, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_pubkey_u64_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_pubkey_u64_pair_t);
  void const * start_data = ctx->data;
  int err = fd_pubkey_u64_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_pubkey_u64_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_pubkey_u64_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_u64_pair_t * self = (fd_pubkey_u64_pair_t *)mem;
  fd_pubkey_u64_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_u64_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_u64_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_u64_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_u64_pair_t * self = (fd_pubkey_u64_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->_0, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->_1, ctx );
}
void * fd_pubkey_u64_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_u64_pair_global_t * self = (fd_pubkey_u64_pair_global_t *)mem;
  fd_pubkey_u64_pair_new( (fd_pubkey_u64_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_u64_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_u64_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_u64_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_u64_pair_global_t * self = (fd_pubkey_u64_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->_0, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->_1, ctx );
}
int fd_pubkey_u64_pair_convert_global_to_local( void const * global_self, fd_pubkey_u64_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_pubkey_u64_pair_global_t const * mem = (fd_pubkey_u64_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->_0, &self->_0, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->_1 = mem->_1;
  return FD_BINCODE_SUCCESS;
}
void fd_pubkey_u64_pair_new(fd_pubkey_u64_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_pubkey_u64_pair_t) );
  fd_pubkey_new( &self->_0 );
}
void fd_pubkey_u64_pair_destroy( fd_pubkey_u64_pair_t * self ) {
  fd_pubkey_destroy( &self->_0 );
}

ulong fd_pubkey_u64_pair_footprint( void ){ return FD_PUBKEY_U64_PAIR_FOOTPRINT; }
ulong fd_pubkey_u64_pair_align( void ){ return FD_PUBKEY_U64_PAIR_ALIGN; }

void fd_pubkey_u64_pair_walk( void * w, fd_pubkey_u64_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_pubkey_u64_pair", level++ );
  fd_pubkey_walk( w, &self->_0, fun, "_0", level );
  fun( w, &self->_1, "_1", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_pubkey_u64_pair", level-- );
}
ulong fd_pubkey_u64_pair_size( fd_pubkey_u64_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->_0 );
  size += sizeof(ulong);
  return size;
}

int fd_unused_accounts_encode( fd_unused_accounts_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->unused1_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->unused1_len ) {
    for( ulong i=0; i < self->unused1_len; i++ ) {
      err = fd_pubkey_encode( self->unused1 + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->unused2_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->unused2_len ) {
    for( ulong i=0; i < self->unused2_len; i++ ) {
      err = fd_pubkey_encode( self->unused2 + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->unused3_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->unused3_len ) {
    for( ulong i=0; i < self->unused3_len; i++ ) {
      err = fd_pubkey_u64_pair_encode( self->unused3 + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_unused_accounts_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_unused_accounts_t);
  void const * start_data = ctx->data;
  int err = fd_unused_accounts_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_unused_accounts_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong unused1_len;
  err = fd_bincode_uint64_decode( &unused1_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( unused1_len ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT*unused1_len;
    for( ulong i=0; i < unused1_len; i++ ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong unused2_len;
  err = fd_bincode_uint64_decode( &unused2_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( unused2_len ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT*unused2_len;
    for( ulong i=0; i < unused2_len; i++ ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong unused3_len;
  err = fd_bincode_uint64_decode( &unused3_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( unused3_len ) {
    *total_sz += FD_PUBKEY_U64_PAIR_ALIGN + FD_PUBKEY_U64_PAIR_FOOTPRINT*unused3_len;
    for( ulong i=0; i < unused3_len; i++ ) {
      err = fd_pubkey_u64_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_unused_accounts_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_unused_accounts_t * self = (fd_unused_accounts_t *)mem;
  fd_unused_accounts_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_unused_accounts_t);
  void * * alloc_mem = &alloc_region;
  fd_unused_accounts_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_unused_accounts_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_unused_accounts_t * self = (fd_unused_accounts_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->unused1_len, ctx );
  if( self->unused1_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->unused1 = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->unused1_len;
    for( ulong i=0; i < self->unused1_len; i++ ) {
      fd_pubkey_new( self->unused1 + i );
      fd_pubkey_decode_inner( self->unused1 + i, alloc_mem, ctx );
    }
  } else
    self->unused1 = NULL;
  fd_bincode_uint64_decode_unsafe( &self->unused2_len, ctx );
  if( self->unused2_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->unused2 = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->unused2_len;
    for( ulong i=0; i < self->unused2_len; i++ ) {
      fd_pubkey_new( self->unused2 + i );
      fd_pubkey_decode_inner( self->unused2 + i, alloc_mem, ctx );
    }
  } else
    self->unused2 = NULL;
  fd_bincode_uint64_decode_unsafe( &self->unused3_len, ctx );
  if( self->unused3_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_U64_PAIR_ALIGN );
    self->unused3 = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_U64_PAIR_FOOTPRINT*self->unused3_len;
    for( ulong i=0; i < self->unused3_len; i++ ) {
      fd_pubkey_u64_pair_new( self->unused3 + i );
      fd_pubkey_u64_pair_decode_inner( self->unused3 + i, alloc_mem, ctx );
    }
  } else
    self->unused3 = NULL;
}
void * fd_unused_accounts_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_unused_accounts_global_t * self = (fd_unused_accounts_global_t *)mem;
  fd_unused_accounts_new( (fd_unused_accounts_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_unused_accounts_global_t);
  void * * alloc_mem = &alloc_region;
  fd_unused_accounts_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_unused_accounts_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_unused_accounts_global_t * self = (fd_unused_accounts_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->unused1_len, ctx );
  if( self->unused1_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->unused1_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->unused1_len;
    for( ulong i=0; i < self->unused1_len; i++ ) {
      fd_pubkey_new( (fd_pubkey_t *)(cur_mem + FD_PUBKEY_FOOTPRINT * i) );
      fd_pubkey_decode_inner_global( cur_mem + FD_PUBKEY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->unused1_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->unused2_len, ctx );
  if( self->unused2_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->unused2_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->unused2_len;
    for( ulong i=0; i < self->unused2_len; i++ ) {
      fd_pubkey_new( (fd_pubkey_t *)(cur_mem + FD_PUBKEY_FOOTPRINT * i) );
      fd_pubkey_decode_inner_global( cur_mem + FD_PUBKEY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->unused2_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->unused3_len, ctx );
  if( self->unused3_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_U64_PAIR_ALIGN );
    self->unused3_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_U64_PAIR_FOOTPRINT*self->unused3_len;
    for( ulong i=0; i < self->unused3_len; i++ ) {
      fd_pubkey_u64_pair_new( (fd_pubkey_u64_pair_t *)(cur_mem + FD_PUBKEY_U64_PAIR_FOOTPRINT * i) );
      fd_pubkey_u64_pair_decode_inner_global( cur_mem + FD_PUBKEY_U64_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->unused3_gaddr = 0UL;
}
int fd_unused_accounts_convert_global_to_local( void const * global_self, fd_unused_accounts_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_unused_accounts_global_t const * mem = (fd_unused_accounts_global_t const *)global_self;
  self->unused1_len = mem->unused1_len;
  self->unused1     = fd_wksp_laddr_fast( ctx->wksp, mem->unused1_gaddr );
  self->unused2_len = mem->unused2_len;
  self->unused2     = fd_wksp_laddr_fast( ctx->wksp, mem->unused2_gaddr );
  self->unused3_len = mem->unused3_len;
  self->unused3     = fd_wksp_laddr_fast( ctx->wksp, mem->unused3_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_unused_accounts_new(fd_unused_accounts_t * self) {
  fd_memset( self, 0, sizeof(fd_unused_accounts_t) );
}
void fd_unused_accounts_destroy( fd_unused_accounts_t * self ) {
  if( self->unused1 ) {
    for( ulong i=0; i < self->unused1_len; i++ )
      fd_pubkey_destroy( self->unused1 + i );
    self->unused1 = NULL;
  }
  if( self->unused2 ) {
    for( ulong i=0; i < self->unused2_len; i++ )
      fd_pubkey_destroy( self->unused2 + i );
    self->unused2 = NULL;
  }
  if( self->unused3 ) {
    for( ulong i=0; i < self->unused3_len; i++ )
      fd_pubkey_u64_pair_destroy( self->unused3 + i );
    self->unused3 = NULL;
  }
}

ulong fd_unused_accounts_footprint( void ){ return FD_UNUSED_ACCOUNTS_FOOTPRINT; }
ulong fd_unused_accounts_align( void ){ return FD_UNUSED_ACCOUNTS_ALIGN; }

void fd_unused_accounts_walk( void * w, fd_unused_accounts_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_unused_accounts", level++ );
  if( self->unused1_len ) {
    fun( w, NULL, "unused1", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->unused1_len; i++ )
      fd_pubkey_walk(w, self->unused1 + i, fun, "pubkey", level );
    fun( w, NULL, "unused1", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->unused2_len ) {
    fun( w, NULL, "unused2", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->unused2_len; i++ )
      fd_pubkey_walk(w, self->unused2 + i, fun, "pubkey", level );
    fun( w, NULL, "unused2", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->unused3_len ) {
    fun( w, NULL, "unused3", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->unused3_len; i++ )
      fd_pubkey_u64_pair_walk(w, self->unused3 + i, fun, "pubkey_u64_pair", level );
    fun( w, NULL, "unused3", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_unused_accounts", level-- );
}
ulong fd_unused_accounts_size( fd_unused_accounts_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->unused1_len; i++ )
      size += fd_pubkey_size( self->unused1 + i );
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->unused2_len; i++ )
      size += fd_pubkey_size( self->unused2 + i );
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->unused3_len; i++ )
      size += fd_pubkey_u64_pair_size( self->unused3 + i );
  } while(0);
  return size;
}

int fd_versioned_bank_encode( fd_versioned_bank_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_block_hash_vec_encode( &self->blockhash_queue, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->ancestors_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->ancestors_len ) {
    for( ulong i=0; i < self->ancestors_len; i++ ) {
      err = fd_slot_pair_encode( self->ancestors + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->parent_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->parent_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hard_forks_encode( &self->hard_forks, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->transaction_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->tick_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->signature_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->capitalization, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->max_tick_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->hashes_per_tick != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_uint64_encode( self->hashes_per_tick[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->ticks_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint128_encode( self->ns_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->genesis_creation_time, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->slots_per_year, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->accounts_data_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->block_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->collector_id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collector_fees, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_encode( &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_encode( &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collected_rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_collector_encode( &self->rent_collector, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_encode( &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_encode( &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stakes_encode( &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_unused_accounts_encode( &self->unused_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch_stakes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->epoch_stakes_len ) {
    for( ulong i=0; i < self->epoch_stakes_len; i++ ) {
      err = fd_epoch_epoch_stakes_pair_encode( self->epoch_stakes + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_bool_encode( (uchar)(self->is_delta), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_versioned_bank_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_versioned_bank_t);
  void const * start_data = ctx->data;
  int err = fd_versioned_bank_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_versioned_bank_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_block_hash_vec_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong ancestors_len;
  err = fd_bincode_uint64_decode( &ancestors_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( ancestors_len ) {
    *total_sz += FD_SLOT_PAIR_ALIGN + FD_SLOT_PAIR_FOOTPRINT*ancestors_len;
    for( ulong i=0; i < ancestors_len; i++ ) {
      err = fd_slot_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hard_forks_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(ulong);
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint128_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_fee_calculator_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_rent_collector_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stakes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_unused_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong epoch_stakes_len;
  err = fd_bincode_uint64_decode( &epoch_stakes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( epoch_stakes_len ) {
    *total_sz += FD_EPOCH_EPOCH_STAKES_PAIR_ALIGN + FD_EPOCH_EPOCH_STAKES_PAIR_FOOTPRINT*epoch_stakes_len;
    for( ulong i=0; i < epoch_stakes_len; i++ ) {
      err = fd_epoch_epoch_stakes_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_versioned_bank_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_bank_t * self = (fd_versioned_bank_t *)mem;
  fd_versioned_bank_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_bank_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_bank_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_bank_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_bank_t * self = (fd_versioned_bank_t *)struct_mem;
  fd_block_hash_vec_decode_inner( &self->blockhash_queue, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ancestors_len, ctx );
  if( self->ancestors_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_PAIR_ALIGN );
    self->ancestors = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_PAIR_FOOTPRINT*self->ancestors_len;
    for( ulong i=0; i < self->ancestors_len; i++ ) {
      fd_slot_pair_new( self->ancestors + i );
      fd_slot_pair_decode_inner( self->ancestors + i, alloc_mem, ctx );
    }
  } else
    self->ancestors = NULL;
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
  fd_hash_decode_inner( &self->parent_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->parent_slot, ctx );
  fd_hard_forks_decode_inner( &self->hard_forks, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->tick_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->capitalization, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->hashes_per_tick = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
      fd_bincode_uint64_decode_unsafe( self->hashes_per_tick, ctx );
    } else {
      self->hashes_per_tick = NULL;
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint128_decode_unsafe( &self->ns_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->genesis_creation_time, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_bincode_uint64_decode_unsafe( &self->accounts_data_len, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_height, ctx );
  fd_pubkey_decode_inner( &self->collector_id, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collector_fees, ctx );
  fd_fee_calculator_decode_inner( &self->fee_calculator, alloc_mem, ctx );
  fd_fee_rate_governor_decode_inner( &self->fee_rate_governor, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_rent, ctx );
  fd_rent_collector_decode_inner( &self->rent_collector, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner( &self->epoch_schedule, alloc_mem, ctx );
  fd_inflation_decode_inner( &self->inflation, alloc_mem, ctx );
  fd_stakes_decode_inner( &self->stakes, alloc_mem, ctx );
  fd_unused_accounts_decode_inner( &self->unused_accounts, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_stakes_len, ctx );
  if( self->epoch_stakes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_EPOCH_EPOCH_STAKES_PAIR_ALIGN );
    self->epoch_stakes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_EPOCH_EPOCH_STAKES_PAIR_FOOTPRINT*self->epoch_stakes_len;
    for( ulong i=0; i < self->epoch_stakes_len; i++ ) {
      fd_epoch_epoch_stakes_pair_new( self->epoch_stakes + i );
      fd_epoch_epoch_stakes_pair_decode_inner( self->epoch_stakes + i, alloc_mem, ctx );
    }
  } else
    self->epoch_stakes = NULL;
  fd_bincode_bool_decode_unsafe( &self->is_delta, ctx );
}
void * fd_versioned_bank_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_bank_global_t * self = (fd_versioned_bank_global_t *)mem;
  fd_versioned_bank_new( (fd_versioned_bank_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_bank_global_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_bank_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_bank_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_bank_global_t * self = (fd_versioned_bank_global_t *)struct_mem;
  fd_block_hash_vec_decode_inner_global( &self->blockhash_queue, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ancestors_len, ctx );
  if( self->ancestors_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_PAIR_ALIGN );
    self->ancestors_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_PAIR_FOOTPRINT*self->ancestors_len;
    for( ulong i=0; i < self->ancestors_len; i++ ) {
      fd_slot_pair_new( (fd_slot_pair_t *)(cur_mem + FD_SLOT_PAIR_FOOTPRINT * i) );
      fd_slot_pair_decode_inner_global( cur_mem + FD_SLOT_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->ancestors_gaddr = 0UL;
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->parent_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->parent_slot, ctx );
  fd_hard_forks_decode_inner_global( &self->hard_forks, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->tick_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->capitalization, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->hashes_per_tick_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_uint64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
    } else {
      self->hashes_per_tick_gaddr = 0UL;
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint128_decode_unsafe( &self->ns_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->genesis_creation_time, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_bincode_uint64_decode_unsafe( &self->accounts_data_len, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_height, ctx );
  fd_pubkey_decode_inner_global( &self->collector_id, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collector_fees, ctx );
  fd_fee_calculator_decode_inner_global( &self->fee_calculator, alloc_mem, ctx );
  fd_fee_rate_governor_decode_inner_global( &self->fee_rate_governor, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_rent, ctx );
  fd_rent_collector_decode_inner_global( &self->rent_collector, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner_global( &self->epoch_schedule, alloc_mem, ctx );
  fd_inflation_decode_inner_global( &self->inflation, alloc_mem, ctx );
  fd_stakes_decode_inner_global( &self->stakes, alloc_mem, ctx );
  fd_unused_accounts_decode_inner_global( &self->unused_accounts, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_stakes_len, ctx );
  if( self->epoch_stakes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_EPOCH_EPOCH_STAKES_PAIR_ALIGN );
    self->epoch_stakes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_EPOCH_EPOCH_STAKES_PAIR_FOOTPRINT*self->epoch_stakes_len;
    for( ulong i=0; i < self->epoch_stakes_len; i++ ) {
      fd_epoch_epoch_stakes_pair_new( (fd_epoch_epoch_stakes_pair_t *)(cur_mem + FD_EPOCH_EPOCH_STAKES_PAIR_FOOTPRINT * i) );
      fd_epoch_epoch_stakes_pair_decode_inner_global( cur_mem + FD_EPOCH_EPOCH_STAKES_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->epoch_stakes_gaddr = 0UL;
  fd_bincode_bool_decode_unsafe( &self->is_delta, ctx );
}
int fd_versioned_bank_convert_global_to_local( void const * global_self, fd_versioned_bank_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_versioned_bank_global_t const * mem = (fd_versioned_bank_global_t const *)global_self;
  err = fd_block_hash_vec_convert_global_to_local( &mem->blockhash_queue, &self->blockhash_queue, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->ancestors_len = mem->ancestors_len;
  self->ancestors     = fd_wksp_laddr_fast( ctx->wksp, mem->ancestors_gaddr );
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->parent_hash, &self->parent_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->parent_slot = mem->parent_slot;
  err = fd_hard_forks_convert_global_to_local( &mem->hard_forks, &self->hard_forks, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->transaction_count = mem->transaction_count;
  self->tick_height = mem->tick_height;
  self->signature_count = mem->signature_count;
  self->capitalization = mem->capitalization;
  self->max_tick_height = mem->max_tick_height;
  self->hashes_per_tick = fd_wksp_laddr_fast( ctx->wksp, mem->hashes_per_tick_gaddr );
  self->ticks_per_slot = mem->ticks_per_slot;
  self->ns_per_slot = mem->ns_per_slot;
  self->genesis_creation_time = mem->genesis_creation_time;
  self->slots_per_year = mem->slots_per_year;
  self->accounts_data_len = mem->accounts_data_len;
  self->slot = mem->slot;
  self->epoch = mem->epoch;
  self->block_height = mem->block_height;
  err = fd_pubkey_convert_global_to_local( &mem->collector_id, &self->collector_id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->collector_fees = mem->collector_fees;
  err = fd_fee_calculator_convert_global_to_local( &mem->fee_calculator, &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_convert_global_to_local( &mem->fee_rate_governor, &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->collected_rent = mem->collected_rent;
  err = fd_rent_collector_convert_global_to_local( &mem->rent_collector, &self->rent_collector, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_convert_global_to_local( &mem->epoch_schedule, &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_convert_global_to_local( &mem->inflation, &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stakes_convert_global_to_local( &mem->stakes, &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_unused_accounts_convert_global_to_local( &mem->unused_accounts, &self->unused_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->epoch_stakes_len = mem->epoch_stakes_len;
  self->epoch_stakes     = fd_wksp_laddr_fast( ctx->wksp, mem->epoch_stakes_gaddr );
  self->is_delta = mem->is_delta;
  return FD_BINCODE_SUCCESS;
}
void fd_versioned_bank_new(fd_versioned_bank_t * self) {
  fd_memset( self, 0, sizeof(fd_versioned_bank_t) );
  fd_block_hash_vec_new( &self->blockhash_queue );
  fd_hash_new( &self->hash );
  fd_hash_new( &self->parent_hash );
  fd_hard_forks_new( &self->hard_forks );
  fd_pubkey_new( &self->collector_id );
  fd_fee_calculator_new( &self->fee_calculator );
  fd_fee_rate_governor_new( &self->fee_rate_governor );
  fd_rent_collector_new( &self->rent_collector );
  fd_epoch_schedule_new( &self->epoch_schedule );
  fd_inflation_new( &self->inflation );
  fd_stakes_new( &self->stakes );
  fd_unused_accounts_new( &self->unused_accounts );
}
void fd_versioned_bank_destroy( fd_versioned_bank_t * self ) {
  fd_block_hash_vec_destroy( &self->blockhash_queue );
  if( self->ancestors ) {
    for( ulong i=0; i < self->ancestors_len; i++ )
      fd_slot_pair_destroy( self->ancestors + i );
    self->ancestors = NULL;
  }
  fd_hash_destroy( &self->hash );
  fd_hash_destroy( &self->parent_hash );
  fd_hard_forks_destroy( &self->hard_forks );
  if( self->hashes_per_tick ) {
    self->hashes_per_tick = NULL;
  }
  fd_pubkey_destroy( &self->collector_id );
  fd_fee_calculator_destroy( &self->fee_calculator );
  fd_fee_rate_governor_destroy( &self->fee_rate_governor );
  fd_rent_collector_destroy( &self->rent_collector );
  fd_epoch_schedule_destroy( &self->epoch_schedule );
  fd_inflation_destroy( &self->inflation );
  fd_stakes_destroy( &self->stakes );
  fd_unused_accounts_destroy( &self->unused_accounts );
  if( self->epoch_stakes ) {
    for( ulong i=0; i < self->epoch_stakes_len; i++ )
      fd_epoch_epoch_stakes_pair_destroy( self->epoch_stakes + i );
    self->epoch_stakes = NULL;
  }
}

ulong fd_versioned_bank_footprint( void ){ return FD_VERSIONED_BANK_FOOTPRINT; }
ulong fd_versioned_bank_align( void ){ return FD_VERSIONED_BANK_ALIGN; }

void fd_versioned_bank_walk( void * w, fd_versioned_bank_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_versioned_bank", level++ );
  fd_block_hash_vec_walk( w, &self->blockhash_queue, fun, "blockhash_queue", level );
  if( self->ancestors_len ) {
    fun( w, NULL, "ancestors", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->ancestors_len; i++ )
      fd_slot_pair_walk(w, self->ancestors + i, fun, "slot_pair", level );
    fun( w, NULL, "ancestors", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fd_hash_walk( w, &self->parent_hash, fun, "parent_hash", level );
  fun( w, &self->parent_slot, "parent_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hard_forks_walk( w, &self->hard_forks, fun, "hard_forks", level );
  fun( w, &self->transaction_count, "transaction_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->tick_height, "tick_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->signature_count, "signature_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->capitalization, "capitalization", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->max_tick_height, "max_tick_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->hashes_per_tick ) {
    fun( w, NULL, "hashes_per_tick", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, self->hashes_per_tick, "hashes_per_tick", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fun( w, &self->ticks_per_slot, "ticks_per_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->ns_per_slot, "ns_per_slot", FD_FLAMENCO_TYPE_UINT128, "uint128", level );
  fun( w, &self->genesis_creation_time, "genesis_creation_time", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slots_per_year, "slots_per_year", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->accounts_data_len, "accounts_data_len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->block_height, "block_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->collector_id, fun, "collector_id", level );
  fun( w, &self->collector_fees, "collector_fees", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_fee_calculator_walk( w, &self->fee_calculator, fun, "fee_calculator", level );
  fd_fee_rate_governor_walk( w, &self->fee_rate_governor, fun, "fee_rate_governor", level );
  fun( w, &self->collected_rent, "collected_rent", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_rent_collector_walk( w, &self->rent_collector, fun, "rent_collector", level );
  fd_epoch_schedule_walk( w, &self->epoch_schedule, fun, "epoch_schedule", level );
  fd_inflation_walk( w, &self->inflation, fun, "inflation", level );
  fd_stakes_walk( w, &self->stakes, fun, "stakes", level );
  fd_unused_accounts_walk( w, &self->unused_accounts, fun, "unused_accounts", level );
  if( self->epoch_stakes_len ) {
    fun( w, NULL, "epoch_stakes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->epoch_stakes_len; i++ )
      fd_epoch_epoch_stakes_pair_walk(w, self->epoch_stakes + i, fun, "epoch_epoch_stakes_pair", level );
    fun( w, NULL, "epoch_stakes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->is_delta, "is_delta", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_versioned_bank", level-- );
}
ulong fd_versioned_bank_size( fd_versioned_bank_t const * self ) {
  ulong size = 0;
  size += fd_block_hash_vec_size( &self->blockhash_queue );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->ancestors_len; i++ )
      size += fd_slot_pair_size( self->ancestors + i );
  } while(0);
  size += fd_hash_size( &self->hash );
  size += fd_hash_size( &self->parent_hash );
  size += sizeof(ulong);
  size += fd_hard_forks_size( &self->hard_forks );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(char);
  if( NULL !=  self->hashes_per_tick ) {
    size += sizeof(ulong);
  }
  size += sizeof(ulong);
  size += sizeof(uint128);
  size += sizeof(ulong);
  size += sizeof(double);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->collector_id );
  size += sizeof(ulong);
  size += fd_fee_calculator_size( &self->fee_calculator );
  size += fd_fee_rate_governor_size( &self->fee_rate_governor );
  size += sizeof(ulong);
  size += fd_rent_collector_size( &self->rent_collector );
  size += fd_epoch_schedule_size( &self->epoch_schedule );
  size += fd_inflation_size( &self->inflation );
  size += fd_stakes_size( &self->stakes );
  size += fd_unused_accounts_size( &self->unused_accounts );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->epoch_stakes_len; i++ )
      size += fd_epoch_epoch_stakes_pair_size( self->epoch_stakes + i );
  } while(0);
  size += sizeof(char);
  return size;
}

int fd_bank_hash_stats_encode( fd_bank_hash_stats_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->num_updated_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num_removed_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num_lamports_stored, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->total_data_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num_executable_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_bank_hash_stats_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bank_hash_stats_t);
  void const * start_data = ctx->data;
  int err = fd_bank_hash_stats_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bank_hash_stats_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_bank_hash_stats_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_stats_t * self = (fd_bank_hash_stats_t *)mem;
  fd_bank_hash_stats_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_hash_stats_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_hash_stats_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_hash_stats_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_stats_t * self = (fd_bank_hash_stats_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->num_updated_accounts, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_removed_accounts, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_lamports_stored, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_data_len, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_executable_accounts, ctx );
}
void * fd_bank_hash_stats_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_stats_global_t * self = (fd_bank_hash_stats_global_t *)mem;
  fd_bank_hash_stats_new( (fd_bank_hash_stats_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_hash_stats_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_hash_stats_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_hash_stats_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_stats_global_t * self = (fd_bank_hash_stats_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->num_updated_accounts, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_removed_accounts, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_lamports_stored, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_data_len, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_executable_accounts, ctx );
}
int fd_bank_hash_stats_convert_global_to_local( void const * global_self, fd_bank_hash_stats_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bank_hash_stats_global_t const * mem = (fd_bank_hash_stats_global_t const *)global_self;
  self->num_updated_accounts = mem->num_updated_accounts;
  self->num_removed_accounts = mem->num_removed_accounts;
  self->num_lamports_stored = mem->num_lamports_stored;
  self->total_data_len = mem->total_data_len;
  self->num_executable_accounts = mem->num_executable_accounts;
  return FD_BINCODE_SUCCESS;
}
void fd_bank_hash_stats_new(fd_bank_hash_stats_t * self) {
  fd_memset( self, 0, sizeof(fd_bank_hash_stats_t) );
}
void fd_bank_hash_stats_destroy( fd_bank_hash_stats_t * self ) {
}

ulong fd_bank_hash_stats_footprint( void ){ return FD_BANK_HASH_STATS_FOOTPRINT; }
ulong fd_bank_hash_stats_align( void ){ return FD_BANK_HASH_STATS_ALIGN; }

void fd_bank_hash_stats_walk( void * w, fd_bank_hash_stats_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bank_hash_stats", level++ );
  fun( w, &self->num_updated_accounts, "num_updated_accounts", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->num_removed_accounts, "num_removed_accounts", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->num_lamports_stored, "num_lamports_stored", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->total_data_len, "total_data_len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->num_executable_accounts, "num_executable_accounts", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bank_hash_stats", level-- );
}
ulong fd_bank_hash_stats_size( fd_bank_hash_stats_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_bank_hash_info_encode( fd_bank_hash_info_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_hash_encode( &self->accounts_delta_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->accounts_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bank_hash_stats_encode( &self->stats, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_bank_hash_info_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bank_hash_info_t);
  void const * start_data = ctx->data;
  int err = fd_bank_hash_info_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bank_hash_info_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bank_hash_stats_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_bank_hash_info_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_info_t * self = (fd_bank_hash_info_t *)mem;
  fd_bank_hash_info_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_hash_info_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_hash_info_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_hash_info_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_info_t * self = (fd_bank_hash_info_t *)struct_mem;
  fd_hash_decode_inner( &self->accounts_delta_hash, alloc_mem, ctx );
  fd_hash_decode_inner( &self->accounts_hash, alloc_mem, ctx );
  fd_bank_hash_stats_decode_inner( &self->stats, alloc_mem, ctx );
}
void * fd_bank_hash_info_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_info_global_t * self = (fd_bank_hash_info_global_t *)mem;
  fd_bank_hash_info_new( (fd_bank_hash_info_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_hash_info_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_hash_info_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_hash_info_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_hash_info_global_t * self = (fd_bank_hash_info_global_t *)struct_mem;
  fd_hash_decode_inner_global( &self->accounts_delta_hash, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->accounts_hash, alloc_mem, ctx );
  fd_bank_hash_stats_decode_inner_global( &self->stats, alloc_mem, ctx );
}
int fd_bank_hash_info_convert_global_to_local( void const * global_self, fd_bank_hash_info_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bank_hash_info_global_t const * mem = (fd_bank_hash_info_global_t const *)global_self;
  err = fd_hash_convert_global_to_local( &mem->accounts_delta_hash, &self->accounts_delta_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->accounts_hash, &self->accounts_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bank_hash_stats_convert_global_to_local( &mem->stats, &self->stats, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_bank_hash_info_new(fd_bank_hash_info_t * self) {
  fd_memset( self, 0, sizeof(fd_bank_hash_info_t) );
  fd_hash_new( &self->accounts_delta_hash );
  fd_hash_new( &self->accounts_hash );
  fd_bank_hash_stats_new( &self->stats );
}
void fd_bank_hash_info_destroy( fd_bank_hash_info_t * self ) {
  fd_hash_destroy( &self->accounts_delta_hash );
  fd_hash_destroy( &self->accounts_hash );
  fd_bank_hash_stats_destroy( &self->stats );
}

ulong fd_bank_hash_info_footprint( void ){ return FD_BANK_HASH_INFO_FOOTPRINT; }
ulong fd_bank_hash_info_align( void ){ return FD_BANK_HASH_INFO_ALIGN; }

void fd_bank_hash_info_walk( void * w, fd_bank_hash_info_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bank_hash_info", level++ );
  fd_hash_walk( w, &self->accounts_delta_hash, fun, "accounts_delta_hash", level );
  fd_hash_walk( w, &self->accounts_hash, fun, "accounts_hash", level );
  fd_bank_hash_stats_walk( w, &self->stats, fun, "stats", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bank_hash_info", level-- );
}
ulong fd_bank_hash_info_size( fd_bank_hash_info_t const * self ) {
  ulong size = 0;
  size += fd_hash_size( &self->accounts_delta_hash );
  size += fd_hash_size( &self->accounts_hash );
  size += fd_bank_hash_stats_size( &self->stats );
  return size;
}

int fd_slot_map_pair_encode( fd_slot_map_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_map_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_map_pair_t);
  void const * start_data = ctx->data;
  int err = fd_slot_map_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_map_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_slot_map_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_map_pair_t * self = (fd_slot_map_pair_t *)mem;
  fd_slot_map_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_map_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_map_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_map_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_map_pair_t * self = (fd_slot_map_pair_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
}
void * fd_slot_map_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_map_pair_global_t * self = (fd_slot_map_pair_global_t *)mem;
  fd_slot_map_pair_new( (fd_slot_map_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_map_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_map_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_map_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_map_pair_global_t * self = (fd_slot_map_pair_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
}
int fd_slot_map_pair_convert_global_to_local( void const * global_self, fd_slot_map_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_map_pair_global_t const * mem = (fd_slot_map_pair_global_t const *)global_self;
  self->slot = mem->slot;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_slot_map_pair_new(fd_slot_map_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_map_pair_t) );
  fd_hash_new( &self->hash );
}
void fd_slot_map_pair_destroy( fd_slot_map_pair_t * self ) {
  fd_hash_destroy( &self->hash );
}

ulong fd_slot_map_pair_footprint( void ){ return FD_SLOT_MAP_PAIR_FOOTPRINT; }
ulong fd_slot_map_pair_align( void ){ return FD_SLOT_MAP_PAIR_ALIGN; }

void fd_slot_map_pair_walk( void * w, fd_slot_map_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_map_pair", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_map_pair", level-- );
}
ulong fd_slot_map_pair_size( fd_slot_map_pair_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_hash_size( &self->hash );
  return size;
}

int fd_snapshot_acc_vec_encode( fd_snapshot_acc_vec_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->file_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_snapshot_acc_vec_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_snapshot_acc_vec_t);
  void const * start_data = ctx->data;
  int err = fd_snapshot_acc_vec_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_snapshot_acc_vec_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_snapshot_acc_vec_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_acc_vec_t * self = (fd_snapshot_acc_vec_t *)mem;
  fd_snapshot_acc_vec_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_snapshot_acc_vec_t);
  void * * alloc_mem = &alloc_region;
  fd_snapshot_acc_vec_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_snapshot_acc_vec_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_acc_vec_t * self = (fd_snapshot_acc_vec_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->id, ctx );
  fd_bincode_uint64_decode_unsafe( &self->file_sz, ctx );
}
void * fd_snapshot_acc_vec_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_acc_vec_global_t * self = (fd_snapshot_acc_vec_global_t *)mem;
  fd_snapshot_acc_vec_new( (fd_snapshot_acc_vec_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_snapshot_acc_vec_global_t);
  void * * alloc_mem = &alloc_region;
  fd_snapshot_acc_vec_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_snapshot_acc_vec_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_acc_vec_global_t * self = (fd_snapshot_acc_vec_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->id, ctx );
  fd_bincode_uint64_decode_unsafe( &self->file_sz, ctx );
}
int fd_snapshot_acc_vec_convert_global_to_local( void const * global_self, fd_snapshot_acc_vec_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_snapshot_acc_vec_global_t const * mem = (fd_snapshot_acc_vec_global_t const *)global_self;
  self->id = mem->id;
  self->file_sz = mem->file_sz;
  return FD_BINCODE_SUCCESS;
}
void fd_snapshot_acc_vec_new(fd_snapshot_acc_vec_t * self) {
  fd_memset( self, 0, sizeof(fd_snapshot_acc_vec_t) );
}
void fd_snapshot_acc_vec_destroy( fd_snapshot_acc_vec_t * self ) {
}

ulong fd_snapshot_acc_vec_footprint( void ){ return FD_SNAPSHOT_ACC_VEC_FOOTPRINT; }
ulong fd_snapshot_acc_vec_align( void ){ return FD_SNAPSHOT_ACC_VEC_ALIGN; }

void fd_snapshot_acc_vec_walk( void * w, fd_snapshot_acc_vec_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_snapshot_acc_vec", level++ );
  fun( w, &self->id, "id", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->file_sz, "file_sz", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_snapshot_acc_vec", level-- );
}
ulong fd_snapshot_acc_vec_size( fd_snapshot_acc_vec_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_snapshot_slot_acc_vecs_encode( fd_snapshot_slot_acc_vecs_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->account_vecs_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->account_vecs_len ) {
    for( ulong i=0; i < self->account_vecs_len; i++ ) {
      err = fd_snapshot_acc_vec_encode( self->account_vecs + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_snapshot_slot_acc_vecs_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_snapshot_slot_acc_vecs_t);
  void const * start_data = ctx->data;
  int err = fd_snapshot_slot_acc_vecs_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_snapshot_slot_acc_vecs_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong account_vecs_len;
  err = fd_bincode_uint64_decode( &account_vecs_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( account_vecs_len ) {
    *total_sz += FD_SNAPSHOT_ACC_VEC_ALIGN + FD_SNAPSHOT_ACC_VEC_FOOTPRINT*account_vecs_len;
    for( ulong i=0; i < account_vecs_len; i++ ) {
      err = fd_snapshot_acc_vec_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_snapshot_slot_acc_vecs_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_slot_acc_vecs_t * self = (fd_snapshot_slot_acc_vecs_t *)mem;
  fd_snapshot_slot_acc_vecs_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_snapshot_slot_acc_vecs_t);
  void * * alloc_mem = &alloc_region;
  fd_snapshot_slot_acc_vecs_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_snapshot_slot_acc_vecs_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_slot_acc_vecs_t * self = (fd_snapshot_slot_acc_vecs_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->account_vecs_len, ctx );
  if( self->account_vecs_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SNAPSHOT_ACC_VEC_ALIGN );
    self->account_vecs = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SNAPSHOT_ACC_VEC_FOOTPRINT*self->account_vecs_len;
    for( ulong i=0; i < self->account_vecs_len; i++ ) {
      fd_snapshot_acc_vec_new( self->account_vecs + i );
      fd_snapshot_acc_vec_decode_inner( self->account_vecs + i, alloc_mem, ctx );
    }
  } else
    self->account_vecs = NULL;
}
void * fd_snapshot_slot_acc_vecs_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_slot_acc_vecs_global_t * self = (fd_snapshot_slot_acc_vecs_global_t *)mem;
  fd_snapshot_slot_acc_vecs_new( (fd_snapshot_slot_acc_vecs_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_snapshot_slot_acc_vecs_global_t);
  void * * alloc_mem = &alloc_region;
  fd_snapshot_slot_acc_vecs_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_snapshot_slot_acc_vecs_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_snapshot_slot_acc_vecs_global_t * self = (fd_snapshot_slot_acc_vecs_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->account_vecs_len, ctx );
  if( self->account_vecs_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SNAPSHOT_ACC_VEC_ALIGN );
    self->account_vecs_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SNAPSHOT_ACC_VEC_FOOTPRINT*self->account_vecs_len;
    for( ulong i=0; i < self->account_vecs_len; i++ ) {
      fd_snapshot_acc_vec_new( (fd_snapshot_acc_vec_t *)(cur_mem + FD_SNAPSHOT_ACC_VEC_FOOTPRINT * i) );
      fd_snapshot_acc_vec_decode_inner_global( cur_mem + FD_SNAPSHOT_ACC_VEC_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->account_vecs_gaddr = 0UL;
}
int fd_snapshot_slot_acc_vecs_convert_global_to_local( void const * global_self, fd_snapshot_slot_acc_vecs_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_snapshot_slot_acc_vecs_global_t const * mem = (fd_snapshot_slot_acc_vecs_global_t const *)global_self;
  self->slot = mem->slot;
  self->account_vecs_len = mem->account_vecs_len;
  self->account_vecs     = fd_wksp_laddr_fast( ctx->wksp, mem->account_vecs_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_snapshot_slot_acc_vecs_new(fd_snapshot_slot_acc_vecs_t * self) {
  fd_memset( self, 0, sizeof(fd_snapshot_slot_acc_vecs_t) );
}
void fd_snapshot_slot_acc_vecs_destroy( fd_snapshot_slot_acc_vecs_t * self ) {
  if( self->account_vecs ) {
    for( ulong i=0; i < self->account_vecs_len; i++ )
      fd_snapshot_acc_vec_destroy( self->account_vecs + i );
    self->account_vecs = NULL;
  }
}

ulong fd_snapshot_slot_acc_vecs_footprint( void ){ return FD_SNAPSHOT_SLOT_ACC_VECS_FOOTPRINT; }
ulong fd_snapshot_slot_acc_vecs_align( void ){ return FD_SNAPSHOT_SLOT_ACC_VECS_ALIGN; }

void fd_snapshot_slot_acc_vecs_walk( void * w, fd_snapshot_slot_acc_vecs_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_snapshot_slot_acc_vecs", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->account_vecs_len ) {
    fun( w, NULL, "account_vecs", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->account_vecs_len; i++ )
      fd_snapshot_acc_vec_walk(w, self->account_vecs + i, fun, "snapshot_acc_vec", level );
    fun( w, NULL, "account_vecs", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_snapshot_slot_acc_vecs", level-- );
}
ulong fd_snapshot_slot_acc_vecs_size( fd_snapshot_slot_acc_vecs_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->account_vecs_len; i++ )
      size += fd_snapshot_acc_vec_size( self->account_vecs + i );
  } while(0);
  return size;
}

FD_FN_PURE uchar fd_reward_type_is_fee(fd_reward_type_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_reward_type_is_rent(fd_reward_type_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_reward_type_is_staking(fd_reward_type_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_reward_type_is_voting(fd_reward_type_t const * self) {
  return self->discriminant == 3;
}
void fd_reward_type_inner_new( fd_reward_type_inner_t * self, uint discriminant );
int fd_reward_type_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_reward_type_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_reward_type_t);
  void const * start_data = ctx->data;
  int err =  fd_reward_type_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_reward_type_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_reward_type_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_reward_type_inner_decode_inner( fd_reward_type_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  }
}
void fd_reward_type_inner_decode_inner_global( fd_reward_type_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  }
}
int fd_reward_type_convert_global_to_local_inner( fd_reward_type_inner_global_t const * mem, fd_reward_type_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_reward_type_convert_global_to_local( void const * global_self, fd_reward_type_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_type_global_t const * mem = (fd_reward_type_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_reward_type_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_reward_type_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_type_t * self = (fd_reward_type_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_reward_type_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_reward_type_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_type_t * self = (fd_reward_type_t *)mem;
  fd_reward_type_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_reward_type_t);
  void * * alloc_mem = &alloc_region;
  fd_reward_type_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_reward_type_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_type_t * self = (fd_reward_type_t *)mem;
  fd_reward_type_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_reward_type_t);
  void * * alloc_mem = &alloc_region;
  fd_reward_type_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_reward_type_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_type_global_t * self = (fd_reward_type_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_reward_type_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_reward_type_inner_new( fd_reward_type_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_reward_type_new_disc( fd_reward_type_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_reward_type_inner_new( &self->inner, self->discriminant );
}
void fd_reward_type_new( fd_reward_type_t * self ) {
  fd_memset( self, 0, sizeof(fd_reward_type_t) );
  fd_reward_type_new_disc( self, UINT_MAX );
}
void fd_reward_type_inner_destroy( fd_reward_type_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_reward_type_destroy( fd_reward_type_t * self ) {
  fd_reward_type_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_reward_type_footprint( void ){ return FD_REWARD_TYPE_FOOTPRINT; }
ulong fd_reward_type_align( void ){ return FD_REWARD_TYPE_ALIGN; }

void fd_reward_type_walk( void * w, fd_reward_type_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_reward_type", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "fee", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "rent", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "staking", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "voting", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_reward_type", level-- );
}
ulong fd_reward_type_size( fd_reward_type_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  }
  return size;
}

int fd_reward_type_inner_encode( fd_reward_type_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  return FD_BINCODE_SUCCESS;
}
int fd_reward_type_encode( fd_reward_type_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_reward_type_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_solana_accounts_db_fields_encode( fd_solana_accounts_db_fields_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->storages_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->storages_len ) {
    for( ulong i=0; i < self->storages_len; i++ ) {
      err = fd_snapshot_slot_acc_vecs_encode( self->storages + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bank_hash_info_encode( &self->bank_hash_info, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->historical_roots_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->historical_roots_len ) {
    for( ulong i=0; i < self->historical_roots_len; i++ ) {
      err = fd_bincode_uint64_encode( self->historical_roots[i], ctx );
    }
  }
  err = fd_bincode_uint64_encode( self->historical_roots_with_hash_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->historical_roots_with_hash_len ) {
    for( ulong i=0; i < self->historical_roots_with_hash_len; i++ ) {
      err = fd_slot_map_pair_encode( self->historical_roots_with_hash + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_solana_accounts_db_fields_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_solana_accounts_db_fields_t);
  void const * start_data = ctx->data;
  int err = fd_solana_accounts_db_fields_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_solana_accounts_db_fields_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong storages_len;
  err = fd_bincode_uint64_decode( &storages_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( storages_len ) {
    *total_sz += FD_SNAPSHOT_SLOT_ACC_VECS_ALIGN + FD_SNAPSHOT_SLOT_ACC_VECS_FOOTPRINT*storages_len;
    for( ulong i=0; i < storages_len; i++ ) {
      err = fd_snapshot_slot_acc_vecs_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bank_hash_info_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong historical_roots_len;
  err = fd_bincode_uint64_decode( &historical_roots_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( historical_roots_len ) {
    *total_sz += 8UL + sizeof(ulong)*historical_roots_len;
    for( ulong i=0; i < historical_roots_len; i++ ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong historical_roots_with_hash_len;
  err = fd_bincode_uint64_decode( &historical_roots_with_hash_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( historical_roots_with_hash_len ) {
    *total_sz += FD_SLOT_MAP_PAIR_ALIGN + FD_SLOT_MAP_PAIR_FOOTPRINT*historical_roots_with_hash_len;
    for( ulong i=0; i < historical_roots_with_hash_len; i++ ) {
      err = fd_slot_map_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_solana_accounts_db_fields_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_accounts_db_fields_t * self = (fd_solana_accounts_db_fields_t *)mem;
  fd_solana_accounts_db_fields_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_solana_accounts_db_fields_t);
  void * * alloc_mem = &alloc_region;
  fd_solana_accounts_db_fields_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_solana_accounts_db_fields_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_accounts_db_fields_t * self = (fd_solana_accounts_db_fields_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->storages_len, ctx );
  if( self->storages_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SNAPSHOT_SLOT_ACC_VECS_ALIGN );
    self->storages = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SNAPSHOT_SLOT_ACC_VECS_FOOTPRINT*self->storages_len;
    for( ulong i=0; i < self->storages_len; i++ ) {
      fd_snapshot_slot_acc_vecs_new( self->storages + i );
      fd_snapshot_slot_acc_vecs_decode_inner( self->storages + i, alloc_mem, ctx );
    }
  } else
    self->storages = NULL;
  fd_bincode_uint64_decode_unsafe( &self->version, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bank_hash_info_decode_inner( &self->bank_hash_info, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->historical_roots_len, ctx );
  if( self->historical_roots_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->historical_roots = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->historical_roots_len;
    for( ulong i=0; i < self->historical_roots_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( self->historical_roots + i, ctx );
    }
  } else
    self->historical_roots = NULL;
  fd_bincode_uint64_decode_unsafe( &self->historical_roots_with_hash_len, ctx );
  if( self->historical_roots_with_hash_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_MAP_PAIR_ALIGN );
    self->historical_roots_with_hash = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_MAP_PAIR_FOOTPRINT*self->historical_roots_with_hash_len;
    for( ulong i=0; i < self->historical_roots_with_hash_len; i++ ) {
      fd_slot_map_pair_new( self->historical_roots_with_hash + i );
      fd_slot_map_pair_decode_inner( self->historical_roots_with_hash + i, alloc_mem, ctx );
    }
  } else
    self->historical_roots_with_hash = NULL;
}
void * fd_solana_accounts_db_fields_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_accounts_db_fields_global_t * self = (fd_solana_accounts_db_fields_global_t *)mem;
  fd_solana_accounts_db_fields_new( (fd_solana_accounts_db_fields_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_solana_accounts_db_fields_global_t);
  void * * alloc_mem = &alloc_region;
  fd_solana_accounts_db_fields_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_solana_accounts_db_fields_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_accounts_db_fields_global_t * self = (fd_solana_accounts_db_fields_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->storages_len, ctx );
  if( self->storages_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SNAPSHOT_SLOT_ACC_VECS_ALIGN );
    self->storages_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SNAPSHOT_SLOT_ACC_VECS_FOOTPRINT*self->storages_len;
    for( ulong i=0; i < self->storages_len; i++ ) {
      fd_snapshot_slot_acc_vecs_new( (fd_snapshot_slot_acc_vecs_t *)(cur_mem + FD_SNAPSHOT_SLOT_ACC_VECS_FOOTPRINT * i) );
      fd_snapshot_slot_acc_vecs_decode_inner_global( cur_mem + FD_SNAPSHOT_SLOT_ACC_VECS_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->storages_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->version, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bank_hash_info_decode_inner_global( &self->bank_hash_info, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->historical_roots_len, ctx );
  if( self->historical_roots_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->historical_roots_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->historical_roots_len;
    for( ulong i=0; i < self->historical_roots_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( (ulong*)(cur_mem + sizeof(ulong) * i), ctx );
    }
  } else
    self->historical_roots_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->historical_roots_with_hash_len, ctx );
  if( self->historical_roots_with_hash_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_MAP_PAIR_ALIGN );
    self->historical_roots_with_hash_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_MAP_PAIR_FOOTPRINT*self->historical_roots_with_hash_len;
    for( ulong i=0; i < self->historical_roots_with_hash_len; i++ ) {
      fd_slot_map_pair_new( (fd_slot_map_pair_t *)(cur_mem + FD_SLOT_MAP_PAIR_FOOTPRINT * i) );
      fd_slot_map_pair_decode_inner_global( cur_mem + FD_SLOT_MAP_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->historical_roots_with_hash_gaddr = 0UL;
}
int fd_solana_accounts_db_fields_convert_global_to_local( void const * global_self, fd_solana_accounts_db_fields_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_solana_accounts_db_fields_global_t const * mem = (fd_solana_accounts_db_fields_global_t const *)global_self;
  self->storages_len = mem->storages_len;
  self->storages     = fd_wksp_laddr_fast( ctx->wksp, mem->storages_gaddr );
  self->version = mem->version;
  self->slot = mem->slot;
  err = fd_bank_hash_info_convert_global_to_local( &mem->bank_hash_info, &self->bank_hash_info, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->historical_roots_len = mem->historical_roots_len;
  self->historical_roots     = fd_wksp_laddr_fast( ctx->wksp, mem->historical_roots_gaddr );
  self->historical_roots_with_hash_len = mem->historical_roots_with_hash_len;
  self->historical_roots_with_hash     = fd_wksp_laddr_fast( ctx->wksp, mem->historical_roots_with_hash_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_solana_accounts_db_fields_new(fd_solana_accounts_db_fields_t * self) {
  fd_memset( self, 0, sizeof(fd_solana_accounts_db_fields_t) );
  fd_bank_hash_info_new( &self->bank_hash_info );
}
void fd_solana_accounts_db_fields_destroy( fd_solana_accounts_db_fields_t * self ) {
  if( self->storages ) {
    for( ulong i=0; i < self->storages_len; i++ )
      fd_snapshot_slot_acc_vecs_destroy( self->storages + i );
    self->storages = NULL;
  }
  fd_bank_hash_info_destroy( &self->bank_hash_info );
  if( self->historical_roots ) {
    self->historical_roots = NULL;
  }
  if( self->historical_roots_with_hash ) {
    for( ulong i=0; i < self->historical_roots_with_hash_len; i++ )
      fd_slot_map_pair_destroy( self->historical_roots_with_hash + i );
    self->historical_roots_with_hash = NULL;
  }
}

ulong fd_solana_accounts_db_fields_footprint( void ){ return FD_SOLANA_ACCOUNTS_DB_FIELDS_FOOTPRINT; }
ulong fd_solana_accounts_db_fields_align( void ){ return FD_SOLANA_ACCOUNTS_DB_FIELDS_ALIGN; }

void fd_solana_accounts_db_fields_walk( void * w, fd_solana_accounts_db_fields_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_solana_accounts_db_fields", level++ );
  if( self->storages_len ) {
    fun( w, NULL, "storages", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->storages_len; i++ )
      fd_snapshot_slot_acc_vecs_walk(w, self->storages + i, fun, "snapshot_slot_acc_vecs", level );
    fun( w, NULL, "storages", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->version, "version", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_bank_hash_info_walk( w, &self->bank_hash_info, fun, "bank_hash_info", level );
  if( self->historical_roots_len ) {
    fun( w, NULL, "historical_roots", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->historical_roots_len; i++ )
      fun( w, self->historical_roots + i, "historical_roots", FD_FLAMENCO_TYPE_ULONG,   "ulong",   level );
    fun( w, NULL, "historical_roots", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->historical_roots_with_hash_len ) {
    fun( w, NULL, "historical_roots_with_hash", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->historical_roots_with_hash_len; i++ )
      fd_slot_map_pair_walk(w, self->historical_roots_with_hash + i, fun, "slot_map_pair", level );
    fun( w, NULL, "historical_roots_with_hash", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_solana_accounts_db_fields", level-- );
}
ulong fd_solana_accounts_db_fields_size( fd_solana_accounts_db_fields_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->storages_len; i++ )
      size += fd_snapshot_slot_acc_vecs_size( self->storages + i );
  } while(0);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_bank_hash_info_size( &self->bank_hash_info );
  do {
    size += sizeof(ulong);
    size += self->historical_roots_len * sizeof(ulong);
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->historical_roots_with_hash_len; i++ )
      size += fd_slot_map_pair_size( self->historical_roots_with_hash + i );
  } while(0);
  return size;
}

int fd_versioned_epoch_stakes_current_encode( fd_versioned_epoch_stakes_current_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stakes_stake_encode( &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->total_stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->node_id_to_vote_accounts_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->node_id_to_vote_accounts_len ) {
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ ) {
      err = fd_pubkey_node_vote_accounts_pair_encode( self->node_id_to_vote_accounts + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->epoch_authorized_voters_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->epoch_authorized_voters_len ) {
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ ) {
      err = fd_pubkey_pubkey_pair_encode( self->epoch_authorized_voters + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_versioned_epoch_stakes_current_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_versioned_epoch_stakes_current_t);
  void const * start_data = ctx->data;
  int err = fd_versioned_epoch_stakes_current_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_versioned_epoch_stakes_current_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stakes_stake_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong node_id_to_vote_accounts_len;
  err = fd_bincode_uint64_decode( &node_id_to_vote_accounts_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( node_id_to_vote_accounts_len ) {
    *total_sz += FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT*node_id_to_vote_accounts_len;
    for( ulong i=0; i < node_id_to_vote_accounts_len; i++ ) {
      err = fd_pubkey_node_vote_accounts_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong epoch_authorized_voters_len;
  err = fd_bincode_uint64_decode( &epoch_authorized_voters_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( epoch_authorized_voters_len ) {
    *total_sz += FD_PUBKEY_PUBKEY_PAIR_ALIGN + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT*epoch_authorized_voters_len;
    for( ulong i=0; i < epoch_authorized_voters_len; i++ ) {
      err = fd_pubkey_pubkey_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_versioned_epoch_stakes_current_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_current_t * self = (fd_versioned_epoch_stakes_current_t *)mem;
  fd_versioned_epoch_stakes_current_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_epoch_stakes_current_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_epoch_stakes_current_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_epoch_stakes_current_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_current_t * self = (fd_versioned_epoch_stakes_current_t *)struct_mem;
  fd_stakes_stake_decode_inner( &self->stakes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_stake, ctx );
  fd_bincode_uint64_decode_unsafe( &self->node_id_to_vote_accounts_len, ctx );
  if( self->node_id_to_vote_accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN );
    self->node_id_to_vote_accounts = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT*self->node_id_to_vote_accounts_len;
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ ) {
      fd_pubkey_node_vote_accounts_pair_new( self->node_id_to_vote_accounts + i );
      fd_pubkey_node_vote_accounts_pair_decode_inner( self->node_id_to_vote_accounts + i, alloc_mem, ctx );
    }
  } else
    self->node_id_to_vote_accounts = NULL;
  fd_bincode_uint64_decode_unsafe( &self->epoch_authorized_voters_len, ctx );
  if( self->epoch_authorized_voters_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_PUBKEY_PAIR_ALIGN );
    self->epoch_authorized_voters = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT*self->epoch_authorized_voters_len;
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ ) {
      fd_pubkey_pubkey_pair_new( self->epoch_authorized_voters + i );
      fd_pubkey_pubkey_pair_decode_inner( self->epoch_authorized_voters + i, alloc_mem, ctx );
    }
  } else
    self->epoch_authorized_voters = NULL;
}
void * fd_versioned_epoch_stakes_current_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_current_global_t * self = (fd_versioned_epoch_stakes_current_global_t *)mem;
  fd_versioned_epoch_stakes_current_new( (fd_versioned_epoch_stakes_current_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_epoch_stakes_current_global_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_epoch_stakes_current_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_epoch_stakes_current_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_current_global_t * self = (fd_versioned_epoch_stakes_current_global_t *)struct_mem;
  fd_stakes_stake_decode_inner_global( &self->stakes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_stake, ctx );
  fd_bincode_uint64_decode_unsafe( &self->node_id_to_vote_accounts_len, ctx );
  if( self->node_id_to_vote_accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_ALIGN );
    self->node_id_to_vote_accounts_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT*self->node_id_to_vote_accounts_len;
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ ) {
      fd_pubkey_node_vote_accounts_pair_new( (fd_pubkey_node_vote_accounts_pair_t *)(cur_mem + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT * i) );
      fd_pubkey_node_vote_accounts_pair_decode_inner_global( cur_mem + FD_PUBKEY_NODE_VOTE_ACCOUNTS_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->node_id_to_vote_accounts_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->epoch_authorized_voters_len, ctx );
  if( self->epoch_authorized_voters_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_PUBKEY_PAIR_ALIGN );
    self->epoch_authorized_voters_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT*self->epoch_authorized_voters_len;
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ ) {
      fd_pubkey_pubkey_pair_new( (fd_pubkey_pubkey_pair_t *)(cur_mem + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT * i) );
      fd_pubkey_pubkey_pair_decode_inner_global( cur_mem + FD_PUBKEY_PUBKEY_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->epoch_authorized_voters_gaddr = 0UL;
}
int fd_versioned_epoch_stakes_current_convert_global_to_local( void const * global_self, fd_versioned_epoch_stakes_current_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_versioned_epoch_stakes_current_global_t const * mem = (fd_versioned_epoch_stakes_current_global_t const *)global_self;
  err = fd_stakes_stake_convert_global_to_local( &mem->stakes, &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->total_stake = mem->total_stake;
  self->node_id_to_vote_accounts_len = mem->node_id_to_vote_accounts_len;
  self->node_id_to_vote_accounts     = fd_wksp_laddr_fast( ctx->wksp, mem->node_id_to_vote_accounts_gaddr );
  self->epoch_authorized_voters_len = mem->epoch_authorized_voters_len;
  self->epoch_authorized_voters     = fd_wksp_laddr_fast( ctx->wksp, mem->epoch_authorized_voters_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_versioned_epoch_stakes_current_new(fd_versioned_epoch_stakes_current_t * self) {
  fd_memset( self, 0, sizeof(fd_versioned_epoch_stakes_current_t) );
  fd_stakes_stake_new( &self->stakes );
}
void fd_versioned_epoch_stakes_current_destroy( fd_versioned_epoch_stakes_current_t * self ) {
  fd_stakes_stake_destroy( &self->stakes );
  if( self->node_id_to_vote_accounts ) {
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ )
      fd_pubkey_node_vote_accounts_pair_destroy( self->node_id_to_vote_accounts + i );
    self->node_id_to_vote_accounts = NULL;
  }
  if( self->epoch_authorized_voters ) {
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ )
      fd_pubkey_pubkey_pair_destroy( self->epoch_authorized_voters + i );
    self->epoch_authorized_voters = NULL;
  }
}

ulong fd_versioned_epoch_stakes_current_footprint( void ){ return FD_VERSIONED_EPOCH_STAKES_CURRENT_FOOTPRINT; }
ulong fd_versioned_epoch_stakes_current_align( void ){ return FD_VERSIONED_EPOCH_STAKES_CURRENT_ALIGN; }

void fd_versioned_epoch_stakes_current_walk( void * w, fd_versioned_epoch_stakes_current_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_versioned_epoch_stakes_current", level++ );
  fd_stakes_stake_walk( w, &self->stakes, fun, "stakes", level );
  fun( w, &self->total_stake, "total_stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->node_id_to_vote_accounts_len ) {
    fun( w, NULL, "node_id_to_vote_accounts", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ )
      fd_pubkey_node_vote_accounts_pair_walk(w, self->node_id_to_vote_accounts + i, fun, "pubkey_node_vote_accounts_pair", level );
    fun( w, NULL, "node_id_to_vote_accounts", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->epoch_authorized_voters_len ) {
    fun( w, NULL, "epoch_authorized_voters", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ )
      fd_pubkey_pubkey_pair_walk(w, self->epoch_authorized_voters + i, fun, "pubkey_pubkey_pair", level );
    fun( w, NULL, "epoch_authorized_voters", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_versioned_epoch_stakes_current", level-- );
}
ulong fd_versioned_epoch_stakes_current_size( fd_versioned_epoch_stakes_current_t const * self ) {
  ulong size = 0;
  size += fd_stakes_stake_size( &self->stakes );
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->node_id_to_vote_accounts_len; i++ )
      size += fd_pubkey_node_vote_accounts_pair_size( self->node_id_to_vote_accounts + i );
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->epoch_authorized_voters_len; i++ )
      size += fd_pubkey_pubkey_pair_size( self->epoch_authorized_voters + i );
  } while(0);
  return size;
}

FD_FN_PURE uchar fd_versioned_epoch_stakes_is_Current(fd_versioned_epoch_stakes_t const * self) {
  return self->discriminant == 0;
}
void fd_versioned_epoch_stakes_inner_new( fd_versioned_epoch_stakes_inner_t * self, uint discriminant );
int fd_versioned_epoch_stakes_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_versioned_epoch_stakes_current_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_versioned_epoch_stakes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_versioned_epoch_stakes_t);
  void const * start_data = ctx->data;
  int err =  fd_versioned_epoch_stakes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_versioned_epoch_stakes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_versioned_epoch_stakes_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_versioned_epoch_stakes_inner_decode_inner( fd_versioned_epoch_stakes_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_versioned_epoch_stakes_current_decode_inner( &self->Current, alloc_mem, ctx );
    break;
  }
  }
}
void fd_versioned_epoch_stakes_inner_decode_inner_global( fd_versioned_epoch_stakes_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_versioned_epoch_stakes_current_decode_inner_global( &self->Current, alloc_mem, ctx );
    break;
  }
  }
}
int fd_versioned_epoch_stakes_convert_global_to_local_inner( fd_versioned_epoch_stakes_inner_global_t const * mem, fd_versioned_epoch_stakes_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_versioned_epoch_stakes_current_convert_global_to_local( &mem->Current, &self->Current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_versioned_epoch_stakes_convert_global_to_local( void const * global_self, fd_versioned_epoch_stakes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_global_t const * mem = (fd_versioned_epoch_stakes_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_versioned_epoch_stakes_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_versioned_epoch_stakes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_t * self = (fd_versioned_epoch_stakes_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_versioned_epoch_stakes_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_versioned_epoch_stakes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_t * self = (fd_versioned_epoch_stakes_t *)mem;
  fd_versioned_epoch_stakes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_epoch_stakes_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_epoch_stakes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_versioned_epoch_stakes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_t * self = (fd_versioned_epoch_stakes_t *)mem;
  fd_versioned_epoch_stakes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_epoch_stakes_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_epoch_stakes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_epoch_stakes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_global_t * self = (fd_versioned_epoch_stakes_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_versioned_epoch_stakes_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_versioned_epoch_stakes_inner_new( fd_versioned_epoch_stakes_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_versioned_epoch_stakes_current_new( &self->Current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_versioned_epoch_stakes_new_disc( fd_versioned_epoch_stakes_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_versioned_epoch_stakes_inner_new( &self->inner, self->discriminant );
}
void fd_versioned_epoch_stakes_new( fd_versioned_epoch_stakes_t * self ) {
  fd_memset( self, 0, sizeof(fd_versioned_epoch_stakes_t) );
  fd_versioned_epoch_stakes_new_disc( self, UINT_MAX );
}
void fd_versioned_epoch_stakes_inner_destroy( fd_versioned_epoch_stakes_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_versioned_epoch_stakes_current_destroy( &self->Current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_versioned_epoch_stakes_destroy( fd_versioned_epoch_stakes_t * self ) {
  fd_versioned_epoch_stakes_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_versioned_epoch_stakes_footprint( void ){ return FD_VERSIONED_EPOCH_STAKES_FOOTPRINT; }
ulong fd_versioned_epoch_stakes_align( void ){ return FD_VERSIONED_EPOCH_STAKES_ALIGN; }

void fd_versioned_epoch_stakes_walk( void * w, fd_versioned_epoch_stakes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_versioned_epoch_stakes", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "Current", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_versioned_epoch_stakes_current_walk( w, &self->inner.Current, fun, "Current", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_versioned_epoch_stakes", level-- );
}
ulong fd_versioned_epoch_stakes_size( fd_versioned_epoch_stakes_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_versioned_epoch_stakes_current_size( &self->inner.Current );
    break;
  }
  }
  return size;
}

int fd_versioned_epoch_stakes_inner_encode( fd_versioned_epoch_stakes_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_versioned_epoch_stakes_current_encode( &self->Current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_versioned_epoch_stakes_encode( fd_versioned_epoch_stakes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_versioned_epoch_stakes_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_versioned_epoch_stakes_pair_encode( fd_versioned_epoch_stakes_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_versioned_epoch_stakes_encode( &self->val, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_versioned_epoch_stakes_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_versioned_epoch_stakes_pair_t);
  void const * start_data = ctx->data;
  int err = fd_versioned_epoch_stakes_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_versioned_epoch_stakes_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_versioned_epoch_stakes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_versioned_epoch_stakes_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_pair_t * self = (fd_versioned_epoch_stakes_pair_t *)mem;
  fd_versioned_epoch_stakes_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_epoch_stakes_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_epoch_stakes_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_epoch_stakes_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_pair_t * self = (fd_versioned_epoch_stakes_pair_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_versioned_epoch_stakes_decode_inner( &self->val, alloc_mem, ctx );
}
void * fd_versioned_epoch_stakes_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_pair_global_t * self = (fd_versioned_epoch_stakes_pair_global_t *)mem;
  fd_versioned_epoch_stakes_pair_new( (fd_versioned_epoch_stakes_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_versioned_epoch_stakes_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_versioned_epoch_stakes_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_versioned_epoch_stakes_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_versioned_epoch_stakes_pair_global_t * self = (fd_versioned_epoch_stakes_pair_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_versioned_epoch_stakes_decode_inner_global( &self->val, alloc_mem, ctx );
}
int fd_versioned_epoch_stakes_pair_convert_global_to_local( void const * global_self, fd_versioned_epoch_stakes_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_versioned_epoch_stakes_pair_global_t const * mem = (fd_versioned_epoch_stakes_pair_global_t const *)global_self;
  self->epoch = mem->epoch;
  err = fd_versioned_epoch_stakes_convert_global_to_local( &mem->val, &self->val, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_versioned_epoch_stakes_pair_new(fd_versioned_epoch_stakes_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_versioned_epoch_stakes_pair_t) );
  fd_versioned_epoch_stakes_new( &self->val );
}
void fd_versioned_epoch_stakes_pair_destroy( fd_versioned_epoch_stakes_pair_t * self ) {
  fd_versioned_epoch_stakes_destroy( &self->val );
}

ulong fd_versioned_epoch_stakes_pair_footprint( void ){ return FD_VERSIONED_EPOCH_STAKES_PAIR_FOOTPRINT; }
ulong fd_versioned_epoch_stakes_pair_align( void ){ return FD_VERSIONED_EPOCH_STAKES_PAIR_ALIGN; }

void fd_versioned_epoch_stakes_pair_walk( void * w, fd_versioned_epoch_stakes_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_versioned_epoch_stakes_pair", level++ );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_versioned_epoch_stakes_walk( w, &self->val, fun, "val", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_versioned_epoch_stakes_pair", level-- );
}
ulong fd_versioned_epoch_stakes_pair_size( fd_versioned_epoch_stakes_pair_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_versioned_epoch_stakes_size( &self->val );
  return size;
}

int fd_reward_info_encode( fd_reward_info_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_reward_type_encode( &self->reward_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->lamports, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->post_balance, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->commission, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_reward_info_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_reward_info_t);
  void const * start_data = ctx->data;
  int err = fd_reward_info_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_reward_info_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_reward_type_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_reward_info_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_info_t * self = (fd_reward_info_t *)mem;
  fd_reward_info_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_reward_info_t);
  void * * alloc_mem = &alloc_region;
  fd_reward_info_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_reward_info_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_info_t * self = (fd_reward_info_t *)struct_mem;
  fd_reward_type_decode_inner( &self->reward_type, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->post_balance, ctx );
  fd_bincode_uint64_decode_unsafe( &self->commission, ctx );
}
void * fd_reward_info_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_info_global_t * self = (fd_reward_info_global_t *)mem;
  fd_reward_info_new( (fd_reward_info_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_reward_info_global_t);
  void * * alloc_mem = &alloc_region;
  fd_reward_info_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_reward_info_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_reward_info_global_t * self = (fd_reward_info_global_t *)struct_mem;
  fd_reward_type_decode_inner_global( &self->reward_type, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->post_balance, ctx );
  fd_bincode_uint64_decode_unsafe( &self->commission, ctx );
}
int fd_reward_info_convert_global_to_local( void const * global_self, fd_reward_info_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_reward_info_global_t const * mem = (fd_reward_info_global_t const *)global_self;
  err = fd_reward_type_convert_global_to_local( &mem->reward_type, &self->reward_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->lamports = mem->lamports;
  self->post_balance = mem->post_balance;
  self->commission = mem->commission;
  return FD_BINCODE_SUCCESS;
}
void fd_reward_info_new(fd_reward_info_t * self) {
  fd_memset( self, 0, sizeof(fd_reward_info_t) );
  fd_reward_type_new( &self->reward_type );
}
void fd_reward_info_destroy( fd_reward_info_t * self ) {
  fd_reward_type_destroy( &self->reward_type );
}

ulong fd_reward_info_footprint( void ){ return FD_REWARD_INFO_FOOTPRINT; }
ulong fd_reward_info_align( void ){ return FD_REWARD_INFO_ALIGN; }

void fd_reward_info_walk( void * w, fd_reward_info_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_reward_info", level++ );
  fd_reward_type_walk( w, &self->reward_type, fun, "reward_type", level );
  fun( w, &self->lamports, "lamports", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->post_balance, "post_balance", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->commission, "commission", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_reward_info", level-- );
}
ulong fd_reward_info_size( fd_reward_info_t const * self ) {
  ulong size = 0;
  size += fd_reward_type_size( &self->reward_type );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_slot_lthash_encode( fd_slot_lthash_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_bytes_encode( self->lthash, sizeof(self->lthash), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_lthash_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_lthash_t);
  void const * start_data = ctx->data;
  int err = fd_slot_lthash_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_lthash_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_bytes_decode_footprint( 2048, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_slot_lthash_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_lthash_t * self = (fd_slot_lthash_t *)mem;
  fd_slot_lthash_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_lthash_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_lthash_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_lthash_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_lthash_t * self = (fd_slot_lthash_t *)struct_mem;
  fd_bincode_bytes_decode_unsafe( &self->lthash[0], sizeof(self->lthash), ctx );
}
void * fd_slot_lthash_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_lthash_global_t * self = (fd_slot_lthash_global_t *)mem;
  fd_slot_lthash_new( (fd_slot_lthash_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_lthash_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_lthash_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_lthash_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_lthash_global_t * self = (fd_slot_lthash_global_t *)struct_mem;
  fd_bincode_bytes_decode_unsafe( &self->lthash[0], sizeof(self->lthash), ctx );
}
int fd_slot_lthash_convert_global_to_local( void const * global_self, fd_slot_lthash_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_lthash_global_t const * mem = (fd_slot_lthash_global_t const *)global_self;
  fd_memcpy( &self->lthash[0], &mem->lthash[0], sizeof(self->lthash) );
  return FD_BINCODE_SUCCESS;
}
void fd_slot_lthash_new(fd_slot_lthash_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_lthash_t) );
}
void fd_slot_lthash_destroy( fd_slot_lthash_t * self ) {
}

ulong fd_slot_lthash_footprint( void ){ return FD_SLOT_LTHASH_FOOTPRINT; }
ulong fd_slot_lthash_align( void ){ return FD_SLOT_LTHASH_ALIGN; }

void fd_slot_lthash_walk( void * w, fd_slot_lthash_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_lthash", level++ );
  fun( w, self->lthash, "lthash", FD_FLAMENCO_TYPE_HASH16384, "uchar[2048]", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_lthash", level-- );
}
ulong fd_slot_lthash_size( fd_slot_lthash_t const * self ) {
  ulong size = 0;
  size += sizeof(char) * 2048;
  return size;
}

int fd_solana_manifest_encode( fd_solana_manifest_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_versioned_bank_encode( &self->bank, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_accounts_db_fields_encode( &self->accounts_db, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->bank_incremental_snapshot_persistence != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bank_incremental_snapshot_persistence_encode( self->bank_incremental_snapshot_persistence, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  if( self->epoch_account_hash != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_hash_encode( self->epoch_account_hash, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->versioned_epoch_stakes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->versioned_epoch_stakes_len ) {
    for( ulong i=0; i < self->versioned_epoch_stakes_len; i++ ) {
      err = fd_versioned_epoch_stakes_pair_encode( self->versioned_epoch_stakes + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  if( self->lthash != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_slot_lthash_encode( self->lthash, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_solana_manifest_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_solana_manifest_t);
  void const * start_data = ctx->data;
  int err = fd_solana_manifest_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_solana_manifest_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_versioned_bank_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_accounts_db_fields_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( ctx->data == ctx->dataend ) return FD_BINCODE_SUCCESS;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_ALIGN + FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_FOOTPRINT;
      err = fd_bank_incremental_snapshot_persistence_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  if( ctx->data == ctx->dataend ) return FD_BINCODE_SUCCESS;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_HASH_ALIGN + FD_HASH_FOOTPRINT;
      err = fd_hash_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  if( ctx->data == ctx->dataend ) return FD_BINCODE_SUCCESS;
  ulong versioned_epoch_stakes_len;
  err = fd_bincode_uint64_decode( &versioned_epoch_stakes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( versioned_epoch_stakes_len ) {
    *total_sz += FD_VERSIONED_EPOCH_STAKES_PAIR_ALIGN + FD_VERSIONED_EPOCH_STAKES_PAIR_FOOTPRINT*versioned_epoch_stakes_len;
    for( ulong i=0; i < versioned_epoch_stakes_len; i++ ) {
      err = fd_versioned_epoch_stakes_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  if( ctx->data == ctx->dataend ) return FD_BINCODE_SUCCESS;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_SLOT_LTHASH_ALIGN + FD_SLOT_LTHASH_FOOTPRINT;
      err = fd_slot_lthash_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_solana_manifest_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_manifest_t * self = (fd_solana_manifest_t *)mem;
  fd_solana_manifest_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_solana_manifest_t);
  void * * alloc_mem = &alloc_region;
  fd_solana_manifest_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_solana_manifest_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_manifest_t * self = (fd_solana_manifest_t *)struct_mem;
  fd_versioned_bank_decode_inner( &self->bank, alloc_mem, ctx );
  fd_solana_accounts_db_fields_decode_inner( &self->accounts_db, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
  if( ctx->data == ctx->dataend ) return;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_ALIGN );
      self->bank_incremental_snapshot_persistence = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_FOOTPRINT;
      fd_bank_incremental_snapshot_persistence_new( self->bank_incremental_snapshot_persistence );
      fd_bank_incremental_snapshot_persistence_decode_inner( self->bank_incremental_snapshot_persistence, alloc_mem, ctx );
    } else {
      self->bank_incremental_snapshot_persistence = NULL;
    }
  }
  if( ctx->data == ctx->dataend ) return;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_HASH_ALIGN );
      self->epoch_account_hash = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_HASH_FOOTPRINT;
      fd_hash_new( self->epoch_account_hash );
      fd_hash_decode_inner( self->epoch_account_hash, alloc_mem, ctx );
    } else {
      self->epoch_account_hash = NULL;
    }
  }
  if( ctx->data == ctx->dataend ) return;
  fd_bincode_uint64_decode_unsafe( &self->versioned_epoch_stakes_len, ctx );
  if( self->versioned_epoch_stakes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_VERSIONED_EPOCH_STAKES_PAIR_ALIGN );
    self->versioned_epoch_stakes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_VERSIONED_EPOCH_STAKES_PAIR_FOOTPRINT*self->versioned_epoch_stakes_len;
    for( ulong i=0; i < self->versioned_epoch_stakes_len; i++ ) {
      fd_versioned_epoch_stakes_pair_new( self->versioned_epoch_stakes + i );
      fd_versioned_epoch_stakes_pair_decode_inner( self->versioned_epoch_stakes + i, alloc_mem, ctx );
    }
  } else
    self->versioned_epoch_stakes = NULL;
  if( ctx->data == ctx->dataend ) return;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_SLOT_LTHASH_ALIGN );
      self->lthash = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_SLOT_LTHASH_FOOTPRINT;
      fd_slot_lthash_new( self->lthash );
      fd_slot_lthash_decode_inner( self->lthash, alloc_mem, ctx );
    } else {
      self->lthash = NULL;
    }
  }
}
void * fd_solana_manifest_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_manifest_global_t * self = (fd_solana_manifest_global_t *)mem;
  fd_solana_manifest_new( (fd_solana_manifest_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_solana_manifest_global_t);
  void * * alloc_mem = &alloc_region;
  fd_solana_manifest_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_solana_manifest_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_solana_manifest_global_t * self = (fd_solana_manifest_global_t *)struct_mem;
  fd_versioned_bank_decode_inner_global( &self->bank, alloc_mem, ctx );
  fd_solana_accounts_db_fields_decode_inner_global( &self->accounts_db, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
  if( ctx->data == ctx->dataend ) return;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_ALIGN );
      self->bank_incremental_snapshot_persistence_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bank_incremental_snapshot_persistence_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_BANK_INCREMENTAL_SNAPSHOT_PERSISTENCE_FOOTPRINT;
      fd_bank_incremental_snapshot_persistence_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->bank_incremental_snapshot_persistence_gaddr ), alloc_mem, ctx );
    } else {
      self->bank_incremental_snapshot_persistence_gaddr = 0UL;
    }
  }
  if( ctx->data == ctx->dataend ) return;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_HASH_ALIGN );
      self->epoch_account_hash_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_hash_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_HASH_FOOTPRINT;
      fd_hash_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->epoch_account_hash_gaddr ), alloc_mem, ctx );
    } else {
      self->epoch_account_hash_gaddr = 0UL;
    }
  }
  if( ctx->data == ctx->dataend ) return;
  fd_bincode_uint64_decode_unsafe( &self->versioned_epoch_stakes_len, ctx );
  if( self->versioned_epoch_stakes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_VERSIONED_EPOCH_STAKES_PAIR_ALIGN );
    self->versioned_epoch_stakes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_VERSIONED_EPOCH_STAKES_PAIR_FOOTPRINT*self->versioned_epoch_stakes_len;
    for( ulong i=0; i < self->versioned_epoch_stakes_len; i++ ) {
      fd_versioned_epoch_stakes_pair_new( (fd_versioned_epoch_stakes_pair_t *)(cur_mem + FD_VERSIONED_EPOCH_STAKES_PAIR_FOOTPRINT * i) );
      fd_versioned_epoch_stakes_pair_decode_inner_global( cur_mem + FD_VERSIONED_EPOCH_STAKES_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->versioned_epoch_stakes_gaddr = 0UL;
  if( ctx->data == ctx->dataend ) return;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_SLOT_LTHASH_ALIGN );
      self->lthash_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_slot_lthash_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_SLOT_LTHASH_FOOTPRINT;
      fd_slot_lthash_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->lthash_gaddr ), alloc_mem, ctx );
    } else {
      self->lthash_gaddr = 0UL;
    }
  }
}
int fd_solana_manifest_convert_global_to_local( void const * global_self, fd_solana_manifest_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_solana_manifest_global_t const * mem = (fd_solana_manifest_global_t const *)global_self;
  err = fd_versioned_bank_convert_global_to_local( &mem->bank, &self->bank, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_accounts_db_fields_convert_global_to_local( &mem->accounts_db, &self->accounts_db, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->lamports_per_signature = mem->lamports_per_signature;
  self->bank_incremental_snapshot_persistence = fd_wksp_laddr_fast( ctx->wksp, mem->bank_incremental_snapshot_persistence_gaddr );
  self->epoch_account_hash = fd_wksp_laddr_fast( ctx->wksp, mem->epoch_account_hash_gaddr );
  self->versioned_epoch_stakes_len = mem->versioned_epoch_stakes_len;
  self->versioned_epoch_stakes     = fd_wksp_laddr_fast( ctx->wksp, mem->versioned_epoch_stakes_gaddr );
  self->lthash = fd_wksp_laddr_fast( ctx->wksp, mem->lthash_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_solana_manifest_new(fd_solana_manifest_t * self) {
  fd_memset( self, 0, sizeof(fd_solana_manifest_t) );
  fd_versioned_bank_new( &self->bank );
  fd_solana_accounts_db_fields_new( &self->accounts_db );
}
void fd_solana_manifest_destroy( fd_solana_manifest_t * self ) {
  fd_versioned_bank_destroy( &self->bank );
  fd_solana_accounts_db_fields_destroy( &self->accounts_db );
  if( self->bank_incremental_snapshot_persistence ) {
    fd_bank_incremental_snapshot_persistence_destroy( self->bank_incremental_snapshot_persistence );
    self->bank_incremental_snapshot_persistence = NULL;
  }
  if( self->epoch_account_hash ) {
    fd_hash_destroy( self->epoch_account_hash );
    self->epoch_account_hash = NULL;
  }
  if( self->versioned_epoch_stakes ) {
    for( ulong i=0; i < self->versioned_epoch_stakes_len; i++ )
      fd_versioned_epoch_stakes_pair_destroy( self->versioned_epoch_stakes + i );
    self->versioned_epoch_stakes = NULL;
  }
  if( self->lthash ) {
    fd_slot_lthash_destroy( self->lthash );
    self->lthash = NULL;
  }
}

ulong fd_solana_manifest_footprint( void ){ return FD_SOLANA_MANIFEST_FOOTPRINT; }
ulong fd_solana_manifest_align( void ){ return FD_SOLANA_MANIFEST_ALIGN; }

void fd_solana_manifest_walk( void * w, fd_solana_manifest_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_solana_manifest", level++ );
  fd_versioned_bank_walk( w, &self->bank, fun, "bank", level );
  fd_solana_accounts_db_fields_walk( w, &self->accounts_db, fun, "accounts_db", level );
  fun( w, &self->lamports_per_signature, "lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->bank_incremental_snapshot_persistence ) {
    fun( w, NULL, "bank_incremental_snapshot_persistence", FD_FLAMENCO_TYPE_NULL, "bank_incremental_snapshot_persistence", level );
  } else {
    fd_bank_incremental_snapshot_persistence_walk( w, self->bank_incremental_snapshot_persistence, fun, "bank_incremental_snapshot_persistence", level );
  }
  if( !self->epoch_account_hash ) {
    fun( w, NULL, "epoch_account_hash", FD_FLAMENCO_TYPE_NULL, "hash", level );
  } else {
    fd_hash_walk( w, self->epoch_account_hash, fun, "epoch_account_hash", level );
  }
  if( self->versioned_epoch_stakes_len ) {
    fun( w, NULL, "versioned_epoch_stakes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->versioned_epoch_stakes_len; i++ )
      fd_versioned_epoch_stakes_pair_walk(w, self->versioned_epoch_stakes + i, fun, "versioned_epoch_stakes_pair", level );
    fun( w, NULL, "versioned_epoch_stakes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( !self->lthash ) {
    fun( w, NULL, "lthash", FD_FLAMENCO_TYPE_NULL, "slot_lthash", level );
  } else {
    fd_slot_lthash_walk( w, self->lthash, fun, "lthash", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_solana_manifest", level-- );
}
ulong fd_solana_manifest_size( fd_solana_manifest_t const * self ) {
  ulong size = 0;
  size += fd_versioned_bank_size( &self->bank );
  size += fd_solana_accounts_db_fields_size( &self->accounts_db );
  size += sizeof(ulong);
  size += sizeof(char);
  if( NULL !=  self->bank_incremental_snapshot_persistence ) {
    size += fd_bank_incremental_snapshot_persistence_size( self->bank_incremental_snapshot_persistence );
  }
  size += sizeof(char);
  if( NULL !=  self->epoch_account_hash ) {
    size += fd_hash_size( self->epoch_account_hash );
  }
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->versioned_epoch_stakes_len; i++ )
      size += fd_versioned_epoch_stakes_pair_size( self->versioned_epoch_stakes + i );
  } while(0);
  size += sizeof(char);
  if( NULL !=  self->lthash ) {
    size += fd_slot_lthash_size( self->lthash );
  }
  return size;
}

int fd_rust_duration_encode( fd_rust_duration_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->seconds, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->nanoseconds, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_rust_duration_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_rust_duration_t);
  void const * start_data = ctx->data;
  int err = fd_rust_duration_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_rust_duration_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_rust_duration_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rust_duration_t * self = (fd_rust_duration_t *)mem;
  fd_rust_duration_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rust_duration_t);
  void * * alloc_mem = &alloc_region;
  fd_rust_duration_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_rust_duration_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rust_duration_t * self = (fd_rust_duration_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->seconds, ctx );
  fd_bincode_uint32_decode_unsafe( &self->nanoseconds, ctx );
}
void * fd_rust_duration_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rust_duration_global_t * self = (fd_rust_duration_global_t *)mem;
  fd_rust_duration_new( (fd_rust_duration_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rust_duration_global_t);
  void * * alloc_mem = &alloc_region;
  fd_rust_duration_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_rust_duration_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rust_duration_global_t * self = (fd_rust_duration_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->seconds, ctx );
  fd_bincode_uint32_decode_unsafe( &self->nanoseconds, ctx );
}
int fd_rust_duration_convert_global_to_local( void const * global_self, fd_rust_duration_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_rust_duration_global_t const * mem = (fd_rust_duration_global_t const *)global_self;
  self->seconds = mem->seconds;
  self->nanoseconds = mem->nanoseconds;
  return FD_BINCODE_SUCCESS;
}
void fd_rust_duration_new(fd_rust_duration_t * self) {
  fd_memset( self, 0, sizeof(fd_rust_duration_t) );
}
void fd_rust_duration_destroy( fd_rust_duration_t * self ) {
}

ulong fd_rust_duration_footprint( void ){ return FD_RUST_DURATION_FOOTPRINT; }
ulong fd_rust_duration_align( void ){ return FD_RUST_DURATION_ALIGN; }

void fd_rust_duration_walk( void * w, fd_rust_duration_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_rust_duration", level++ );
  fun( w, &self->seconds, "seconds", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->nanoseconds, "nanoseconds", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_rust_duration", level-- );
}
ulong fd_rust_duration_size( fd_rust_duration_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(uint);
  return size;
}

int fd_poh_config_encode( fd_poh_config_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_rust_duration_encode( &self->target_tick_duration, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->target_tick_count != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_uint64_encode( self->target_tick_count[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_bool_encode( self->has_hashes_per_tick, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_hashes_per_tick ) {
    err = fd_bincode_uint64_encode( self->hashes_per_tick, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_poh_config_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_poh_config_t);
  void const * start_data = ctx->data;
  int err = fd_poh_config_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_poh_config_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_rust_duration_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(ulong);
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_poh_config_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_poh_config_t * self = (fd_poh_config_t *)mem;
  fd_poh_config_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_poh_config_t);
  void * * alloc_mem = &alloc_region;
  fd_poh_config_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_poh_config_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_poh_config_t * self = (fd_poh_config_t *)struct_mem;
  fd_rust_duration_decode_inner( &self->target_tick_duration, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->target_tick_count = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
      fd_bincode_uint64_decode_unsafe( self->target_tick_count, ctx );
    } else {
      self->target_tick_count = NULL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_hashes_per_tick = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->hashes_per_tick, ctx );
    }
  }
}
void * fd_poh_config_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_poh_config_global_t * self = (fd_poh_config_global_t *)mem;
  fd_poh_config_new( (fd_poh_config_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_poh_config_global_t);
  void * * alloc_mem = &alloc_region;
  fd_poh_config_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_poh_config_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_poh_config_global_t * self = (fd_poh_config_global_t *)struct_mem;
  fd_rust_duration_decode_inner_global( &self->target_tick_duration, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->target_tick_count_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_uint64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
    } else {
      self->target_tick_count_gaddr = 0UL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_hashes_per_tick = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->hashes_per_tick, ctx );
    }
  }
}
int fd_poh_config_convert_global_to_local( void const * global_self, fd_poh_config_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_poh_config_global_t const * mem = (fd_poh_config_global_t const *)global_self;
  err = fd_rust_duration_convert_global_to_local( &mem->target_tick_duration, &self->target_tick_duration, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->target_tick_count = fd_wksp_laddr_fast( ctx->wksp, mem->target_tick_count_gaddr );
  self->hashes_per_tick = mem->hashes_per_tick;
  self->has_hashes_per_tick = mem->has_hashes_per_tick;
  return FD_BINCODE_SUCCESS;
}
void fd_poh_config_new(fd_poh_config_t * self) {
  fd_memset( self, 0, sizeof(fd_poh_config_t) );
  fd_rust_duration_new( &self->target_tick_duration );
}
void fd_poh_config_destroy( fd_poh_config_t * self ) {
  fd_rust_duration_destroy( &self->target_tick_duration );
  if( self->target_tick_count ) {
    self->target_tick_count = NULL;
  }
  if( self->has_hashes_per_tick ) {
    self->has_hashes_per_tick = 0;
  }
}

ulong fd_poh_config_footprint( void ){ return FD_POH_CONFIG_FOOTPRINT; }
ulong fd_poh_config_align( void ){ return FD_POH_CONFIG_ALIGN; }

void fd_poh_config_walk( void * w, fd_poh_config_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_poh_config", level++ );
  fd_rust_duration_walk( w, &self->target_tick_duration, fun, "target_tick_duration", level );
  if( !self->target_tick_count ) {
    fun( w, NULL, "target_tick_count", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, self->target_tick_count, "target_tick_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  if( !self->has_hashes_per_tick ) {
    fun( w, NULL, "hashes_per_tick", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->hashes_per_tick, "hashes_per_tick", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_poh_config", level-- );
}
ulong fd_poh_config_size( fd_poh_config_t const * self ) {
  ulong size = 0;
  size += fd_rust_duration_size( &self->target_tick_duration );
  size += sizeof(char);
  if( NULL !=  self->target_tick_count ) {
    size += sizeof(ulong);
  }
  size += sizeof(char);
  if( self->has_hashes_per_tick ) {
    size += sizeof(ulong);
  }
  return size;
}

int fd_string_pubkey_pair_encode( fd_string_pubkey_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->string_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->string_len ) {
    err = fd_bincode_bytes_encode( self->string, self->string_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_string_pubkey_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_string_pubkey_pair_t);
  void const * start_data = ctx->data;
  int err = fd_string_pubkey_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_string_pubkey_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong string_len;
  err = fd_bincode_uint64_decode( &string_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += string_len;
  if( string_len ) {
    err = fd_bincode_bytes_decode_footprint( string_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - string_len, string_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_string_pubkey_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_string_pubkey_pair_t * self = (fd_string_pubkey_pair_t *)mem;
  fd_string_pubkey_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_string_pubkey_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_string_pubkey_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_string_pubkey_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_string_pubkey_pair_t * self = (fd_string_pubkey_pair_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->string_len, ctx );
  if( self->string_len ) {
    self->string = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->string, self->string_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->string_len;
  } else
    self->string = NULL;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
}
void * fd_string_pubkey_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_string_pubkey_pair_global_t * self = (fd_string_pubkey_pair_global_t *)mem;
  fd_string_pubkey_pair_new( (fd_string_pubkey_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_string_pubkey_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_string_pubkey_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_string_pubkey_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_string_pubkey_pair_global_t * self = (fd_string_pubkey_pair_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->string_len, ctx );
  if( self->string_len ) {
    self->string_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->string_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->string_len;
  } else
    self->string_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
}
int fd_string_pubkey_pair_convert_global_to_local( void const * global_self, fd_string_pubkey_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_string_pubkey_pair_global_t const * mem = (fd_string_pubkey_pair_global_t const *)global_self;
  self->string_len = mem->string_len;
  self->string     = fd_wksp_laddr_fast( ctx->wksp, mem->string_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_string_pubkey_pair_new(fd_string_pubkey_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_string_pubkey_pair_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_string_pubkey_pair_destroy( fd_string_pubkey_pair_t * self ) {
  if( self->string ) {
    self->string = NULL;
  }
  fd_pubkey_destroy( &self->pubkey );
}

ulong fd_string_pubkey_pair_footprint( void ){ return FD_STRING_PUBKEY_PAIR_FOOTPRINT; }
ulong fd_string_pubkey_pair_align( void ){ return FD_STRING_PUBKEY_PAIR_ALIGN; }

void fd_string_pubkey_pair_walk( void * w, fd_string_pubkey_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_string_pubkey_pair", level++ );
  fun(w, self->string, "string", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_string_pubkey_pair", level-- );
}
ulong fd_string_pubkey_pair_size( fd_string_pubkey_pair_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->string_len;
  } while(0);
  size += fd_pubkey_size( &self->pubkey );
  return size;
}

int fd_pubkey_account_pair_encode( fd_pubkey_account_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_account_encode( &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_pubkey_account_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_pubkey_account_pair_t);
  void const * start_data = ctx->data;
  int err = fd_pubkey_account_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_pubkey_account_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_account_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_pubkey_account_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_account_pair_t * self = (fd_pubkey_account_pair_t *)mem;
  fd_pubkey_account_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_account_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_account_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_account_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_account_pair_t * self = (fd_pubkey_account_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_solana_account_decode_inner( &self->account, alloc_mem, ctx );
}
void * fd_pubkey_account_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_account_pair_global_t * self = (fd_pubkey_account_pair_global_t *)mem;
  fd_pubkey_account_pair_new( (fd_pubkey_account_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_account_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_account_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_account_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_account_pair_global_t * self = (fd_pubkey_account_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_solana_account_decode_inner_global( &self->account, alloc_mem, ctx );
}
int fd_pubkey_account_pair_convert_global_to_local( void const * global_self, fd_pubkey_account_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_pubkey_account_pair_global_t const * mem = (fd_pubkey_account_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_solana_account_convert_global_to_local( &mem->account, &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_pubkey_account_pair_new(fd_pubkey_account_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_pubkey_account_pair_t) );
  fd_pubkey_new( &self->key );
  fd_solana_account_new( &self->account );
}
void fd_pubkey_account_pair_destroy( fd_pubkey_account_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
  fd_solana_account_destroy( &self->account );
}

ulong fd_pubkey_account_pair_footprint( void ){ return FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT; }
ulong fd_pubkey_account_pair_align( void ){ return FD_PUBKEY_ACCOUNT_PAIR_ALIGN; }

void fd_pubkey_account_pair_walk( void * w, fd_pubkey_account_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_pubkey_account_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fd_solana_account_walk( w, &self->account, fun, "account", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_pubkey_account_pair", level-- );
}
ulong fd_pubkey_account_pair_size( fd_pubkey_account_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += fd_solana_account_size( &self->account );
  return size;
}

int fd_genesis_solana_encode( fd_genesis_solana_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->creation_time, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->accounts_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->accounts_len ) {
    for( ulong i=0; i < self->accounts_len; i++ ) {
      err = fd_pubkey_account_pair_encode( self->accounts + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->native_instruction_processors_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->native_instruction_processors_len ) {
    for( ulong i=0; i < self->native_instruction_processors_len; i++ ) {
      err = fd_string_pubkey_pair_encode( self->native_instruction_processors + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->rewards_pools_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->rewards_pools_len ) {
    for( ulong i=0; i < self->rewards_pools_len; i++ ) {
      err = fd_pubkey_account_pair_encode( self->rewards_pools + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->ticks_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->unused, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_poh_config_encode( &self->poh_config, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->__backwards_compat_with_v0_23, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_encode( &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_encode( &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_encode( &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_encode( &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->cluster_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_genesis_solana_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_genesis_solana_t);
  void const * start_data = ctx->data;
  int err = fd_genesis_solana_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_genesis_solana_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong accounts_len;
  err = fd_bincode_uint64_decode( &accounts_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( accounts_len ) {
    *total_sz += FD_PUBKEY_ACCOUNT_PAIR_ALIGN + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT*accounts_len;
    for( ulong i=0; i < accounts_len; i++ ) {
      err = fd_pubkey_account_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong native_instruction_processors_len;
  err = fd_bincode_uint64_decode( &native_instruction_processors_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( native_instruction_processors_len ) {
    *total_sz += FD_STRING_PUBKEY_PAIR_ALIGN + FD_STRING_PUBKEY_PAIR_FOOTPRINT*native_instruction_processors_len;
    for( ulong i=0; i < native_instruction_processors_len; i++ ) {
      err = fd_string_pubkey_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong rewards_pools_len;
  err = fd_bincode_uint64_decode( &rewards_pools_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( rewards_pools_len ) {
    *total_sz += FD_PUBKEY_ACCOUNT_PAIR_ALIGN + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT*rewards_pools_len;
    for( ulong i=0; i < rewards_pools_len; i++ ) {
      err = fd_pubkey_account_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_poh_config_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_fee_rate_governor_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_genesis_solana_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_genesis_solana_t * self = (fd_genesis_solana_t *)mem;
  fd_genesis_solana_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_genesis_solana_t);
  void * * alloc_mem = &alloc_region;
  fd_genesis_solana_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_genesis_solana_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_genesis_solana_t * self = (fd_genesis_solana_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->creation_time, ctx );
  fd_bincode_uint64_decode_unsafe( &self->accounts_len, ctx );
  if( self->accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ACCOUNT_PAIR_ALIGN );
    self->accounts = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT*self->accounts_len;
    for( ulong i=0; i < self->accounts_len; i++ ) {
      fd_pubkey_account_pair_new( self->accounts + i );
      fd_pubkey_account_pair_decode_inner( self->accounts + i, alloc_mem, ctx );
    }
  } else
    self->accounts = NULL;
  fd_bincode_uint64_decode_unsafe( &self->native_instruction_processors_len, ctx );
  if( self->native_instruction_processors_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_STRING_PUBKEY_PAIR_ALIGN );
    self->native_instruction_processors = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_STRING_PUBKEY_PAIR_FOOTPRINT*self->native_instruction_processors_len;
    for( ulong i=0; i < self->native_instruction_processors_len; i++ ) {
      fd_string_pubkey_pair_new( self->native_instruction_processors + i );
      fd_string_pubkey_pair_decode_inner( self->native_instruction_processors + i, alloc_mem, ctx );
    }
  } else
    self->native_instruction_processors = NULL;
  fd_bincode_uint64_decode_unsafe( &self->rewards_pools_len, ctx );
  if( self->rewards_pools_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ACCOUNT_PAIR_ALIGN );
    self->rewards_pools = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT*self->rewards_pools_len;
    for( ulong i=0; i < self->rewards_pools_len; i++ ) {
      fd_pubkey_account_pair_new( self->rewards_pools + i );
      fd_pubkey_account_pair_decode_inner( self->rewards_pools + i, alloc_mem, ctx );
    }
  } else
    self->rewards_pools = NULL;
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->unused, ctx );
  fd_poh_config_decode_inner( &self->poh_config, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->__backwards_compat_with_v0_23, ctx );
  fd_fee_rate_governor_decode_inner( &self->fee_rate_governor, alloc_mem, ctx );
  fd_rent_decode_inner( &self->rent, alloc_mem, ctx );
  fd_inflation_decode_inner( &self->inflation, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner( &self->epoch_schedule, alloc_mem, ctx );
  fd_bincode_uint32_decode_unsafe( &self->cluster_type, ctx );
}
void * fd_genesis_solana_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_genesis_solana_global_t * self = (fd_genesis_solana_global_t *)mem;
  fd_genesis_solana_new( (fd_genesis_solana_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_genesis_solana_global_t);
  void * * alloc_mem = &alloc_region;
  fd_genesis_solana_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_genesis_solana_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_genesis_solana_global_t * self = (fd_genesis_solana_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->creation_time, ctx );
  fd_bincode_uint64_decode_unsafe( &self->accounts_len, ctx );
  if( self->accounts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ACCOUNT_PAIR_ALIGN );
    self->accounts_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT*self->accounts_len;
    for( ulong i=0; i < self->accounts_len; i++ ) {
      fd_pubkey_account_pair_new( (fd_pubkey_account_pair_t *)(cur_mem + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT * i) );
      fd_pubkey_account_pair_decode_inner_global( cur_mem + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->accounts_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->native_instruction_processors_len, ctx );
  if( self->native_instruction_processors_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_STRING_PUBKEY_PAIR_ALIGN );
    self->native_instruction_processors_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_STRING_PUBKEY_PAIR_FOOTPRINT*self->native_instruction_processors_len;
    for( ulong i=0; i < self->native_instruction_processors_len; i++ ) {
      fd_string_pubkey_pair_new( (fd_string_pubkey_pair_t *)(cur_mem + FD_STRING_PUBKEY_PAIR_FOOTPRINT * i) );
      fd_string_pubkey_pair_decode_inner_global( cur_mem + FD_STRING_PUBKEY_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->native_instruction_processors_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->rewards_pools_len, ctx );
  if( self->rewards_pools_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ACCOUNT_PAIR_ALIGN );
    self->rewards_pools_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT*self->rewards_pools_len;
    for( ulong i=0; i < self->rewards_pools_len; i++ ) {
      fd_pubkey_account_pair_new( (fd_pubkey_account_pair_t *)(cur_mem + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT * i) );
      fd_pubkey_account_pair_decode_inner_global( cur_mem + FD_PUBKEY_ACCOUNT_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->rewards_pools_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->unused, ctx );
  fd_poh_config_decode_inner_global( &self->poh_config, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->__backwards_compat_with_v0_23, ctx );
  fd_fee_rate_governor_decode_inner_global( &self->fee_rate_governor, alloc_mem, ctx );
  fd_rent_decode_inner_global( &self->rent, alloc_mem, ctx );
  fd_inflation_decode_inner_global( &self->inflation, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner_global( &self->epoch_schedule, alloc_mem, ctx );
  fd_bincode_uint32_decode_unsafe( &self->cluster_type, ctx );
}
int fd_genesis_solana_convert_global_to_local( void const * global_self, fd_genesis_solana_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_genesis_solana_global_t const * mem = (fd_genesis_solana_global_t const *)global_self;
  self->creation_time = mem->creation_time;
  self->accounts_len = mem->accounts_len;
  self->accounts     = fd_wksp_laddr_fast( ctx->wksp, mem->accounts_gaddr );
  self->native_instruction_processors_len = mem->native_instruction_processors_len;
  self->native_instruction_processors     = fd_wksp_laddr_fast( ctx->wksp, mem->native_instruction_processors_gaddr );
  self->rewards_pools_len = mem->rewards_pools_len;
  self->rewards_pools     = fd_wksp_laddr_fast( ctx->wksp, mem->rewards_pools_gaddr );
  self->ticks_per_slot = mem->ticks_per_slot;
  self->unused = mem->unused;
  err = fd_poh_config_convert_global_to_local( &mem->poh_config, &self->poh_config, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->__backwards_compat_with_v0_23 = mem->__backwards_compat_with_v0_23;
  err = fd_fee_rate_governor_convert_global_to_local( &mem->fee_rate_governor, &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_convert_global_to_local( &mem->rent, &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_convert_global_to_local( &mem->inflation, &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_convert_global_to_local( &mem->epoch_schedule, &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->cluster_type = mem->cluster_type;
  return FD_BINCODE_SUCCESS;
}
void fd_genesis_solana_new(fd_genesis_solana_t * self) {
  fd_memset( self, 0, sizeof(fd_genesis_solana_t) );
  fd_poh_config_new( &self->poh_config );
  fd_fee_rate_governor_new( &self->fee_rate_governor );
  fd_rent_new( &self->rent );
  fd_inflation_new( &self->inflation );
  fd_epoch_schedule_new( &self->epoch_schedule );
}
void fd_genesis_solana_destroy( fd_genesis_solana_t * self ) {
  if( self->accounts ) {
    for( ulong i=0; i < self->accounts_len; i++ )
      fd_pubkey_account_pair_destroy( self->accounts + i );
    self->accounts = NULL;
  }
  if( self->native_instruction_processors ) {
    for( ulong i=0; i < self->native_instruction_processors_len; i++ )
      fd_string_pubkey_pair_destroy( self->native_instruction_processors + i );
    self->native_instruction_processors = NULL;
  }
  if( self->rewards_pools ) {
    for( ulong i=0; i < self->rewards_pools_len; i++ )
      fd_pubkey_account_pair_destroy( self->rewards_pools + i );
    self->rewards_pools = NULL;
  }
  fd_poh_config_destroy( &self->poh_config );
  fd_fee_rate_governor_destroy( &self->fee_rate_governor );
  fd_rent_destroy( &self->rent );
  fd_inflation_destroy( &self->inflation );
  fd_epoch_schedule_destroy( &self->epoch_schedule );
}

ulong fd_genesis_solana_footprint( void ){ return FD_GENESIS_SOLANA_FOOTPRINT; }
ulong fd_genesis_solana_align( void ){ return FD_GENESIS_SOLANA_ALIGN; }

void fd_genesis_solana_walk( void * w, fd_genesis_solana_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_genesis_solana", level++ );
  fun( w, &self->creation_time, "creation_time", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->accounts_len ) {
    fun( w, NULL, "accounts", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->accounts_len; i++ )
      fd_pubkey_account_pair_walk(w, self->accounts + i, fun, "pubkey_account_pair", level );
    fun( w, NULL, "accounts", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->native_instruction_processors_len ) {
    fun( w, NULL, "native_instruction_processors", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->native_instruction_processors_len; i++ )
      fd_string_pubkey_pair_walk(w, self->native_instruction_processors + i, fun, "string_pubkey_pair", level );
    fun( w, NULL, "native_instruction_processors", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->rewards_pools_len ) {
    fun( w, NULL, "rewards_pools", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->rewards_pools_len; i++ )
      fd_pubkey_account_pair_walk(w, self->rewards_pools + i, fun, "pubkey_account_pair", level );
    fun( w, NULL, "rewards_pools", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->ticks_per_slot, "ticks_per_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->unused, "unused", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_poh_config_walk( w, &self->poh_config, fun, "poh_config", level );
  fun( w, &self->__backwards_compat_with_v0_23, "__backwards_compat_with_v0_23", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_fee_rate_governor_walk( w, &self->fee_rate_governor, fun, "fee_rate_governor", level );
  fd_rent_walk( w, &self->rent, fun, "rent", level );
  fd_inflation_walk( w, &self->inflation, fun, "inflation", level );
  fd_epoch_schedule_walk( w, &self->epoch_schedule, fun, "epoch_schedule", level );
  fun( w, &self->cluster_type, "cluster_type", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_genesis_solana", level-- );
}
ulong fd_genesis_solana_size( fd_genesis_solana_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->accounts_len; i++ )
      size += fd_pubkey_account_pair_size( self->accounts + i );
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->native_instruction_processors_len; i++ )
      size += fd_string_pubkey_pair_size( self->native_instruction_processors + i );
  } while(0);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->rewards_pools_len; i++ )
      size += fd_pubkey_account_pair_size( self->rewards_pools + i );
  } while(0);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_poh_config_size( &self->poh_config );
  size += sizeof(ulong);
  size += fd_fee_rate_governor_size( &self->fee_rate_governor );
  size += fd_rent_size( &self->rent );
  size += fd_inflation_size( &self->inflation );
  size += fd_epoch_schedule_size( &self->epoch_schedule );
  size += sizeof(uint);
  return size;
}

int fd_sol_sysvar_clock_encode( fd_sol_sysvar_clock_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->epoch_start_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->leader_schedule_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->unix_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_sol_sysvar_clock_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_sol_sysvar_clock_t);
  void const * start_data = ctx->data;
  int err = fd_sol_sysvar_clock_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_sol_sysvar_clock_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_sol_sysvar_clock_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_clock_t * self = (fd_sol_sysvar_clock_t *)mem;
  fd_sol_sysvar_clock_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sol_sysvar_clock_t);
  void * * alloc_mem = &alloc_region;
  fd_sol_sysvar_clock_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_sol_sysvar_clock_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_clock_t * self = (fd_sol_sysvar_clock_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->epoch_start_timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->leader_schedule_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->unix_timestamp, ctx );
}
void * fd_sol_sysvar_clock_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_clock_global_t * self = (fd_sol_sysvar_clock_global_t *)mem;
  fd_sol_sysvar_clock_new( (fd_sol_sysvar_clock_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sol_sysvar_clock_global_t);
  void * * alloc_mem = &alloc_region;
  fd_sol_sysvar_clock_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_sol_sysvar_clock_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_clock_global_t * self = (fd_sol_sysvar_clock_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->epoch_start_timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->leader_schedule_epoch, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->unix_timestamp, ctx );
}
int fd_sol_sysvar_clock_convert_global_to_local( void const * global_self, fd_sol_sysvar_clock_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_sol_sysvar_clock_global_t const * mem = (fd_sol_sysvar_clock_global_t const *)global_self;
  self->slot = mem->slot;
  self->epoch_start_timestamp = mem->epoch_start_timestamp;
  self->epoch = mem->epoch;
  self->leader_schedule_epoch = mem->leader_schedule_epoch;
  self->unix_timestamp = mem->unix_timestamp;
  return FD_BINCODE_SUCCESS;
}
void fd_sol_sysvar_clock_new(fd_sol_sysvar_clock_t * self) {
  fd_memset( self, 0, sizeof(fd_sol_sysvar_clock_t) );
}
void fd_sol_sysvar_clock_destroy( fd_sol_sysvar_clock_t * self ) {
}

ulong fd_sol_sysvar_clock_footprint( void ){ return FD_SOL_SYSVAR_CLOCK_FOOTPRINT; }
ulong fd_sol_sysvar_clock_align( void ){ return FD_SOL_SYSVAR_CLOCK_ALIGN; }

void fd_sol_sysvar_clock_walk( void * w, fd_sol_sysvar_clock_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_sol_sysvar_clock", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->epoch_start_timestamp, "epoch_start_timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->leader_schedule_epoch, "leader_schedule_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->unix_timestamp, "unix_timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_sol_sysvar_clock", level-- );
}
ulong fd_sol_sysvar_clock_size( fd_sol_sysvar_clock_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(long);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(long);
  return size;
}

int fd_sol_sysvar_last_restart_slot_encode( fd_sol_sysvar_last_restart_slot_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_sol_sysvar_last_restart_slot_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_sol_sysvar_last_restart_slot_t);
  void const * start_data = ctx->data;
  int err = fd_sol_sysvar_last_restart_slot_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_sol_sysvar_last_restart_slot_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_sol_sysvar_last_restart_slot_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_last_restart_slot_t * self = (fd_sol_sysvar_last_restart_slot_t *)mem;
  fd_sol_sysvar_last_restart_slot_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sol_sysvar_last_restart_slot_t);
  void * * alloc_mem = &alloc_region;
  fd_sol_sysvar_last_restart_slot_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_sol_sysvar_last_restart_slot_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_last_restart_slot_t * self = (fd_sol_sysvar_last_restart_slot_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
void * fd_sol_sysvar_last_restart_slot_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_last_restart_slot_global_t * self = (fd_sol_sysvar_last_restart_slot_global_t *)mem;
  fd_sol_sysvar_last_restart_slot_new( (fd_sol_sysvar_last_restart_slot_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sol_sysvar_last_restart_slot_global_t);
  void * * alloc_mem = &alloc_region;
  fd_sol_sysvar_last_restart_slot_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_sol_sysvar_last_restart_slot_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sol_sysvar_last_restart_slot_global_t * self = (fd_sol_sysvar_last_restart_slot_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
int fd_sol_sysvar_last_restart_slot_convert_global_to_local( void const * global_self, fd_sol_sysvar_last_restart_slot_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_sol_sysvar_last_restart_slot_global_t const * mem = (fd_sol_sysvar_last_restart_slot_global_t const *)global_self;
  self->slot = mem->slot;
  return FD_BINCODE_SUCCESS;
}
void fd_sol_sysvar_last_restart_slot_new(fd_sol_sysvar_last_restart_slot_t * self) {
  fd_memset( self, 0, sizeof(fd_sol_sysvar_last_restart_slot_t) );
}
void fd_sol_sysvar_last_restart_slot_destroy( fd_sol_sysvar_last_restart_slot_t * self ) {
}

ulong fd_sol_sysvar_last_restart_slot_footprint( void ){ return FD_SOL_SYSVAR_LAST_RESTART_SLOT_FOOTPRINT; }
ulong fd_sol_sysvar_last_restart_slot_align( void ){ return FD_SOL_SYSVAR_LAST_RESTART_SLOT_ALIGN; }

void fd_sol_sysvar_last_restart_slot_walk( void * w, fd_sol_sysvar_last_restart_slot_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_sol_sysvar_last_restart_slot", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_sol_sysvar_last_restart_slot", level-- );
}
ulong fd_sol_sysvar_last_restart_slot_size( fd_sol_sysvar_last_restart_slot_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  return size;
}

int fd_vote_lockout_encode( fd_vote_lockout_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->confirmation_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_lockout_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_lockout_t);
  void const * start_data = ctx->data;
  int err = fd_vote_lockout_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_lockout_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_lockout_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_lockout_t * self = (fd_vote_lockout_t *)mem;
  fd_vote_lockout_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_lockout_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_lockout_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_lockout_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_lockout_t * self = (fd_vote_lockout_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint32_decode_unsafe( &self->confirmation_count, ctx );
}
void * fd_vote_lockout_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_lockout_global_t * self = (fd_vote_lockout_global_t *)mem;
  fd_vote_lockout_new( (fd_vote_lockout_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_lockout_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_lockout_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_lockout_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_lockout_global_t * self = (fd_vote_lockout_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint32_decode_unsafe( &self->confirmation_count, ctx );
}
int fd_vote_lockout_convert_global_to_local( void const * global_self, fd_vote_lockout_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_lockout_global_t const * mem = (fd_vote_lockout_global_t const *)global_self;
  self->slot = mem->slot;
  self->confirmation_count = mem->confirmation_count;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_lockout_new(fd_vote_lockout_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_lockout_t) );
}
void fd_vote_lockout_destroy( fd_vote_lockout_t * self ) {
}

ulong fd_vote_lockout_footprint( void ){ return FD_VOTE_LOCKOUT_FOOTPRINT; }
ulong fd_vote_lockout_align( void ){ return FD_VOTE_LOCKOUT_ALIGN; }

void fd_vote_lockout_walk( void * w, fd_vote_lockout_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_lockout", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->confirmation_count, "confirmation_count", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_lockout", level-- );
}
ulong fd_vote_lockout_size( fd_vote_lockout_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(uint);
  return size;
}

int fd_lockout_offset_encode( fd_lockout_offset_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_varint_encode( self->offset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->confirmation_count), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_lockout_offset_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_lockout_offset_t);
  void const * start_data = ctx->data;
  int err = fd_lockout_offset_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_lockout_offset_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_varint_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_lockout_offset_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockout_offset_t * self = (fd_lockout_offset_t *)mem;
  fd_lockout_offset_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lockout_offset_t);
  void * * alloc_mem = &alloc_region;
  fd_lockout_offset_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_lockout_offset_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockout_offset_t * self = (fd_lockout_offset_t *)struct_mem;
  fd_bincode_varint_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint8_decode_unsafe( &self->confirmation_count, ctx );
}
void * fd_lockout_offset_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockout_offset_global_t * self = (fd_lockout_offset_global_t *)mem;
  fd_lockout_offset_new( (fd_lockout_offset_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lockout_offset_global_t);
  void * * alloc_mem = &alloc_region;
  fd_lockout_offset_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_lockout_offset_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockout_offset_global_t * self = (fd_lockout_offset_global_t *)struct_mem;
  fd_bincode_varint_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint8_decode_unsafe( &self->confirmation_count, ctx );
}
int fd_lockout_offset_convert_global_to_local( void const * global_self, fd_lockout_offset_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_lockout_offset_global_t const * mem = (fd_lockout_offset_global_t const *)global_self;
  self->offset = mem->offset;
  self->confirmation_count = mem->confirmation_count;
  return FD_BINCODE_SUCCESS;
}
void fd_lockout_offset_new(fd_lockout_offset_t * self) {
  fd_memset( self, 0, sizeof(fd_lockout_offset_t) );
}
void fd_lockout_offset_destroy( fd_lockout_offset_t * self ) {
}

ulong fd_lockout_offset_footprint( void ){ return FD_LOCKOUT_OFFSET_FOOTPRINT; }
ulong fd_lockout_offset_align( void ){ return FD_LOCKOUT_OFFSET_ALIGN; }

void fd_lockout_offset_walk( void * w, fd_lockout_offset_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_lockout_offset", level++ );
  fun( w, &self->offset, "offset", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->confirmation_count, "confirmation_count", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_lockout_offset", level-- );
}
ulong fd_lockout_offset_size( fd_lockout_offset_t const * self ) {
  ulong size = 0;
  size += fd_bincode_varint_size( self->offset );
  size += sizeof(char);
  return size;
}

int fd_vote_authorized_voter_encode( fd_vote_authorized_voter_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorized_voter_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_authorized_voter_t);
  void const * start_data = ctx->data;
  int err = fd_vote_authorized_voter_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_authorized_voter_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_authorized_voter_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voter_t * self = (fd_vote_authorized_voter_t *)mem;
  fd_vote_authorized_voter_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorized_voter_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorized_voter_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorized_voter_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voter_t * self = (fd_vote_authorized_voter_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
}
void * fd_vote_authorized_voter_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voter_global_t * self = (fd_vote_authorized_voter_global_t *)mem;
  fd_vote_authorized_voter_new( (fd_vote_authorized_voter_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorized_voter_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorized_voter_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorized_voter_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voter_global_t * self = (fd_vote_authorized_voter_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
}
int fd_vote_authorized_voter_convert_global_to_local( void const * global_self, fd_vote_authorized_voter_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_authorized_voter_global_t const * mem = (fd_vote_authorized_voter_global_t const *)global_self;
  self->epoch = mem->epoch;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_authorized_voter_new(fd_vote_authorized_voter_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_authorized_voter_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_vote_authorized_voter_destroy( fd_vote_authorized_voter_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
}

ulong fd_vote_authorized_voter_footprint( void ){ return FD_VOTE_AUTHORIZED_VOTER_FOOTPRINT; }
ulong fd_vote_authorized_voter_align( void ){ return FD_VOTE_AUTHORIZED_VOTER_ALIGN; }

void fd_vote_authorized_voter_walk( void * w, fd_vote_authorized_voter_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_authorized_voter", level++ );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_authorized_voter", level-- );
}
ulong fd_vote_authorized_voter_size( fd_vote_authorized_voter_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->pubkey );
  return size;
}

int fd_vote_prior_voter_encode( fd_vote_prior_voter_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch_start, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch_end, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_prior_voter_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_prior_voter_t);
  void const * start_data = ctx->data;
  int err = fd_vote_prior_voter_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_prior_voter_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_vote_prior_voter_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_t * self = (fd_vote_prior_voter_t *)mem;
  fd_vote_prior_voter_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voter_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voter_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voter_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_t * self = (fd_vote_prior_voter_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_start, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_end, ctx );
}
void * fd_vote_prior_voter_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_global_t * self = (fd_vote_prior_voter_global_t *)mem;
  fd_vote_prior_voter_new( (fd_vote_prior_voter_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voter_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voter_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voter_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_global_t * self = (fd_vote_prior_voter_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_start, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_end, ctx );
}
int fd_vote_prior_voter_convert_global_to_local( void const * global_self, fd_vote_prior_voter_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_prior_voter_global_t const * mem = (fd_vote_prior_voter_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->epoch_start = mem->epoch_start;
  self->epoch_end = mem->epoch_end;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_prior_voter_new(fd_vote_prior_voter_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_prior_voter_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_vote_prior_voter_destroy( fd_vote_prior_voter_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
}

ulong fd_vote_prior_voter_footprint( void ){ return FD_VOTE_PRIOR_VOTER_FOOTPRINT; }
ulong fd_vote_prior_voter_align( void ){ return FD_VOTE_PRIOR_VOTER_ALIGN; }

void fd_vote_prior_voter_walk( void * w, fd_vote_prior_voter_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_prior_voter", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun( w, &self->epoch_start, "epoch_start", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->epoch_end, "epoch_end", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_prior_voter", level-- );
}
ulong fd_vote_prior_voter_size( fd_vote_prior_voter_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_vote_prior_voter_0_23_5_encode( fd_vote_prior_voter_0_23_5_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch_start, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch_end, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_prior_voter_0_23_5_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_prior_voter_0_23_5_t);
  void const * start_data = ctx->data;
  int err = fd_vote_prior_voter_0_23_5_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_prior_voter_0_23_5_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_vote_prior_voter_0_23_5_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_0_23_5_t * self = (fd_vote_prior_voter_0_23_5_t *)mem;
  fd_vote_prior_voter_0_23_5_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voter_0_23_5_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voter_0_23_5_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voter_0_23_5_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_0_23_5_t * self = (fd_vote_prior_voter_0_23_5_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_start, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_end, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
void * fd_vote_prior_voter_0_23_5_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_0_23_5_global_t * self = (fd_vote_prior_voter_0_23_5_global_t *)mem;
  fd_vote_prior_voter_0_23_5_new( (fd_vote_prior_voter_0_23_5_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voter_0_23_5_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voter_0_23_5_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voter_0_23_5_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voter_0_23_5_global_t * self = (fd_vote_prior_voter_0_23_5_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_start, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch_end, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
int fd_vote_prior_voter_0_23_5_convert_global_to_local( void const * global_self, fd_vote_prior_voter_0_23_5_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_prior_voter_0_23_5_global_t const * mem = (fd_vote_prior_voter_0_23_5_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->epoch_start = mem->epoch_start;
  self->epoch_end = mem->epoch_end;
  self->slot = mem->slot;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_prior_voter_0_23_5_new(fd_vote_prior_voter_0_23_5_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_prior_voter_0_23_5_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_vote_prior_voter_0_23_5_destroy( fd_vote_prior_voter_0_23_5_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
}

ulong fd_vote_prior_voter_0_23_5_footprint( void ){ return FD_VOTE_PRIOR_VOTER_0_23_5_FOOTPRINT; }
ulong fd_vote_prior_voter_0_23_5_align( void ){ return FD_VOTE_PRIOR_VOTER_0_23_5_ALIGN; }

void fd_vote_prior_voter_0_23_5_walk( void * w, fd_vote_prior_voter_0_23_5_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_prior_voter_0_23_5", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun( w, &self->epoch_start, "epoch_start", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->epoch_end, "epoch_end", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_prior_voter_0_23_5", level-- );
}
ulong fd_vote_prior_voter_0_23_5_size( fd_vote_prior_voter_0_23_5_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_vote_epoch_credits_encode( fd_vote_epoch_credits_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->credits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->prev_credits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_epoch_credits_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_epoch_credits_t);
  void const * start_data = ctx->data;
  int err = fd_vote_epoch_credits_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_epoch_credits_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_vote_epoch_credits_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_epoch_credits_t * self = (fd_vote_epoch_credits_t *)mem;
  fd_vote_epoch_credits_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_epoch_credits_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_epoch_credits_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_epoch_credits_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_epoch_credits_t * self = (fd_vote_epoch_credits_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->credits, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prev_credits, ctx );
}
void * fd_vote_epoch_credits_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_epoch_credits_global_t * self = (fd_vote_epoch_credits_global_t *)mem;
  fd_vote_epoch_credits_new( (fd_vote_epoch_credits_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_epoch_credits_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_epoch_credits_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_epoch_credits_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_epoch_credits_global_t * self = (fd_vote_epoch_credits_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_bincode_uint64_decode_unsafe( &self->credits, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prev_credits, ctx );
}
int fd_vote_epoch_credits_convert_global_to_local( void const * global_self, fd_vote_epoch_credits_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_epoch_credits_global_t const * mem = (fd_vote_epoch_credits_global_t const *)global_self;
  self->epoch = mem->epoch;
  self->credits = mem->credits;
  self->prev_credits = mem->prev_credits;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_epoch_credits_new(fd_vote_epoch_credits_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_epoch_credits_t) );
}
void fd_vote_epoch_credits_destroy( fd_vote_epoch_credits_t * self ) {
}

ulong fd_vote_epoch_credits_footprint( void ){ return FD_VOTE_EPOCH_CREDITS_FOOTPRINT; }
ulong fd_vote_epoch_credits_align( void ){ return FD_VOTE_EPOCH_CREDITS_ALIGN; }

void fd_vote_epoch_credits_walk( void * w, fd_vote_epoch_credits_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_epoch_credits", level++ );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->credits, "credits", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->prev_credits, "prev_credits", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_epoch_credits", level-- );
}
ulong fd_vote_epoch_credits_size( fd_vote_epoch_credits_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_vote_block_timestamp_encode( fd_vote_block_timestamp_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_block_timestamp_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_block_timestamp_t);
  void const * start_data = ctx->data;
  int err = fd_vote_block_timestamp_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_block_timestamp_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_block_timestamp_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_block_timestamp_t * self = (fd_vote_block_timestamp_t *)mem;
  fd_vote_block_timestamp_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_block_timestamp_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_block_timestamp_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_block_timestamp_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_block_timestamp_t * self = (fd_vote_block_timestamp_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
}
void * fd_vote_block_timestamp_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_block_timestamp_global_t * self = (fd_vote_block_timestamp_global_t *)mem;
  fd_vote_block_timestamp_new( (fd_vote_block_timestamp_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_block_timestamp_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_block_timestamp_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_block_timestamp_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_block_timestamp_global_t * self = (fd_vote_block_timestamp_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
}
int fd_vote_block_timestamp_convert_global_to_local( void const * global_self, fd_vote_block_timestamp_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_block_timestamp_global_t const * mem = (fd_vote_block_timestamp_global_t const *)global_self;
  self->slot = mem->slot;
  self->timestamp = mem->timestamp;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_block_timestamp_new(fd_vote_block_timestamp_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_block_timestamp_t) );
}
void fd_vote_block_timestamp_destroy( fd_vote_block_timestamp_t * self ) {
}

ulong fd_vote_block_timestamp_footprint( void ){ return FD_VOTE_BLOCK_TIMESTAMP_FOOTPRINT; }
ulong fd_vote_block_timestamp_align( void ){ return FD_VOTE_BLOCK_TIMESTAMP_ALIGN; }

void fd_vote_block_timestamp_walk( void * w, fd_vote_block_timestamp_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_block_timestamp", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_block_timestamp", level-- );
}
ulong fd_vote_block_timestamp_size( fd_vote_block_timestamp_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(long);
  return size;
}

int fd_vote_prior_voters_encode( fd_vote_prior_voters_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  for( ulong i=0; i<32; i++ ) {
    err = fd_vote_prior_voter_encode( self->buf + i, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->idx, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->is_empty), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_prior_voters_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_prior_voters_t);
  void const * start_data = ctx->data;
  int err = fd_vote_prior_voters_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_prior_voters_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  for( ulong i=0; i<32; i++ ) {
    err = fd_vote_prior_voter_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_prior_voters_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_t * self = (fd_vote_prior_voters_t *)mem;
  fd_vote_prior_voters_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voters_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voters_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voters_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_t * self = (fd_vote_prior_voters_t *)struct_mem;
  for( ulong i=0; i<32; i++ ) {
    fd_vote_prior_voter_decode_inner( self->buf + i, alloc_mem, ctx );
  }
  fd_bincode_uint64_decode_unsafe( &self->idx, ctx );
  fd_bincode_bool_decode_unsafe( &self->is_empty, ctx );
}
void * fd_vote_prior_voters_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_global_t * self = (fd_vote_prior_voters_global_t *)mem;
  fd_vote_prior_voters_new( (fd_vote_prior_voters_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voters_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voters_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voters_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_global_t * self = (fd_vote_prior_voters_global_t *)struct_mem;
  for( ulong i=0; i<32; i++ ) {
    fd_vote_prior_voter_decode_inner( self->buf + i, alloc_mem, ctx );
  }
  fd_bincode_uint64_decode_unsafe( &self->idx, ctx );
  fd_bincode_bool_decode_unsafe( &self->is_empty, ctx );
}
int fd_vote_prior_voters_convert_global_to_local( void const * global_self, fd_vote_prior_voters_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_prior_voters_global_t const * mem = (fd_vote_prior_voters_global_t const *)global_self;
  for( ulong i=0; i<32; i++ ) {
    fd_vote_prior_voter_convert_global_to_local( &mem->buf[i], &self->buf[i], ctx );
  }
  self->idx = mem->idx;
  self->is_empty = mem->is_empty;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_prior_voters_new(fd_vote_prior_voters_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_prior_voters_t) );
  for( ulong i=0; i<32; i++ )
    fd_vote_prior_voter_new( self->buf + i );
}
void fd_vote_prior_voters_destroy( fd_vote_prior_voters_t * self ) {
  for( ulong i=0; i<32; i++ )
    fd_vote_prior_voter_destroy( self->buf + i );
}

ulong fd_vote_prior_voters_footprint( void ){ return FD_VOTE_PRIOR_VOTERS_FOOTPRINT; }
ulong fd_vote_prior_voters_align( void ){ return FD_VOTE_PRIOR_VOTERS_ALIGN; }

void fd_vote_prior_voters_walk( void * w, fd_vote_prior_voters_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_prior_voters", level++ );
  fun( w, NULL, "buf", FD_FLAMENCO_TYPE_ARR, "vote_prior_voter[]", level++ );
  for( ulong i=0; i<32; i++ )
    fd_vote_prior_voter_walk( w, self->buf + i, fun, "vote_prior_voter", level );
  fun( w, NULL, "buf", FD_FLAMENCO_TYPE_ARR_END, "vote_prior_voter[]", level-- );
  fun( w, &self->idx, "idx", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->is_empty, "is_empty", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_prior_voters", level-- );
}
ulong fd_vote_prior_voters_size( fd_vote_prior_voters_t const * self ) {
  ulong size = 0;
  for( ulong i=0; i<32; i++ )
    size += fd_vote_prior_voter_size( self->buf + i );
  size += sizeof(ulong);
  size += sizeof(char);
  return size;
}

int fd_vote_prior_voters_0_23_5_encode( fd_vote_prior_voters_0_23_5_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  for( ulong i=0; i<32; i++ ) {
    err = fd_vote_prior_voter_0_23_5_encode( self->buf + i, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->idx, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_prior_voters_0_23_5_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_prior_voters_0_23_5_t);
  void const * start_data = ctx->data;
  int err = fd_vote_prior_voters_0_23_5_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_prior_voters_0_23_5_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  for( ulong i=0; i<32; i++ ) {
    err = fd_vote_prior_voter_0_23_5_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_vote_prior_voters_0_23_5_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_0_23_5_t * self = (fd_vote_prior_voters_0_23_5_t *)mem;
  fd_vote_prior_voters_0_23_5_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voters_0_23_5_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voters_0_23_5_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voters_0_23_5_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_0_23_5_t * self = (fd_vote_prior_voters_0_23_5_t *)struct_mem;
  for( ulong i=0; i<32; i++ ) {
    fd_vote_prior_voter_0_23_5_decode_inner( self->buf + i, alloc_mem, ctx );
  }
  fd_bincode_uint64_decode_unsafe( &self->idx, ctx );
}
void * fd_vote_prior_voters_0_23_5_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_0_23_5_global_t * self = (fd_vote_prior_voters_0_23_5_global_t *)mem;
  fd_vote_prior_voters_0_23_5_new( (fd_vote_prior_voters_0_23_5_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_prior_voters_0_23_5_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_prior_voters_0_23_5_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_prior_voters_0_23_5_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_prior_voters_0_23_5_global_t * self = (fd_vote_prior_voters_0_23_5_global_t *)struct_mem;
  for( ulong i=0; i<32; i++ ) {
    fd_vote_prior_voter_0_23_5_decode_inner( self->buf + i, alloc_mem, ctx );
  }
  fd_bincode_uint64_decode_unsafe( &self->idx, ctx );
}
int fd_vote_prior_voters_0_23_5_convert_global_to_local( void const * global_self, fd_vote_prior_voters_0_23_5_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_prior_voters_0_23_5_global_t const * mem = (fd_vote_prior_voters_0_23_5_global_t const *)global_self;
  for( ulong i=0; i<32; i++ ) {
    fd_vote_prior_voter_0_23_5_convert_global_to_local( &mem->buf[i], &self->buf[i], ctx );
  }
  self->idx = mem->idx;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_prior_voters_0_23_5_new(fd_vote_prior_voters_0_23_5_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_prior_voters_0_23_5_t) );
  for( ulong i=0; i<32; i++ )
    fd_vote_prior_voter_0_23_5_new( self->buf + i );
}
void fd_vote_prior_voters_0_23_5_destroy( fd_vote_prior_voters_0_23_5_t * self ) {
  for( ulong i=0; i<32; i++ )
    fd_vote_prior_voter_0_23_5_destroy( self->buf + i );
}

ulong fd_vote_prior_voters_0_23_5_footprint( void ){ return FD_VOTE_PRIOR_VOTERS_0_23_5_FOOTPRINT; }
ulong fd_vote_prior_voters_0_23_5_align( void ){ return FD_VOTE_PRIOR_VOTERS_0_23_5_ALIGN; }

void fd_vote_prior_voters_0_23_5_walk( void * w, fd_vote_prior_voters_0_23_5_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_prior_voters_0_23_5", level++ );
  fun( w, NULL, "buf", FD_FLAMENCO_TYPE_ARR, "vote_prior_voter_0_23_5[]", level++ );
  for( ulong i=0; i<32; i++ )
    fd_vote_prior_voter_0_23_5_walk( w, self->buf + i, fun, "vote_prior_voter_0_23_5", level );
  fun( w, NULL, "buf", FD_FLAMENCO_TYPE_ARR_END, "vote_prior_voter_0_23_5[]", level-- );
  fun( w, &self->idx, "idx", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_prior_voters_0_23_5", level-- );
}
ulong fd_vote_prior_voters_0_23_5_size( fd_vote_prior_voters_0_23_5_t const * self ) {
  ulong size = 0;
  for( ulong i=0; i<32; i++ )
    size += fd_vote_prior_voter_0_23_5_size( self->buf + i );
  size += sizeof(ulong);
  return size;
}

int fd_landed_vote_encode( fd_landed_vote_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->latency), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_lockout_encode( &self->lockout, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_landed_vote_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_landed_vote_t);
  void const * start_data = ctx->data;
  int err = fd_landed_vote_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_landed_vote_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_lockout_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_landed_vote_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_landed_vote_t * self = (fd_landed_vote_t *)mem;
  fd_landed_vote_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_landed_vote_t);
  void * * alloc_mem = &alloc_region;
  fd_landed_vote_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_landed_vote_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_landed_vote_t * self = (fd_landed_vote_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->latency, ctx );
  fd_vote_lockout_decode_inner( &self->lockout, alloc_mem, ctx );
}
void * fd_landed_vote_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_landed_vote_global_t * self = (fd_landed_vote_global_t *)mem;
  fd_landed_vote_new( (fd_landed_vote_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_landed_vote_global_t);
  void * * alloc_mem = &alloc_region;
  fd_landed_vote_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_landed_vote_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_landed_vote_global_t * self = (fd_landed_vote_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->latency, ctx );
  fd_vote_lockout_decode_inner_global( &self->lockout, alloc_mem, ctx );
}
int fd_landed_vote_convert_global_to_local( void const * global_self, fd_landed_vote_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_landed_vote_global_t const * mem = (fd_landed_vote_global_t const *)global_self;
  self->latency = mem->latency;
  err = fd_vote_lockout_convert_global_to_local( &mem->lockout, &self->lockout, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_landed_vote_new(fd_landed_vote_t * self) {
  fd_memset( self, 0, sizeof(fd_landed_vote_t) );
  fd_vote_lockout_new( &self->lockout );
}
void fd_landed_vote_destroy( fd_landed_vote_t * self ) {
  fd_vote_lockout_destroy( &self->lockout );
}

ulong fd_landed_vote_footprint( void ){ return FD_LANDED_VOTE_FOOTPRINT; }
ulong fd_landed_vote_align( void ){ return FD_LANDED_VOTE_ALIGN; }

void fd_landed_vote_walk( void * w, fd_landed_vote_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_landed_vote", level++ );
  fun( w, &self->latency, "latency", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_vote_lockout_walk( w, &self->lockout, fun, "lockout", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_landed_vote", level-- );
}
ulong fd_landed_vote_size( fd_landed_vote_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  size += fd_vote_lockout_size( &self->lockout );
  return size;
}

int fd_vote_state_0_23_5_encode( fd_vote_state_0_23_5_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authorized_voter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->authorized_voter_epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_0_23_5_encode( &self->prior_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->commission), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->votes ) {
    ulong votes_len = deq_fd_vote_lockout_t_cnt( self->votes );
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes ); !deq_fd_vote_lockout_t_iter_done( self->votes, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t const * ele = deq_fd_vote_lockout_t_iter_ele_const( self->votes, iter );
      err = fd_vote_lockout_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong votes_len = 0;
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_bool_encode( self->has_root_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_root_slot ) {
    err = fd_bincode_uint64_encode( self->root_slot, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  if( self->epoch_credits ) {
    ulong epoch_credits_len = deq_fd_vote_epoch_credits_t_cnt( self->epoch_credits );
    err = fd_bincode_uint64_encode( epoch_credits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t const * ele = deq_fd_vote_epoch_credits_t_iter_ele_const( self->epoch_credits, iter );
      err = fd_vote_epoch_credits_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong epoch_credits_len = 0;
    err = fd_bincode_uint64_encode( epoch_credits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_vote_block_timestamp_encode( &self->last_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_state_0_23_5_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_state_0_23_5_t);
  void const * start_data = ctx->data;
  int err = fd_vote_state_0_23_5_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_state_0_23_5_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_vote_prior_voters_0_23_5_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong votes_len;
  err = fd_bincode_uint64_decode( &votes_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  *total_sz += deq_fd_vote_lockout_t_align() + deq_fd_vote_lockout_t_footprint( votes_max );
  ulong votes_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( votes_len, 12, &votes_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( votes_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong epoch_credits_len;
  err = fd_bincode_uint64_decode( &epoch_credits_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  *total_sz += deq_fd_vote_epoch_credits_t_align() + deq_fd_vote_epoch_credits_t_footprint( epoch_credits_max );
  ulong epoch_credits_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( epoch_credits_len, 24, &epoch_credits_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( epoch_credits_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_block_timestamp_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_state_0_23_5_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_0_23_5_t * self = (fd_vote_state_0_23_5_t *)mem;
  fd_vote_state_0_23_5_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_0_23_5_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_0_23_5_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_0_23_5_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_0_23_5_t * self = (fd_vote_state_0_23_5_t *)struct_mem;
  fd_pubkey_decode_inner( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->authorized_voter, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->authorized_voter_epoch, ctx );
  fd_vote_prior_voters_0_23_5_decode_inner( &self->prior_voters, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  self->votes = deq_fd_vote_lockout_t_join_new( alloc_mem, votes_max );
  for( ulong i=0; i < votes_len; i++ ) {
    fd_vote_lockout_t * elem = deq_fd_vote_lockout_t_push_tail_nocopy( self->votes );
    fd_vote_lockout_new( elem );
    fd_vote_lockout_decode_inner( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root_slot = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root_slot, ctx );
    }
  }
  ulong epoch_credits_len;
  fd_bincode_uint64_decode_unsafe( &epoch_credits_len, ctx );
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  self->epoch_credits = deq_fd_vote_epoch_credits_t_join_new( alloc_mem, epoch_credits_max );
  for( ulong i=0; i < epoch_credits_len; i++ ) {
    fd_vote_epoch_credits_t * elem = deq_fd_vote_epoch_credits_t_push_tail_nocopy( self->epoch_credits );
    fd_vote_epoch_credits_new( elem );
    fd_vote_epoch_credits_decode_inner( elem, alloc_mem, ctx );
  }
  fd_vote_block_timestamp_decode_inner( &self->last_timestamp, alloc_mem, ctx );
}
void * fd_vote_state_0_23_5_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_0_23_5_global_t * self = (fd_vote_state_0_23_5_global_t *)mem;
  fd_vote_state_0_23_5_new( (fd_vote_state_0_23_5_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_0_23_5_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_0_23_5_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_0_23_5_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_0_23_5_global_t * self = (fd_vote_state_0_23_5_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->authorized_voter, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->authorized_voter_epoch, ctx );
  fd_vote_prior_voters_0_23_5_decode_inner_global( &self->prior_voters, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_vote_lockout_t_align() );
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  self->votes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_lockout_t * votes = deq_fd_vote_lockout_t_join_new( alloc_mem, votes_max );
  for( ulong i=0; i < votes_len; i++ ) {
    fd_vote_lockout_t * elem = deq_fd_vote_lockout_t_push_tail_nocopy( votes );
    fd_vote_lockout_new( elem );
    fd_vote_lockout_decode_inner_global( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root_slot = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root_slot, ctx );
    }
  }
  ulong epoch_credits_len;
  fd_bincode_uint64_decode_unsafe( &epoch_credits_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_vote_epoch_credits_t_align() );
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  self->epoch_credits_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_epoch_credits_t * epoch_credits = deq_fd_vote_epoch_credits_t_join_new( alloc_mem, epoch_credits_max );
  for( ulong i=0; i < epoch_credits_len; i++ ) {
    fd_vote_epoch_credits_t * elem = deq_fd_vote_epoch_credits_t_push_tail_nocopy( epoch_credits );
    fd_vote_epoch_credits_new( elem );
    fd_vote_epoch_credits_decode_inner_global( elem, alloc_mem, ctx );
  }
  fd_vote_block_timestamp_decode_inner_global( &self->last_timestamp, alloc_mem, ctx );
}
int fd_vote_state_0_23_5_convert_global_to_local( void const * global_self, fd_vote_state_0_23_5_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_state_0_23_5_global_t const * mem = (fd_vote_state_0_23_5_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->node_pubkey, &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->authorized_voter, &self->authorized_voter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->authorized_voter_epoch = mem->authorized_voter_epoch;
  err = fd_vote_prior_voters_0_23_5_convert_global_to_local( &mem->prior_voters, &self->prior_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->authorized_withdrawer, &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->commission = mem->commission;
  self->votes = deq_fd_vote_lockout_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->votes_gaddr ) );
  self->root_slot = mem->root_slot;
  self->has_root_slot = mem->has_root_slot;
  self->epoch_credits = deq_fd_vote_epoch_credits_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->epoch_credits_gaddr ) );
  err = fd_vote_block_timestamp_convert_global_to_local( &mem->last_timestamp, &self->last_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_state_0_23_5_new(fd_vote_state_0_23_5_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_state_0_23_5_t) );
  fd_pubkey_new( &self->node_pubkey );
  fd_pubkey_new( &self->authorized_voter );
  fd_vote_prior_voters_0_23_5_new( &self->prior_voters );
  fd_pubkey_new( &self->authorized_withdrawer );
  fd_vote_block_timestamp_new( &self->last_timestamp );
}
void fd_vote_state_0_23_5_destroy( fd_vote_state_0_23_5_t * self ) {
  fd_pubkey_destroy( &self->node_pubkey );
  fd_pubkey_destroy( &self->authorized_voter );
  fd_vote_prior_voters_0_23_5_destroy( &self->prior_voters );
  fd_pubkey_destroy( &self->authorized_withdrawer );
  if( self->votes ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes ); !deq_fd_vote_lockout_t_iter_done( self->votes, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->votes, iter );
      fd_vote_lockout_destroy( ele );
    }
    self->votes = NULL;
  }
  if( self->has_root_slot ) {
    self->has_root_slot = 0;
  }
  if( self->epoch_credits ) {
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      fd_vote_epoch_credits_destroy( ele );
    }
    self->epoch_credits = NULL;
  }
  fd_vote_block_timestamp_destroy( &self->last_timestamp );
}

ulong fd_vote_state_0_23_5_footprint( void ){ return FD_VOTE_STATE_0_23_5_FOOTPRINT; }
ulong fd_vote_state_0_23_5_align( void ){ return FD_VOTE_STATE_0_23_5_ALIGN; }

void fd_vote_state_0_23_5_walk( void * w, fd_vote_state_0_23_5_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_state_0_23_5", level++ );
  fd_pubkey_walk( w, &self->node_pubkey, fun, "node_pubkey", level );
  fd_pubkey_walk( w, &self->authorized_voter, fun, "authorized_voter", level );
  fun( w, &self->authorized_voter_epoch, "authorized_voter_epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_vote_prior_voters_0_23_5_walk( w, &self->prior_voters, fun, "prior_voters", level );
  fd_pubkey_walk( w, &self->authorized_withdrawer, fun, "authorized_withdrawer", level );
  fun( w, &self->commission, "commission", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );

  /* Walk deque */
  fun( w, self->votes, "votes", FD_FLAMENCO_TYPE_ARR, "votes", level++ );
  if( self->votes ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes );
         !deq_fd_vote_lockout_t_iter_done( self->votes, iter );
         iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->votes, iter );
      fd_vote_lockout_walk(w, ele, fun, "votes", level );
    }
  }
  fun( w, self->votes, "votes", FD_FLAMENCO_TYPE_ARR_END, "votes", level-- );
  /* Done walking deque */

  if( !self->has_root_slot ) {
    fun( w, NULL, "root_slot", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->root_slot, "root_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }

  /* Walk deque */
  fun( w, self->epoch_credits, "epoch_credits", FD_FLAMENCO_TYPE_ARR, "epoch_credits", level++ );
  if( self->epoch_credits ) {
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits );
         !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter );
         iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      fd_vote_epoch_credits_walk(w, ele, fun, "epoch_credits", level );
    }
  }
  fun( w, self->epoch_credits, "epoch_credits", FD_FLAMENCO_TYPE_ARR_END, "epoch_credits", level-- );
  /* Done walking deque */

  fd_vote_block_timestamp_walk( w, &self->last_timestamp, fun, "last_timestamp", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_state_0_23_5", level-- );
}
ulong fd_vote_state_0_23_5_size( fd_vote_state_0_23_5_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->node_pubkey );
  size += fd_pubkey_size( &self->authorized_voter );
  size += sizeof(ulong);
  size += fd_vote_prior_voters_0_23_5_size( &self->prior_voters );
  size += fd_pubkey_size( &self->authorized_withdrawer );
  size += sizeof(char);
  if( self->votes ) {
    size += sizeof(ulong);
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes ); !deq_fd_vote_lockout_t_iter_done( self->votes, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->votes, iter );
      size += fd_vote_lockout_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(char);
  if( self->has_root_slot ) {
    size += sizeof(ulong);
  }
  if( self->epoch_credits ) {
    size += sizeof(ulong);
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      size += fd_vote_epoch_credits_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += fd_vote_block_timestamp_size( &self->last_timestamp );
  return size;
}

int fd_vote_authorized_voters_encode( fd_vote_authorized_voters_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->treap ) {
    ulong fd_vote_authorized_voters_len = fd_vote_authorized_voters_treap_ele_cnt( self->treap );
    err = fd_bincode_uint64_encode( fd_vote_authorized_voters_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_vote_authorized_voters_treap_fwd_iter_t iter = fd_vote_authorized_voters_treap_fwd_iter_init( self->treap, self->pool );
         !fd_vote_authorized_voters_treap_fwd_iter_done( iter );
         iter = fd_vote_authorized_voters_treap_fwd_iter_next( iter, self->pool ) ) {
      fd_vote_authorized_voter_t * ele = fd_vote_authorized_voters_treap_fwd_iter_ele( iter, self->pool );
      err = fd_vote_authorized_voter_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong fd_vote_authorized_voters_len = 0;
    err = fd_bincode_uint64_encode( fd_vote_authorized_voters_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorized_voters_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_authorized_voters_t);
  void const * start_data = ctx->data;
  int err = fd_vote_authorized_voters_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_authorized_voters_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong fd_vote_authorized_voters_treap_len;
  err = fd_bincode_uint64_decode( &fd_vote_authorized_voters_treap_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong fd_vote_authorized_voters_treap_max = fd_ulong_max( fd_ulong_max( fd_vote_authorized_voters_treap_len, FD_VOTE_AUTHORIZED_VOTERS_MIN ), 1UL );
  *total_sz += fd_vote_authorized_voters_pool_align() + fd_vote_authorized_voters_pool_footprint( fd_vote_authorized_voters_treap_max );
  *total_sz += fd_vote_authorized_voters_treap_align() + fd_vote_authorized_voters_treap_footprint( fd_vote_authorized_voters_treap_max );
  for( ulong i=0; i < fd_vote_authorized_voters_treap_len; i++ ) {
    err = fd_vote_authorized_voter_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY ( err ) ) return err;
  }
  return 0;
}
void * fd_vote_authorized_voters_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voters_t * self = (fd_vote_authorized_voters_t *)mem;
  fd_vote_authorized_voters_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorized_voters_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorized_voters_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorized_voters_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voters_t * self = (fd_vote_authorized_voters_t *)struct_mem;
  ulong fd_vote_authorized_voters_treap_len;
  fd_bincode_uint64_decode_unsafe( &fd_vote_authorized_voters_treap_len, ctx );
  ulong fd_vote_authorized_voters_treap_max = fd_ulong_max( fd_vote_authorized_voters_treap_len, FD_VOTE_AUTHORIZED_VOTERS_MIN );
  self->pool = fd_vote_authorized_voters_pool_join_new( alloc_mem, fd_vote_authorized_voters_treap_max );
  self->treap = fd_vote_authorized_voters_treap_join_new( alloc_mem, fd_vote_authorized_voters_treap_max );
  for( ulong i=0; i < fd_vote_authorized_voters_treap_len; i++ ) {
    fd_vote_authorized_voter_t * ele = fd_vote_authorized_voters_pool_ele_acquire( self->pool );
    fd_vote_authorized_voter_new( ele );
    fd_vote_authorized_voter_decode_inner( ele, alloc_mem, ctx );
    fd_vote_authorized_voter_t * repeated_entry = fd_vote_authorized_voters_treap_ele_query( self->treap, ele->epoch, self->pool );
    if( repeated_entry ) {
        fd_vote_authorized_voters_treap_ele_remove( self->treap, repeated_entry, self->pool ); // Remove the element before inserting it back to avoid duplication
        fd_vote_authorized_voters_pool_ele_release( self->pool, repeated_entry );
    }
    fd_vote_authorized_voters_treap_ele_insert( self->treap, ele, self->pool ); /* this cannot fail */
  }
}
void * fd_vote_authorized_voters_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voters_global_t * self = (fd_vote_authorized_voters_global_t *)mem;
  fd_vote_authorized_voters_new( (fd_vote_authorized_voters_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorized_voters_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorized_voters_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorized_voters_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorized_voters_global_t * self = (fd_vote_authorized_voters_global_t *)struct_mem;
  ulong fd_vote_authorized_voters_treap_len;
  fd_bincode_uint64_decode_unsafe( &fd_vote_authorized_voters_treap_len, ctx );
  ulong fd_vote_authorized_voters_treap_max = fd_ulong_max( fd_vote_authorized_voters_treap_len, FD_VOTE_AUTHORIZED_VOTERS_MIN );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_vote_authorized_voters_pool_align() );
  self->pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_authorized_voter_t * pool = fd_vote_authorized_voters_pool_join_new( alloc_mem, fd_vote_authorized_voters_treap_max );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_vote_authorized_voters_treap_align() );
  self->treap_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_authorized_voters_treap_t * treap = fd_vote_authorized_voters_treap_join_new( alloc_mem, fd_vote_authorized_voters_treap_max );
  for( ulong i=0; i < fd_vote_authorized_voters_treap_len; i++ ) {
    fd_vote_authorized_voter_t * ele = fd_vote_authorized_voters_pool_ele_acquire( pool );
    fd_vote_authorized_voter_new( ele );
    fd_vote_authorized_voter_decode_inner( ele, alloc_mem, ctx );
    fd_vote_authorized_voter_t * repeated_entry = fd_vote_authorized_voters_treap_ele_query( treap, ele->epoch, pool );
    if( repeated_entry ) {
        fd_vote_authorized_voters_treap_ele_remove( treap, repeated_entry, pool ); // Remove the element before inserting it back to avoid duplication
        fd_vote_authorized_voters_pool_ele_release( pool, repeated_entry );
    }
    fd_vote_authorized_voters_treap_ele_insert( treap, ele, pool ); /* this cannot fail */
  }
}
int fd_vote_authorized_voters_convert_global_to_local( void const * global_self, fd_vote_authorized_voters_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_authorized_voters_global_t const * mem = (fd_vote_authorized_voters_global_t const *)global_self;
  self->pool  = fd_vote_authorized_voters_pool_join( fd_wksp_laddr_fast( ctx->wksp, mem->pool_gaddr ) );
  self->treap = fd_vote_authorized_voters_treap_join( fd_wksp_laddr_fast( ctx->wksp, mem->treap_gaddr ) );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_authorized_voters_new(fd_vote_authorized_voters_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_authorized_voters_t) );
}
void fd_vote_authorized_voters_destroy( fd_vote_authorized_voters_t * self ) {
  if( !self->treap || !self->pool ) return;
  for( fd_vote_authorized_voters_treap_fwd_iter_t iter = fd_vote_authorized_voters_treap_fwd_iter_init( self->treap, self->pool );
         !fd_vote_authorized_voters_treap_fwd_iter_done( iter );
         iter = fd_vote_authorized_voters_treap_fwd_iter_next( iter, self->pool ) ) {
      fd_vote_authorized_voter_t * ele = fd_vote_authorized_voters_treap_fwd_iter_ele( iter, self->pool );
      fd_vote_authorized_voter_destroy( ele );
    }
  self->pool = NULL;
  self->treap = NULL;
}

ulong fd_vote_authorized_voters_footprint( void ){ return FD_VOTE_AUTHORIZED_VOTERS_FOOTPRINT; }
ulong fd_vote_authorized_voters_align( void ){ return FD_VOTE_AUTHORIZED_VOTERS_ALIGN; }

void fd_vote_authorized_voters_walk( void * w, fd_vote_authorized_voters_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_authorized_voters", level++ );
  if( self->treap ) {
    for( fd_vote_authorized_voters_treap_fwd_iter_t iter = fd_vote_authorized_voters_treap_fwd_iter_init( self->treap, self->pool );
         !fd_vote_authorized_voters_treap_fwd_iter_done( iter );
         iter = fd_vote_authorized_voters_treap_fwd_iter_next( iter, self->pool ) ) {
      fd_vote_authorized_voter_t * ele = fd_vote_authorized_voters_treap_fwd_iter_ele( iter, self->pool );
      fd_vote_authorized_voter_walk( w, ele, fun, "fd_vote_authorized_voter_t", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_authorized_voters", level-- );
}
ulong fd_vote_authorized_voters_size( fd_vote_authorized_voters_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  if( self->treap ) {
    for( fd_vote_authorized_voters_treap_fwd_iter_t iter = fd_vote_authorized_voters_treap_fwd_iter_init( self->treap, self->pool );
         !fd_vote_authorized_voters_treap_fwd_iter_done( iter );
         iter = fd_vote_authorized_voters_treap_fwd_iter_next( iter, self->pool ) ) {
      fd_vote_authorized_voter_t * ele = fd_vote_authorized_voters_treap_fwd_iter_ele( iter, self->pool );
      size += fd_vote_authorized_voter_size( ele );
    }
  }
  return size;
}

int fd_vote_state_1_14_11_encode( fd_vote_state_1_14_11_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->commission), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->votes ) {
    ulong votes_len = deq_fd_vote_lockout_t_cnt( self->votes );
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes ); !deq_fd_vote_lockout_t_iter_done( self->votes, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t const * ele = deq_fd_vote_lockout_t_iter_ele_const( self->votes, iter );
      err = fd_vote_lockout_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong votes_len = 0;
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_bool_encode( self->has_root_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_root_slot ) {
    err = fd_bincode_uint64_encode( self->root_slot, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_vote_authorized_voters_encode( &self->authorized_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_encode( &self->prior_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->epoch_credits ) {
    ulong epoch_credits_len = deq_fd_vote_epoch_credits_t_cnt( self->epoch_credits );
    err = fd_bincode_uint64_encode( epoch_credits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t const * ele = deq_fd_vote_epoch_credits_t_iter_ele_const( self->epoch_credits, iter );
      err = fd_vote_epoch_credits_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong epoch_credits_len = 0;
    err = fd_bincode_uint64_encode( epoch_credits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_vote_block_timestamp_encode( &self->last_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_state_1_14_11_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_state_1_14_11_t);
  void const * start_data = ctx->data;
  int err = fd_vote_state_1_14_11_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_state_1_14_11_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong votes_len;
  err = fd_bincode_uint64_decode( &votes_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  *total_sz += deq_fd_vote_lockout_t_align() + deq_fd_vote_lockout_t_footprint( votes_max );
  ulong votes_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( votes_len, 12, &votes_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( votes_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_vote_authorized_voters_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong epoch_credits_len;
  err = fd_bincode_uint64_decode( &epoch_credits_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  *total_sz += deq_fd_vote_epoch_credits_t_align() + deq_fd_vote_epoch_credits_t_footprint( epoch_credits_max );
  ulong epoch_credits_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( epoch_credits_len, 24, &epoch_credits_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( epoch_credits_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_block_timestamp_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_state_1_14_11_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_1_14_11_t * self = (fd_vote_state_1_14_11_t *)mem;
  fd_vote_state_1_14_11_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_1_14_11_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_1_14_11_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_1_14_11_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_1_14_11_t * self = (fd_vote_state_1_14_11_t *)struct_mem;
  fd_pubkey_decode_inner( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  self->votes = deq_fd_vote_lockout_t_join_new( alloc_mem, votes_max );
  for( ulong i=0; i < votes_len; i++ ) {
    fd_vote_lockout_t * elem = deq_fd_vote_lockout_t_push_tail_nocopy( self->votes );
    fd_vote_lockout_new( elem );
    fd_vote_lockout_decode_inner( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root_slot = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root_slot, ctx );
    }
  }
  fd_vote_authorized_voters_decode_inner( &self->authorized_voters, alloc_mem, ctx );
  fd_vote_prior_voters_decode_inner( &self->prior_voters, alloc_mem, ctx );
  ulong epoch_credits_len;
  fd_bincode_uint64_decode_unsafe( &epoch_credits_len, ctx );
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  self->epoch_credits = deq_fd_vote_epoch_credits_t_join_new( alloc_mem, epoch_credits_max );
  for( ulong i=0; i < epoch_credits_len; i++ ) {
    fd_vote_epoch_credits_t * elem = deq_fd_vote_epoch_credits_t_push_tail_nocopy( self->epoch_credits );
    fd_vote_epoch_credits_new( elem );
    fd_vote_epoch_credits_decode_inner( elem, alloc_mem, ctx );
  }
  fd_vote_block_timestamp_decode_inner( &self->last_timestamp, alloc_mem, ctx );
}
void * fd_vote_state_1_14_11_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_1_14_11_global_t * self = (fd_vote_state_1_14_11_global_t *)mem;
  fd_vote_state_1_14_11_new( (fd_vote_state_1_14_11_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_1_14_11_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_1_14_11_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_1_14_11_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_1_14_11_global_t * self = (fd_vote_state_1_14_11_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_vote_lockout_t_align() );
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  self->votes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_lockout_t * votes = deq_fd_vote_lockout_t_join_new( alloc_mem, votes_max );
  for( ulong i=0; i < votes_len; i++ ) {
    fd_vote_lockout_t * elem = deq_fd_vote_lockout_t_push_tail_nocopy( votes );
    fd_vote_lockout_new( elem );
    fd_vote_lockout_decode_inner_global( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root_slot = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root_slot, ctx );
    }
  }
  fd_vote_authorized_voters_decode_inner_global( &self->authorized_voters, alloc_mem, ctx );
  fd_vote_prior_voters_decode_inner_global( &self->prior_voters, alloc_mem, ctx );
  ulong epoch_credits_len;
  fd_bincode_uint64_decode_unsafe( &epoch_credits_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_vote_epoch_credits_t_align() );
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  self->epoch_credits_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_epoch_credits_t * epoch_credits = deq_fd_vote_epoch_credits_t_join_new( alloc_mem, epoch_credits_max );
  for( ulong i=0; i < epoch_credits_len; i++ ) {
    fd_vote_epoch_credits_t * elem = deq_fd_vote_epoch_credits_t_push_tail_nocopy( epoch_credits );
    fd_vote_epoch_credits_new( elem );
    fd_vote_epoch_credits_decode_inner_global( elem, alloc_mem, ctx );
  }
  fd_vote_block_timestamp_decode_inner_global( &self->last_timestamp, alloc_mem, ctx );
}
int fd_vote_state_1_14_11_convert_global_to_local( void const * global_self, fd_vote_state_1_14_11_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_state_1_14_11_global_t const * mem = (fd_vote_state_1_14_11_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->node_pubkey, &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->authorized_withdrawer, &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->commission = mem->commission;
  self->votes = deq_fd_vote_lockout_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->votes_gaddr ) );
  self->root_slot = mem->root_slot;
  self->has_root_slot = mem->has_root_slot;
  err = fd_vote_authorized_voters_convert_global_to_local( &mem->authorized_voters, &self->authorized_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_convert_global_to_local( &mem->prior_voters, &self->prior_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->epoch_credits = deq_fd_vote_epoch_credits_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->epoch_credits_gaddr ) );
  err = fd_vote_block_timestamp_convert_global_to_local( &mem->last_timestamp, &self->last_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_state_1_14_11_new(fd_vote_state_1_14_11_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_state_1_14_11_t) );
  fd_pubkey_new( &self->node_pubkey );
  fd_pubkey_new( &self->authorized_withdrawer );
  fd_vote_authorized_voters_new( &self->authorized_voters );
  fd_vote_prior_voters_new( &self->prior_voters );
  fd_vote_block_timestamp_new( &self->last_timestamp );
}
void fd_vote_state_1_14_11_destroy( fd_vote_state_1_14_11_t * self ) {
  fd_pubkey_destroy( &self->node_pubkey );
  fd_pubkey_destroy( &self->authorized_withdrawer );
  if( self->votes ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes ); !deq_fd_vote_lockout_t_iter_done( self->votes, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->votes, iter );
      fd_vote_lockout_destroy( ele );
    }
    self->votes = NULL;
  }
  if( self->has_root_slot ) {
    self->has_root_slot = 0;
  }
  fd_vote_authorized_voters_destroy( &self->authorized_voters );
  fd_vote_prior_voters_destroy( &self->prior_voters );
  if( self->epoch_credits ) {
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      fd_vote_epoch_credits_destroy( ele );
    }
    self->epoch_credits = NULL;
  }
  fd_vote_block_timestamp_destroy( &self->last_timestamp );
}

ulong fd_vote_state_1_14_11_footprint( void ){ return FD_VOTE_STATE_1_14_11_FOOTPRINT; }
ulong fd_vote_state_1_14_11_align( void ){ return FD_VOTE_STATE_1_14_11_ALIGN; }

void fd_vote_state_1_14_11_walk( void * w, fd_vote_state_1_14_11_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_state_1_14_11", level++ );
  fd_pubkey_walk( w, &self->node_pubkey, fun, "node_pubkey", level );
  fd_pubkey_walk( w, &self->authorized_withdrawer, fun, "authorized_withdrawer", level );
  fun( w, &self->commission, "commission", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );

  /* Walk deque */
  fun( w, self->votes, "votes", FD_FLAMENCO_TYPE_ARR, "votes", level++ );
  if( self->votes ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes );
         !deq_fd_vote_lockout_t_iter_done( self->votes, iter );
         iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->votes, iter );
      fd_vote_lockout_walk(w, ele, fun, "votes", level );
    }
  }
  fun( w, self->votes, "votes", FD_FLAMENCO_TYPE_ARR_END, "votes", level-- );
  /* Done walking deque */

  if( !self->has_root_slot ) {
    fun( w, NULL, "root_slot", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->root_slot, "root_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fd_vote_authorized_voters_walk( w, &self->authorized_voters, fun, "authorized_voters", level );
  fd_vote_prior_voters_walk( w, &self->prior_voters, fun, "prior_voters", level );

  /* Walk deque */
  fun( w, self->epoch_credits, "epoch_credits", FD_FLAMENCO_TYPE_ARR, "epoch_credits", level++ );
  if( self->epoch_credits ) {
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits );
         !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter );
         iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      fd_vote_epoch_credits_walk(w, ele, fun, "epoch_credits", level );
    }
  }
  fun( w, self->epoch_credits, "epoch_credits", FD_FLAMENCO_TYPE_ARR_END, "epoch_credits", level-- );
  /* Done walking deque */

  fd_vote_block_timestamp_walk( w, &self->last_timestamp, fun, "last_timestamp", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_state_1_14_11", level-- );
}
ulong fd_vote_state_1_14_11_size( fd_vote_state_1_14_11_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->node_pubkey );
  size += fd_pubkey_size( &self->authorized_withdrawer );
  size += sizeof(char);
  if( self->votes ) {
    size += sizeof(ulong);
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->votes ); !deq_fd_vote_lockout_t_iter_done( self->votes, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->votes, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->votes, iter );
      size += fd_vote_lockout_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(char);
  if( self->has_root_slot ) {
    size += sizeof(ulong);
  }
  size += fd_vote_authorized_voters_size( &self->authorized_voters );
  size += fd_vote_prior_voters_size( &self->prior_voters );
  if( self->epoch_credits ) {
    size += sizeof(ulong);
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      size += fd_vote_epoch_credits_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += fd_vote_block_timestamp_size( &self->last_timestamp );
  return size;
}

int fd_vote_state_encode( fd_vote_state_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->commission), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->votes ) {
    ulong votes_len = deq_fd_landed_vote_t_cnt( self->votes );
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_landed_vote_t_iter_t iter = deq_fd_landed_vote_t_iter_init( self->votes ); !deq_fd_landed_vote_t_iter_done( self->votes, iter ); iter = deq_fd_landed_vote_t_iter_next( self->votes, iter ) ) {
      fd_landed_vote_t const * ele = deq_fd_landed_vote_t_iter_ele_const( self->votes, iter );
      err = fd_landed_vote_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong votes_len = 0;
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_bool_encode( self->has_root_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_root_slot ) {
    err = fd_bincode_uint64_encode( self->root_slot, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_vote_authorized_voters_encode( &self->authorized_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_encode( &self->prior_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->epoch_credits ) {
    ulong epoch_credits_len = deq_fd_vote_epoch_credits_t_cnt( self->epoch_credits );
    err = fd_bincode_uint64_encode( epoch_credits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t const * ele = deq_fd_vote_epoch_credits_t_iter_ele_const( self->epoch_credits, iter );
      err = fd_vote_epoch_credits_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong epoch_credits_len = 0;
    err = fd_bincode_uint64_encode( epoch_credits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_vote_block_timestamp_encode( &self->last_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_state_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_state_t);
  void const * start_data = ctx->data;
  int err = fd_vote_state_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_state_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong votes_len;
  err = fd_bincode_uint64_decode( &votes_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  *total_sz += deq_fd_landed_vote_t_align() + deq_fd_landed_vote_t_footprint( votes_max );
  ulong votes_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( votes_len, 13, &votes_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( votes_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_vote_authorized_voters_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong epoch_credits_len;
  err = fd_bincode_uint64_decode( &epoch_credits_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  *total_sz += deq_fd_vote_epoch_credits_t_align() + deq_fd_vote_epoch_credits_t_footprint( epoch_credits_max );
  ulong epoch_credits_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( epoch_credits_len, 24, &epoch_credits_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( epoch_credits_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_block_timestamp_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_state_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_t * self = (fd_vote_state_t *)mem;
  fd_vote_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_t * self = (fd_vote_state_t *)struct_mem;
  fd_pubkey_decode_inner( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  self->votes = deq_fd_landed_vote_t_join_new( alloc_mem, votes_max );
  for( ulong i=0; i < votes_len; i++ ) {
    fd_landed_vote_t * elem = deq_fd_landed_vote_t_push_tail_nocopy( self->votes );
    fd_landed_vote_new( elem );
    fd_landed_vote_decode_inner( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root_slot = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root_slot, ctx );
    }
  }
  fd_vote_authorized_voters_decode_inner( &self->authorized_voters, alloc_mem, ctx );
  fd_vote_prior_voters_decode_inner( &self->prior_voters, alloc_mem, ctx );
  ulong epoch_credits_len;
  fd_bincode_uint64_decode_unsafe( &epoch_credits_len, ctx );
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  self->epoch_credits = deq_fd_vote_epoch_credits_t_join_new( alloc_mem, epoch_credits_max );
  for( ulong i=0; i < epoch_credits_len; i++ ) {
    fd_vote_epoch_credits_t * elem = deq_fd_vote_epoch_credits_t_push_tail_nocopy( self->epoch_credits );
    fd_vote_epoch_credits_new( elem );
    fd_vote_epoch_credits_decode_inner( elem, alloc_mem, ctx );
  }
  fd_vote_block_timestamp_decode_inner( &self->last_timestamp, alloc_mem, ctx );
}
void * fd_vote_state_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_global_t * self = (fd_vote_state_global_t *)mem;
  fd_vote_state_new( (fd_vote_state_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_global_t * self = (fd_vote_state_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_landed_vote_t_align() );
  ulong votes_max = fd_ulong_max( votes_len, 32 );
  self->votes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_landed_vote_t * votes = deq_fd_landed_vote_t_join_new( alloc_mem, votes_max );
  for( ulong i=0; i < votes_len; i++ ) {
    fd_landed_vote_t * elem = deq_fd_landed_vote_t_push_tail_nocopy( votes );
    fd_landed_vote_new( elem );
    fd_landed_vote_decode_inner_global( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root_slot = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root_slot, ctx );
    }
  }
  fd_vote_authorized_voters_decode_inner_global( &self->authorized_voters, alloc_mem, ctx );
  fd_vote_prior_voters_decode_inner_global( &self->prior_voters, alloc_mem, ctx );
  ulong epoch_credits_len;
  fd_bincode_uint64_decode_unsafe( &epoch_credits_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_vote_epoch_credits_t_align() );
  ulong epoch_credits_max = fd_ulong_max( epoch_credits_len, 64 );
  self->epoch_credits_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_epoch_credits_t * epoch_credits = deq_fd_vote_epoch_credits_t_join_new( alloc_mem, epoch_credits_max );
  for( ulong i=0; i < epoch_credits_len; i++ ) {
    fd_vote_epoch_credits_t * elem = deq_fd_vote_epoch_credits_t_push_tail_nocopy( epoch_credits );
    fd_vote_epoch_credits_new( elem );
    fd_vote_epoch_credits_decode_inner_global( elem, alloc_mem, ctx );
  }
  fd_vote_block_timestamp_decode_inner_global( &self->last_timestamp, alloc_mem, ctx );
}
int fd_vote_state_convert_global_to_local( void const * global_self, fd_vote_state_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_state_global_t const * mem = (fd_vote_state_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->node_pubkey, &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->authorized_withdrawer, &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->commission = mem->commission;
  self->votes = deq_fd_landed_vote_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->votes_gaddr ) );
  self->root_slot = mem->root_slot;
  self->has_root_slot = mem->has_root_slot;
  err = fd_vote_authorized_voters_convert_global_to_local( &mem->authorized_voters, &self->authorized_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_prior_voters_convert_global_to_local( &mem->prior_voters, &self->prior_voters, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->epoch_credits = deq_fd_vote_epoch_credits_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->epoch_credits_gaddr ) );
  err = fd_vote_block_timestamp_convert_global_to_local( &mem->last_timestamp, &self->last_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_state_new(fd_vote_state_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_state_t) );
  fd_pubkey_new( &self->node_pubkey );
  fd_pubkey_new( &self->authorized_withdrawer );
  fd_vote_authorized_voters_new( &self->authorized_voters );
  fd_vote_prior_voters_new( &self->prior_voters );
  fd_vote_block_timestamp_new( &self->last_timestamp );
}
void fd_vote_state_destroy( fd_vote_state_t * self ) {
  fd_pubkey_destroy( &self->node_pubkey );
  fd_pubkey_destroy( &self->authorized_withdrawer );
  if( self->votes ) {
    for( deq_fd_landed_vote_t_iter_t iter = deq_fd_landed_vote_t_iter_init( self->votes ); !deq_fd_landed_vote_t_iter_done( self->votes, iter ); iter = deq_fd_landed_vote_t_iter_next( self->votes, iter ) ) {
      fd_landed_vote_t * ele = deq_fd_landed_vote_t_iter_ele( self->votes, iter );
      fd_landed_vote_destroy( ele );
    }
    self->votes = NULL;
  }
  if( self->has_root_slot ) {
    self->has_root_slot = 0;
  }
  fd_vote_authorized_voters_destroy( &self->authorized_voters );
  fd_vote_prior_voters_destroy( &self->prior_voters );
  if( self->epoch_credits ) {
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      fd_vote_epoch_credits_destroy( ele );
    }
    self->epoch_credits = NULL;
  }
  fd_vote_block_timestamp_destroy( &self->last_timestamp );
}

ulong fd_vote_state_footprint( void ){ return FD_VOTE_STATE_FOOTPRINT; }
ulong fd_vote_state_align( void ){ return FD_VOTE_STATE_ALIGN; }

void fd_vote_state_walk( void * w, fd_vote_state_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_state", level++ );
  fd_pubkey_walk( w, &self->node_pubkey, fun, "node_pubkey", level );
  fd_pubkey_walk( w, &self->authorized_withdrawer, fun, "authorized_withdrawer", level );
  fun( w, &self->commission, "commission", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );

  /* Walk deque */
  fun( w, self->votes, "votes", FD_FLAMENCO_TYPE_ARR, "votes", level++ );
  if( self->votes ) {
    for( deq_fd_landed_vote_t_iter_t iter = deq_fd_landed_vote_t_iter_init( self->votes );
         !deq_fd_landed_vote_t_iter_done( self->votes, iter );
         iter = deq_fd_landed_vote_t_iter_next( self->votes, iter ) ) {
      fd_landed_vote_t * ele = deq_fd_landed_vote_t_iter_ele( self->votes, iter );
      fd_landed_vote_walk(w, ele, fun, "votes", level );
    }
  }
  fun( w, self->votes, "votes", FD_FLAMENCO_TYPE_ARR_END, "votes", level-- );
  /* Done walking deque */

  if( !self->has_root_slot ) {
    fun( w, NULL, "root_slot", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->root_slot, "root_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fd_vote_authorized_voters_walk( w, &self->authorized_voters, fun, "authorized_voters", level );
  fd_vote_prior_voters_walk( w, &self->prior_voters, fun, "prior_voters", level );

  /* Walk deque */
  fun( w, self->epoch_credits, "epoch_credits", FD_FLAMENCO_TYPE_ARR, "epoch_credits", level++ );
  if( self->epoch_credits ) {
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits );
         !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter );
         iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      fd_vote_epoch_credits_walk(w, ele, fun, "epoch_credits", level );
    }
  }
  fun( w, self->epoch_credits, "epoch_credits", FD_FLAMENCO_TYPE_ARR_END, "epoch_credits", level-- );
  /* Done walking deque */

  fd_vote_block_timestamp_walk( w, &self->last_timestamp, fun, "last_timestamp", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_state", level-- );
}
ulong fd_vote_state_size( fd_vote_state_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->node_pubkey );
  size += fd_pubkey_size( &self->authorized_withdrawer );
  size += sizeof(char);
  if( self->votes ) {
    size += sizeof(ulong);
    for( deq_fd_landed_vote_t_iter_t iter = deq_fd_landed_vote_t_iter_init( self->votes ); !deq_fd_landed_vote_t_iter_done( self->votes, iter ); iter = deq_fd_landed_vote_t_iter_next( self->votes, iter ) ) {
      fd_landed_vote_t * ele = deq_fd_landed_vote_t_iter_ele( self->votes, iter );
      size += fd_landed_vote_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(char);
  if( self->has_root_slot ) {
    size += sizeof(ulong);
  }
  size += fd_vote_authorized_voters_size( &self->authorized_voters );
  size += fd_vote_prior_voters_size( &self->prior_voters );
  if( self->epoch_credits ) {
    size += sizeof(ulong);
    for( deq_fd_vote_epoch_credits_t_iter_t iter = deq_fd_vote_epoch_credits_t_iter_init( self->epoch_credits ); !deq_fd_vote_epoch_credits_t_iter_done( self->epoch_credits, iter ); iter = deq_fd_vote_epoch_credits_t_iter_next( self->epoch_credits, iter ) ) {
      fd_vote_epoch_credits_t * ele = deq_fd_vote_epoch_credits_t_iter_ele( self->epoch_credits, iter );
      size += fd_vote_epoch_credits_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += fd_vote_block_timestamp_size( &self->last_timestamp );
  return size;
}

FD_FN_PURE uchar fd_vote_state_versioned_is_v0_23_5(fd_vote_state_versioned_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_vote_state_versioned_is_v1_14_11(fd_vote_state_versioned_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_vote_state_versioned_is_current(fd_vote_state_versioned_t const * self) {
  return self->discriminant == 2;
}
void fd_vote_state_versioned_inner_new( fd_vote_state_versioned_inner_t * self, uint discriminant );
int fd_vote_state_versioned_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_vote_state_0_23_5_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_vote_state_1_14_11_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_vote_state_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_vote_state_versioned_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_state_versioned_t);
  void const * start_data = ctx->data;
  int err =  fd_vote_state_versioned_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_state_versioned_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_vote_state_versioned_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_vote_state_versioned_inner_decode_inner( fd_vote_state_versioned_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_vote_state_0_23_5_decode_inner( &self->v0_23_5, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_vote_state_1_14_11_decode_inner( &self->v1_14_11, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_vote_state_decode_inner( &self->current, alloc_mem, ctx );
    break;
  }
  }
}
void fd_vote_state_versioned_inner_decode_inner_global( fd_vote_state_versioned_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_vote_state_0_23_5_decode_inner_global( &self->v0_23_5, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_vote_state_1_14_11_decode_inner_global( &self->v1_14_11, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_vote_state_decode_inner_global( &self->current, alloc_mem, ctx );
    break;
  }
  }
}
int fd_vote_state_versioned_convert_global_to_local_inner( fd_vote_state_versioned_inner_global_t const * mem, fd_vote_state_versioned_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_vote_state_0_23_5_convert_global_to_local( &mem->v0_23_5, &self->v0_23_5, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_vote_state_1_14_11_convert_global_to_local( &mem->v1_14_11, &self->v1_14_11, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_vote_state_convert_global_to_local( &mem->current, &self->current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_state_versioned_convert_global_to_local( void const * global_self, fd_vote_state_versioned_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_versioned_global_t const * mem = (fd_vote_state_versioned_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_vote_state_versioned_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_state_versioned_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_versioned_t * self = (fd_vote_state_versioned_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_vote_state_versioned_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_vote_state_versioned_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_versioned_t * self = (fd_vote_state_versioned_t *)mem;
  fd_vote_state_versioned_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_versioned_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_versioned_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_vote_state_versioned_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_versioned_t * self = (fd_vote_state_versioned_t *)mem;
  fd_vote_state_versioned_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_versioned_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_versioned_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_versioned_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_versioned_global_t * self = (fd_vote_state_versioned_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_vote_state_versioned_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_vote_state_versioned_inner_new( fd_vote_state_versioned_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_vote_state_0_23_5_new( &self->v0_23_5 );
    break;
  }
  case 1: {
    fd_vote_state_1_14_11_new( &self->v1_14_11 );
    break;
  }
  case 2: {
    fd_vote_state_new( &self->current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_vote_state_versioned_new_disc( fd_vote_state_versioned_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_vote_state_versioned_inner_new( &self->inner, self->discriminant );
}
void fd_vote_state_versioned_new( fd_vote_state_versioned_t * self ) {
  fd_memset( self, 0, sizeof(fd_vote_state_versioned_t) );
  fd_vote_state_versioned_new_disc( self, UINT_MAX );
}
void fd_vote_state_versioned_inner_destroy( fd_vote_state_versioned_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_vote_state_0_23_5_destroy( &self->v0_23_5 );
    break;
  }
  case 1: {
    fd_vote_state_1_14_11_destroy( &self->v1_14_11 );
    break;
  }
  case 2: {
    fd_vote_state_destroy( &self->current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_vote_state_versioned_destroy( fd_vote_state_versioned_t * self ) {
  fd_vote_state_versioned_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_vote_state_versioned_footprint( void ){ return FD_VOTE_STATE_VERSIONED_FOOTPRINT; }
ulong fd_vote_state_versioned_align( void ){ return FD_VOTE_STATE_VERSIONED_ALIGN; }

void fd_vote_state_versioned_walk( void * w, fd_vote_state_versioned_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_vote_state_versioned", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "v0_23_5", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_state_0_23_5_walk( w, &self->inner.v0_23_5, fun, "v0_23_5", level );
    break;
  }
  case 1: {
    fun( w, self, "v1_14_11", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_state_1_14_11_walk( w, &self->inner.v1_14_11, fun, "v1_14_11", level );
    break;
  }
  case 2: {
    fun( w, self, "current", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_state_walk( w, &self->inner.current, fun, "current", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_vote_state_versioned", level-- );
}
ulong fd_vote_state_versioned_size( fd_vote_state_versioned_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_vote_state_0_23_5_size( &self->inner.v0_23_5 );
    break;
  }
  case 1: {
    size += fd_vote_state_1_14_11_size( &self->inner.v1_14_11 );
    break;
  }
  case 2: {
    size += fd_vote_state_size( &self->inner.current );
    break;
  }
  }
  return size;
}

int fd_vote_state_versioned_inner_encode( fd_vote_state_versioned_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_vote_state_0_23_5_encode( &self->v0_23_5, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_vote_state_1_14_11_encode( &self->v1_14_11, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_vote_state_encode( &self->current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_state_versioned_encode( fd_vote_state_versioned_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_vote_state_versioned_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_vote_state_update_encode( fd_vote_state_update_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->lockouts ) {
    ulong lockouts_len = deq_fd_vote_lockout_t_cnt( self->lockouts );
    err = fd_bincode_uint64_encode( lockouts_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts ); !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t const * ele = deq_fd_vote_lockout_t_iter_ele_const( self->lockouts, iter );
      err = fd_vote_lockout_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong lockouts_len = 0;
    err = fd_bincode_uint64_encode( lockouts_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_bool_encode( self->has_root, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_root ) {
    err = fd_bincode_uint64_encode( self->root, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_timestamp ) {
    err = fd_bincode_int64_encode( self->timestamp, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_state_update_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_state_update_t);
  void const * start_data = ctx->data;
  int err = fd_vote_state_update_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_state_update_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong lockouts_len;
  err = fd_bincode_uint64_decode( &lockouts_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong lockouts_max = fd_ulong_max( lockouts_len, 32 );
  *total_sz += deq_fd_vote_lockout_t_align() + deq_fd_vote_lockout_t_footprint( lockouts_max );
  ulong lockouts_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( lockouts_len, 12, &lockouts_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( lockouts_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_int64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_vote_state_update_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_update_t * self = (fd_vote_state_update_t *)mem;
  fd_vote_state_update_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_update_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_update_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_update_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_update_t * self = (fd_vote_state_update_t *)struct_mem;
  ulong lockouts_len;
  fd_bincode_uint64_decode_unsafe( &lockouts_len, ctx );
  ulong lockouts_max = fd_ulong_max( lockouts_len, 32 );
  self->lockouts = deq_fd_vote_lockout_t_join_new( alloc_mem, lockouts_max );
  for( ulong i=0; i < lockouts_len; i++ ) {
    fd_vote_lockout_t * elem = deq_fd_vote_lockout_t_push_tail_nocopy( self->lockouts );
    fd_vote_lockout_new( elem );
    fd_vote_lockout_decode_inner( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root, ctx );
    }
  }
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_timestamp = !!o;
    if( o ) {
      fd_bincode_int64_decode_unsafe( &self->timestamp, ctx );
    }
  }
}
void * fd_vote_state_update_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_update_global_t * self = (fd_vote_state_update_global_t *)mem;
  fd_vote_state_update_new( (fd_vote_state_update_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_state_update_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_state_update_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_state_update_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_state_update_global_t * self = (fd_vote_state_update_global_t *)struct_mem;
  ulong lockouts_len;
  fd_bincode_uint64_decode_unsafe( &lockouts_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_vote_lockout_t_align() );
  ulong lockouts_max = fd_ulong_max( lockouts_len, 32 );
  self->lockouts_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_vote_lockout_t * lockouts = deq_fd_vote_lockout_t_join_new( alloc_mem, lockouts_max );
  for( ulong i=0; i < lockouts_len; i++ ) {
    fd_vote_lockout_t * elem = deq_fd_vote_lockout_t_push_tail_nocopy( lockouts );
    fd_vote_lockout_new( elem );
    fd_vote_lockout_decode_inner_global( elem, alloc_mem, ctx );
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_root = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->root, ctx );
    }
  }
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_timestamp = !!o;
    if( o ) {
      fd_bincode_int64_decode_unsafe( &self->timestamp, ctx );
    }
  }
}
int fd_vote_state_update_convert_global_to_local( void const * global_self, fd_vote_state_update_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_state_update_global_t const * mem = (fd_vote_state_update_global_t const *)global_self;
  self->lockouts = deq_fd_vote_lockout_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->lockouts_gaddr ) );
  self->root = mem->root;
  self->has_root = mem->has_root;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = mem->timestamp;
  self->has_timestamp = mem->has_timestamp;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_state_update_new(fd_vote_state_update_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_state_update_t) );
  fd_hash_new( &self->hash );
}
void fd_vote_state_update_destroy( fd_vote_state_update_t * self ) {
  if( self->lockouts ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts ); !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->lockouts, iter );
      fd_vote_lockout_destroy( ele );
    }
    self->lockouts = NULL;
  }
  if( self->has_root ) {
    self->has_root = 0;
  }
  fd_hash_destroy( &self->hash );
  if( self->has_timestamp ) {
    self->has_timestamp = 0;
  }
}

ulong fd_vote_state_update_footprint( void ){ return FD_VOTE_STATE_UPDATE_FOOTPRINT; }
ulong fd_vote_state_update_align( void ){ return FD_VOTE_STATE_UPDATE_ALIGN; }

void fd_vote_state_update_walk( void * w, fd_vote_state_update_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_state_update", level++ );

  /* Walk deque */
  fun( w, self->lockouts, "lockouts", FD_FLAMENCO_TYPE_ARR, "lockouts", level++ );
  if( self->lockouts ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts );
         !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter );
         iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->lockouts, iter );
      fd_vote_lockout_walk(w, ele, fun, "lockouts", level );
    }
  }
  fun( w, self->lockouts, "lockouts", FD_FLAMENCO_TYPE_ARR_END, "lockouts", level-- );
  /* Done walking deque */

  if( !self->has_root ) {
    fun( w, NULL, "root", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->root, "root", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  if( !self->has_timestamp ) {
    fun( w, NULL, "timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_state_update", level-- );
}
ulong fd_vote_state_update_size( fd_vote_state_update_t const * self ) {
  ulong size = 0;
  if( self->lockouts ) {
    size += sizeof(ulong);
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts ); !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->lockouts, iter );
      size += fd_vote_lockout_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(char);
  if( self->has_root ) {
    size += sizeof(ulong);
  }
  size += fd_hash_size( &self->hash );
  size += sizeof(char);
  if( self->has_timestamp ) {
    size += sizeof(long);
  }
  return size;
}

int fd_compact_vote_state_update_encode( fd_compact_vote_state_update_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->root, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_compact_u16_encode( &self->lockouts_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->lockouts_len ) {
    for( ulong i=0; i < self->lockouts_len; i++ ) {
      err = fd_lockout_offset_encode( self->lockouts + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_timestamp ) {
    err = fd_bincode_int64_encode( self->timestamp, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_compact_vote_state_update_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_compact_vote_state_update_t);
  void const * start_data = ctx->data;
  int err = fd_compact_vote_state_update_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_compact_vote_state_update_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ushort lockouts_len;
  err = fd_bincode_compact_u16_decode( &lockouts_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( lockouts_len ) {
    *total_sz += FD_LOCKOUT_OFFSET_ALIGN + FD_LOCKOUT_OFFSET_FOOTPRINT*lockouts_len;
    for( ulong i=0; i < lockouts_len; i++ ) {
      err = fd_lockout_offset_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_int64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_compact_vote_state_update_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_t * self = (fd_compact_vote_state_update_t *)mem;
  fd_compact_vote_state_update_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compact_vote_state_update_t);
  void * * alloc_mem = &alloc_region;
  fd_compact_vote_state_update_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_compact_vote_state_update_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_t * self = (fd_compact_vote_state_update_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->root, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->lockouts_len, ctx );
  if( self->lockouts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_LOCKOUT_OFFSET_ALIGN );
    self->lockouts = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_LOCKOUT_OFFSET_FOOTPRINT*self->lockouts_len;
    for( ulong i=0; i < self->lockouts_len; i++ ) {
      fd_lockout_offset_new( self->lockouts + i );
      fd_lockout_offset_decode_inner( self->lockouts + i, alloc_mem, ctx );
    }
  } else
    self->lockouts = NULL;
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_timestamp = !!o;
    if( o ) {
      fd_bincode_int64_decode_unsafe( &self->timestamp, ctx );
    }
  }
}
void * fd_compact_vote_state_update_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_global_t * self = (fd_compact_vote_state_update_global_t *)mem;
  fd_compact_vote_state_update_new( (fd_compact_vote_state_update_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compact_vote_state_update_global_t);
  void * * alloc_mem = &alloc_region;
  fd_compact_vote_state_update_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_compact_vote_state_update_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_global_t * self = (fd_compact_vote_state_update_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->root, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->lockouts_len, ctx );
  if( self->lockouts_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_LOCKOUT_OFFSET_ALIGN );
    self->lockouts_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_LOCKOUT_OFFSET_FOOTPRINT*self->lockouts_len;
    for( ulong i=0; i < self->lockouts_len; i++ ) {
      fd_lockout_offset_new( (fd_lockout_offset_t *)(cur_mem + FD_LOCKOUT_OFFSET_FOOTPRINT * i) );
      fd_lockout_offset_decode_inner_global( cur_mem + FD_LOCKOUT_OFFSET_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->lockouts_gaddr = 0UL;
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_timestamp = !!o;
    if( o ) {
      fd_bincode_int64_decode_unsafe( &self->timestamp, ctx );
    }
  }
}
int fd_compact_vote_state_update_convert_global_to_local( void const * global_self, fd_compact_vote_state_update_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_compact_vote_state_update_global_t const * mem = (fd_compact_vote_state_update_global_t const *)global_self;
  self->root = mem->root;
  self->lockouts_len = mem->lockouts_len;
  self->lockouts     = fd_wksp_laddr_fast( ctx->wksp, mem->lockouts_gaddr );
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = mem->timestamp;
  self->has_timestamp = mem->has_timestamp;
  return FD_BINCODE_SUCCESS;
}
void fd_compact_vote_state_update_new(fd_compact_vote_state_update_t * self) {
  fd_memset( self, 0, sizeof(fd_compact_vote_state_update_t) );
  fd_hash_new( &self->hash );
}
void fd_compact_vote_state_update_destroy( fd_compact_vote_state_update_t * self ) {
  if( self->lockouts ) {
    for( ulong i=0; i < self->lockouts_len; i++ )
      fd_lockout_offset_destroy( self->lockouts + i );
    self->lockouts = NULL;
  }
  fd_hash_destroy( &self->hash );
  if( self->has_timestamp ) {
    self->has_timestamp = 0;
  }
}

ulong fd_compact_vote_state_update_footprint( void ){ return FD_COMPACT_VOTE_STATE_UPDATE_FOOTPRINT; }
ulong fd_compact_vote_state_update_align( void ){ return FD_COMPACT_VOTE_STATE_UPDATE_ALIGN; }

void fd_compact_vote_state_update_walk( void * w, fd_compact_vote_state_update_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_compact_vote_state_update", level++ );
  fun( w, &self->root, "root", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->lockouts_len ) {
    fun( w, NULL, "lockouts", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->lockouts_len; i++ )
      fd_lockout_offset_walk(w, self->lockouts + i, fun, "lockout_offset", level );
    fun( w, NULL, "lockouts", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  if( !self->has_timestamp ) {
    fun( w, NULL, "timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_compact_vote_state_update", level-- );
}
ulong fd_compact_vote_state_update_size( fd_compact_vote_state_update_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  do {
    ushort tmp = (ushort)self->lockouts_len;
    size += fd_bincode_compact_u16_size( &tmp );
    for( ulong i=0; i < self->lockouts_len; i++ )
      size += fd_lockout_offset_size( self->lockouts + i );
  } while(0);
  size += fd_hash_size( &self->hash );
  size += sizeof(char);
  if( self->has_timestamp ) {
    size += sizeof(long);
  }
  return size;
}

int fd_compact_vote_state_update_switch_encode( fd_compact_vote_state_update_switch_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_compact_vote_state_update_encode( &self->compact_vote_state_update, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_compact_vote_state_update_switch_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_compact_vote_state_update_switch_t);
  void const * start_data = ctx->data;
  int err = fd_compact_vote_state_update_switch_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_compact_vote_state_update_switch_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_compact_vote_state_update_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_compact_vote_state_update_switch_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_switch_t * self = (fd_compact_vote_state_update_switch_t *)mem;
  fd_compact_vote_state_update_switch_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compact_vote_state_update_switch_t);
  void * * alloc_mem = &alloc_region;
  fd_compact_vote_state_update_switch_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_compact_vote_state_update_switch_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_switch_t * self = (fd_compact_vote_state_update_switch_t *)struct_mem;
  fd_compact_vote_state_update_decode_inner( &self->compact_vote_state_update, alloc_mem, ctx );
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
}
void * fd_compact_vote_state_update_switch_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_switch_global_t * self = (fd_compact_vote_state_update_switch_global_t *)mem;
  fd_compact_vote_state_update_switch_new( (fd_compact_vote_state_update_switch_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compact_vote_state_update_switch_global_t);
  void * * alloc_mem = &alloc_region;
  fd_compact_vote_state_update_switch_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_compact_vote_state_update_switch_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_vote_state_update_switch_global_t * self = (fd_compact_vote_state_update_switch_global_t *)struct_mem;
  fd_compact_vote_state_update_decode_inner_global( &self->compact_vote_state_update, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
}
int fd_compact_vote_state_update_switch_convert_global_to_local( void const * global_self, fd_compact_vote_state_update_switch_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_compact_vote_state_update_switch_global_t const * mem = (fd_compact_vote_state_update_switch_global_t const *)global_self;
  err = fd_compact_vote_state_update_convert_global_to_local( &mem->compact_vote_state_update, &self->compact_vote_state_update, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_compact_vote_state_update_switch_new(fd_compact_vote_state_update_switch_t * self) {
  fd_memset( self, 0, sizeof(fd_compact_vote_state_update_switch_t) );
  fd_compact_vote_state_update_new( &self->compact_vote_state_update );
  fd_hash_new( &self->hash );
}
void fd_compact_vote_state_update_switch_destroy( fd_compact_vote_state_update_switch_t * self ) {
  fd_compact_vote_state_update_destroy( &self->compact_vote_state_update );
  fd_hash_destroy( &self->hash );
}

ulong fd_compact_vote_state_update_switch_footprint( void ){ return FD_COMPACT_VOTE_STATE_UPDATE_SWITCH_FOOTPRINT; }
ulong fd_compact_vote_state_update_switch_align( void ){ return FD_COMPACT_VOTE_STATE_UPDATE_SWITCH_ALIGN; }

void fd_compact_vote_state_update_switch_walk( void * w, fd_compact_vote_state_update_switch_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_compact_vote_state_update_switch", level++ );
  fd_compact_vote_state_update_walk( w, &self->compact_vote_state_update, fun, "compact_vote_state_update", level );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_compact_vote_state_update_switch", level-- );
}
ulong fd_compact_vote_state_update_switch_size( fd_compact_vote_state_update_switch_t const * self ) {
  ulong size = 0;
  size += fd_compact_vote_state_update_size( &self->compact_vote_state_update );
  size += fd_hash_size( &self->hash );
  return size;
}

int fd_compact_tower_sync_encode( fd_compact_tower_sync_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->root, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->lockout_offsets ) {
    ushort lockout_offsets_len = (ushort)deq_fd_lockout_offset_t_cnt( self->lockout_offsets );
    err = fd_bincode_compact_u16_encode( &lockout_offsets_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_lockout_offset_t_iter_t iter = deq_fd_lockout_offset_t_iter_init( self->lockout_offsets ); !deq_fd_lockout_offset_t_iter_done( self->lockout_offsets, iter ); iter = deq_fd_lockout_offset_t_iter_next( self->lockout_offsets, iter ) ) {
      fd_lockout_offset_t const * ele = deq_fd_lockout_offset_t_iter_ele_const( self->lockout_offsets, iter );
      err = fd_lockout_offset_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ushort lockout_offsets_len = 0;
    err = fd_bincode_compact_u16_encode( &lockout_offsets_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_timestamp ) {
    err = fd_bincode_int64_encode( self->timestamp, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_hash_encode( &self->block_id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_compact_tower_sync_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_compact_tower_sync_t);
  void const * start_data = ctx->data;
  int err = fd_compact_tower_sync_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_compact_tower_sync_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ushort lockout_offsets_len;
  err = fd_bincode_compact_u16_decode( &lockout_offsets_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong lockout_offsets_max = fd_ulong_max( lockout_offsets_len, 32 );
  *total_sz += deq_fd_lockout_offset_t_align() + deq_fd_lockout_offset_t_footprint( lockout_offsets_max );
  for( ulong i = 0; i < lockout_offsets_len; ++i ) {
    err = fd_lockout_offset_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_int64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_compact_tower_sync_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_tower_sync_t * self = (fd_compact_tower_sync_t *)mem;
  fd_compact_tower_sync_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compact_tower_sync_t);
  void * * alloc_mem = &alloc_region;
  fd_compact_tower_sync_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_compact_tower_sync_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_tower_sync_t * self = (fd_compact_tower_sync_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->root, ctx );
  ushort lockout_offsets_len;
  fd_bincode_compact_u16_decode_unsafe( &lockout_offsets_len, ctx );
  ulong lockout_offsets_max = fd_ulong_max( lockout_offsets_len, 32 );
  self->lockout_offsets = deq_fd_lockout_offset_t_join_new( alloc_mem, lockout_offsets_max );
  for( ulong i=0; i < lockout_offsets_len; i++ ) {
    fd_lockout_offset_t * elem = deq_fd_lockout_offset_t_push_tail_nocopy( self->lockout_offsets );
    fd_lockout_offset_new( elem );
    fd_lockout_offset_decode_inner( elem, alloc_mem, ctx );
  }
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_timestamp = !!o;
    if( o ) {
      fd_bincode_int64_decode_unsafe( &self->timestamp, ctx );
    }
  }
  fd_hash_decode_inner( &self->block_id, alloc_mem, ctx );
}
void * fd_compact_tower_sync_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_tower_sync_global_t * self = (fd_compact_tower_sync_global_t *)mem;
  fd_compact_tower_sync_new( (fd_compact_tower_sync_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compact_tower_sync_global_t);
  void * * alloc_mem = &alloc_region;
  fd_compact_tower_sync_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_compact_tower_sync_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compact_tower_sync_global_t * self = (fd_compact_tower_sync_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->root, ctx );
  ushort lockout_offsets_len;
  fd_bincode_compact_u16_decode_unsafe( &lockout_offsets_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_lockout_offset_t_align() );
  ulong lockout_offsets_max = fd_ulong_max( lockout_offsets_len, 32 );
  self->lockout_offsets_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_lockout_offset_t * lockout_offsets = deq_fd_lockout_offset_t_join_new( alloc_mem, lockout_offsets_max );
  for( ulong i=0; i < lockout_offsets_len; i++ ) {
    fd_lockout_offset_t * elem = deq_fd_lockout_offset_t_push_tail_nocopy( lockout_offsets );
    fd_lockout_offset_new( elem );
    fd_lockout_offset_decode_inner_global( elem, alloc_mem, ctx );
  }
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_timestamp = !!o;
    if( o ) {
      fd_bincode_int64_decode_unsafe( &self->timestamp, ctx );
    }
  }
  fd_hash_decode_inner_global( &self->block_id, alloc_mem, ctx );
}
int fd_compact_tower_sync_convert_global_to_local( void const * global_self, fd_compact_tower_sync_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_compact_tower_sync_global_t const * mem = (fd_compact_tower_sync_global_t const *)global_self;
  self->root = mem->root;
  self->lockout_offsets = deq_fd_lockout_offset_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->lockout_offsets_gaddr ) );
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = mem->timestamp;
  self->has_timestamp = mem->has_timestamp;
  err = fd_hash_convert_global_to_local( &mem->block_id, &self->block_id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_compact_tower_sync_new(fd_compact_tower_sync_t * self) {
  fd_memset( self, 0, sizeof(fd_compact_tower_sync_t) );
  fd_hash_new( &self->hash );
  fd_hash_new( &self->block_id );
}
void fd_compact_tower_sync_destroy( fd_compact_tower_sync_t * self ) {
  if( self->lockout_offsets ) {
    for( deq_fd_lockout_offset_t_iter_t iter = deq_fd_lockout_offset_t_iter_init( self->lockout_offsets ); !deq_fd_lockout_offset_t_iter_done( self->lockout_offsets, iter ); iter = deq_fd_lockout_offset_t_iter_next( self->lockout_offsets, iter ) ) {
      fd_lockout_offset_t * ele = deq_fd_lockout_offset_t_iter_ele( self->lockout_offsets, iter );
      fd_lockout_offset_destroy( ele );
    }
    self->lockout_offsets = NULL;
  }
  fd_hash_destroy( &self->hash );
  if( self->has_timestamp ) {
    self->has_timestamp = 0;
  }
  fd_hash_destroy( &self->block_id );
}

ulong fd_compact_tower_sync_footprint( void ){ return FD_COMPACT_TOWER_SYNC_FOOTPRINT; }
ulong fd_compact_tower_sync_align( void ){ return FD_COMPACT_TOWER_SYNC_ALIGN; }

void fd_compact_tower_sync_walk( void * w, fd_compact_tower_sync_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_compact_tower_sync", level++ );
  fun( w, &self->root, "root", FD_FLAMENCO_TYPE_ULONG, "ulong", level );

  /* Walk deque */
  fun( w, self->lockout_offsets, "lockout_offsets", FD_FLAMENCO_TYPE_ARR, "lockout_offsets", level++ );
  if( self->lockout_offsets ) {
    for( deq_fd_lockout_offset_t_iter_t iter = deq_fd_lockout_offset_t_iter_init( self->lockout_offsets );
         !deq_fd_lockout_offset_t_iter_done( self->lockout_offsets, iter );
         iter = deq_fd_lockout_offset_t_iter_next( self->lockout_offsets, iter ) ) {
      fd_lockout_offset_t * ele = deq_fd_lockout_offset_t_iter_ele( self->lockout_offsets, iter );
      fd_lockout_offset_walk(w, ele, fun, "lockout_offsets", level );
    }
  }
  fun( w, self->lockout_offsets, "lockout_offsets", FD_FLAMENCO_TYPE_ARR_END, "lockout_offsets", level-- );
  /* Done walking deque */

  fd_hash_walk( w, &self->hash, fun, "hash", level );
  if( !self->has_timestamp ) {
    fun( w, NULL, "timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  fd_hash_walk( w, &self->block_id, fun, "block_id", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_compact_tower_sync", level-- );
}
ulong fd_compact_tower_sync_size( fd_compact_tower_sync_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  if( self->lockout_offsets ) {
    ushort lockout_offsets_len = (ushort)deq_fd_lockout_offset_t_cnt( self->lockout_offsets );
    size += fd_bincode_compact_u16_size( &lockout_offsets_len );
    for( deq_fd_lockout_offset_t_iter_t iter = deq_fd_lockout_offset_t_iter_init( self->lockout_offsets ); !deq_fd_lockout_offset_t_iter_done( self->lockout_offsets, iter ); iter = deq_fd_lockout_offset_t_iter_next( self->lockout_offsets, iter ) ) {
      fd_lockout_offset_t * ele = deq_fd_lockout_offset_t_iter_ele( self->lockout_offsets, iter );
      size += fd_lockout_offset_size( ele );
    }
  } else {
    size += 1;
  }
  size += fd_hash_size( &self->hash );
  size += sizeof(char);
  if( self->has_timestamp ) {
    size += sizeof(long);
  }
  size += fd_hash_size( &self->block_id );
  return size;
}

int fd_tower_sync_convert_global_to_local( void const * global_self, fd_tower_sync_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_tower_sync_global_t const * mem = (fd_tower_sync_global_t const *)global_self;
  self->lockouts = deq_fd_vote_lockout_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->lockouts_gaddr ) );
  self->lockouts_cnt = mem->lockouts_cnt;
  self->root = mem->root;
  self->has_root = mem->has_root;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = mem->timestamp;
  self->has_timestamp = mem->has_timestamp;
  err = fd_hash_convert_global_to_local( &mem->block_id, &self->block_id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_tower_sync_new(fd_tower_sync_t * self) {
  fd_memset( self, 0, sizeof(fd_tower_sync_t) );
  fd_hash_new( &self->hash );
  fd_hash_new( &self->block_id );
}
void fd_tower_sync_destroy( fd_tower_sync_t * self ) {
  if( self->lockouts ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts ); !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->lockouts, iter );
      fd_vote_lockout_destroy( ele );
    }
    self->lockouts = NULL;
  }
  if( self->has_root ) {
    self->has_root = 0;
  }
  fd_hash_destroy( &self->hash );
  if( self->has_timestamp ) {
    self->has_timestamp = 0;
  }
  fd_hash_destroy( &self->block_id );
}

ulong fd_tower_sync_footprint( void ){ return FD_TOWER_SYNC_FOOTPRINT; }
ulong fd_tower_sync_align( void ){ return FD_TOWER_SYNC_ALIGN; }

void fd_tower_sync_walk( void * w, fd_tower_sync_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_tower_sync", level++ );

  /* Walk deque */
  fun( w, self->lockouts, "lockouts", FD_FLAMENCO_TYPE_ARR, "lockouts", level++ );
  if( self->lockouts ) {
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts );
         !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter );
         iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->lockouts, iter );
      fd_vote_lockout_walk(w, ele, fun, "lockouts", level );
    }
  }
  fun( w, self->lockouts, "lockouts", FD_FLAMENCO_TYPE_ARR_END, "lockouts", level-- );
  /* Done walking deque */

  fun( w, &self->lockouts_cnt, "lockouts_cnt", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->has_root ) {
    fun( w, NULL, "root", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->root, "root", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  if( !self->has_timestamp ) {
    fun( w, NULL, "timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  fd_hash_walk( w, &self->block_id, fun, "block_id", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_tower_sync", level-- );
}
ulong fd_tower_sync_size( fd_tower_sync_t const * self ) {
  ulong size = 0;
  if( self->lockouts ) {
    size += sizeof(ulong);
    for( deq_fd_vote_lockout_t_iter_t iter = deq_fd_vote_lockout_t_iter_init( self->lockouts ); !deq_fd_vote_lockout_t_iter_done( self->lockouts, iter ); iter = deq_fd_vote_lockout_t_iter_next( self->lockouts, iter ) ) {
      fd_vote_lockout_t * ele = deq_fd_vote_lockout_t_iter_ele( self->lockouts, iter );
      size += fd_vote_lockout_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(ulong);
  size += sizeof(char);
  if( self->has_root ) {
    size += sizeof(ulong);
  }
  size += fd_hash_size( &self->hash );
  size += sizeof(char);
  if( self->has_timestamp ) {
    size += sizeof(long);
  }
  size += fd_hash_size( &self->block_id );
  return size;
}

int fd_tower_sync_switch_encode( fd_tower_sync_switch_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_tower_sync_encode( &self->tower_sync, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_tower_sync_switch_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_tower_sync_switch_t);
  void const * start_data = ctx->data;
  int err = fd_tower_sync_switch_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_tower_sync_switch_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_tower_sync_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_tower_sync_switch_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_tower_sync_switch_t * self = (fd_tower_sync_switch_t *)mem;
  fd_tower_sync_switch_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_tower_sync_switch_t);
  void * * alloc_mem = &alloc_region;
  fd_tower_sync_switch_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_tower_sync_switch_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_tower_sync_switch_t * self = (fd_tower_sync_switch_t *)struct_mem;
  fd_tower_sync_decode_inner( &self->tower_sync, alloc_mem, ctx );
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
}
void * fd_tower_sync_switch_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_tower_sync_switch_global_t * self = (fd_tower_sync_switch_global_t *)mem;
  fd_tower_sync_switch_new( (fd_tower_sync_switch_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_tower_sync_switch_global_t);
  void * * alloc_mem = &alloc_region;
  fd_tower_sync_switch_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_tower_sync_switch_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_tower_sync_switch_global_t * self = (fd_tower_sync_switch_global_t *)struct_mem;
  fd_tower_sync_decode_inner_global( &self->tower_sync, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
}
int fd_tower_sync_switch_convert_global_to_local( void const * global_self, fd_tower_sync_switch_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_tower_sync_switch_global_t const * mem = (fd_tower_sync_switch_global_t const *)global_self;
  err = fd_tower_sync_convert_global_to_local( &mem->tower_sync, &self->tower_sync, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_tower_sync_switch_new(fd_tower_sync_switch_t * self) {
  fd_memset( self, 0, sizeof(fd_tower_sync_switch_t) );
  fd_tower_sync_new( &self->tower_sync );
  fd_hash_new( &self->hash );
}
void fd_tower_sync_switch_destroy( fd_tower_sync_switch_t * self ) {
  fd_tower_sync_destroy( &self->tower_sync );
  fd_hash_destroy( &self->hash );
}

ulong fd_tower_sync_switch_footprint( void ){ return FD_TOWER_SYNC_SWITCH_FOOTPRINT; }
ulong fd_tower_sync_switch_align( void ){ return FD_TOWER_SYNC_SWITCH_ALIGN; }

void fd_tower_sync_switch_walk( void * w, fd_tower_sync_switch_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_tower_sync_switch", level++ );
  fd_tower_sync_walk( w, &self->tower_sync, fun, "tower_sync", level );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_tower_sync_switch", level-- );
}
ulong fd_tower_sync_switch_size( fd_tower_sync_switch_t const * self ) {
  ulong size = 0;
  size += fd_tower_sync_size( &self->tower_sync );
  size += fd_hash_size( &self->hash );
  return size;
}

int fd_slot_history_inner_encode( fd_slot_history_inner_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->blocks_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->blocks_len ) {
    for( ulong i=0; i < self->blocks_len; i++ ) {
      err = fd_bincode_uint64_encode( self->blocks[i], ctx );
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_slot_history_inner_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_history_inner_t);
  void const * start_data = ctx->data;
  int err = fd_slot_history_inner_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_history_inner_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong blocks_len;
  err = fd_bincode_uint64_decode( &blocks_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( blocks_len ) {
    *total_sz += 8UL + sizeof(ulong)*blocks_len;
    for( ulong i=0; i < blocks_len; i++ ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_slot_history_inner_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_inner_t * self = (fd_slot_history_inner_t *)mem;
  fd_slot_history_inner_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_history_inner_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_history_inner_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_history_inner_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_inner_t * self = (fd_slot_history_inner_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->blocks_len, ctx );
  if( self->blocks_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->blocks = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->blocks_len;
    for( ulong i=0; i < self->blocks_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( self->blocks + i, ctx );
    }
  } else
    self->blocks = NULL;
}
void * fd_slot_history_inner_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_inner_global_t * self = (fd_slot_history_inner_global_t *)mem;
  fd_slot_history_inner_new( (fd_slot_history_inner_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_history_inner_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_history_inner_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_history_inner_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_inner_global_t * self = (fd_slot_history_inner_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->blocks_len, ctx );
  if( self->blocks_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->blocks_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->blocks_len;
    for( ulong i=0; i < self->blocks_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( (ulong*)(cur_mem + sizeof(ulong) * i), ctx );
    }
  } else
    self->blocks_gaddr = 0UL;
}
int fd_slot_history_inner_convert_global_to_local( void const * global_self, fd_slot_history_inner_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_history_inner_global_t const * mem = (fd_slot_history_inner_global_t const *)global_self;
  self->blocks_len = mem->blocks_len;
  self->blocks     = fd_wksp_laddr_fast( ctx->wksp, mem->blocks_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_slot_history_inner_new(fd_slot_history_inner_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_history_inner_t) );
}
void fd_slot_history_inner_destroy( fd_slot_history_inner_t * self ) {
  if( self->blocks ) {
    self->blocks = NULL;
  }
}

ulong fd_slot_history_inner_footprint( void ){ return FD_SLOT_HISTORY_INNER_FOOTPRINT; }
ulong fd_slot_history_inner_align( void ){ return FD_SLOT_HISTORY_INNER_ALIGN; }

void fd_slot_history_inner_walk( void * w, fd_slot_history_inner_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_history_inner", level++ );
  if( self->blocks_len ) {
    fun( w, NULL, "blocks", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->blocks_len; i++ )
      fun( w, self->blocks + i, "blocks", FD_FLAMENCO_TYPE_ULONG,   "ulong",   level );
    fun( w, NULL, "blocks", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_history_inner", level-- );
}
ulong fd_slot_history_inner_size( fd_slot_history_inner_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->blocks_len * sizeof(ulong);
  } while(0);
  return size;
}

int fd_slot_history_bitvec_encode( fd_slot_history_bitvec_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->bits != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_slot_history_inner_encode( self->bits, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_history_bitvec_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_history_bitvec_t);
  void const * start_data = ctx->data;
  int err = fd_slot_history_bitvec_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_history_bitvec_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_SLOT_HISTORY_INNER_ALIGN + FD_SLOT_HISTORY_INNER_FOOTPRINT;
      err = fd_slot_history_inner_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_slot_history_bitvec_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_bitvec_t * self = (fd_slot_history_bitvec_t *)mem;
  fd_slot_history_bitvec_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_history_bitvec_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_history_bitvec_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_history_bitvec_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_bitvec_t * self = (fd_slot_history_bitvec_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_SLOT_HISTORY_INNER_ALIGN );
      self->bits = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_SLOT_HISTORY_INNER_FOOTPRINT;
      fd_slot_history_inner_new( self->bits );
      fd_slot_history_inner_decode_inner( self->bits, alloc_mem, ctx );
    } else {
      self->bits = NULL;
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
void * fd_slot_history_bitvec_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_bitvec_global_t * self = (fd_slot_history_bitvec_global_t *)mem;
  fd_slot_history_bitvec_new( (fd_slot_history_bitvec_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_history_bitvec_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_history_bitvec_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_history_bitvec_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_bitvec_global_t * self = (fd_slot_history_bitvec_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_SLOT_HISTORY_INNER_ALIGN );
      self->bits_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_slot_history_inner_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_SLOT_HISTORY_INNER_FOOTPRINT;
      fd_slot_history_inner_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->bits_gaddr ), alloc_mem, ctx );
    } else {
      self->bits_gaddr = 0UL;
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
int fd_slot_history_bitvec_convert_global_to_local( void const * global_self, fd_slot_history_bitvec_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_history_bitvec_global_t const * mem = (fd_slot_history_bitvec_global_t const *)global_self;
  self->bits = fd_wksp_laddr_fast( ctx->wksp, mem->bits_gaddr );
  self->len = mem->len;
  return FD_BINCODE_SUCCESS;
}
void fd_slot_history_bitvec_new(fd_slot_history_bitvec_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_history_bitvec_t) );
}
void fd_slot_history_bitvec_destroy( fd_slot_history_bitvec_t * self ) {
  if( self->bits ) {
    fd_slot_history_inner_destroy( self->bits );
    self->bits = NULL;
  }
}

ulong fd_slot_history_bitvec_footprint( void ){ return FD_SLOT_HISTORY_BITVEC_FOOTPRINT; }
ulong fd_slot_history_bitvec_align( void ){ return FD_SLOT_HISTORY_BITVEC_ALIGN; }

void fd_slot_history_bitvec_walk( void * w, fd_slot_history_bitvec_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_history_bitvec", level++ );
  if( !self->bits ) {
    fun( w, NULL, "bits", FD_FLAMENCO_TYPE_NULL, "slot_history_inner", level );
  } else {
    fd_slot_history_inner_walk( w, self->bits, fun, "bits", level );
  }
  fun( w, &self->len, "len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_history_bitvec", level-- );
}
ulong fd_slot_history_bitvec_size( fd_slot_history_bitvec_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( NULL !=  self->bits ) {
    size += fd_slot_history_inner_size( self->bits );
  }
  size += sizeof(ulong);
  return size;
}

int fd_slot_history_encode( fd_slot_history_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_slot_history_bitvec_encode( &self->bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->next_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_history_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_history_t);
  void const * start_data = ctx->data;
  int err = fd_slot_history_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_history_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_slot_history_bitvec_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_slot_history_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_t * self = (fd_slot_history_t *)mem;
  fd_slot_history_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_history_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_history_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_history_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_t * self = (fd_slot_history_t *)struct_mem;
  fd_slot_history_bitvec_decode_inner( &self->bits, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->next_slot, ctx );
}
void * fd_slot_history_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_global_t * self = (fd_slot_history_global_t *)mem;
  fd_slot_history_new( (fd_slot_history_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_history_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_history_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_history_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_history_global_t * self = (fd_slot_history_global_t *)struct_mem;
  fd_slot_history_bitvec_decode_inner_global( &self->bits, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->next_slot, ctx );
}
int fd_slot_history_convert_global_to_local( void const * global_self, fd_slot_history_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_history_global_t const * mem = (fd_slot_history_global_t const *)global_self;
  err = fd_slot_history_bitvec_convert_global_to_local( &mem->bits, &self->bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->next_slot = mem->next_slot;
  return FD_BINCODE_SUCCESS;
}
void fd_slot_history_new(fd_slot_history_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_history_t) );
  fd_slot_history_bitvec_new( &self->bits );
}
void fd_slot_history_destroy( fd_slot_history_t * self ) {
  fd_slot_history_bitvec_destroy( &self->bits );
}

ulong fd_slot_history_footprint( void ){ return FD_SLOT_HISTORY_FOOTPRINT; }
ulong fd_slot_history_align( void ){ return FD_SLOT_HISTORY_ALIGN; }

void fd_slot_history_walk( void * w, fd_slot_history_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_history", level++ );
  fd_slot_history_bitvec_walk( w, &self->bits, fun, "bits", level );
  fun( w, &self->next_slot, "next_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_history", level-- );
}
ulong fd_slot_history_size( fd_slot_history_t const * self ) {
  ulong size = 0;
  size += fd_slot_history_bitvec_size( &self->bits );
  size += sizeof(ulong);
  return size;
}

int fd_slot_hash_encode( fd_slot_hash_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_hash_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_hash_t);
  void const * start_data = ctx->data;
  int err = fd_slot_hash_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_hash_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_slot_hash_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hash_t * self = (fd_slot_hash_t *)mem;
  fd_slot_hash_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_hash_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_hash_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_hash_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hash_t * self = (fd_slot_hash_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
}
void * fd_slot_hash_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hash_global_t * self = (fd_slot_hash_global_t *)mem;
  fd_slot_hash_new( (fd_slot_hash_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_hash_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_hash_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_hash_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hash_global_t * self = (fd_slot_hash_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
}
int fd_slot_hash_convert_global_to_local( void const * global_self, fd_slot_hash_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_hash_global_t const * mem = (fd_slot_hash_global_t const *)global_self;
  self->slot = mem->slot;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_slot_hash_new(fd_slot_hash_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_hash_t) );
  fd_hash_new( &self->hash );
}
void fd_slot_hash_destroy( fd_slot_hash_t * self ) {
  fd_hash_destroy( &self->hash );
}

ulong fd_slot_hash_footprint( void ){ return FD_SLOT_HASH_FOOTPRINT; }
ulong fd_slot_hash_align( void ){ return FD_SLOT_HASH_ALIGN; }

void fd_slot_hash_walk( void * w, fd_slot_hash_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_hash", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_hash", level-- );
}
ulong fd_slot_hash_size( fd_slot_hash_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_hash_size( &self->hash );
  return size;
}

int fd_slot_hashes_encode( fd_slot_hashes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->hashes ) {
    ulong hashes_len = deq_fd_slot_hash_t_cnt( self->hashes );
    err = fd_bincode_uint64_encode( hashes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_slot_hash_t_iter_t iter = deq_fd_slot_hash_t_iter_init( self->hashes ); !deq_fd_slot_hash_t_iter_done( self->hashes, iter ); iter = deq_fd_slot_hash_t_iter_next( self->hashes, iter ) ) {
      fd_slot_hash_t const * ele = deq_fd_slot_hash_t_iter_ele_const( self->hashes, iter );
      err = fd_slot_hash_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong hashes_len = 0;
    err = fd_bincode_uint64_encode( hashes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_slot_hashes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_hashes_t);
  void const * start_data = ctx->data;
  int err = fd_slot_hashes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_hashes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong hashes_len;
  err = fd_bincode_uint64_decode( &hashes_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong hashes_max = fd_ulong_max( hashes_len, 512 );
  *total_sz += deq_fd_slot_hash_t_align() + deq_fd_slot_hash_t_footprint( hashes_max );
  ulong hashes_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( hashes_len, 40, &hashes_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( hashes_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_slot_hashes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hashes_t * self = (fd_slot_hashes_t *)mem;
  fd_slot_hashes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_hashes_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_hashes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_hashes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hashes_t * self = (fd_slot_hashes_t *)struct_mem;
  ulong hashes_len;
  fd_bincode_uint64_decode_unsafe( &hashes_len, ctx );
  ulong hashes_max = fd_ulong_max( hashes_len, 512 );
  self->hashes = deq_fd_slot_hash_t_join_new( alloc_mem, hashes_max );
  for( ulong i=0; i < hashes_len; i++ ) {
    fd_slot_hash_t * elem = deq_fd_slot_hash_t_push_tail_nocopy( self->hashes );
    fd_slot_hash_new( elem );
    fd_slot_hash_decode_inner( elem, alloc_mem, ctx );
  }
}
void * fd_slot_hashes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hashes_global_t * self = (fd_slot_hashes_global_t *)mem;
  fd_slot_hashes_new( (fd_slot_hashes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_hashes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_hashes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_hashes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_hashes_global_t * self = (fd_slot_hashes_global_t *)struct_mem;
  ulong hashes_len;
  fd_bincode_uint64_decode_unsafe( &hashes_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_slot_hash_t_align() );
  ulong hashes_max = fd_ulong_max( hashes_len, 512 );
  self->hashes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_slot_hash_t * hashes = deq_fd_slot_hash_t_join_new( alloc_mem, hashes_max );
  for( ulong i=0; i < hashes_len; i++ ) {
    fd_slot_hash_t * elem = deq_fd_slot_hash_t_push_tail_nocopy( hashes );
    fd_slot_hash_new( elem );
    fd_slot_hash_decode_inner_global( elem, alloc_mem, ctx );
  }
}
int fd_slot_hashes_convert_global_to_local( void const * global_self, fd_slot_hashes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_hashes_global_t const * mem = (fd_slot_hashes_global_t const *)global_self;
  self->hashes = deq_fd_slot_hash_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->hashes_gaddr ) );
  return FD_BINCODE_SUCCESS;
}
void fd_slot_hashes_new(fd_slot_hashes_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_hashes_t) );
}
void fd_slot_hashes_destroy( fd_slot_hashes_t * self ) {
  if( self->hashes ) {
    for( deq_fd_slot_hash_t_iter_t iter = deq_fd_slot_hash_t_iter_init( self->hashes ); !deq_fd_slot_hash_t_iter_done( self->hashes, iter ); iter = deq_fd_slot_hash_t_iter_next( self->hashes, iter ) ) {
      fd_slot_hash_t * ele = deq_fd_slot_hash_t_iter_ele( self->hashes, iter );
      fd_slot_hash_destroy( ele );
    }
    self->hashes = NULL;
  }
}

ulong fd_slot_hashes_footprint( void ){ return FD_SLOT_HASHES_FOOTPRINT; }
ulong fd_slot_hashes_align( void ){ return FD_SLOT_HASHES_ALIGN; }

void fd_slot_hashes_walk( void * w, fd_slot_hashes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_hashes", level++ );

  /* Walk deque */
  fun( w, self->hashes, "hashes", FD_FLAMENCO_TYPE_ARR, "hashes", level++ );
  if( self->hashes ) {
    for( deq_fd_slot_hash_t_iter_t iter = deq_fd_slot_hash_t_iter_init( self->hashes );
         !deq_fd_slot_hash_t_iter_done( self->hashes, iter );
         iter = deq_fd_slot_hash_t_iter_next( self->hashes, iter ) ) {
      fd_slot_hash_t * ele = deq_fd_slot_hash_t_iter_ele( self->hashes, iter );
      fd_slot_hash_walk(w, ele, fun, "hashes", level );
    }
  }
  fun( w, self->hashes, "hashes", FD_FLAMENCO_TYPE_ARR_END, "hashes", level-- );
  /* Done walking deque */

  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_hashes", level-- );
}
ulong fd_slot_hashes_size( fd_slot_hashes_t const * self ) {
  ulong size = 0;
  if( self->hashes ) {
    size += sizeof(ulong);
    for( deq_fd_slot_hash_t_iter_t iter = deq_fd_slot_hash_t_iter_init( self->hashes ); !deq_fd_slot_hash_t_iter_done( self->hashes, iter ); iter = deq_fd_slot_hash_t_iter_next( self->hashes, iter ) ) {
      fd_slot_hash_t * ele = deq_fd_slot_hash_t_iter_ele( self->hashes, iter );
      size += fd_slot_hash_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_block_block_hash_entry_encode( fd_block_block_hash_entry_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_hash_encode( &self->blockhash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_encode( &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_block_block_hash_entry_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_block_block_hash_entry_t);
  void const * start_data = ctx->data;
  int err = fd_block_block_hash_entry_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_block_block_hash_entry_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_block_block_hash_entry_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_block_hash_entry_t * self = (fd_block_block_hash_entry_t *)mem;
  fd_block_block_hash_entry_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_block_block_hash_entry_t);
  void * * alloc_mem = &alloc_region;
  fd_block_block_hash_entry_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_block_block_hash_entry_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_block_hash_entry_t * self = (fd_block_block_hash_entry_t *)struct_mem;
  fd_hash_decode_inner( &self->blockhash, alloc_mem, ctx );
  fd_fee_calculator_decode_inner( &self->fee_calculator, alloc_mem, ctx );
}
void * fd_block_block_hash_entry_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_block_hash_entry_global_t * self = (fd_block_block_hash_entry_global_t *)mem;
  fd_block_block_hash_entry_new( (fd_block_block_hash_entry_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_block_block_hash_entry_global_t);
  void * * alloc_mem = &alloc_region;
  fd_block_block_hash_entry_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_block_block_hash_entry_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_block_block_hash_entry_global_t * self = (fd_block_block_hash_entry_global_t *)struct_mem;
  fd_hash_decode_inner_global( &self->blockhash, alloc_mem, ctx );
  fd_fee_calculator_decode_inner_global( &self->fee_calculator, alloc_mem, ctx );
}
int fd_block_block_hash_entry_convert_global_to_local( void const * global_self, fd_block_block_hash_entry_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_block_block_hash_entry_global_t const * mem = (fd_block_block_hash_entry_global_t const *)global_self;
  err = fd_hash_convert_global_to_local( &mem->blockhash, &self->blockhash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_convert_global_to_local( &mem->fee_calculator, &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_block_block_hash_entry_new(fd_block_block_hash_entry_t * self) {
  fd_memset( self, 0, sizeof(fd_block_block_hash_entry_t) );
  fd_hash_new( &self->blockhash );
  fd_fee_calculator_new( &self->fee_calculator );
}
void fd_block_block_hash_entry_destroy( fd_block_block_hash_entry_t * self ) {
  fd_hash_destroy( &self->blockhash );
  fd_fee_calculator_destroy( &self->fee_calculator );
}

ulong fd_block_block_hash_entry_footprint( void ){ return FD_BLOCK_BLOCK_HASH_ENTRY_FOOTPRINT; }
ulong fd_block_block_hash_entry_align( void ){ return FD_BLOCK_BLOCK_HASH_ENTRY_ALIGN; }

void fd_block_block_hash_entry_walk( void * w, fd_block_block_hash_entry_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_block_block_hash_entry", level++ );
  fd_hash_walk( w, &self->blockhash, fun, "blockhash", level );
  fd_fee_calculator_walk( w, &self->fee_calculator, fun, "fee_calculator", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_block_block_hash_entry", level-- );
}
ulong fd_block_block_hash_entry_size( fd_block_block_hash_entry_t const * self ) {
  ulong size = 0;
  size += fd_hash_size( &self->blockhash );
  size += fd_fee_calculator_size( &self->fee_calculator );
  return size;
}

int fd_recent_block_hashes_encode( fd_recent_block_hashes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->hashes ) {
    ulong hashes_len = deq_fd_block_block_hash_entry_t_cnt( self->hashes );
    err = fd_bincode_uint64_encode( hashes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_fd_block_block_hash_entry_t_iter_t iter = deq_fd_block_block_hash_entry_t_iter_init( self->hashes ); !deq_fd_block_block_hash_entry_t_iter_done( self->hashes, iter ); iter = deq_fd_block_block_hash_entry_t_iter_next( self->hashes, iter ) ) {
      fd_block_block_hash_entry_t const * ele = deq_fd_block_block_hash_entry_t_iter_ele_const( self->hashes, iter );
      err = fd_block_block_hash_entry_encode( ele, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong hashes_len = 0;
    err = fd_bincode_uint64_encode( hashes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_recent_block_hashes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_recent_block_hashes_t);
  void const * start_data = ctx->data;
  int err = fd_recent_block_hashes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_recent_block_hashes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong hashes_len;
  err = fd_bincode_uint64_decode( &hashes_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong hashes_max = fd_ulong_max( hashes_len, 151 );
  *total_sz += deq_fd_block_block_hash_entry_t_align() + deq_fd_block_block_hash_entry_t_footprint( hashes_max );
  ulong hashes_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( hashes_len, 40, &hashes_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( hashes_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_recent_block_hashes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_recent_block_hashes_t * self = (fd_recent_block_hashes_t *)mem;
  fd_recent_block_hashes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_recent_block_hashes_t);
  void * * alloc_mem = &alloc_region;
  fd_recent_block_hashes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_recent_block_hashes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_recent_block_hashes_t * self = (fd_recent_block_hashes_t *)struct_mem;
  ulong hashes_len;
  fd_bincode_uint64_decode_unsafe( &hashes_len, ctx );
  ulong hashes_max = fd_ulong_max( hashes_len, 151 );
  self->hashes = deq_fd_block_block_hash_entry_t_join_new( alloc_mem, hashes_max );
  for( ulong i=0; i < hashes_len; i++ ) {
    fd_block_block_hash_entry_t * elem = deq_fd_block_block_hash_entry_t_push_tail_nocopy( self->hashes );
    fd_block_block_hash_entry_new( elem );
    fd_block_block_hash_entry_decode_inner( elem, alloc_mem, ctx );
  }
}
void * fd_recent_block_hashes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_recent_block_hashes_global_t * self = (fd_recent_block_hashes_global_t *)mem;
  fd_recent_block_hashes_new( (fd_recent_block_hashes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_recent_block_hashes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_recent_block_hashes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_recent_block_hashes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_recent_block_hashes_global_t * self = (fd_recent_block_hashes_global_t *)struct_mem;
  ulong hashes_len;
  fd_bincode_uint64_decode_unsafe( &hashes_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_fd_block_block_hash_entry_t_align() );
  ulong hashes_max = fd_ulong_max( hashes_len, 151 );
  self->hashes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  fd_block_block_hash_entry_t * hashes = deq_fd_block_block_hash_entry_t_join_new( alloc_mem, hashes_max );
  for( ulong i=0; i < hashes_len; i++ ) {
    fd_block_block_hash_entry_t * elem = deq_fd_block_block_hash_entry_t_push_tail_nocopy( hashes );
    fd_block_block_hash_entry_new( elem );
    fd_block_block_hash_entry_decode_inner_global( elem, alloc_mem, ctx );
  }
}
int fd_recent_block_hashes_convert_global_to_local( void const * global_self, fd_recent_block_hashes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_recent_block_hashes_global_t const * mem = (fd_recent_block_hashes_global_t const *)global_self;
  self->hashes = deq_fd_block_block_hash_entry_t_join( fd_wksp_laddr_fast( ctx->wksp, mem->hashes_gaddr ) );
  return FD_BINCODE_SUCCESS;
}
void fd_recent_block_hashes_new(fd_recent_block_hashes_t * self) {
  fd_memset( self, 0, sizeof(fd_recent_block_hashes_t) );
}
void fd_recent_block_hashes_destroy( fd_recent_block_hashes_t * self ) {
  if( self->hashes ) {
    for( deq_fd_block_block_hash_entry_t_iter_t iter = deq_fd_block_block_hash_entry_t_iter_init( self->hashes ); !deq_fd_block_block_hash_entry_t_iter_done( self->hashes, iter ); iter = deq_fd_block_block_hash_entry_t_iter_next( self->hashes, iter ) ) {
      fd_block_block_hash_entry_t * ele = deq_fd_block_block_hash_entry_t_iter_ele( self->hashes, iter );
      fd_block_block_hash_entry_destroy( ele );
    }
    self->hashes = NULL;
  }
}

ulong fd_recent_block_hashes_footprint( void ){ return FD_RECENT_BLOCK_HASHES_FOOTPRINT; }
ulong fd_recent_block_hashes_align( void ){ return FD_RECENT_BLOCK_HASHES_ALIGN; }

void fd_recent_block_hashes_walk( void * w, fd_recent_block_hashes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_recent_block_hashes", level++ );

  /* Walk deque */
  fun( w, self->hashes, "hashes", FD_FLAMENCO_TYPE_ARR, "hashes", level++ );
  if( self->hashes ) {
    for( deq_fd_block_block_hash_entry_t_iter_t iter = deq_fd_block_block_hash_entry_t_iter_init( self->hashes );
         !deq_fd_block_block_hash_entry_t_iter_done( self->hashes, iter );
         iter = deq_fd_block_block_hash_entry_t_iter_next( self->hashes, iter ) ) {
      fd_block_block_hash_entry_t * ele = deq_fd_block_block_hash_entry_t_iter_ele( self->hashes, iter );
      fd_block_block_hash_entry_walk(w, ele, fun, "hashes", level );
    }
  }
  fun( w, self->hashes, "hashes", FD_FLAMENCO_TYPE_ARR_END, "hashes", level-- );
  /* Done walking deque */

  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_recent_block_hashes", level-- );
}
ulong fd_recent_block_hashes_size( fd_recent_block_hashes_t const * self ) {
  ulong size = 0;
  if( self->hashes ) {
    size += sizeof(ulong);
    for( deq_fd_block_block_hash_entry_t_iter_t iter = deq_fd_block_block_hash_entry_t_iter_init( self->hashes ); !deq_fd_block_block_hash_entry_t_iter_done( self->hashes, iter ); iter = deq_fd_block_block_hash_entry_t_iter_next( self->hashes, iter ) ) {
      fd_block_block_hash_entry_t * ele = deq_fd_block_block_hash_entry_t_iter_ele( self->hashes, iter );
      size += fd_block_block_hash_entry_size( ele );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_slot_meta_encode( fd_slot_meta_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->consumed, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->received, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->first_shred_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->last_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->parent_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->next_slot_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->next_slot_len ) {
    for( ulong i=0; i < self->next_slot_len; i++ ) {
      err = fd_bincode_uint64_encode( self->next_slot[i], ctx );
    }
  }
  err = fd_bincode_uint8_encode( (uchar)(self->is_connected), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->entry_end_indexes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->entry_end_indexes_len ) {
    for( ulong i=0; i < self->entry_end_indexes_len; i++ ) {
      err = fd_bincode_uint32_encode( self->entry_end_indexes[i], ctx );
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_slot_meta_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_meta_t);
  void const * start_data = ctx->data;
  int err = fd_slot_meta_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_meta_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong next_slot_len;
  err = fd_bincode_uint64_decode( &next_slot_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( next_slot_len ) {
    *total_sz += 8UL + sizeof(ulong)*next_slot_len;
    for( ulong i=0; i < next_slot_len; i++ ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong entry_end_indexes_len;
  err = fd_bincode_uint64_decode( &entry_end_indexes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( entry_end_indexes_len ) {
    *total_sz += 8UL + sizeof(uint)*entry_end_indexes_len;
    for( ulong i=0; i < entry_end_indexes_len; i++ ) {
      err = fd_bincode_uint32_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_slot_meta_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_meta_t * self = (fd_slot_meta_t *)mem;
  fd_slot_meta_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_meta_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_meta_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_meta_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_meta_t * self = (fd_slot_meta_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->consumed, ctx );
  fd_bincode_uint64_decode_unsafe( &self->received, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->first_shred_timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_index, ctx );
  fd_bincode_uint64_decode_unsafe( &self->parent_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->next_slot_len, ctx );
  if( self->next_slot_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->next_slot = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->next_slot_len;
    for( ulong i=0; i < self->next_slot_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( self->next_slot + i, ctx );
    }
  } else
    self->next_slot = NULL;
  fd_bincode_uint8_decode_unsafe( &self->is_connected, ctx );
  fd_bincode_uint64_decode_unsafe( &self->entry_end_indexes_len, ctx );
  if( self->entry_end_indexes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->entry_end_indexes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(uint)*self->entry_end_indexes_len;
    for( ulong i=0; i < self->entry_end_indexes_len; i++ ) {
      fd_bincode_uint32_decode_unsafe( self->entry_end_indexes + i, ctx );
    }
  } else
    self->entry_end_indexes = NULL;
}
void * fd_slot_meta_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_meta_global_t * self = (fd_slot_meta_global_t *)mem;
  fd_slot_meta_new( (fd_slot_meta_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_meta_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_meta_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_meta_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_meta_global_t * self = (fd_slot_meta_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->consumed, ctx );
  fd_bincode_uint64_decode_unsafe( &self->received, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->first_shred_timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_index, ctx );
  fd_bincode_uint64_decode_unsafe( &self->parent_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->next_slot_len, ctx );
  if( self->next_slot_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->next_slot_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->next_slot_len;
    for( ulong i=0; i < self->next_slot_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( (ulong*)(cur_mem + sizeof(ulong) * i), ctx );
    }
  } else
    self->next_slot_gaddr = 0UL;
  fd_bincode_uint8_decode_unsafe( &self->is_connected, ctx );
  fd_bincode_uint64_decode_unsafe( &self->entry_end_indexes_len, ctx );
  if( self->entry_end_indexes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->entry_end_indexes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(uint)*self->entry_end_indexes_len;
    for( ulong i=0; i < self->entry_end_indexes_len; i++ ) {
      fd_bincode_uint32_decode_unsafe( (uint*)(cur_mem + sizeof(uint) * i), ctx );
    }
  } else
    self->entry_end_indexes_gaddr = 0UL;
}
int fd_slot_meta_convert_global_to_local( void const * global_self, fd_slot_meta_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_meta_global_t const * mem = (fd_slot_meta_global_t const *)global_self;
  self->slot = mem->slot;
  self->consumed = mem->consumed;
  self->received = mem->received;
  self->first_shred_timestamp = mem->first_shred_timestamp;
  self->last_index = mem->last_index;
  self->parent_slot = mem->parent_slot;
  self->next_slot_len = mem->next_slot_len;
  self->next_slot     = fd_wksp_laddr_fast( ctx->wksp, mem->next_slot_gaddr );
  self->is_connected = mem->is_connected;
  self->entry_end_indexes_len = mem->entry_end_indexes_len;
  self->entry_end_indexes     = fd_wksp_laddr_fast( ctx->wksp, mem->entry_end_indexes_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_slot_meta_new(fd_slot_meta_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_meta_t) );
}
void fd_slot_meta_destroy( fd_slot_meta_t * self ) {
  if( self->next_slot ) {
    self->next_slot = NULL;
  }
  if( self->entry_end_indexes ) {
    self->entry_end_indexes = NULL;
  }
}

ulong fd_slot_meta_footprint( void ){ return FD_SLOT_META_FOOTPRINT; }
ulong fd_slot_meta_align( void ){ return FD_SLOT_META_ALIGN; }

void fd_slot_meta_walk( void * w, fd_slot_meta_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_meta", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->consumed, "consumed", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->received, "received", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->first_shred_timestamp, "first_shred_timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, &self->last_index, "last_index", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->parent_slot, "parent_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->next_slot_len ) {
    fun( w, NULL, "next_slot", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->next_slot_len; i++ )
      fun( w, self->next_slot + i, "next_slot", FD_FLAMENCO_TYPE_ULONG,   "ulong",   level );
    fun( w, NULL, "next_slot", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->is_connected, "is_connected", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  if( self->entry_end_indexes_len ) {
    fun( w, NULL, "entry_end_indexes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->entry_end_indexes_len; i++ )
      fun( w, self->entry_end_indexes + i, "entry_end_indexes", FD_FLAMENCO_TYPE_UINT,    "uint",    level );
    fun( w, NULL, "entry_end_indexes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_meta", level-- );
}
ulong fd_slot_meta_size( fd_slot_meta_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(long);
  size += sizeof(ulong);
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    size += self->next_slot_len * sizeof(ulong);
  } while(0);
  size += sizeof(char);
  do {
    size += sizeof(ulong);
    size += self->entry_end_indexes_len * sizeof(uint);
  } while(0);
  return size;
}

int fd_clock_timestamp_vote_encode( fd_clock_timestamp_vote_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_clock_timestamp_vote_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_clock_timestamp_vote_t);
  void const * start_data = ctx->data;
  int err = fd_clock_timestamp_vote_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_clock_timestamp_vote_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_clock_timestamp_vote_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_vote_t * self = (fd_clock_timestamp_vote_t *)mem;
  fd_clock_timestamp_vote_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_clock_timestamp_vote_t);
  void * * alloc_mem = &alloc_region;
  fd_clock_timestamp_vote_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_clock_timestamp_vote_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_vote_t * self = (fd_clock_timestamp_vote_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
void * fd_clock_timestamp_vote_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_vote_global_t * self = (fd_clock_timestamp_vote_global_t *)mem;
  fd_clock_timestamp_vote_new( (fd_clock_timestamp_vote_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_clock_timestamp_vote_global_t);
  void * * alloc_mem = &alloc_region;
  fd_clock_timestamp_vote_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_clock_timestamp_vote_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_vote_global_t * self = (fd_clock_timestamp_vote_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
int fd_clock_timestamp_vote_convert_global_to_local( void const * global_self, fd_clock_timestamp_vote_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_clock_timestamp_vote_global_t const * mem = (fd_clock_timestamp_vote_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = mem->timestamp;
  self->slot = mem->slot;
  return FD_BINCODE_SUCCESS;
}
void fd_clock_timestamp_vote_new(fd_clock_timestamp_vote_t * self) {
  fd_memset( self, 0, sizeof(fd_clock_timestamp_vote_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_clock_timestamp_vote_destroy( fd_clock_timestamp_vote_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
}

ulong fd_clock_timestamp_vote_footprint( void ){ return FD_CLOCK_TIMESTAMP_VOTE_FOOTPRINT; }
ulong fd_clock_timestamp_vote_align( void ){ return FD_CLOCK_TIMESTAMP_VOTE_ALIGN; }

void fd_clock_timestamp_vote_walk( void * w, fd_clock_timestamp_vote_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_clock_timestamp_vote", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_clock_timestamp_vote", level-- );
}
ulong fd_clock_timestamp_vote_size( fd_clock_timestamp_vote_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += sizeof(long);
  size += sizeof(ulong);
  return size;
}

int fd_clock_timestamp_votes_encode( fd_clock_timestamp_votes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->votes_root ) {
    ulong votes_len = fd_clock_timestamp_vote_t_map_size( self->votes_pool, self->votes_root );
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_clock_timestamp_vote_t_mapnode_t * n = fd_clock_timestamp_vote_t_map_minimum( self->votes_pool, self->votes_root ); n; n = fd_clock_timestamp_vote_t_map_successor( self->votes_pool, n ) ) {
      err = fd_clock_timestamp_vote_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong votes_len = 0;
    err = fd_bincode_uint64_encode( votes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_clock_timestamp_votes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_clock_timestamp_votes_t);
  void const * start_data = ctx->data;
  int err = fd_clock_timestamp_votes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_clock_timestamp_votes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong votes_len = 0UL;
  err = fd_bincode_uint64_decode( &votes_len, ctx );
  ulong votes_cnt = fd_ulong_max( votes_len, 15000 );
  *total_sz += fd_clock_timestamp_vote_t_map_align() + fd_clock_timestamp_vote_t_map_footprint( votes_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < votes_len; i++ ) {
    err = fd_clock_timestamp_vote_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_clock_timestamp_votes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_votes_t * self = (fd_clock_timestamp_votes_t *)mem;
  fd_clock_timestamp_votes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_clock_timestamp_votes_t);
  void * * alloc_mem = &alloc_region;
  fd_clock_timestamp_votes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_clock_timestamp_votes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_votes_t * self = (fd_clock_timestamp_votes_t *)struct_mem;
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  self->votes_pool = fd_clock_timestamp_vote_t_map_join_new( alloc_mem, fd_ulong_max( votes_len, 15000 ) );
  self->votes_root = NULL;
  for( ulong i=0; i < votes_len; i++ ) {
    fd_clock_timestamp_vote_t_mapnode_t * node = fd_clock_timestamp_vote_t_map_acquire( self->votes_pool );
    fd_clock_timestamp_vote_new( &node->elem );
    fd_clock_timestamp_vote_decode_inner( &node->elem, alloc_mem, ctx );
    fd_clock_timestamp_vote_t_map_insert( self->votes_pool, &self->votes_root, node );
  }
}
void * fd_clock_timestamp_votes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_votes_global_t * self = (fd_clock_timestamp_votes_global_t *)mem;
  fd_clock_timestamp_votes_new( (fd_clock_timestamp_votes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_clock_timestamp_votes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_clock_timestamp_votes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_clock_timestamp_votes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_clock_timestamp_votes_global_t * self = (fd_clock_timestamp_votes_global_t *)struct_mem;
  ulong votes_len;
  fd_bincode_uint64_decode_unsafe( &votes_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_clock_timestamp_vote_t_map_align() );
  fd_clock_timestamp_vote_t_mapnode_t * votes_pool = fd_clock_timestamp_vote_t_map_join_new( alloc_mem, fd_ulong_max( votes_len, 15000 ) );
  fd_clock_timestamp_vote_t_mapnode_t * votes_root = NULL;
  self->votes_root_gaddr = 0UL;
  for( ulong i=0; i < votes_len; i++ ) {
    fd_clock_timestamp_vote_t_mapnode_t * node = fd_clock_timestamp_vote_t_map_acquire( votes_pool );
    fd_clock_timestamp_vote_new( &node->elem );
    fd_clock_timestamp_vote_decode_inner( &node->elem, alloc_mem, ctx );
    fd_clock_timestamp_vote_t_map_insert( votes_pool, &votes_root, node );
  }
  self->votes_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, votes_pool );
  self->votes_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, votes_root );
}
int fd_clock_timestamp_votes_convert_global_to_local( void const * global_self, fd_clock_timestamp_votes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_clock_timestamp_votes_global_t const * mem = (fd_clock_timestamp_votes_global_t const *)global_self;
  self->votes_pool = fd_wksp_laddr_fast( ctx->wksp, mem->votes_pool_gaddr );
  self->votes_root = fd_wksp_laddr_fast( ctx->wksp, mem->votes_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_clock_timestamp_votes_new(fd_clock_timestamp_votes_t * self) {
  fd_memset( self, 0, sizeof(fd_clock_timestamp_votes_t) );
}
void fd_clock_timestamp_votes_destroy( fd_clock_timestamp_votes_t * self ) {
  for( fd_clock_timestamp_vote_t_mapnode_t * n = fd_clock_timestamp_vote_t_map_minimum(self->votes_pool, self->votes_root ); n; n = fd_clock_timestamp_vote_t_map_successor(self->votes_pool, n) ) {
    fd_clock_timestamp_vote_destroy( &n->elem );
  }
  self->votes_pool = NULL;
  self->votes_root = NULL;
}

ulong fd_clock_timestamp_votes_footprint( void ){ return FD_CLOCK_TIMESTAMP_VOTES_FOOTPRINT; }
ulong fd_clock_timestamp_votes_align( void ){ return FD_CLOCK_TIMESTAMP_VOTES_ALIGN; }

void fd_clock_timestamp_votes_walk( void * w, fd_clock_timestamp_votes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_clock_timestamp_votes", level++ );
  if( self->votes_root ) {
    for( fd_clock_timestamp_vote_t_mapnode_t * n = fd_clock_timestamp_vote_t_map_minimum(self->votes_pool, self->votes_root ); n; n = fd_clock_timestamp_vote_t_map_successor( self->votes_pool, n ) ) {
      fd_clock_timestamp_vote_walk(w, &n->elem, fun, "votes", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_clock_timestamp_votes", level-- );
}
ulong fd_clock_timestamp_votes_size( fd_clock_timestamp_votes_t const * self ) {
  ulong size = 0;
  if( self->votes_root ) {
    size += sizeof(ulong);
    for( fd_clock_timestamp_vote_t_mapnode_t * n = fd_clock_timestamp_vote_t_map_minimum( self->votes_pool, self->votes_root ); n; n = fd_clock_timestamp_vote_t_map_successor( self->votes_pool, n ) ) {
      size += fd_clock_timestamp_vote_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_sysvar_fees_encode( fd_sysvar_fees_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_fee_calculator_encode( &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_sysvar_fees_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_sysvar_fees_t);
  void const * start_data = ctx->data;
  int err = fd_sysvar_fees_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_sysvar_fees_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_fee_calculator_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_sysvar_fees_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_fees_t * self = (fd_sysvar_fees_t *)mem;
  fd_sysvar_fees_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sysvar_fees_t);
  void * * alloc_mem = &alloc_region;
  fd_sysvar_fees_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_sysvar_fees_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_fees_t * self = (fd_sysvar_fees_t *)struct_mem;
  fd_fee_calculator_decode_inner( &self->fee_calculator, alloc_mem, ctx );
}
void * fd_sysvar_fees_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_fees_global_t * self = (fd_sysvar_fees_global_t *)mem;
  fd_sysvar_fees_new( (fd_sysvar_fees_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sysvar_fees_global_t);
  void * * alloc_mem = &alloc_region;
  fd_sysvar_fees_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_sysvar_fees_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_fees_global_t * self = (fd_sysvar_fees_global_t *)struct_mem;
  fd_fee_calculator_decode_inner_global( &self->fee_calculator, alloc_mem, ctx );
}
int fd_sysvar_fees_convert_global_to_local( void const * global_self, fd_sysvar_fees_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_sysvar_fees_global_t const * mem = (fd_sysvar_fees_global_t const *)global_self;
  err = fd_fee_calculator_convert_global_to_local( &mem->fee_calculator, &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_sysvar_fees_new(fd_sysvar_fees_t * self) {
  fd_memset( self, 0, sizeof(fd_sysvar_fees_t) );
  fd_fee_calculator_new( &self->fee_calculator );
}
void fd_sysvar_fees_destroy( fd_sysvar_fees_t * self ) {
  fd_fee_calculator_destroy( &self->fee_calculator );
}

ulong fd_sysvar_fees_footprint( void ){ return FD_SYSVAR_FEES_FOOTPRINT; }
ulong fd_sysvar_fees_align( void ){ return FD_SYSVAR_FEES_ALIGN; }

void fd_sysvar_fees_walk( void * w, fd_sysvar_fees_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_sysvar_fees", level++ );
  fd_fee_calculator_walk( w, &self->fee_calculator, fun, "fee_calculator", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_sysvar_fees", level-- );
}
ulong fd_sysvar_fees_size( fd_sysvar_fees_t const * self ) {
  ulong size = 0;
  size += fd_fee_calculator_size( &self->fee_calculator );
  return size;
}

int fd_sysvar_epoch_rewards_encode( fd_sysvar_epoch_rewards_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->distribution_starting_block_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num_partitions, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->parent_blockhash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint128_encode( self->total_points, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->total_rewards, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->distributed_rewards, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->active), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_sysvar_epoch_rewards_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_sysvar_epoch_rewards_t);
  void const * start_data = ctx->data;
  int err = fd_sysvar_epoch_rewards_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_sysvar_epoch_rewards_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint128_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_sysvar_epoch_rewards_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_epoch_rewards_t * self = (fd_sysvar_epoch_rewards_t *)mem;
  fd_sysvar_epoch_rewards_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sysvar_epoch_rewards_t);
  void * * alloc_mem = &alloc_region;
  fd_sysvar_epoch_rewards_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_sysvar_epoch_rewards_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_epoch_rewards_t * self = (fd_sysvar_epoch_rewards_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->distribution_starting_block_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_partitions, ctx );
  fd_hash_decode_inner( &self->parent_blockhash, alloc_mem, ctx );
  fd_bincode_uint128_decode_unsafe( &self->total_points, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_rewards, ctx );
  fd_bincode_uint64_decode_unsafe( &self->distributed_rewards, ctx );
  fd_bincode_bool_decode_unsafe( &self->active, ctx );
}
void * fd_sysvar_epoch_rewards_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_epoch_rewards_global_t * self = (fd_sysvar_epoch_rewards_global_t *)mem;
  fd_sysvar_epoch_rewards_new( (fd_sysvar_epoch_rewards_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_sysvar_epoch_rewards_global_t);
  void * * alloc_mem = &alloc_region;
  fd_sysvar_epoch_rewards_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_sysvar_epoch_rewards_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_sysvar_epoch_rewards_global_t * self = (fd_sysvar_epoch_rewards_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->distribution_starting_block_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_partitions, ctx );
  fd_hash_decode_inner_global( &self->parent_blockhash, alloc_mem, ctx );
  fd_bincode_uint128_decode_unsafe( &self->total_points, ctx );
  fd_bincode_uint64_decode_unsafe( &self->total_rewards, ctx );
  fd_bincode_uint64_decode_unsafe( &self->distributed_rewards, ctx );
  fd_bincode_bool_decode_unsafe( &self->active, ctx );
}
int fd_sysvar_epoch_rewards_convert_global_to_local( void const * global_self, fd_sysvar_epoch_rewards_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_sysvar_epoch_rewards_global_t const * mem = (fd_sysvar_epoch_rewards_global_t const *)global_self;
  self->distribution_starting_block_height = mem->distribution_starting_block_height;
  self->num_partitions = mem->num_partitions;
  err = fd_hash_convert_global_to_local( &mem->parent_blockhash, &self->parent_blockhash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->total_points = mem->total_points;
  self->total_rewards = mem->total_rewards;
  self->distributed_rewards = mem->distributed_rewards;
  self->active = mem->active;
  return FD_BINCODE_SUCCESS;
}
void fd_sysvar_epoch_rewards_new(fd_sysvar_epoch_rewards_t * self) {
  fd_memset( self, 0, sizeof(fd_sysvar_epoch_rewards_t) );
  fd_hash_new( &self->parent_blockhash );
}
void fd_sysvar_epoch_rewards_destroy( fd_sysvar_epoch_rewards_t * self ) {
  fd_hash_destroy( &self->parent_blockhash );
}

ulong fd_sysvar_epoch_rewards_footprint( void ){ return FD_SYSVAR_EPOCH_REWARDS_FOOTPRINT; }
ulong fd_sysvar_epoch_rewards_align( void ){ return FD_SYSVAR_EPOCH_REWARDS_ALIGN; }

void fd_sysvar_epoch_rewards_walk( void * w, fd_sysvar_epoch_rewards_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_sysvar_epoch_rewards", level++ );
  fun( w, &self->distribution_starting_block_height, "distribution_starting_block_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->num_partitions, "num_partitions", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->parent_blockhash, fun, "parent_blockhash", level );
  fun( w, &self->total_points, "total_points", FD_FLAMENCO_TYPE_UINT128, "uint128", level );
  fun( w, &self->total_rewards, "total_rewards", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->distributed_rewards, "distributed_rewards", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->active, "active", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_sysvar_epoch_rewards", level-- );
}
ulong fd_sysvar_epoch_rewards_size( fd_sysvar_epoch_rewards_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_hash_size( &self->parent_blockhash );
  size += sizeof(uint128);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(char);
  return size;
}

int fd_config_keys_pair_encode( fd_config_keys_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->signer), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_config_keys_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_config_keys_pair_t);
  void const * start_data = ctx->data;
  int err = fd_config_keys_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_config_keys_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_config_keys_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_pair_t * self = (fd_config_keys_pair_t *)mem;
  fd_config_keys_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_config_keys_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_config_keys_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_config_keys_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_pair_t * self = (fd_config_keys_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_bincode_bool_decode_unsafe( &self->signer, ctx );
}
void * fd_config_keys_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_pair_global_t * self = (fd_config_keys_pair_global_t *)mem;
  fd_config_keys_pair_new( (fd_config_keys_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_config_keys_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_config_keys_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_config_keys_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_pair_global_t * self = (fd_config_keys_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_bincode_bool_decode_unsafe( &self->signer, ctx );
}
int fd_config_keys_pair_convert_global_to_local( void const * global_self, fd_config_keys_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_config_keys_pair_global_t const * mem = (fd_config_keys_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->signer = mem->signer;
  return FD_BINCODE_SUCCESS;
}
void fd_config_keys_pair_new(fd_config_keys_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_config_keys_pair_t) );
  fd_pubkey_new( &self->key );
}
void fd_config_keys_pair_destroy( fd_config_keys_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
}

ulong fd_config_keys_pair_footprint( void ){ return FD_CONFIG_KEYS_PAIR_FOOTPRINT; }
ulong fd_config_keys_pair_align( void ){ return FD_CONFIG_KEYS_PAIR_ALIGN; }

void fd_config_keys_pair_walk( void * w, fd_config_keys_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_config_keys_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fun( w, &self->signer, "signer", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_config_keys_pair", level-- );
}
ulong fd_config_keys_pair_size( fd_config_keys_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += sizeof(char);
  return size;
}

int fd_stake_config_encode( fd_stake_config_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_compact_u16_encode( &self->config_keys_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->config_keys_len ) {
    for( ulong i=0; i < self->config_keys_len; i++ ) {
      err = fd_config_keys_pair_encode( self->config_keys + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_double_encode( self->warmup_cooldown_rate, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->slash_penalty), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_config_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_config_t);
  void const * start_data = ctx->data;
  int err = fd_stake_config_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_config_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ushort config_keys_len;
  err = fd_bincode_compact_u16_decode( &config_keys_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( config_keys_len ) {
    *total_sz += FD_CONFIG_KEYS_PAIR_ALIGN + FD_CONFIG_KEYS_PAIR_FOOTPRINT*config_keys_len;
    for( ulong i=0; i < config_keys_len; i++ ) {
      err = fd_config_keys_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_config_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_config_t * self = (fd_stake_config_t *)mem;
  fd_stake_config_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_config_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_config_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_config_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_config_t * self = (fd_stake_config_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->config_keys_len, ctx );
  if( self->config_keys_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CONFIG_KEYS_PAIR_ALIGN );
    self->config_keys = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CONFIG_KEYS_PAIR_FOOTPRINT*self->config_keys_len;
    for( ulong i=0; i < self->config_keys_len; i++ ) {
      fd_config_keys_pair_new( self->config_keys + i );
      fd_config_keys_pair_decode_inner( self->config_keys + i, alloc_mem, ctx );
    }
  } else
    self->config_keys = NULL;
  fd_bincode_double_decode_unsafe( &self->warmup_cooldown_rate, ctx );
  fd_bincode_uint8_decode_unsafe( &self->slash_penalty, ctx );
}
void * fd_stake_config_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_config_global_t * self = (fd_stake_config_global_t *)mem;
  fd_stake_config_new( (fd_stake_config_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_config_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_config_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_config_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_config_global_t * self = (fd_stake_config_global_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->config_keys_len, ctx );
  if( self->config_keys_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CONFIG_KEYS_PAIR_ALIGN );
    self->config_keys_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CONFIG_KEYS_PAIR_FOOTPRINT*self->config_keys_len;
    for( ulong i=0; i < self->config_keys_len; i++ ) {
      fd_config_keys_pair_new( (fd_config_keys_pair_t *)(cur_mem + FD_CONFIG_KEYS_PAIR_FOOTPRINT * i) );
      fd_config_keys_pair_decode_inner_global( cur_mem + FD_CONFIG_KEYS_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->config_keys_gaddr = 0UL;
  fd_bincode_double_decode_unsafe( &self->warmup_cooldown_rate, ctx );
  fd_bincode_uint8_decode_unsafe( &self->slash_penalty, ctx );
}
int fd_stake_config_convert_global_to_local( void const * global_self, fd_stake_config_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_config_global_t const * mem = (fd_stake_config_global_t const *)global_self;
  self->config_keys_len = mem->config_keys_len;
  self->config_keys     = fd_wksp_laddr_fast( ctx->wksp, mem->config_keys_gaddr );
  self->warmup_cooldown_rate = mem->warmup_cooldown_rate;
  self->slash_penalty = mem->slash_penalty;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_config_new(fd_stake_config_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_config_t) );
}
void fd_stake_config_destroy( fd_stake_config_t * self ) {
  if( self->config_keys ) {
    for( ulong i=0; i < self->config_keys_len; i++ )
      fd_config_keys_pair_destroy( self->config_keys + i );
    self->config_keys = NULL;
  }
}

ulong fd_stake_config_footprint( void ){ return FD_STAKE_CONFIG_FOOTPRINT; }
ulong fd_stake_config_align( void ){ return FD_STAKE_CONFIG_ALIGN; }

void fd_stake_config_walk( void * w, fd_stake_config_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_config", level++ );
  if( self->config_keys_len ) {
    fun( w, NULL, "config_keys", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->config_keys_len; i++ )
      fd_config_keys_pair_walk(w, self->config_keys + i, fun, "config_keys_pair", level );
    fun( w, NULL, "config_keys", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->warmup_cooldown_rate, "warmup_cooldown_rate", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->slash_penalty, "slash_penalty", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_config", level-- );
}
ulong fd_stake_config_size( fd_stake_config_t const * self ) {
  ulong size = 0;
  do {
    ushort tmp = (ushort)self->config_keys_len;
    size += fd_bincode_compact_u16_size( &tmp );
    for( ulong i=0; i < self->config_keys_len; i++ )
      size += fd_config_keys_pair_size( self->config_keys + i );
  } while(0);
  size += sizeof(double);
  size += sizeof(char);
  return size;
}

int fd_feature_entry_encode( fd_feature_entry_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->description_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->description_len ) {
    err = fd_bincode_bytes_encode( self->description, self->description_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->since_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_feature_entry_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_feature_entry_t);
  void const * start_data = ctx->data;
  int err = fd_feature_entry_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_feature_entry_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong description_len;
  err = fd_bincode_uint64_decode( &description_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += description_len;
  if( description_len ) {
    err = fd_bincode_bytes_decode_footprint( description_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - description_len, description_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_feature_entry_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_entry_t * self = (fd_feature_entry_t *)mem;
  fd_feature_entry_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_feature_entry_t);
  void * * alloc_mem = &alloc_region;
  fd_feature_entry_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_feature_entry_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_entry_t * self = (fd_feature_entry_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->description_len, ctx );
  if( self->description_len ) {
    self->description = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->description, self->description_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->description_len;
  } else
    self->description = NULL;
  fd_bincode_uint64_decode_unsafe( &self->since_slot, ctx );
}
void * fd_feature_entry_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_entry_global_t * self = (fd_feature_entry_global_t *)mem;
  fd_feature_entry_new( (fd_feature_entry_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_feature_entry_global_t);
  void * * alloc_mem = &alloc_region;
  fd_feature_entry_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_feature_entry_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_feature_entry_global_t * self = (fd_feature_entry_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->description_len, ctx );
  if( self->description_len ) {
    self->description_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->description_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->description_len;
  } else
    self->description_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->since_slot, ctx );
}
int fd_feature_entry_convert_global_to_local( void const * global_self, fd_feature_entry_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_feature_entry_global_t const * mem = (fd_feature_entry_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->description_len = mem->description_len;
  self->description     = fd_wksp_laddr_fast( ctx->wksp, mem->description_gaddr );
  self->since_slot = mem->since_slot;
  return FD_BINCODE_SUCCESS;
}
void fd_feature_entry_new(fd_feature_entry_t * self) {
  fd_memset( self, 0, sizeof(fd_feature_entry_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_feature_entry_destroy( fd_feature_entry_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  if( self->description ) {
    self->description = NULL;
  }
}

ulong fd_feature_entry_footprint( void ){ return FD_FEATURE_ENTRY_FOOTPRINT; }
ulong fd_feature_entry_align( void ){ return FD_FEATURE_ENTRY_ALIGN; }

void fd_feature_entry_walk( void * w, fd_feature_entry_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_feature_entry", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun(w, self->description, "description", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->since_slot, "since_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_feature_entry", level-- );
}
ulong fd_feature_entry_size( fd_feature_entry_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  do {
    size += sizeof(ulong);
    size += self->description_len;
  } while(0);
  size += sizeof(ulong);
  return size;
}

int fd_firedancer_bank_encode( fd_firedancer_bank_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stakes_encode( &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_recent_block_hashes_encode( &self->recent_block_hashes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_clock_timestamp_votes_encode( &self->timestamp_votes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->prev_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->poh, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->banks_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_encode( &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->capitalization, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->block_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->hashes_per_tick, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->ticks_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint128_encode( self->ns_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->genesis_creation_time, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->slots_per_year, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->max_tick_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_encode( &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_encode( &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_encode( &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collected_fees, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collected_rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_accounts_encode( &self->epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_last_restart_slot_encode( &self->last_restart_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_firedancer_bank_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_firedancer_bank_t);
  void const * start_data = ctx->data;
  int err = fd_firedancer_bank_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_firedancer_bank_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stakes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_recent_block_hashes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_clock_timestamp_votes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint128_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_inflation_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_last_restart_slot_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_firedancer_bank_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_firedancer_bank_t * self = (fd_firedancer_bank_t *)mem;
  fd_firedancer_bank_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_firedancer_bank_t);
  void * * alloc_mem = &alloc_region;
  fd_firedancer_bank_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_firedancer_bank_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_firedancer_bank_t * self = (fd_firedancer_bank_t *)struct_mem;
  fd_stakes_decode_inner( &self->stakes, alloc_mem, ctx );
  fd_recent_block_hashes_decode_inner( &self->recent_block_hashes, alloc_mem, ctx );
  fd_clock_timestamp_votes_decode_inner( &self->timestamp_votes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prev_slot, ctx );
  fd_hash_decode_inner( &self->poh, alloc_mem, ctx );
  fd_hash_decode_inner( &self->banks_hash, alloc_mem, ctx );
  fd_fee_rate_governor_decode_inner( &self->fee_rate_governor, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->capitalization, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_per_tick, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint128_decode_unsafe( &self->ns_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->genesis_creation_time, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  fd_inflation_decode_inner( &self->inflation, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner( &self->epoch_schedule, alloc_mem, ctx );
  fd_rent_decode_inner( &self->rent, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_fees, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_rent, ctx );
  fd_vote_accounts_decode_inner( &self->epoch_stakes, alloc_mem, ctx );
  fd_sol_sysvar_last_restart_slot_decode_inner( &self->last_restart_slot, alloc_mem, ctx );
}
void * fd_firedancer_bank_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_firedancer_bank_global_t * self = (fd_firedancer_bank_global_t *)mem;
  fd_firedancer_bank_new( (fd_firedancer_bank_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_firedancer_bank_global_t);
  void * * alloc_mem = &alloc_region;
  fd_firedancer_bank_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_firedancer_bank_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_firedancer_bank_global_t * self = (fd_firedancer_bank_global_t *)struct_mem;
  fd_stakes_decode_inner_global( &self->stakes, alloc_mem, ctx );
  fd_recent_block_hashes_decode_inner_global( &self->recent_block_hashes, alloc_mem, ctx );
  fd_clock_timestamp_votes_decode_inner_global( &self->timestamp_votes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prev_slot, ctx );
  fd_hash_decode_inner_global( &self->poh, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->banks_hash, alloc_mem, ctx );
  fd_fee_rate_governor_decode_inner_global( &self->fee_rate_governor, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->capitalization, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_per_tick, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint128_decode_unsafe( &self->ns_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->genesis_creation_time, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  fd_inflation_decode_inner_global( &self->inflation, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner_global( &self->epoch_schedule, alloc_mem, ctx );
  fd_rent_decode_inner_global( &self->rent, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_fees, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_rent, ctx );
  fd_vote_accounts_decode_inner_global( &self->epoch_stakes, alloc_mem, ctx );
  fd_sol_sysvar_last_restart_slot_decode_inner_global( &self->last_restart_slot, alloc_mem, ctx );
}
int fd_firedancer_bank_convert_global_to_local( void const * global_self, fd_firedancer_bank_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_firedancer_bank_global_t const * mem = (fd_firedancer_bank_global_t const *)global_self;
  err = fd_stakes_convert_global_to_local( &mem->stakes, &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_recent_block_hashes_convert_global_to_local( &mem->recent_block_hashes, &self->recent_block_hashes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_clock_timestamp_votes_convert_global_to_local( &mem->timestamp_votes, &self->timestamp_votes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slot = mem->slot;
  self->prev_slot = mem->prev_slot;
  err = fd_hash_convert_global_to_local( &mem->poh, &self->poh, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->banks_hash, &self->banks_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_convert_global_to_local( &mem->fee_rate_governor, &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->capitalization = mem->capitalization;
  self->block_height = mem->block_height;
  self->lamports_per_signature = mem->lamports_per_signature;
  self->hashes_per_tick = mem->hashes_per_tick;
  self->ticks_per_slot = mem->ticks_per_slot;
  self->ns_per_slot = mem->ns_per_slot;
  self->genesis_creation_time = mem->genesis_creation_time;
  self->slots_per_year = mem->slots_per_year;
  self->max_tick_height = mem->max_tick_height;
  err = fd_inflation_convert_global_to_local( &mem->inflation, &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_convert_global_to_local( &mem->epoch_schedule, &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_convert_global_to_local( &mem->rent, &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->collected_fees = mem->collected_fees;
  self->collected_rent = mem->collected_rent;
  err = fd_vote_accounts_convert_global_to_local( &mem->epoch_stakes, &self->epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_last_restart_slot_convert_global_to_local( &mem->last_restart_slot, &self->last_restart_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_firedancer_bank_new(fd_firedancer_bank_t * self) {
  fd_memset( self, 0, sizeof(fd_firedancer_bank_t) );
  fd_stakes_new( &self->stakes );
  fd_recent_block_hashes_new( &self->recent_block_hashes );
  fd_clock_timestamp_votes_new( &self->timestamp_votes );
  fd_hash_new( &self->poh );
  fd_hash_new( &self->banks_hash );
  fd_fee_rate_governor_new( &self->fee_rate_governor );
  fd_inflation_new( &self->inflation );
  fd_epoch_schedule_new( &self->epoch_schedule );
  fd_rent_new( &self->rent );
  fd_vote_accounts_new( &self->epoch_stakes );
  fd_sol_sysvar_last_restart_slot_new( &self->last_restart_slot );
}
void fd_firedancer_bank_destroy( fd_firedancer_bank_t * self ) {
  fd_stakes_destroy( &self->stakes );
  fd_recent_block_hashes_destroy( &self->recent_block_hashes );
  fd_clock_timestamp_votes_destroy( &self->timestamp_votes );
  fd_hash_destroy( &self->poh );
  fd_hash_destroy( &self->banks_hash );
  fd_fee_rate_governor_destroy( &self->fee_rate_governor );
  fd_inflation_destroy( &self->inflation );
  fd_epoch_schedule_destroy( &self->epoch_schedule );
  fd_rent_destroy( &self->rent );
  fd_vote_accounts_destroy( &self->epoch_stakes );
  fd_sol_sysvar_last_restart_slot_destroy( &self->last_restart_slot );
}

ulong fd_firedancer_bank_footprint( void ){ return FD_FIREDANCER_BANK_FOOTPRINT; }
ulong fd_firedancer_bank_align( void ){ return FD_FIREDANCER_BANK_ALIGN; }

void fd_firedancer_bank_walk( void * w, fd_firedancer_bank_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_firedancer_bank", level++ );
  fd_stakes_walk( w, &self->stakes, fun, "stakes", level );
  fd_recent_block_hashes_walk( w, &self->recent_block_hashes, fun, "recent_block_hashes", level );
  fd_clock_timestamp_votes_walk( w, &self->timestamp_votes, fun, "timestamp_votes", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->prev_slot, "prev_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->poh, fun, "poh", level );
  fd_hash_walk( w, &self->banks_hash, fun, "banks_hash", level );
  fd_fee_rate_governor_walk( w, &self->fee_rate_governor, fun, "fee_rate_governor", level );
  fun( w, &self->capitalization, "capitalization", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->block_height, "block_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->lamports_per_signature, "lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->hashes_per_tick, "hashes_per_tick", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->ticks_per_slot, "ticks_per_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->ns_per_slot, "ns_per_slot", FD_FLAMENCO_TYPE_UINT128, "uint128", level );
  fun( w, &self->genesis_creation_time, "genesis_creation_time", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slots_per_year, "slots_per_year", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->max_tick_height, "max_tick_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_inflation_walk( w, &self->inflation, fun, "inflation", level );
  fd_epoch_schedule_walk( w, &self->epoch_schedule, fun, "epoch_schedule", level );
  fd_rent_walk( w, &self->rent, fun, "rent", level );
  fun( w, &self->collected_fees, "collected_fees", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->collected_rent, "collected_rent", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_vote_accounts_walk( w, &self->epoch_stakes, fun, "epoch_stakes", level );
  fd_sol_sysvar_last_restart_slot_walk( w, &self->last_restart_slot, fun, "last_restart_slot", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_firedancer_bank", level-- );
}
ulong fd_firedancer_bank_size( fd_firedancer_bank_t const * self ) {
  ulong size = 0;
  size += fd_stakes_size( &self->stakes );
  size += fd_recent_block_hashes_size( &self->recent_block_hashes );
  size += fd_clock_timestamp_votes_size( &self->timestamp_votes );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_hash_size( &self->poh );
  size += fd_hash_size( &self->banks_hash );
  size += fd_fee_rate_governor_size( &self->fee_rate_governor );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(uint128);
  size += sizeof(ulong);
  size += sizeof(double);
  size += sizeof(ulong);
  size += fd_inflation_size( &self->inflation );
  size += fd_epoch_schedule_size( &self->epoch_schedule );
  size += fd_rent_size( &self->rent );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_vote_accounts_size( &self->epoch_stakes );
  size += fd_sol_sysvar_last_restart_slot_size( &self->last_restart_slot );
  return size;
}

FD_FN_PURE uchar fd_cluster_type_is_Testnet(fd_cluster_type_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_cluster_type_is_MainnetBeta(fd_cluster_type_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_cluster_type_is_Devnet(fd_cluster_type_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_cluster_type_is_Development(fd_cluster_type_t const * self) {
  return self->discriminant == 3;
}
void fd_cluster_type_inner_new( fd_cluster_type_inner_t * self, uint discriminant );
int fd_cluster_type_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_cluster_type_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_cluster_type_t);
  void const * start_data = ctx->data;
  int err =  fd_cluster_type_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_cluster_type_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_cluster_type_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_cluster_type_inner_decode_inner( fd_cluster_type_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  }
}
void fd_cluster_type_inner_decode_inner_global( fd_cluster_type_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  }
}
int fd_cluster_type_convert_global_to_local_inner( fd_cluster_type_inner_global_t const * mem, fd_cluster_type_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_cluster_type_convert_global_to_local( void const * global_self, fd_cluster_type_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_cluster_type_global_t const * mem = (fd_cluster_type_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_cluster_type_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_cluster_type_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cluster_type_t * self = (fd_cluster_type_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_cluster_type_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_cluster_type_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cluster_type_t * self = (fd_cluster_type_t *)mem;
  fd_cluster_type_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_cluster_type_t);
  void * * alloc_mem = &alloc_region;
  fd_cluster_type_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_cluster_type_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cluster_type_t * self = (fd_cluster_type_t *)mem;
  fd_cluster_type_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_cluster_type_t);
  void * * alloc_mem = &alloc_region;
  fd_cluster_type_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_cluster_type_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cluster_type_global_t * self = (fd_cluster_type_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_cluster_type_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_cluster_type_inner_new( fd_cluster_type_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_cluster_type_new_disc( fd_cluster_type_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_cluster_type_inner_new( &self->inner, self->discriminant );
}
void fd_cluster_type_new( fd_cluster_type_t * self ) {
  fd_memset( self, 0, sizeof(fd_cluster_type_t) );
  fd_cluster_type_new_disc( self, UINT_MAX );
}
void fd_cluster_type_inner_destroy( fd_cluster_type_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_cluster_type_destroy( fd_cluster_type_t * self ) {
  fd_cluster_type_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_cluster_type_footprint( void ){ return FD_CLUSTER_TYPE_FOOTPRINT; }
ulong fd_cluster_type_align( void ){ return FD_CLUSTER_TYPE_ALIGN; }

void fd_cluster_type_walk( void * w, fd_cluster_type_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_cluster_type", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "Testnet", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "MainnetBeta", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "Devnet", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "Development", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_cluster_type", level-- );
}
ulong fd_cluster_type_size( fd_cluster_type_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  }
  return size;
}

int fd_cluster_type_inner_encode( fd_cluster_type_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  return FD_BINCODE_SUCCESS;
}
int fd_cluster_type_encode( fd_cluster_type_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_cluster_type_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_pubkey_node_encode( fd_pubkey_node_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_pubkey_node_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_pubkey_node_t);
  void const * start_data = ctx->data;
  int err = fd_pubkey_node_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_pubkey_node_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_pubkey_node_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_t * self = (fd_pubkey_node_t *)mem;
  fd_pubkey_node_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_node_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_node_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_node_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_t * self = (fd_pubkey_node_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
}
void * fd_pubkey_node_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_global_t * self = (fd_pubkey_node_global_t *)mem;
  fd_pubkey_node_new( (fd_pubkey_node_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_node_global_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_node_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_node_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_node_global_t * self = (fd_pubkey_node_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
}
int fd_pubkey_node_convert_global_to_local( void const * global_self, fd_pubkey_node_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_pubkey_node_global_t const * mem = (fd_pubkey_node_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_pubkey_node_new(fd_pubkey_node_t * self) {
  fd_memset( self, 0, sizeof(fd_pubkey_node_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_pubkey_node_destroy( fd_pubkey_node_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
}

ulong fd_pubkey_node_footprint( void ){ return FD_PUBKEY_NODE_FOOTPRINT; }
ulong fd_pubkey_node_align( void ){ return FD_PUBKEY_NODE_ALIGN; }

void fd_pubkey_node_walk( void * w, fd_pubkey_node_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_pubkey_node", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_pubkey_node", level-- );
}
ulong fd_pubkey_node_size( fd_pubkey_node_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  return size;
}

int fd_rent_fresh_accounts_partition_encode( fd_rent_fresh_accounts_partition_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->partition, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->accounts_root ) {
    ulong accounts_len = fd_pubkey_node_t_map_size( self->accounts_pool, self->accounts_root );
    err = fd_bincode_uint64_encode( accounts_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_pubkey_node_t_mapnode_t * n = fd_pubkey_node_t_map_minimum( self->accounts_pool, self->accounts_root ); n; n = fd_pubkey_node_t_map_successor( self->accounts_pool, n ) ) {
      err = fd_pubkey_node_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong accounts_len = 0;
    err = fd_bincode_uint64_encode( accounts_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_rent_fresh_accounts_partition_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_rent_fresh_accounts_partition_t);
  void const * start_data = ctx->data;
  int err = fd_rent_fresh_accounts_partition_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_rent_fresh_accounts_partition_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong accounts_len = 0UL;
  err = fd_bincode_uint64_decode( &accounts_len, ctx );
  ulong accounts_cnt = fd_ulong_max( accounts_len, 100 );
  *total_sz += fd_pubkey_node_t_map_align() + fd_pubkey_node_t_map_footprint( accounts_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < accounts_len; i++ ) {
    err = fd_pubkey_node_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_rent_fresh_accounts_partition_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_partition_t * self = (fd_rent_fresh_accounts_partition_t *)mem;
  fd_rent_fresh_accounts_partition_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_fresh_accounts_partition_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_fresh_accounts_partition_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_fresh_accounts_partition_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_partition_t * self = (fd_rent_fresh_accounts_partition_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->partition, ctx );
  ulong accounts_len;
  fd_bincode_uint64_decode_unsafe( &accounts_len, ctx );
  self->accounts_pool = fd_pubkey_node_t_map_join_new( alloc_mem, fd_ulong_max( accounts_len, 100 ) );
  self->accounts_root = NULL;
  for( ulong i=0; i < accounts_len; i++ ) {
    fd_pubkey_node_t_mapnode_t * node = fd_pubkey_node_t_map_acquire( self->accounts_pool );
    fd_pubkey_node_new( &node->elem );
    fd_pubkey_node_decode_inner( &node->elem, alloc_mem, ctx );
    fd_pubkey_node_t_map_insert( self->accounts_pool, &self->accounts_root, node );
  }
}
void * fd_rent_fresh_accounts_partition_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_partition_global_t * self = (fd_rent_fresh_accounts_partition_global_t *)mem;
  fd_rent_fresh_accounts_partition_new( (fd_rent_fresh_accounts_partition_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_fresh_accounts_partition_global_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_fresh_accounts_partition_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_fresh_accounts_partition_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_partition_global_t * self = (fd_rent_fresh_accounts_partition_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->partition, ctx );
  ulong accounts_len;
  fd_bincode_uint64_decode_unsafe( &accounts_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_pubkey_node_t_map_align() );
  fd_pubkey_node_t_mapnode_t * accounts_pool = fd_pubkey_node_t_map_join_new( alloc_mem, fd_ulong_max( accounts_len, 100 ) );
  fd_pubkey_node_t_mapnode_t * accounts_root = NULL;
  self->accounts_root_gaddr = 0UL;
  for( ulong i=0; i < accounts_len; i++ ) {
    fd_pubkey_node_t_mapnode_t * node = fd_pubkey_node_t_map_acquire( accounts_pool );
    fd_pubkey_node_new( &node->elem );
    fd_pubkey_node_decode_inner( &node->elem, alloc_mem, ctx );
    fd_pubkey_node_t_map_insert( accounts_pool, &accounts_root, node );
  }
  self->accounts_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, accounts_pool );
  self->accounts_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, accounts_root );
}
int fd_rent_fresh_accounts_partition_convert_global_to_local( void const * global_self, fd_rent_fresh_accounts_partition_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_rent_fresh_accounts_partition_global_t const * mem = (fd_rent_fresh_accounts_partition_global_t const *)global_self;
  self->partition = mem->partition;
  self->accounts_pool = fd_wksp_laddr_fast( ctx->wksp, mem->accounts_pool_gaddr );
  self->accounts_root = fd_wksp_laddr_fast( ctx->wksp, mem->accounts_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_rent_fresh_accounts_partition_new(fd_rent_fresh_accounts_partition_t * self) {
  fd_memset( self, 0, sizeof(fd_rent_fresh_accounts_partition_t) );
}
void fd_rent_fresh_accounts_partition_destroy( fd_rent_fresh_accounts_partition_t * self ) {
  for( fd_pubkey_node_t_mapnode_t * n = fd_pubkey_node_t_map_minimum(self->accounts_pool, self->accounts_root ); n; n = fd_pubkey_node_t_map_successor(self->accounts_pool, n) ) {
    fd_pubkey_node_destroy( &n->elem );
  }
  self->accounts_pool = NULL;
  self->accounts_root = NULL;
}

ulong fd_rent_fresh_accounts_partition_footprint( void ){ return FD_RENT_FRESH_ACCOUNTS_PARTITION_FOOTPRINT; }
ulong fd_rent_fresh_accounts_partition_align( void ){ return FD_RENT_FRESH_ACCOUNTS_PARTITION_ALIGN; }

void fd_rent_fresh_accounts_partition_walk( void * w, fd_rent_fresh_accounts_partition_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_rent_fresh_accounts_partition", level++ );
  fun( w, &self->partition, "partition", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->accounts_root ) {
    for( fd_pubkey_node_t_mapnode_t * n = fd_pubkey_node_t_map_minimum(self->accounts_pool, self->accounts_root ); n; n = fd_pubkey_node_t_map_successor( self->accounts_pool, n ) ) {
      fd_pubkey_node_walk(w, &n->elem, fun, "accounts", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_rent_fresh_accounts_partition", level-- );
}
ulong fd_rent_fresh_accounts_partition_size( fd_rent_fresh_accounts_partition_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  if( self->accounts_root ) {
    size += sizeof(ulong);
    for( fd_pubkey_node_t_mapnode_t * n = fd_pubkey_node_t_map_minimum( self->accounts_pool, self->accounts_root ); n; n = fd_pubkey_node_t_map_successor( self->accounts_pool, n ) ) {
      size += fd_pubkey_node_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_rent_fresh_accounts_encode( fd_rent_fresh_accounts_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->total_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->partitions_root ) {
    ulong partitions_len = fd_rent_fresh_accounts_partition_t_map_size( self->partitions_pool, self->partitions_root );
    err = fd_bincode_uint64_encode( partitions_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_rent_fresh_accounts_partition_t_mapnode_t * n = fd_rent_fresh_accounts_partition_t_map_minimum( self->partitions_pool, self->partitions_root ); n; n = fd_rent_fresh_accounts_partition_t_map_successor( self->partitions_pool, n ) ) {
      err = fd_rent_fresh_accounts_partition_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong partitions_len = 0;
    err = fd_bincode_uint64_encode( partitions_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_rent_fresh_accounts_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_rent_fresh_accounts_t);
  void const * start_data = ctx->data;
  int err = fd_rent_fresh_accounts_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_rent_fresh_accounts_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong partitions_len = 0UL;
  err = fd_bincode_uint64_decode( &partitions_len, ctx );
  ulong partitions_cnt = fd_ulong_max( partitions_len, 400 );
  *total_sz += fd_rent_fresh_accounts_partition_t_map_align() + fd_rent_fresh_accounts_partition_t_map_footprint( partitions_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < partitions_len; i++ ) {
    err = fd_rent_fresh_accounts_partition_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_rent_fresh_accounts_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_t * self = (fd_rent_fresh_accounts_t *)mem;
  fd_rent_fresh_accounts_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_fresh_accounts_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_fresh_accounts_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_fresh_accounts_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_t * self = (fd_rent_fresh_accounts_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->total_count, ctx );
  ulong partitions_len;
  fd_bincode_uint64_decode_unsafe( &partitions_len, ctx );
  self->partitions_pool = fd_rent_fresh_accounts_partition_t_map_join_new( alloc_mem, fd_ulong_max( partitions_len, 400 ) );
  self->partitions_root = NULL;
  for( ulong i=0; i < partitions_len; i++ ) {
    fd_rent_fresh_accounts_partition_t_mapnode_t * node = fd_rent_fresh_accounts_partition_t_map_acquire( self->partitions_pool );
    fd_rent_fresh_accounts_partition_new( &node->elem );
    fd_rent_fresh_accounts_partition_decode_inner( &node->elem, alloc_mem, ctx );
    fd_rent_fresh_accounts_partition_t_map_insert( self->partitions_pool, &self->partitions_root, node );
  }
}
void * fd_rent_fresh_accounts_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_global_t * self = (fd_rent_fresh_accounts_global_t *)mem;
  fd_rent_fresh_accounts_new( (fd_rent_fresh_accounts_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_rent_fresh_accounts_global_t);
  void * * alloc_mem = &alloc_region;
  fd_rent_fresh_accounts_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_rent_fresh_accounts_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_rent_fresh_accounts_global_t * self = (fd_rent_fresh_accounts_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->total_count, ctx );
  ulong partitions_len;
  fd_bincode_uint64_decode_unsafe( &partitions_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_rent_fresh_accounts_partition_t_map_align() );
  fd_rent_fresh_accounts_partition_t_mapnode_t * partitions_pool = fd_rent_fresh_accounts_partition_t_map_join_new( alloc_mem, fd_ulong_max( partitions_len, 400 ) );
  fd_rent_fresh_accounts_partition_t_mapnode_t * partitions_root = NULL;
  self->partitions_root_gaddr = 0UL;
  for( ulong i=0; i < partitions_len; i++ ) {
    fd_rent_fresh_accounts_partition_t_mapnode_t * node = fd_rent_fresh_accounts_partition_t_map_acquire( partitions_pool );
    fd_rent_fresh_accounts_partition_new( &node->elem );
    fd_rent_fresh_accounts_partition_decode_inner( &node->elem, alloc_mem, ctx );
    fd_rent_fresh_accounts_partition_t_map_insert( partitions_pool, &partitions_root, node );
  }
  self->partitions_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, partitions_pool );
  self->partitions_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, partitions_root );
}
int fd_rent_fresh_accounts_convert_global_to_local( void const * global_self, fd_rent_fresh_accounts_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_rent_fresh_accounts_global_t const * mem = (fd_rent_fresh_accounts_global_t const *)global_self;
  self->total_count = mem->total_count;
  self->partitions_pool = fd_wksp_laddr_fast( ctx->wksp, mem->partitions_pool_gaddr );
  self->partitions_root = fd_wksp_laddr_fast( ctx->wksp, mem->partitions_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_rent_fresh_accounts_new(fd_rent_fresh_accounts_t * self) {
  fd_memset( self, 0, sizeof(fd_rent_fresh_accounts_t) );
}
void fd_rent_fresh_accounts_destroy( fd_rent_fresh_accounts_t * self ) {
  for( fd_rent_fresh_accounts_partition_t_mapnode_t * n = fd_rent_fresh_accounts_partition_t_map_minimum(self->partitions_pool, self->partitions_root ); n; n = fd_rent_fresh_accounts_partition_t_map_successor(self->partitions_pool, n) ) {
    fd_rent_fresh_accounts_partition_destroy( &n->elem );
  }
  self->partitions_pool = NULL;
  self->partitions_root = NULL;
}

ulong fd_rent_fresh_accounts_footprint( void ){ return FD_RENT_FRESH_ACCOUNTS_FOOTPRINT; }
ulong fd_rent_fresh_accounts_align( void ){ return FD_RENT_FRESH_ACCOUNTS_ALIGN; }

void fd_rent_fresh_accounts_walk( void * w, fd_rent_fresh_accounts_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_rent_fresh_accounts", level++ );
  fun( w, &self->total_count, "total_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->partitions_root ) {
    for( fd_rent_fresh_accounts_partition_t_mapnode_t * n = fd_rent_fresh_accounts_partition_t_map_minimum(self->partitions_pool, self->partitions_root ); n; n = fd_rent_fresh_accounts_partition_t_map_successor( self->partitions_pool, n ) ) {
      fd_rent_fresh_accounts_partition_walk(w, &n->elem, fun, "partitions", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_rent_fresh_accounts", level-- );
}
ulong fd_rent_fresh_accounts_size( fd_rent_fresh_accounts_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  if( self->partitions_root ) {
    size += sizeof(ulong);
    for( fd_rent_fresh_accounts_partition_t_mapnode_t * n = fd_rent_fresh_accounts_partition_t_map_minimum( self->partitions_pool, self->partitions_root ); n; n = fd_rent_fresh_accounts_partition_t_map_successor( self->partitions_pool, n ) ) {
      size += fd_rent_fresh_accounts_partition_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_epoch_bank_encode( fd_epoch_bank_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stakes_encode( &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->hashes_per_tick, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->ticks_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint128_encode( self->ns_per_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->genesis_creation_time, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->slots_per_year, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->max_tick_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_inflation_encode( &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_encode( &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_encode( &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->eah_start_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->eah_stop_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->eah_interval, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->genesis_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->cluster_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i<3; i++ ) {
    err = fd_bincode_uint32_encode( self->cluster_version[i], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_vote_accounts_encode( &self->next_epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_encode( &self->rent_epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_epoch_bank_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_epoch_bank_t);
  void const * start_data = ctx->data;
  int err = fd_epoch_bank_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_epoch_bank_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stakes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint128_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_inflation_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i<3; i++ ) {
    err = fd_bincode_uint32_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_epoch_bank_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_bank_t * self = (fd_epoch_bank_t *)mem;
  fd_epoch_bank_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_bank_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_bank_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_bank_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_bank_t * self = (fd_epoch_bank_t *)struct_mem;
  fd_stakes_decode_inner( &self->stakes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_per_tick, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint128_decode_unsafe( &self->ns_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->genesis_creation_time, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  fd_inflation_decode_inner( &self->inflation, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner( &self->epoch_schedule, alloc_mem, ctx );
  fd_rent_decode_inner( &self->rent, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->eah_start_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->eah_stop_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->eah_interval, ctx );
  fd_hash_decode_inner( &self->genesis_hash, alloc_mem, ctx );
  fd_bincode_uint32_decode_unsafe( &self->cluster_type, ctx );
  for( ulong i=0; i<3; i++ ) {
    fd_bincode_uint32_decode_unsafe( self->cluster_version + i, ctx );
  }
  fd_vote_accounts_decode_inner( &self->next_epoch_stakes, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner( &self->rent_epoch_schedule, alloc_mem, ctx );
}
void * fd_epoch_bank_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_bank_global_t * self = (fd_epoch_bank_global_t *)mem;
  fd_epoch_bank_new( (fd_epoch_bank_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_bank_global_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_bank_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_bank_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_bank_global_t * self = (fd_epoch_bank_global_t *)struct_mem;
  fd_stakes_decode_inner_global( &self->stakes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_per_tick, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ticks_per_slot, ctx );
  fd_bincode_uint128_decode_unsafe( &self->ns_per_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->genesis_creation_time, ctx );
  fd_bincode_double_decode_unsafe( &self->slots_per_year, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  fd_inflation_decode_inner_global( &self->inflation, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner_global( &self->epoch_schedule, alloc_mem, ctx );
  fd_rent_decode_inner_global( &self->rent, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->eah_start_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->eah_stop_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->eah_interval, ctx );
  fd_hash_decode_inner_global( &self->genesis_hash, alloc_mem, ctx );
  fd_bincode_uint32_decode_unsafe( &self->cluster_type, ctx );
  for( ulong i=0; i<3; i++ ) {
    fd_bincode_uint32_decode_unsafe( self->cluster_version + i, ctx );
  }
  fd_vote_accounts_decode_inner_global( &self->next_epoch_stakes, alloc_mem, ctx );
  fd_epoch_schedule_decode_inner_global( &self->rent_epoch_schedule, alloc_mem, ctx );
}
int fd_epoch_bank_convert_global_to_local( void const * global_self, fd_epoch_bank_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_epoch_bank_global_t const * mem = (fd_epoch_bank_global_t const *)global_self;
  err = fd_stakes_convert_global_to_local( &mem->stakes, &self->stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->hashes_per_tick = mem->hashes_per_tick;
  self->ticks_per_slot = mem->ticks_per_slot;
  self->ns_per_slot = mem->ns_per_slot;
  self->genesis_creation_time = mem->genesis_creation_time;
  self->slots_per_year = mem->slots_per_year;
  self->max_tick_height = mem->max_tick_height;
  err = fd_inflation_convert_global_to_local( &mem->inflation, &self->inflation, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_convert_global_to_local( &mem->epoch_schedule, &self->epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_convert_global_to_local( &mem->rent, &self->rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->eah_start_slot = mem->eah_start_slot;
  self->eah_stop_slot = mem->eah_stop_slot;
  self->eah_interval = mem->eah_interval;
  err = fd_hash_convert_global_to_local( &mem->genesis_hash, &self->genesis_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->cluster_type = mem->cluster_type;
  fd_memcpy( self->cluster_version, mem->cluster_version, 3 * sizeof(uint) );
  err = fd_vote_accounts_convert_global_to_local( &mem->next_epoch_stakes, &self->next_epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_epoch_schedule_convert_global_to_local( &mem->rent_epoch_schedule, &self->rent_epoch_schedule, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_epoch_bank_new(fd_epoch_bank_t * self) {
  fd_memset( self, 0, sizeof(fd_epoch_bank_t) );
  fd_stakes_new( &self->stakes );
  fd_inflation_new( &self->inflation );
  fd_epoch_schedule_new( &self->epoch_schedule );
  fd_rent_new( &self->rent );
  fd_hash_new( &self->genesis_hash );
  fd_vote_accounts_new( &self->next_epoch_stakes );
  fd_epoch_schedule_new( &self->rent_epoch_schedule );
}
void fd_epoch_bank_destroy( fd_epoch_bank_t * self ) {
  fd_stakes_destroy( &self->stakes );
  fd_inflation_destroy( &self->inflation );
  fd_epoch_schedule_destroy( &self->epoch_schedule );
  fd_rent_destroy( &self->rent );
  fd_hash_destroy( &self->genesis_hash );
  fd_vote_accounts_destroy( &self->next_epoch_stakes );
  fd_epoch_schedule_destroy( &self->rent_epoch_schedule );
}

ulong fd_epoch_bank_footprint( void ){ return FD_EPOCH_BANK_FOOTPRINT; }
ulong fd_epoch_bank_align( void ){ return FD_EPOCH_BANK_ALIGN; }

void fd_epoch_bank_walk( void * w, fd_epoch_bank_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_epoch_bank", level++ );
  fd_stakes_walk( w, &self->stakes, fun, "stakes", level );
  fun( w, &self->hashes_per_tick, "hashes_per_tick", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->ticks_per_slot, "ticks_per_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->ns_per_slot, "ns_per_slot", FD_FLAMENCO_TYPE_UINT128, "uint128", level );
  fun( w, &self->genesis_creation_time, "genesis_creation_time", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slots_per_year, "slots_per_year", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->max_tick_height, "max_tick_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_inflation_walk( w, &self->inflation, fun, "inflation", level );
  fd_epoch_schedule_walk( w, &self->epoch_schedule, fun, "epoch_schedule", level );
  fd_rent_walk( w, &self->rent, fun, "rent", level );
  fun( w, &self->eah_start_slot, "eah_start_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->eah_stop_slot, "eah_stop_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->eah_interval, "eah_interval", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->genesis_hash, fun, "genesis_hash", level );
  fun( w, &self->cluster_type, "cluster_type", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, NULL, "cluster_version", FD_FLAMENCO_TYPE_ARR, "uint[]", level++ );
  for( ulong i=0; i<3; i++ )
    fun( w, self->cluster_version + i, "cluster_version", FD_FLAMENCO_TYPE_UINT,    "uint",    level );
  fun( w, NULL, "cluster_version", FD_FLAMENCO_TYPE_ARR_END, "uint[]", level-- );
  fd_vote_accounts_walk( w, &self->next_epoch_stakes, fun, "next_epoch_stakes", level );
  fd_epoch_schedule_walk( w, &self->rent_epoch_schedule, fun, "rent_epoch_schedule", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_epoch_bank", level-- );
}
ulong fd_epoch_bank_size( fd_epoch_bank_t const * self ) {
  ulong size = 0;
  size += fd_stakes_size( &self->stakes );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(uint128);
  size += sizeof(ulong);
  size += sizeof(double);
  size += sizeof(ulong);
  size += fd_inflation_size( &self->inflation );
  size += fd_epoch_schedule_size( &self->epoch_schedule );
  size += fd_rent_size( &self->rent );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_hash_size( &self->genesis_hash );
  size += sizeof(uint);
  size += 3 * sizeof(uint);
  size += fd_vote_accounts_size( &self->next_epoch_stakes );
  size += fd_epoch_schedule_size( &self->rent_epoch_schedule );
  return size;
}

int fd_slot_bank_encode( fd_slot_bank_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_clock_timestamp_votes_encode( &self->timestamp_votes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->prev_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->poh, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->banks_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->epoch_account_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_encode( &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->capitalization, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->block_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->max_tick_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collected_execution_fees, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collected_priority_fees, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->collected_rent, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_accounts_encode( &self->epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_last_restart_slot_encode( &self->last_restart_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_keys_encode( &self->stake_account_keys, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_keys_encode( &self->vote_account_keys, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->lamports_per_signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->transaction_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_slot_lthash_encode( &self->lthash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_block_hash_queue_encode( &self->block_hash_queue, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->prev_banks_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->parent_signature_cnt, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->tick_height, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_use_preceeding_epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_use_preceeding_epoch_stakes ) {
    err = fd_bincode_uint64_encode( self->use_preceeding_epoch_stakes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_hard_forks_encode( &self->hard_forks, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_fresh_accounts_encode( &self->rent_fresh_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_slot_bank_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_bank_t);
  void const * start_data = ctx->data;
  int err = fd_slot_bank_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_bank_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_clock_timestamp_votes_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_vote_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_last_restart_slot_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_keys_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_keys_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_slot_lthash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_block_hash_queue_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_hard_forks_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_fresh_accounts_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_slot_bank_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_bank_t * self = (fd_slot_bank_t *)mem;
  fd_slot_bank_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_bank_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_bank_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_bank_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_bank_t * self = (fd_slot_bank_t *)struct_mem;
  fd_clock_timestamp_votes_decode_inner( &self->timestamp_votes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prev_slot, ctx );
  fd_hash_decode_inner( &self->poh, alloc_mem, ctx );
  fd_hash_decode_inner( &self->banks_hash, alloc_mem, ctx );
  fd_hash_decode_inner( &self->epoch_account_hash, alloc_mem, ctx );
  fd_fee_rate_governor_decode_inner( &self->fee_rate_governor, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->capitalization, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_execution_fees, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_priority_fees, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_rent, ctx );
  fd_vote_accounts_decode_inner( &self->epoch_stakes, alloc_mem, ctx );
  fd_sol_sysvar_last_restart_slot_decode_inner( &self->last_restart_slot, alloc_mem, ctx );
  fd_account_keys_decode_inner( &self->stake_account_keys, alloc_mem, ctx );
  fd_account_keys_decode_inner( &self->vote_account_keys, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_count, ctx );
  fd_slot_lthash_decode_inner( &self->lthash, alloc_mem, ctx );
  fd_block_hash_queue_decode_inner( &self->block_hash_queue, alloc_mem, ctx );
  fd_hash_decode_inner( &self->prev_banks_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->parent_signature_cnt, ctx );
  fd_bincode_uint64_decode_unsafe( &self->tick_height, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_use_preceeding_epoch_stakes = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->use_preceeding_epoch_stakes, ctx );
    }
  }
  fd_hard_forks_decode_inner( &self->hard_forks, alloc_mem, ctx );
  fd_rent_fresh_accounts_decode_inner( &self->rent_fresh_accounts, alloc_mem, ctx );
}
void * fd_slot_bank_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_bank_global_t * self = (fd_slot_bank_global_t *)mem;
  fd_slot_bank_new( (fd_slot_bank_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_bank_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_bank_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_bank_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_bank_global_t * self = (fd_slot_bank_global_t *)struct_mem;
  fd_clock_timestamp_votes_decode_inner_global( &self->timestamp_votes, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prev_slot, ctx );
  fd_hash_decode_inner_global( &self->poh, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->banks_hash, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->epoch_account_hash, alloc_mem, ctx );
  fd_fee_rate_governor_decode_inner_global( &self->fee_rate_governor, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->capitalization, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->max_tick_height, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_execution_fees, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_priority_fees, ctx );
  fd_bincode_uint64_decode_unsafe( &self->collected_rent, ctx );
  fd_vote_accounts_decode_inner_global( &self->epoch_stakes, alloc_mem, ctx );
  fd_sol_sysvar_last_restart_slot_decode_inner_global( &self->last_restart_slot, alloc_mem, ctx );
  fd_account_keys_decode_inner_global( &self->stake_account_keys, alloc_mem, ctx );
  fd_account_keys_decode_inner_global( &self->vote_account_keys, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lamports_per_signature, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_count, ctx );
  fd_slot_lthash_decode_inner_global( &self->lthash, alloc_mem, ctx );
  fd_block_hash_queue_decode_inner_global( &self->block_hash_queue, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->prev_banks_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->parent_signature_cnt, ctx );
  fd_bincode_uint64_decode_unsafe( &self->tick_height, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_use_preceeding_epoch_stakes = !!o;
    if( o ) {
      fd_bincode_uint64_decode_unsafe( &self->use_preceeding_epoch_stakes, ctx );
    }
  }
  fd_hard_forks_decode_inner_global( &self->hard_forks, alloc_mem, ctx );
  fd_rent_fresh_accounts_decode_inner_global( &self->rent_fresh_accounts, alloc_mem, ctx );
}
int fd_slot_bank_convert_global_to_local( void const * global_self, fd_slot_bank_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_bank_global_t const * mem = (fd_slot_bank_global_t const *)global_self;
  err = fd_clock_timestamp_votes_convert_global_to_local( &mem->timestamp_votes, &self->timestamp_votes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slot = mem->slot;
  self->prev_slot = mem->prev_slot;
  err = fd_hash_convert_global_to_local( &mem->poh, &self->poh, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->banks_hash, &self->banks_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->epoch_account_hash, &self->epoch_account_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_rate_governor_convert_global_to_local( &mem->fee_rate_governor, &self->fee_rate_governor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->capitalization = mem->capitalization;
  self->block_height = mem->block_height;
  self->max_tick_height = mem->max_tick_height;
  self->collected_execution_fees = mem->collected_execution_fees;
  self->collected_priority_fees = mem->collected_priority_fees;
  self->collected_rent = mem->collected_rent;
  err = fd_vote_accounts_convert_global_to_local( &mem->epoch_stakes, &self->epoch_stakes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_last_restart_slot_convert_global_to_local( &mem->last_restart_slot, &self->last_restart_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_keys_convert_global_to_local( &mem->stake_account_keys, &self->stake_account_keys, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_keys_convert_global_to_local( &mem->vote_account_keys, &self->vote_account_keys, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->lamports_per_signature = mem->lamports_per_signature;
  self->transaction_count = mem->transaction_count;
  err = fd_slot_lthash_convert_global_to_local( &mem->lthash, &self->lthash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_block_hash_queue_convert_global_to_local( &mem->block_hash_queue, &self->block_hash_queue, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->prev_banks_hash, &self->prev_banks_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->parent_signature_cnt = mem->parent_signature_cnt;
  self->tick_height = mem->tick_height;
  self->use_preceeding_epoch_stakes = mem->use_preceeding_epoch_stakes;
  self->has_use_preceeding_epoch_stakes = mem->has_use_preceeding_epoch_stakes;
  err = fd_hard_forks_convert_global_to_local( &mem->hard_forks, &self->hard_forks, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_rent_fresh_accounts_convert_global_to_local( &mem->rent_fresh_accounts, &self->rent_fresh_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_slot_bank_new(fd_slot_bank_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_bank_t) );
  fd_clock_timestamp_votes_new( &self->timestamp_votes );
  fd_hash_new( &self->poh );
  fd_hash_new( &self->banks_hash );
  fd_hash_new( &self->epoch_account_hash );
  fd_fee_rate_governor_new( &self->fee_rate_governor );
  fd_vote_accounts_new( &self->epoch_stakes );
  fd_sol_sysvar_last_restart_slot_new( &self->last_restart_slot );
  fd_account_keys_new( &self->stake_account_keys );
  fd_account_keys_new( &self->vote_account_keys );
  fd_slot_lthash_new( &self->lthash );
  fd_block_hash_queue_new( &self->block_hash_queue );
  fd_hash_new( &self->prev_banks_hash );
  fd_hard_forks_new( &self->hard_forks );
  fd_rent_fresh_accounts_new( &self->rent_fresh_accounts );
}
void fd_slot_bank_destroy( fd_slot_bank_t * self ) {
  fd_clock_timestamp_votes_destroy( &self->timestamp_votes );
  fd_hash_destroy( &self->poh );
  fd_hash_destroy( &self->banks_hash );
  fd_hash_destroy( &self->epoch_account_hash );
  fd_fee_rate_governor_destroy( &self->fee_rate_governor );
  fd_vote_accounts_destroy( &self->epoch_stakes );
  fd_sol_sysvar_last_restart_slot_destroy( &self->last_restart_slot );
  fd_account_keys_destroy( &self->stake_account_keys );
  fd_account_keys_destroy( &self->vote_account_keys );
  fd_slot_lthash_destroy( &self->lthash );
  fd_block_hash_queue_destroy( &self->block_hash_queue );
  fd_hash_destroy( &self->prev_banks_hash );
  if( self->has_use_preceeding_epoch_stakes ) {
    self->has_use_preceeding_epoch_stakes = 0;
  }
  fd_hard_forks_destroy( &self->hard_forks );
  fd_rent_fresh_accounts_destroy( &self->rent_fresh_accounts );
}

ulong fd_slot_bank_footprint( void ){ return FD_SLOT_BANK_FOOTPRINT; }
ulong fd_slot_bank_align( void ){ return FD_SLOT_BANK_ALIGN; }

void fd_slot_bank_walk( void * w, fd_slot_bank_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_bank", level++ );
  fd_clock_timestamp_votes_walk( w, &self->timestamp_votes, fun, "timestamp_votes", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->prev_slot, "prev_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->poh, fun, "poh", level );
  fd_hash_walk( w, &self->banks_hash, fun, "banks_hash", level );
  fd_hash_walk( w, &self->epoch_account_hash, fun, "epoch_account_hash", level );
  fd_fee_rate_governor_walk( w, &self->fee_rate_governor, fun, "fee_rate_governor", level );
  fun( w, &self->capitalization, "capitalization", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->block_height, "block_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->max_tick_height, "max_tick_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->collected_execution_fees, "collected_execution_fees", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->collected_priority_fees, "collected_priority_fees", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->collected_rent, "collected_rent", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_vote_accounts_walk( w, &self->epoch_stakes, fun, "epoch_stakes", level );
  fd_sol_sysvar_last_restart_slot_walk( w, &self->last_restart_slot, fun, "last_restart_slot", level );
  fd_account_keys_walk( w, &self->stake_account_keys, fun, "stake_account_keys", level );
  fd_account_keys_walk( w, &self->vote_account_keys, fun, "vote_account_keys", level );
  fun( w, &self->lamports_per_signature, "lamports_per_signature", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->transaction_count, "transaction_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_slot_lthash_walk( w, &self->lthash, fun, "lthash", level );
  fd_block_hash_queue_walk( w, &self->block_hash_queue, fun, "block_hash_queue", level );
  fd_hash_walk( w, &self->prev_banks_hash, fun, "prev_banks_hash", level );
  fun( w, &self->parent_signature_cnt, "parent_signature_cnt", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->tick_height, "tick_height", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->has_use_preceeding_epoch_stakes ) {
    fun( w, NULL, "use_preceeding_epoch_stakes", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, &self->use_preceeding_epoch_stakes, "use_preceeding_epoch_stakes", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fd_hard_forks_walk( w, &self->hard_forks, fun, "hard_forks", level );
  fd_rent_fresh_accounts_walk( w, &self->rent_fresh_accounts, fun, "rent_fresh_accounts", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_bank", level-- );
}
ulong fd_slot_bank_size( fd_slot_bank_t const * self ) {
  ulong size = 0;
  size += fd_clock_timestamp_votes_size( &self->timestamp_votes );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_hash_size( &self->poh );
  size += fd_hash_size( &self->banks_hash );
  size += fd_hash_size( &self->epoch_account_hash );
  size += fd_fee_rate_governor_size( &self->fee_rate_governor );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_vote_accounts_size( &self->epoch_stakes );
  size += fd_sol_sysvar_last_restart_slot_size( &self->last_restart_slot );
  size += fd_account_keys_size( &self->stake_account_keys );
  size += fd_account_keys_size( &self->vote_account_keys );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_slot_lthash_size( &self->lthash );
  size += fd_block_hash_queue_size( &self->block_hash_queue );
  size += fd_hash_size( &self->prev_banks_hash );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(char);
  if( self->has_use_preceeding_epoch_stakes ) {
    size += sizeof(ulong);
  }
  size += fd_hard_forks_size( &self->hard_forks );
  size += fd_rent_fresh_accounts_size( &self->rent_fresh_accounts );
  return size;
}

int fd_prev_epoch_inflation_rewards_encode( fd_prev_epoch_inflation_rewards_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->validator_rewards, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->prev_epoch_duration_in_years, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->validator_rate, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_encode( self->foundation_rate, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_prev_epoch_inflation_rewards_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_prev_epoch_inflation_rewards_t);
  void const * start_data = ctx->data;
  int err = fd_prev_epoch_inflation_rewards_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_prev_epoch_inflation_rewards_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_double_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_prev_epoch_inflation_rewards_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_prev_epoch_inflation_rewards_t * self = (fd_prev_epoch_inflation_rewards_t *)mem;
  fd_prev_epoch_inflation_rewards_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_prev_epoch_inflation_rewards_t);
  void * * alloc_mem = &alloc_region;
  fd_prev_epoch_inflation_rewards_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_prev_epoch_inflation_rewards_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_prev_epoch_inflation_rewards_t * self = (fd_prev_epoch_inflation_rewards_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->validator_rewards, ctx );
  fd_bincode_double_decode_unsafe( &self->prev_epoch_duration_in_years, ctx );
  fd_bincode_double_decode_unsafe( &self->validator_rate, ctx );
  fd_bincode_double_decode_unsafe( &self->foundation_rate, ctx );
}
void * fd_prev_epoch_inflation_rewards_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_prev_epoch_inflation_rewards_global_t * self = (fd_prev_epoch_inflation_rewards_global_t *)mem;
  fd_prev_epoch_inflation_rewards_new( (fd_prev_epoch_inflation_rewards_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_prev_epoch_inflation_rewards_global_t);
  void * * alloc_mem = &alloc_region;
  fd_prev_epoch_inflation_rewards_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_prev_epoch_inflation_rewards_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_prev_epoch_inflation_rewards_global_t * self = (fd_prev_epoch_inflation_rewards_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->validator_rewards, ctx );
  fd_bincode_double_decode_unsafe( &self->prev_epoch_duration_in_years, ctx );
  fd_bincode_double_decode_unsafe( &self->validator_rate, ctx );
  fd_bincode_double_decode_unsafe( &self->foundation_rate, ctx );
}
int fd_prev_epoch_inflation_rewards_convert_global_to_local( void const * global_self, fd_prev_epoch_inflation_rewards_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_prev_epoch_inflation_rewards_global_t const * mem = (fd_prev_epoch_inflation_rewards_global_t const *)global_self;
  self->validator_rewards = mem->validator_rewards;
  self->prev_epoch_duration_in_years = mem->prev_epoch_duration_in_years;
  self->validator_rate = mem->validator_rate;
  self->foundation_rate = mem->foundation_rate;
  return FD_BINCODE_SUCCESS;
}
void fd_prev_epoch_inflation_rewards_new(fd_prev_epoch_inflation_rewards_t * self) {
  fd_memset( self, 0, sizeof(fd_prev_epoch_inflation_rewards_t) );
}
void fd_prev_epoch_inflation_rewards_destroy( fd_prev_epoch_inflation_rewards_t * self ) {
}

ulong fd_prev_epoch_inflation_rewards_footprint( void ){ return FD_PREV_EPOCH_INFLATION_REWARDS_FOOTPRINT; }
ulong fd_prev_epoch_inflation_rewards_align( void ){ return FD_PREV_EPOCH_INFLATION_REWARDS_ALIGN; }

void fd_prev_epoch_inflation_rewards_walk( void * w, fd_prev_epoch_inflation_rewards_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_prev_epoch_inflation_rewards", level++ );
  fun( w, &self->validator_rewards, "validator_rewards", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->prev_epoch_duration_in_years, "prev_epoch_duration_in_years", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->validator_rate, "validator_rate", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, &self->foundation_rate, "foundation_rate", FD_FLAMENCO_TYPE_DOUBLE, "double", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_prev_epoch_inflation_rewards", level-- );
}
ulong fd_prev_epoch_inflation_rewards_size( fd_prev_epoch_inflation_rewards_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(double);
  size += sizeof(double);
  size += sizeof(double);
  return size;
}

int fd_vote_encode( fd_vote_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->slots ) {
    ulong slots_len = deq_ulong_cnt( self->slots );
    err = fd_bincode_uint64_encode( slots_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( deq_ulong_iter_t iter = deq_ulong_iter_init( self->slots ); !deq_ulong_iter_done( self->slots, iter ); iter = deq_ulong_iter_next( self->slots, iter ) ) {
      ulong const * ele = deq_ulong_iter_ele_const( self->slots, iter );
      err = fd_bincode_uint64_encode( ele[0], ctx );
    }
  } else {
    ulong slots_len = 0;
    err = fd_bincode_uint64_encode( slots_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->timestamp != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_int64_encode( self->timestamp[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_t);
  void const * start_data = ctx->data;
  int err = fd_vote_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong slots_len;
  err = fd_bincode_uint64_decode( &slots_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong slots_max = slots_len == 0 ? 1 : slots_len;
  *total_sz += deq_ulong_align() + deq_ulong_footprint( slots_max ) ;
  ulong slots_sz;
  if( FD_UNLIKELY( __builtin_umull_overflow( slots_len, 8, &slots_sz ) ) ) return FD_BINCODE_ERR_UNDERFLOW;
  err = fd_bincode_bytes_decode_footprint( slots_sz, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(long);
      err = fd_bincode_int64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_vote_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_t * self = (fd_vote_t *)mem;
  fd_vote_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_t * self = (fd_vote_t *)struct_mem;
  ulong slots_len;
  fd_bincode_uint64_decode_unsafe( &slots_len, ctx );
  self->slots = deq_ulong_join_new( alloc_mem, slots_len );
  for( ulong i=0; i < slots_len; i++ ) {
    ulong * elem = deq_ulong_push_tail_nocopy( self->slots );
    fd_bincode_uint64_decode_unsafe( elem, ctx );
  }
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->timestamp = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(long);
      fd_bincode_int64_decode_unsafe( self->timestamp, ctx );
    } else {
      self->timestamp = NULL;
    }
  }
}
void * fd_vote_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_global_t * self = (fd_vote_global_t *)mem;
  fd_vote_new( (fd_vote_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_global_t * self = (fd_vote_global_t *)struct_mem;
  ulong slots_len;
  fd_bincode_uint64_decode_unsafe( &slots_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, deq_ulong_align() );
  self->slots_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
  ulong * slots = deq_ulong_join_new( alloc_mem, slots_len );
  for( ulong i=0; i < slots_len; i++ ) {
    ulong * elem = deq_ulong_push_tail_nocopy( slots );
    fd_bincode_uint64_decode_unsafe( elem, ctx );
  }
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->timestamp_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_int64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(long);
    } else {
      self->timestamp_gaddr = 0UL;
    }
  }
}
int fd_vote_convert_global_to_local( void const * global_self, fd_vote_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_global_t const * mem = (fd_vote_global_t const *)global_self;
  self->slots = deq_ulong_join( fd_wksp_laddr_fast( ctx->wksp, mem->slots_gaddr ) );
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = fd_wksp_laddr_fast( ctx->wksp, mem->timestamp_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_new(fd_vote_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_t) );
  fd_hash_new( &self->hash );
}
void fd_vote_destroy( fd_vote_t * self ) {
  if( self->slots ) {
    self->slots = NULL;
  }
  fd_hash_destroy( &self->hash );
  if( self->timestamp ) {
    self->timestamp = NULL;
  }
}

ulong fd_vote_footprint( void ){ return FD_VOTE_FOOTPRINT; }
ulong fd_vote_align( void ){ return FD_VOTE_ALIGN; }

void fd_vote_walk( void * w, fd_vote_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote", level++ );

  /* Walk deque */
  fun( w, self->slots, "slots", FD_FLAMENCO_TYPE_ARR, "slots", level++ );
  if( self->slots ) {
    for( deq_ulong_iter_t iter = deq_ulong_iter_init( self->slots );
         !deq_ulong_iter_done( self->slots, iter );
         iter = deq_ulong_iter_next( self->slots, iter ) ) {
      ulong * ele = deq_ulong_iter_ele( self->slots, iter );
      fun(w, ele, "ele", FD_FLAMENCO_TYPE_ULONG, "long",  level );
    }
  }
  fun( w, self->slots, "slots", FD_FLAMENCO_TYPE_ARR_END, "slots", level-- );
  /* Done walking deque */

  fd_hash_walk( w, &self->hash, fun, "hash", level );
  if( !self->timestamp ) {
    fun( w, NULL, "timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote", level-- );
}
ulong fd_vote_size( fd_vote_t const * self ) {
  ulong size = 0;
  if( self->slots ) {
    size += sizeof(ulong);
    ulong slots_len = deq_ulong_cnt(self->slots);
    size += slots_len * sizeof(ulong);
  } else {
    size += sizeof(ulong);
  }
  size += fd_hash_size( &self->hash );
  size += sizeof(char);
  if( NULL !=  self->timestamp ) {
    size += sizeof(long);
  }
  return size;
}

int fd_vote_init_encode( fd_vote_init_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authorized_voter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->commission), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_init_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_init_t);
  void const * start_data = ctx->data;
  int err = fd_vote_init_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_init_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_init_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_init_t * self = (fd_vote_init_t *)mem;
  fd_vote_init_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_init_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_init_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_init_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_init_t * self = (fd_vote_init_t *)struct_mem;
  fd_pubkey_decode_inner( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->authorized_voter, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
}
void * fd_vote_init_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_init_global_t * self = (fd_vote_init_global_t *)mem;
  fd_vote_init_new( (fd_vote_init_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_init_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_init_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_init_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_init_global_t * self = (fd_vote_init_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->node_pubkey, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->authorized_voter, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->authorized_withdrawer, alloc_mem, ctx );
  fd_bincode_uint8_decode_unsafe( &self->commission, ctx );
}
int fd_vote_init_convert_global_to_local( void const * global_self, fd_vote_init_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_init_global_t const * mem = (fd_vote_init_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->node_pubkey, &self->node_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->authorized_voter, &self->authorized_voter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->authorized_withdrawer, &self->authorized_withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->commission = mem->commission;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_init_new(fd_vote_init_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_init_t) );
  fd_pubkey_new( &self->node_pubkey );
  fd_pubkey_new( &self->authorized_voter );
  fd_pubkey_new( &self->authorized_withdrawer );
}
void fd_vote_init_destroy( fd_vote_init_t * self ) {
  fd_pubkey_destroy( &self->node_pubkey );
  fd_pubkey_destroy( &self->authorized_voter );
  fd_pubkey_destroy( &self->authorized_withdrawer );
}

ulong fd_vote_init_footprint( void ){ return FD_VOTE_INIT_FOOTPRINT; }
ulong fd_vote_init_align( void ){ return FD_VOTE_INIT_ALIGN; }

void fd_vote_init_walk( void * w, fd_vote_init_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_init", level++ );
  fd_pubkey_walk( w, &self->node_pubkey, fun, "node_pubkey", level );
  fd_pubkey_walk( w, &self->authorized_voter, fun, "authorized_voter", level );
  fd_pubkey_walk( w, &self->authorized_withdrawer, fun, "authorized_withdrawer", level );
  fun( w, &self->commission, "commission", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_init", level-- );
}
ulong fd_vote_init_size( fd_vote_init_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->node_pubkey );
  size += fd_pubkey_size( &self->authorized_voter );
  size += fd_pubkey_size( &self->authorized_withdrawer );
  size += sizeof(char);
  return size;
}

FD_FN_PURE uchar fd_vote_authorize_is_voter(fd_vote_authorize_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_vote_authorize_is_withdrawer(fd_vote_authorize_t const * self) {
  return self->discriminant == 1;
}
void fd_vote_authorize_inner_new( fd_vote_authorize_inner_t * self, uint discriminant );
int fd_vote_authorize_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_vote_authorize_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_authorize_t);
  void const * start_data = ctx->data;
  int err =  fd_vote_authorize_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_authorize_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_vote_authorize_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_vote_authorize_inner_decode_inner( fd_vote_authorize_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  }
}
void fd_vote_authorize_inner_decode_inner_global( fd_vote_authorize_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  }
}
int fd_vote_authorize_convert_global_to_local_inner( fd_vote_authorize_inner_global_t const * mem, fd_vote_authorize_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorize_convert_global_to_local( void const * global_self, fd_vote_authorize_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_global_t const * mem = (fd_vote_authorize_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_vote_authorize_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_authorize_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_t * self = (fd_vote_authorize_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_vote_authorize_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_vote_authorize_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_t * self = (fd_vote_authorize_t *)mem;
  fd_vote_authorize_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_vote_authorize_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_t * self = (fd_vote_authorize_t *)mem;
  fd_vote_authorize_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_global_t * self = (fd_vote_authorize_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_vote_authorize_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_vote_authorize_inner_new( fd_vote_authorize_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_vote_authorize_new_disc( fd_vote_authorize_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_vote_authorize_inner_new( &self->inner, self->discriminant );
}
void fd_vote_authorize_new( fd_vote_authorize_t * self ) {
  fd_memset( self, 0, sizeof(fd_vote_authorize_t) );
  fd_vote_authorize_new_disc( self, UINT_MAX );
}
void fd_vote_authorize_inner_destroy( fd_vote_authorize_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_vote_authorize_destroy( fd_vote_authorize_t * self ) {
  fd_vote_authorize_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_vote_authorize_footprint( void ){ return FD_VOTE_AUTHORIZE_FOOTPRINT; }
ulong fd_vote_authorize_align( void ){ return FD_VOTE_AUTHORIZE_ALIGN; }

void fd_vote_authorize_walk( void * w, fd_vote_authorize_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_vote_authorize", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "voter", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "withdrawer", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_vote_authorize", level-- );
}
ulong fd_vote_authorize_size( fd_vote_authorize_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  }
  return size;
}

int fd_vote_authorize_inner_encode( fd_vote_authorize_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorize_encode( fd_vote_authorize_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_vote_authorize_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_vote_authorize_pubkey_encode( fd_vote_authorize_pubkey_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_authorize_encode( &self->vote_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorize_pubkey_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_authorize_pubkey_t);
  void const * start_data = ctx->data;
  int err = fd_vote_authorize_pubkey_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_authorize_pubkey_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_authorize_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_authorize_pubkey_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_pubkey_t * self = (fd_vote_authorize_pubkey_t *)mem;
  fd_vote_authorize_pubkey_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_pubkey_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_pubkey_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_pubkey_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_pubkey_t * self = (fd_vote_authorize_pubkey_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_vote_authorize_decode_inner( &self->vote_authorize, alloc_mem, ctx );
}
void * fd_vote_authorize_pubkey_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_pubkey_global_t * self = (fd_vote_authorize_pubkey_global_t *)mem;
  fd_vote_authorize_pubkey_new( (fd_vote_authorize_pubkey_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_pubkey_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_pubkey_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_pubkey_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_pubkey_global_t * self = (fd_vote_authorize_pubkey_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_vote_authorize_decode_inner_global( &self->vote_authorize, alloc_mem, ctx );
}
int fd_vote_authorize_pubkey_convert_global_to_local( void const * global_self, fd_vote_authorize_pubkey_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_authorize_pubkey_global_t const * mem = (fd_vote_authorize_pubkey_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_authorize_convert_global_to_local( &mem->vote_authorize, &self->vote_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_authorize_pubkey_new(fd_vote_authorize_pubkey_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_authorize_pubkey_t) );
  fd_pubkey_new( &self->pubkey );
  fd_vote_authorize_new( &self->vote_authorize );
}
void fd_vote_authorize_pubkey_destroy( fd_vote_authorize_pubkey_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  fd_vote_authorize_destroy( &self->vote_authorize );
}

ulong fd_vote_authorize_pubkey_footprint( void ){ return FD_VOTE_AUTHORIZE_PUBKEY_FOOTPRINT; }
ulong fd_vote_authorize_pubkey_align( void ){ return FD_VOTE_AUTHORIZE_PUBKEY_ALIGN; }

void fd_vote_authorize_pubkey_walk( void * w, fd_vote_authorize_pubkey_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_authorize_pubkey", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fd_vote_authorize_walk( w, &self->vote_authorize, fun, "vote_authorize", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_authorize_pubkey", level-- );
}
ulong fd_vote_authorize_pubkey_size( fd_vote_authorize_pubkey_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += fd_vote_authorize_size( &self->vote_authorize );
  return size;
}

int fd_vote_switch_encode( fd_vote_switch_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_vote_encode( &self->vote, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_switch_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_switch_t);
  void const * start_data = ctx->data;
  int err = fd_vote_switch_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_switch_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_vote_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_switch_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_switch_t * self = (fd_vote_switch_t *)mem;
  fd_vote_switch_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_switch_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_switch_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_switch_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_switch_t * self = (fd_vote_switch_t *)struct_mem;
  fd_vote_decode_inner( &self->vote, alloc_mem, ctx );
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
}
void * fd_vote_switch_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_switch_global_t * self = (fd_vote_switch_global_t *)mem;
  fd_vote_switch_new( (fd_vote_switch_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_switch_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_switch_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_switch_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_switch_global_t * self = (fd_vote_switch_global_t *)struct_mem;
  fd_vote_decode_inner_global( &self->vote, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
}
int fd_vote_switch_convert_global_to_local( void const * global_self, fd_vote_switch_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_switch_global_t const * mem = (fd_vote_switch_global_t const *)global_self;
  err = fd_vote_convert_global_to_local( &mem->vote, &self->vote, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_switch_new(fd_vote_switch_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_switch_t) );
  fd_vote_new( &self->vote );
  fd_hash_new( &self->hash );
}
void fd_vote_switch_destroy( fd_vote_switch_t * self ) {
  fd_vote_destroy( &self->vote );
  fd_hash_destroy( &self->hash );
}

ulong fd_vote_switch_footprint( void ){ return FD_VOTE_SWITCH_FOOTPRINT; }
ulong fd_vote_switch_align( void ){ return FD_VOTE_SWITCH_ALIGN; }

void fd_vote_switch_walk( void * w, fd_vote_switch_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_switch", level++ );
  fd_vote_walk( w, &self->vote, fun, "vote", level );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_switch", level-- );
}
ulong fd_vote_switch_size( fd_vote_switch_t const * self ) {
  ulong size = 0;
  size += fd_vote_size( &self->vote );
  size += fd_hash_size( &self->hash );
  return size;
}

int fd_update_vote_state_switch_encode( fd_update_vote_state_switch_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_vote_state_update_encode( &self->vote_state_update, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_update_vote_state_switch_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_update_vote_state_switch_t);
  void const * start_data = ctx->data;
  int err = fd_update_vote_state_switch_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_update_vote_state_switch_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_vote_state_update_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_update_vote_state_switch_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_update_vote_state_switch_t * self = (fd_update_vote_state_switch_t *)mem;
  fd_update_vote_state_switch_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_update_vote_state_switch_t);
  void * * alloc_mem = &alloc_region;
  fd_update_vote_state_switch_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_update_vote_state_switch_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_update_vote_state_switch_t * self = (fd_update_vote_state_switch_t *)struct_mem;
  fd_vote_state_update_decode_inner( &self->vote_state_update, alloc_mem, ctx );
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
}
void * fd_update_vote_state_switch_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_update_vote_state_switch_global_t * self = (fd_update_vote_state_switch_global_t *)mem;
  fd_update_vote_state_switch_new( (fd_update_vote_state_switch_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_update_vote_state_switch_global_t);
  void * * alloc_mem = &alloc_region;
  fd_update_vote_state_switch_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_update_vote_state_switch_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_update_vote_state_switch_global_t * self = (fd_update_vote_state_switch_global_t *)struct_mem;
  fd_vote_state_update_decode_inner_global( &self->vote_state_update, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
}
int fd_update_vote_state_switch_convert_global_to_local( void const * global_self, fd_update_vote_state_switch_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_update_vote_state_switch_global_t const * mem = (fd_update_vote_state_switch_global_t const *)global_self;
  err = fd_vote_state_update_convert_global_to_local( &mem->vote_state_update, &self->vote_state_update, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_update_vote_state_switch_new(fd_update_vote_state_switch_t * self) {
  fd_memset( self, 0, sizeof(fd_update_vote_state_switch_t) );
  fd_vote_state_update_new( &self->vote_state_update );
  fd_hash_new( &self->hash );
}
void fd_update_vote_state_switch_destroy( fd_update_vote_state_switch_t * self ) {
  fd_vote_state_update_destroy( &self->vote_state_update );
  fd_hash_destroy( &self->hash );
}

ulong fd_update_vote_state_switch_footprint( void ){ return FD_UPDATE_VOTE_STATE_SWITCH_FOOTPRINT; }
ulong fd_update_vote_state_switch_align( void ){ return FD_UPDATE_VOTE_STATE_SWITCH_ALIGN; }

void fd_update_vote_state_switch_walk( void * w, fd_update_vote_state_switch_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_update_vote_state_switch", level++ );
  fd_vote_state_update_walk( w, &self->vote_state_update, fun, "vote_state_update", level );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_update_vote_state_switch", level-- );
}
ulong fd_update_vote_state_switch_size( fd_update_vote_state_switch_t const * self ) {
  ulong size = 0;
  size += fd_vote_state_update_size( &self->vote_state_update );
  size += fd_hash_size( &self->hash );
  return size;
}

int fd_vote_authorize_with_seed_args_encode( fd_vote_authorize_with_seed_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_vote_authorize_encode( &self->authorization_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->current_authority_derived_key_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->current_authority_derived_key_seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->current_authority_derived_key_seed_len ) {
    err = fd_bincode_bytes_encode( self->current_authority_derived_key_seed, self->current_authority_derived_key_seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->new_authority, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorize_with_seed_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_authorize_with_seed_args_t);
  void const * start_data = ctx->data;
  int err = fd_vote_authorize_with_seed_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_authorize_with_seed_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_vote_authorize_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong current_authority_derived_key_seed_len;
  err = fd_bincode_uint64_decode( &current_authority_derived_key_seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += current_authority_derived_key_seed_len;
  if( current_authority_derived_key_seed_len ) {
    err = fd_bincode_bytes_decode_footprint( current_authority_derived_key_seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - current_authority_derived_key_seed_len, current_authority_derived_key_seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_authorize_with_seed_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_with_seed_args_t * self = (fd_vote_authorize_with_seed_args_t *)mem;
  fd_vote_authorize_with_seed_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_with_seed_args_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_with_seed_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_with_seed_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_with_seed_args_t * self = (fd_vote_authorize_with_seed_args_t *)struct_mem;
  fd_vote_authorize_decode_inner( &self->authorization_type, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->current_authority_derived_key_owner, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->current_authority_derived_key_seed_len, ctx );
  if( self->current_authority_derived_key_seed_len ) {
    self->current_authority_derived_key_seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->current_authority_derived_key_seed, self->current_authority_derived_key_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->current_authority_derived_key_seed_len;
  } else
    self->current_authority_derived_key_seed = NULL;
  fd_pubkey_decode_inner( &self->new_authority, alloc_mem, ctx );
}
void * fd_vote_authorize_with_seed_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_with_seed_args_global_t * self = (fd_vote_authorize_with_seed_args_global_t *)mem;
  fd_vote_authorize_with_seed_args_new( (fd_vote_authorize_with_seed_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_with_seed_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_with_seed_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_with_seed_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_with_seed_args_global_t * self = (fd_vote_authorize_with_seed_args_global_t *)struct_mem;
  fd_vote_authorize_decode_inner_global( &self->authorization_type, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->current_authority_derived_key_owner, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->current_authority_derived_key_seed_len, ctx );
  if( self->current_authority_derived_key_seed_len ) {
    self->current_authority_derived_key_seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->current_authority_derived_key_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->current_authority_derived_key_seed_len;
  } else
    self->current_authority_derived_key_seed_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->new_authority, alloc_mem, ctx );
}
int fd_vote_authorize_with_seed_args_convert_global_to_local( void const * global_self, fd_vote_authorize_with_seed_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_authorize_with_seed_args_global_t const * mem = (fd_vote_authorize_with_seed_args_global_t const *)global_self;
  err = fd_vote_authorize_convert_global_to_local( &mem->authorization_type, &self->authorization_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->current_authority_derived_key_owner, &self->current_authority_derived_key_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->current_authority_derived_key_seed_len = mem->current_authority_derived_key_seed_len;
  self->current_authority_derived_key_seed     = fd_wksp_laddr_fast( ctx->wksp, mem->current_authority_derived_key_seed_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->new_authority, &self->new_authority, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_authorize_with_seed_args_new(fd_vote_authorize_with_seed_args_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_authorize_with_seed_args_t) );
  fd_vote_authorize_new( &self->authorization_type );
  fd_pubkey_new( &self->current_authority_derived_key_owner );
  fd_pubkey_new( &self->new_authority );
}
void fd_vote_authorize_with_seed_args_destroy( fd_vote_authorize_with_seed_args_t * self ) {
  fd_vote_authorize_destroy( &self->authorization_type );
  fd_pubkey_destroy( &self->current_authority_derived_key_owner );
  if( self->current_authority_derived_key_seed ) {
    self->current_authority_derived_key_seed = NULL;
  }
  fd_pubkey_destroy( &self->new_authority );
}

ulong fd_vote_authorize_with_seed_args_footprint( void ){ return FD_VOTE_AUTHORIZE_WITH_SEED_ARGS_FOOTPRINT; }
ulong fd_vote_authorize_with_seed_args_align( void ){ return FD_VOTE_AUTHORIZE_WITH_SEED_ARGS_ALIGN; }

void fd_vote_authorize_with_seed_args_walk( void * w, fd_vote_authorize_with_seed_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_authorize_with_seed_args", level++ );
  fd_vote_authorize_walk( w, &self->authorization_type, fun, "authorization_type", level );
  fd_pubkey_walk( w, &self->current_authority_derived_key_owner, fun, "current_authority_derived_key_owner", level );
  fun(w, self->current_authority_derived_key_seed, "current_authority_derived_key_seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->new_authority, fun, "new_authority", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_authorize_with_seed_args", level-- );
}
ulong fd_vote_authorize_with_seed_args_size( fd_vote_authorize_with_seed_args_t const * self ) {
  ulong size = 0;
  size += fd_vote_authorize_size( &self->authorization_type );
  size += fd_pubkey_size( &self->current_authority_derived_key_owner );
  do {
    size += sizeof(ulong);
    size += self->current_authority_derived_key_seed_len;
  } while(0);
  size += fd_pubkey_size( &self->new_authority );
  return size;
}

int fd_vote_authorize_checked_with_seed_args_encode( fd_vote_authorize_checked_with_seed_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_vote_authorize_encode( &self->authorization_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->current_authority_derived_key_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->current_authority_derived_key_seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->current_authority_derived_key_seed_len ) {
    err = fd_bincode_bytes_encode( self->current_authority_derived_key_seed, self->current_authority_derived_key_seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_authorize_checked_with_seed_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_authorize_checked_with_seed_args_t);
  void const * start_data = ctx->data;
  int err = fd_vote_authorize_checked_with_seed_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_authorize_checked_with_seed_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_vote_authorize_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong current_authority_derived_key_seed_len;
  err = fd_bincode_uint64_decode( &current_authority_derived_key_seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += current_authority_derived_key_seed_len;
  if( current_authority_derived_key_seed_len ) {
    err = fd_bincode_bytes_decode_footprint( current_authority_derived_key_seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - current_authority_derived_key_seed_len, current_authority_derived_key_seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_vote_authorize_checked_with_seed_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_checked_with_seed_args_t * self = (fd_vote_authorize_checked_with_seed_args_t *)mem;
  fd_vote_authorize_checked_with_seed_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_checked_with_seed_args_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_checked_with_seed_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_checked_with_seed_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_checked_with_seed_args_t * self = (fd_vote_authorize_checked_with_seed_args_t *)struct_mem;
  fd_vote_authorize_decode_inner( &self->authorization_type, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->current_authority_derived_key_owner, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->current_authority_derived_key_seed_len, ctx );
  if( self->current_authority_derived_key_seed_len ) {
    self->current_authority_derived_key_seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->current_authority_derived_key_seed, self->current_authority_derived_key_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->current_authority_derived_key_seed_len;
  } else
    self->current_authority_derived_key_seed = NULL;
}
void * fd_vote_authorize_checked_with_seed_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_checked_with_seed_args_global_t * self = (fd_vote_authorize_checked_with_seed_args_global_t *)mem;
  fd_vote_authorize_checked_with_seed_args_new( (fd_vote_authorize_checked_with_seed_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_authorize_checked_with_seed_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_authorize_checked_with_seed_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_authorize_checked_with_seed_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_authorize_checked_with_seed_args_global_t * self = (fd_vote_authorize_checked_with_seed_args_global_t *)struct_mem;
  fd_vote_authorize_decode_inner_global( &self->authorization_type, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->current_authority_derived_key_owner, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->current_authority_derived_key_seed_len, ctx );
  if( self->current_authority_derived_key_seed_len ) {
    self->current_authority_derived_key_seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->current_authority_derived_key_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->current_authority_derived_key_seed_len;
  } else
    self->current_authority_derived_key_seed_gaddr = 0UL;
}
int fd_vote_authorize_checked_with_seed_args_convert_global_to_local( void const * global_self, fd_vote_authorize_checked_with_seed_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_authorize_checked_with_seed_args_global_t const * mem = (fd_vote_authorize_checked_with_seed_args_global_t const *)global_self;
  err = fd_vote_authorize_convert_global_to_local( &mem->authorization_type, &self->authorization_type, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->current_authority_derived_key_owner, &self->current_authority_derived_key_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->current_authority_derived_key_seed_len = mem->current_authority_derived_key_seed_len;
  self->current_authority_derived_key_seed     = fd_wksp_laddr_fast( ctx->wksp, mem->current_authority_derived_key_seed_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_authorize_checked_with_seed_args_new(fd_vote_authorize_checked_with_seed_args_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_authorize_checked_with_seed_args_t) );
  fd_vote_authorize_new( &self->authorization_type );
  fd_pubkey_new( &self->current_authority_derived_key_owner );
}
void fd_vote_authorize_checked_with_seed_args_destroy( fd_vote_authorize_checked_with_seed_args_t * self ) {
  fd_vote_authorize_destroy( &self->authorization_type );
  fd_pubkey_destroy( &self->current_authority_derived_key_owner );
  if( self->current_authority_derived_key_seed ) {
    self->current_authority_derived_key_seed = NULL;
  }
}

ulong fd_vote_authorize_checked_with_seed_args_footprint( void ){ return FD_VOTE_AUTHORIZE_CHECKED_WITH_SEED_ARGS_FOOTPRINT; }
ulong fd_vote_authorize_checked_with_seed_args_align( void ){ return FD_VOTE_AUTHORIZE_CHECKED_WITH_SEED_ARGS_ALIGN; }

void fd_vote_authorize_checked_with_seed_args_walk( void * w, fd_vote_authorize_checked_with_seed_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_authorize_checked_with_seed_args", level++ );
  fd_vote_authorize_walk( w, &self->authorization_type, fun, "authorization_type", level );
  fd_pubkey_walk( w, &self->current_authority_derived_key_owner, fun, "current_authority_derived_key_owner", level );
  fun(w, self->current_authority_derived_key_seed, "current_authority_derived_key_seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_authorize_checked_with_seed_args", level-- );
}
ulong fd_vote_authorize_checked_with_seed_args_size( fd_vote_authorize_checked_with_seed_args_t const * self ) {
  ulong size = 0;
  size += fd_vote_authorize_size( &self->authorization_type );
  size += fd_pubkey_size( &self->current_authority_derived_key_owner );
  do {
    size += sizeof(ulong);
    size += self->current_authority_derived_key_seed_len;
  } while(0);
  return size;
}

FD_FN_PURE uchar fd_vote_instruction_is_initialize_account(fd_vote_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_vote_instruction_is_authorize(fd_vote_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_vote_instruction_is_vote(fd_vote_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_vote_instruction_is_withdraw(fd_vote_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_vote_instruction_is_update_validator_identity(fd_vote_instruction_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_vote_instruction_is_update_commission(fd_vote_instruction_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_vote_instruction_is_vote_switch(fd_vote_instruction_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_vote_instruction_is_authorize_checked(fd_vote_instruction_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_vote_instruction_is_update_vote_state(fd_vote_instruction_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_vote_instruction_is_update_vote_state_switch(fd_vote_instruction_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_vote_instruction_is_authorize_with_seed(fd_vote_instruction_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_vote_instruction_is_authorize_checked_with_seed(fd_vote_instruction_t const * self) {
  return self->discriminant == 11;
}
FD_FN_PURE uchar fd_vote_instruction_is_compact_update_vote_state(fd_vote_instruction_t const * self) {
  return self->discriminant == 12;
}
FD_FN_PURE uchar fd_vote_instruction_is_compact_update_vote_state_switch(fd_vote_instruction_t const * self) {
  return self->discriminant == 13;
}
FD_FN_PURE uchar fd_vote_instruction_is_tower_sync(fd_vote_instruction_t const * self) {
  return self->discriminant == 14;
}
FD_FN_PURE uchar fd_vote_instruction_is_tower_sync_switch(fd_vote_instruction_t const * self) {
  return self->discriminant == 15;
}
void fd_vote_instruction_inner_new( fd_vote_instruction_inner_t * self, uint discriminant );
int fd_vote_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_vote_init_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_vote_authorize_pubkey_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_vote_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    err = fd_vote_switch_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    err = fd_vote_authorize_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    err = fd_vote_state_update_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    err = fd_update_vote_state_switch_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    err = fd_vote_authorize_with_seed_args_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    err = fd_vote_authorize_checked_with_seed_args_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 12: {
    err = fd_compact_vote_state_update_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 13: {
    err = fd_compact_vote_state_update_switch_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 14: {
    err = fd_tower_sync_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 15: {
    err = fd_tower_sync_switch_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_vote_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_vote_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_vote_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_vote_instruction_inner_decode_inner( fd_vote_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_vote_init_decode_inner( &self->initialize_account, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_vote_authorize_pubkey_decode_inner( &self->authorize, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_vote_decode_inner( &self->vote, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_bincode_uint64_decode_unsafe( &self->withdraw, ctx );
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    fd_bincode_uint8_decode_unsafe( &self->update_commission, ctx );
    break;
  }
  case 6: {
    fd_vote_switch_decode_inner( &self->vote_switch, alloc_mem, ctx );
    break;
  }
  case 7: {
    fd_vote_authorize_decode_inner( &self->authorize_checked, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_vote_state_update_decode_inner( &self->update_vote_state, alloc_mem, ctx );
    break;
  }
  case 9: {
    fd_update_vote_state_switch_decode_inner( &self->update_vote_state_switch, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_vote_authorize_with_seed_args_decode_inner( &self->authorize_with_seed, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_vote_authorize_checked_with_seed_args_decode_inner( &self->authorize_checked_with_seed, alloc_mem, ctx );
    break;
  }
  case 12: {
    fd_compact_vote_state_update_decode_inner( &self->compact_update_vote_state, alloc_mem, ctx );
    break;
  }
  case 13: {
    fd_compact_vote_state_update_switch_decode_inner( &self->compact_update_vote_state_switch, alloc_mem, ctx );
    break;
  }
  case 14: {
    fd_tower_sync_decode_inner( &self->tower_sync, alloc_mem, ctx );
    break;
  }
  case 15: {
    fd_tower_sync_switch_decode_inner( &self->tower_sync_switch, alloc_mem, ctx );
    break;
  }
  }
}
void fd_vote_instruction_inner_decode_inner_global( fd_vote_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_vote_init_decode_inner_global( &self->initialize_account, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_vote_authorize_pubkey_decode_inner_global( &self->authorize, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_vote_decode_inner_global( &self->vote, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_bincode_uint64_decode_unsafe( &self->withdraw, ctx );
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    fd_bincode_uint8_decode_unsafe( &self->update_commission, ctx );
    break;
  }
  case 6: {
    fd_vote_switch_decode_inner_global( &self->vote_switch, alloc_mem, ctx );
    break;
  }
  case 7: {
    fd_vote_authorize_decode_inner_global( &self->authorize_checked, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_vote_state_update_decode_inner_global( &self->update_vote_state, alloc_mem, ctx );
    break;
  }
  case 9: {
    fd_update_vote_state_switch_decode_inner_global( &self->update_vote_state_switch, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_vote_authorize_with_seed_args_decode_inner_global( &self->authorize_with_seed, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_vote_authorize_checked_with_seed_args_decode_inner_global( &self->authorize_checked_with_seed, alloc_mem, ctx );
    break;
  }
  case 12: {
    fd_compact_vote_state_update_decode_inner_global( &self->compact_update_vote_state, alloc_mem, ctx );
    break;
  }
  case 13: {
    fd_compact_vote_state_update_switch_decode_inner_global( &self->compact_update_vote_state_switch, alloc_mem, ctx );
    break;
  }
  case 14: {
    fd_tower_sync_decode_inner_global( &self->tower_sync, alloc_mem, ctx );
    break;
  }
  case 15: {
    fd_tower_sync_switch_decode_inner_global( &self->tower_sync_switch, alloc_mem, ctx );
    break;
  }
  }
}
int fd_vote_instruction_convert_global_to_local_inner( fd_vote_instruction_inner_global_t const * mem, fd_vote_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_vote_init_convert_global_to_local( &mem->initialize_account, &self->initialize_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_vote_authorize_pubkey_convert_global_to_local( &mem->authorize, &self->authorize, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_vote_convert_global_to_local( &mem->vote, &self->vote, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    self->withdraw = mem->withdraw;
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    self->update_commission = mem->update_commission;
    break;
  }
  case 6: {
    err = fd_vote_switch_convert_global_to_local( &mem->vote_switch, &self->vote_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    err = fd_vote_authorize_convert_global_to_local( &mem->authorize_checked, &self->authorize_checked, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_vote_state_update_convert_global_to_local( &mem->update_vote_state, &self->update_vote_state, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_update_vote_state_switch_convert_global_to_local( &mem->update_vote_state_switch, &self->update_vote_state_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_vote_authorize_with_seed_args_convert_global_to_local( &mem->authorize_with_seed, &self->authorize_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_vote_authorize_checked_with_seed_args_convert_global_to_local( &mem->authorize_checked_with_seed, &self->authorize_checked_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    err = fd_compact_vote_state_update_convert_global_to_local( &mem->compact_update_vote_state, &self->compact_update_vote_state, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 13: {
    err = fd_compact_vote_state_update_switch_convert_global_to_local( &mem->compact_update_vote_state_switch, &self->compact_update_vote_state_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 14: {
    err = fd_tower_sync_convert_global_to_local( &mem->tower_sync, &self->tower_sync, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 15: {
    err = fd_tower_sync_switch_convert_global_to_local( &mem->tower_sync_switch, &self->tower_sync_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_instruction_convert_global_to_local( void const * global_self, fd_vote_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_instruction_global_t const * mem = (fd_vote_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_vote_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_vote_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_instruction_t * self = (fd_vote_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_vote_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_vote_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_instruction_t * self = (fd_vote_instruction_t *)mem;
  fd_vote_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_vote_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_instruction_t * self = (fd_vote_instruction_t *)mem;
  fd_vote_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_instruction_global_t * self = (fd_vote_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_vote_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_vote_instruction_inner_new( fd_vote_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_vote_init_new( &self->initialize_account );
    break;
  }
  case 1: {
    fd_vote_authorize_pubkey_new( &self->authorize );
    break;
  }
  case 2: {
    fd_vote_new( &self->vote );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_vote_switch_new( &self->vote_switch );
    break;
  }
  case 7: {
    fd_vote_authorize_new( &self->authorize_checked );
    break;
  }
  case 8: {
    fd_vote_state_update_new( &self->update_vote_state );
    break;
  }
  case 9: {
    fd_update_vote_state_switch_new( &self->update_vote_state_switch );
    break;
  }
  case 10: {
    fd_vote_authorize_with_seed_args_new( &self->authorize_with_seed );
    break;
  }
  case 11: {
    fd_vote_authorize_checked_with_seed_args_new( &self->authorize_checked_with_seed );
    break;
  }
  case 12: {
    fd_compact_vote_state_update_new( &self->compact_update_vote_state );
    break;
  }
  case 13: {
    fd_compact_vote_state_update_switch_new( &self->compact_update_vote_state_switch );
    break;
  }
  case 14: {
    fd_tower_sync_new( &self->tower_sync );
    break;
  }
  case 15: {
    fd_tower_sync_switch_new( &self->tower_sync_switch );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_vote_instruction_new_disc( fd_vote_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_vote_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_vote_instruction_new( fd_vote_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_vote_instruction_t) );
  fd_vote_instruction_new_disc( self, UINT_MAX );
}
void fd_vote_instruction_inner_destroy( fd_vote_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_vote_init_destroy( &self->initialize_account );
    break;
  }
  case 1: {
    fd_vote_authorize_pubkey_destroy( &self->authorize );
    break;
  }
  case 2: {
    fd_vote_destroy( &self->vote );
    break;
  }
  case 3: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_vote_switch_destroy( &self->vote_switch );
    break;
  }
  case 7: {
    fd_vote_authorize_destroy( &self->authorize_checked );
    break;
  }
  case 8: {
    fd_vote_state_update_destroy( &self->update_vote_state );
    break;
  }
  case 9: {
    fd_update_vote_state_switch_destroy( &self->update_vote_state_switch );
    break;
  }
  case 10: {
    fd_vote_authorize_with_seed_args_destroy( &self->authorize_with_seed );
    break;
  }
  case 11: {
    fd_vote_authorize_checked_with_seed_args_destroy( &self->authorize_checked_with_seed );
    break;
  }
  case 12: {
    fd_compact_vote_state_update_destroy( &self->compact_update_vote_state );
    break;
  }
  case 13: {
    fd_compact_vote_state_update_switch_destroy( &self->compact_update_vote_state_switch );
    break;
  }
  case 14: {
    fd_tower_sync_destroy( &self->tower_sync );
    break;
  }
  case 15: {
    fd_tower_sync_switch_destroy( &self->tower_sync_switch );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_vote_instruction_destroy( fd_vote_instruction_t * self ) {
  fd_vote_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_vote_instruction_footprint( void ){ return FD_VOTE_INSTRUCTION_FOOTPRINT; }
ulong fd_vote_instruction_align( void ){ return FD_VOTE_INSTRUCTION_ALIGN; }

void fd_vote_instruction_walk( void * w, fd_vote_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_vote_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "initialize_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_init_walk( w, &self->inner.initialize_account, fun, "initialize_account", level );
    break;
  }
  case 1: {
    fun( w, self, "authorize", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_authorize_pubkey_walk( w, &self->inner.authorize, fun, "authorize", level );
    break;
  }
  case 2: {
    fun( w, self, "vote", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_walk( w, &self->inner.vote, fun, "vote", level );
    break;
  }
  case 3: {
    fun( w, self, "withdraw", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.withdraw, "withdraw", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 4: {
    fun( w, self, "update_validator_identity", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "update_commission", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.update_commission, "update_commission", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
    break;
  }
  case 6: {
    fun( w, self, "vote_switch", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_switch_walk( w, &self->inner.vote_switch, fun, "vote_switch", level );
    break;
  }
  case 7: {
    fun( w, self, "authorize_checked", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_authorize_walk( w, &self->inner.authorize_checked, fun, "authorize_checked", level );
    break;
  }
  case 8: {
    fun( w, self, "update_vote_state", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_state_update_walk( w, &self->inner.update_vote_state, fun, "update_vote_state", level );
    break;
  }
  case 9: {
    fun( w, self, "update_vote_state_switch", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_update_vote_state_switch_walk( w, &self->inner.update_vote_state_switch, fun, "update_vote_state_switch", level );
    break;
  }
  case 10: {
    fun( w, self, "authorize_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_authorize_with_seed_args_walk( w, &self->inner.authorize_with_seed, fun, "authorize_with_seed", level );
    break;
  }
  case 11: {
    fun( w, self, "authorize_checked_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_vote_authorize_checked_with_seed_args_walk( w, &self->inner.authorize_checked_with_seed, fun, "authorize_checked_with_seed", level );
    break;
  }
  case 12: {
    fun( w, self, "compact_update_vote_state", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_compact_vote_state_update_walk( w, &self->inner.compact_update_vote_state, fun, "compact_update_vote_state", level );
    break;
  }
  case 13: {
    fun( w, self, "compact_update_vote_state_switch", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_compact_vote_state_update_switch_walk( w, &self->inner.compact_update_vote_state_switch, fun, "compact_update_vote_state_switch", level );
    break;
  }
  case 14: {
    fun( w, self, "tower_sync", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_tower_sync_walk( w, &self->inner.tower_sync, fun, "tower_sync", level );
    break;
  }
  case 15: {
    fun( w, self, "tower_sync_switch", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_tower_sync_switch_walk( w, &self->inner.tower_sync_switch, fun, "tower_sync_switch", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_vote_instruction", level-- );
}
ulong fd_vote_instruction_size( fd_vote_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_vote_init_size( &self->inner.initialize_account );
    break;
  }
  case 1: {
    size += fd_vote_authorize_pubkey_size( &self->inner.authorize );
    break;
  }
  case 2: {
    size += fd_vote_size( &self->inner.vote );
    break;
  }
  case 3: {
    size += sizeof(ulong);
    break;
  }
  case 5: {
    size += sizeof(char);
    break;
  }
  case 6: {
    size += fd_vote_switch_size( &self->inner.vote_switch );
    break;
  }
  case 7: {
    size += fd_vote_authorize_size( &self->inner.authorize_checked );
    break;
  }
  case 8: {
    size += fd_vote_state_update_size( &self->inner.update_vote_state );
    break;
  }
  case 9: {
    size += fd_update_vote_state_switch_size( &self->inner.update_vote_state_switch );
    break;
  }
  case 10: {
    size += fd_vote_authorize_with_seed_args_size( &self->inner.authorize_with_seed );
    break;
  }
  case 11: {
    size += fd_vote_authorize_checked_with_seed_args_size( &self->inner.authorize_checked_with_seed );
    break;
  }
  case 12: {
    size += fd_compact_vote_state_update_size( &self->inner.compact_update_vote_state );
    break;
  }
  case 13: {
    size += fd_compact_vote_state_update_switch_size( &self->inner.compact_update_vote_state_switch );
    break;
  }
  case 14: {
    size += fd_tower_sync_size( &self->inner.tower_sync );
    break;
  }
  case 15: {
    size += fd_tower_sync_switch_size( &self->inner.tower_sync_switch );
    break;
  }
  }
  return size;
}

int fd_vote_instruction_inner_encode( fd_vote_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_vote_init_encode( &self->initialize_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_vote_authorize_pubkey_encode( &self->authorize, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_vote_encode( &self->vote, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_bincode_uint64_encode( self->withdraw, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 5: {
    err = fd_bincode_uint8_encode( (uchar)(self->update_commission), ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 6: {
    err = fd_vote_switch_encode( &self->vote_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    err = fd_vote_authorize_encode( &self->authorize_checked, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_vote_state_update_encode( &self->update_vote_state, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_update_vote_state_switch_encode( &self->update_vote_state_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_vote_authorize_with_seed_args_encode( &self->authorize_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_vote_authorize_checked_with_seed_args_encode( &self->authorize_checked_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    err = fd_compact_vote_state_update_encode( &self->compact_update_vote_state, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 13: {
    err = fd_compact_vote_state_update_switch_encode( &self->compact_update_vote_state_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 14: {
    err = fd_tower_sync_encode( &self->tower_sync, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 15: {
    err = fd_tower_sync_switch_encode( &self->tower_sync_switch, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_vote_instruction_encode( fd_vote_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_vote_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_system_program_instruction_create_account_encode( fd_system_program_instruction_create_account_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->lamports, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->space, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_create_account_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_program_instruction_create_account_t);
  void const * start_data = ctx->data;
  int err = fd_system_program_instruction_create_account_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_program_instruction_create_account_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_system_program_instruction_create_account_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_t * self = (fd_system_program_instruction_create_account_t *)mem;
  fd_system_program_instruction_create_account_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_create_account_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_create_account_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_create_account_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_t * self = (fd_system_program_instruction_create_account_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->space, ctx );
  fd_pubkey_decode_inner( &self->owner, alloc_mem, ctx );
}
void * fd_system_program_instruction_create_account_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_global_t * self = (fd_system_program_instruction_create_account_global_t *)mem;
  fd_system_program_instruction_create_account_new( (fd_system_program_instruction_create_account_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_create_account_global_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_create_account_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_create_account_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_global_t * self = (fd_system_program_instruction_create_account_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->space, ctx );
  fd_pubkey_decode_inner_global( &self->owner, alloc_mem, ctx );
}
int fd_system_program_instruction_create_account_convert_global_to_local( void const * global_self, fd_system_program_instruction_create_account_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_system_program_instruction_create_account_global_t const * mem = (fd_system_program_instruction_create_account_global_t const *)global_self;
  self->lamports = mem->lamports;
  self->space = mem->space;
  err = fd_pubkey_convert_global_to_local( &mem->owner, &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_system_program_instruction_create_account_new(fd_system_program_instruction_create_account_t * self) {
  fd_memset( self, 0, sizeof(fd_system_program_instruction_create_account_t) );
  fd_pubkey_new( &self->owner );
}
void fd_system_program_instruction_create_account_destroy( fd_system_program_instruction_create_account_t * self ) {
  fd_pubkey_destroy( &self->owner );
}

ulong fd_system_program_instruction_create_account_footprint( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_CREATE_ACCOUNT_FOOTPRINT; }
ulong fd_system_program_instruction_create_account_align( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_CREATE_ACCOUNT_ALIGN; }

void fd_system_program_instruction_create_account_walk( void * w, fd_system_program_instruction_create_account_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_system_program_instruction_create_account", level++ );
  fun( w, &self->lamports, "lamports", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->space, "space", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->owner, fun, "owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_system_program_instruction_create_account", level-- );
}
ulong fd_system_program_instruction_create_account_size( fd_system_program_instruction_create_account_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->owner );
  return size;
}

int fd_system_program_instruction_create_account_with_seed_encode( fd_system_program_instruction_create_account_with_seed_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->base, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->seed_len ) {
    err = fd_bincode_bytes_encode( self->seed, self->seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->lamports, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->space, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_create_account_with_seed_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_program_instruction_create_account_with_seed_t);
  void const * start_data = ctx->data;
  int err = fd_system_program_instruction_create_account_with_seed_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_program_instruction_create_account_with_seed_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong seed_len;
  err = fd_bincode_uint64_decode( &seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += seed_len;
  if( seed_len ) {
    err = fd_bincode_bytes_decode_footprint( seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - seed_len, seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_system_program_instruction_create_account_with_seed_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_with_seed_t * self = (fd_system_program_instruction_create_account_with_seed_t *)mem;
  fd_system_program_instruction_create_account_with_seed_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_create_account_with_seed_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_create_account_with_seed_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_create_account_with_seed_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_with_seed_t * self = (fd_system_program_instruction_create_account_with_seed_t *)struct_mem;
  fd_pubkey_decode_inner( &self->base, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->seed_len, ctx );
  if( self->seed_len ) {
    self->seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->seed, self->seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->seed_len;
  } else
    self->seed = NULL;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->space, ctx );
  fd_pubkey_decode_inner( &self->owner, alloc_mem, ctx );
}
void * fd_system_program_instruction_create_account_with_seed_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_with_seed_global_t * self = (fd_system_program_instruction_create_account_with_seed_global_t *)mem;
  fd_system_program_instruction_create_account_with_seed_new( (fd_system_program_instruction_create_account_with_seed_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_create_account_with_seed_global_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_create_account_with_seed_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_create_account_with_seed_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_create_account_with_seed_global_t * self = (fd_system_program_instruction_create_account_with_seed_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->base, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->seed_len, ctx );
  if( self->seed_len ) {
    self->seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->seed_len;
  } else
    self->seed_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->space, ctx );
  fd_pubkey_decode_inner_global( &self->owner, alloc_mem, ctx );
}
int fd_system_program_instruction_create_account_with_seed_convert_global_to_local( void const * global_self, fd_system_program_instruction_create_account_with_seed_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_system_program_instruction_create_account_with_seed_global_t const * mem = (fd_system_program_instruction_create_account_with_seed_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->base, &self->base, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->seed_len = mem->seed_len;
  self->seed     = fd_wksp_laddr_fast( ctx->wksp, mem->seed_gaddr );
  self->lamports = mem->lamports;
  self->space = mem->space;
  err = fd_pubkey_convert_global_to_local( &mem->owner, &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_system_program_instruction_create_account_with_seed_new(fd_system_program_instruction_create_account_with_seed_t * self) {
  fd_memset( self, 0, sizeof(fd_system_program_instruction_create_account_with_seed_t) );
  fd_pubkey_new( &self->base );
  fd_pubkey_new( &self->owner );
}
void fd_system_program_instruction_create_account_with_seed_destroy( fd_system_program_instruction_create_account_with_seed_t * self ) {
  fd_pubkey_destroy( &self->base );
  if( self->seed ) {
    self->seed = NULL;
  }
  fd_pubkey_destroy( &self->owner );
}

ulong fd_system_program_instruction_create_account_with_seed_footprint( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_CREATE_ACCOUNT_WITH_SEED_FOOTPRINT; }
ulong fd_system_program_instruction_create_account_with_seed_align( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_CREATE_ACCOUNT_WITH_SEED_ALIGN; }

void fd_system_program_instruction_create_account_with_seed_walk( void * w, fd_system_program_instruction_create_account_with_seed_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_system_program_instruction_create_account_with_seed", level++ );
  fd_pubkey_walk( w, &self->base, fun, "base", level );
  fun(w, self->seed, "seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->lamports, "lamports", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->space, "space", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->owner, fun, "owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_system_program_instruction_create_account_with_seed", level-- );
}
ulong fd_system_program_instruction_create_account_with_seed_size( fd_system_program_instruction_create_account_with_seed_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->base );
  do {
    size += sizeof(ulong);
    size += self->seed_len;
  } while(0);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->owner );
  return size;
}

int fd_system_program_instruction_allocate_with_seed_encode( fd_system_program_instruction_allocate_with_seed_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->base, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->seed_len ) {
    err = fd_bincode_bytes_encode( self->seed, self->seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->space, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_allocate_with_seed_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_program_instruction_allocate_with_seed_t);
  void const * start_data = ctx->data;
  int err = fd_system_program_instruction_allocate_with_seed_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_program_instruction_allocate_with_seed_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong seed_len;
  err = fd_bincode_uint64_decode( &seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += seed_len;
  if( seed_len ) {
    err = fd_bincode_bytes_decode_footprint( seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - seed_len, seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_system_program_instruction_allocate_with_seed_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_allocate_with_seed_t * self = (fd_system_program_instruction_allocate_with_seed_t *)mem;
  fd_system_program_instruction_allocate_with_seed_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_allocate_with_seed_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_allocate_with_seed_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_allocate_with_seed_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_allocate_with_seed_t * self = (fd_system_program_instruction_allocate_with_seed_t *)struct_mem;
  fd_pubkey_decode_inner( &self->base, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->seed_len, ctx );
  if( self->seed_len ) {
    self->seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->seed, self->seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->seed_len;
  } else
    self->seed = NULL;
  fd_bincode_uint64_decode_unsafe( &self->space, ctx );
  fd_pubkey_decode_inner( &self->owner, alloc_mem, ctx );
}
void * fd_system_program_instruction_allocate_with_seed_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_allocate_with_seed_global_t * self = (fd_system_program_instruction_allocate_with_seed_global_t *)mem;
  fd_system_program_instruction_allocate_with_seed_new( (fd_system_program_instruction_allocate_with_seed_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_allocate_with_seed_global_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_allocate_with_seed_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_allocate_with_seed_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_allocate_with_seed_global_t * self = (fd_system_program_instruction_allocate_with_seed_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->base, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->seed_len, ctx );
  if( self->seed_len ) {
    self->seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->seed_len;
  } else
    self->seed_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->space, ctx );
  fd_pubkey_decode_inner_global( &self->owner, alloc_mem, ctx );
}
int fd_system_program_instruction_allocate_with_seed_convert_global_to_local( void const * global_self, fd_system_program_instruction_allocate_with_seed_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_system_program_instruction_allocate_with_seed_global_t const * mem = (fd_system_program_instruction_allocate_with_seed_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->base, &self->base, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->seed_len = mem->seed_len;
  self->seed     = fd_wksp_laddr_fast( ctx->wksp, mem->seed_gaddr );
  self->space = mem->space;
  err = fd_pubkey_convert_global_to_local( &mem->owner, &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_system_program_instruction_allocate_with_seed_new(fd_system_program_instruction_allocate_with_seed_t * self) {
  fd_memset( self, 0, sizeof(fd_system_program_instruction_allocate_with_seed_t) );
  fd_pubkey_new( &self->base );
  fd_pubkey_new( &self->owner );
}
void fd_system_program_instruction_allocate_with_seed_destroy( fd_system_program_instruction_allocate_with_seed_t * self ) {
  fd_pubkey_destroy( &self->base );
  if( self->seed ) {
    self->seed = NULL;
  }
  fd_pubkey_destroy( &self->owner );
}

ulong fd_system_program_instruction_allocate_with_seed_footprint( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_ALLOCATE_WITH_SEED_FOOTPRINT; }
ulong fd_system_program_instruction_allocate_with_seed_align( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_ALLOCATE_WITH_SEED_ALIGN; }

void fd_system_program_instruction_allocate_with_seed_walk( void * w, fd_system_program_instruction_allocate_with_seed_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_system_program_instruction_allocate_with_seed", level++ );
  fd_pubkey_walk( w, &self->base, fun, "base", level );
  fun(w, self->seed, "seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->space, "space", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->owner, fun, "owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_system_program_instruction_allocate_with_seed", level-- );
}
ulong fd_system_program_instruction_allocate_with_seed_size( fd_system_program_instruction_allocate_with_seed_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->base );
  do {
    size += sizeof(ulong);
    size += self->seed_len;
  } while(0);
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->owner );
  return size;
}

int fd_system_program_instruction_assign_with_seed_encode( fd_system_program_instruction_assign_with_seed_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->base, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->seed_len ) {
    err = fd_bincode_bytes_encode( self->seed, self->seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_assign_with_seed_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_program_instruction_assign_with_seed_t);
  void const * start_data = ctx->data;
  int err = fd_system_program_instruction_assign_with_seed_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_program_instruction_assign_with_seed_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong seed_len;
  err = fd_bincode_uint64_decode( &seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += seed_len;
  if( seed_len ) {
    err = fd_bincode_bytes_decode_footprint( seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - seed_len, seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_system_program_instruction_assign_with_seed_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_assign_with_seed_t * self = (fd_system_program_instruction_assign_with_seed_t *)mem;
  fd_system_program_instruction_assign_with_seed_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_assign_with_seed_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_assign_with_seed_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_assign_with_seed_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_assign_with_seed_t * self = (fd_system_program_instruction_assign_with_seed_t *)struct_mem;
  fd_pubkey_decode_inner( &self->base, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->seed_len, ctx );
  if( self->seed_len ) {
    self->seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->seed, self->seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->seed_len;
  } else
    self->seed = NULL;
  fd_pubkey_decode_inner( &self->owner, alloc_mem, ctx );
}
void * fd_system_program_instruction_assign_with_seed_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_assign_with_seed_global_t * self = (fd_system_program_instruction_assign_with_seed_global_t *)mem;
  fd_system_program_instruction_assign_with_seed_new( (fd_system_program_instruction_assign_with_seed_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_assign_with_seed_global_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_assign_with_seed_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_assign_with_seed_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_assign_with_seed_global_t * self = (fd_system_program_instruction_assign_with_seed_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->base, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->seed_len, ctx );
  if( self->seed_len ) {
    self->seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->seed_len;
  } else
    self->seed_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->owner, alloc_mem, ctx );
}
int fd_system_program_instruction_assign_with_seed_convert_global_to_local( void const * global_self, fd_system_program_instruction_assign_with_seed_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_system_program_instruction_assign_with_seed_global_t const * mem = (fd_system_program_instruction_assign_with_seed_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->base, &self->base, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->seed_len = mem->seed_len;
  self->seed     = fd_wksp_laddr_fast( ctx->wksp, mem->seed_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->owner, &self->owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_system_program_instruction_assign_with_seed_new(fd_system_program_instruction_assign_with_seed_t * self) {
  fd_memset( self, 0, sizeof(fd_system_program_instruction_assign_with_seed_t) );
  fd_pubkey_new( &self->base );
  fd_pubkey_new( &self->owner );
}
void fd_system_program_instruction_assign_with_seed_destroy( fd_system_program_instruction_assign_with_seed_t * self ) {
  fd_pubkey_destroy( &self->base );
  if( self->seed ) {
    self->seed = NULL;
  }
  fd_pubkey_destroy( &self->owner );
}

ulong fd_system_program_instruction_assign_with_seed_footprint( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_ASSIGN_WITH_SEED_FOOTPRINT; }
ulong fd_system_program_instruction_assign_with_seed_align( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_ASSIGN_WITH_SEED_ALIGN; }

void fd_system_program_instruction_assign_with_seed_walk( void * w, fd_system_program_instruction_assign_with_seed_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_system_program_instruction_assign_with_seed", level++ );
  fd_pubkey_walk( w, &self->base, fun, "base", level );
  fun(w, self->seed, "seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->owner, fun, "owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_system_program_instruction_assign_with_seed", level-- );
}
ulong fd_system_program_instruction_assign_with_seed_size( fd_system_program_instruction_assign_with_seed_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->base );
  do {
    size += sizeof(ulong);
    size += self->seed_len;
  } while(0);
  size += fd_pubkey_size( &self->owner );
  return size;
}

int fd_system_program_instruction_transfer_with_seed_encode( fd_system_program_instruction_transfer_with_seed_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->lamports, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->from_seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->from_seed_len ) {
    err = fd_bincode_bytes_encode( self->from_seed, self->from_seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->from_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_transfer_with_seed_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_program_instruction_transfer_with_seed_t);
  void const * start_data = ctx->data;
  int err = fd_system_program_instruction_transfer_with_seed_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_program_instruction_transfer_with_seed_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong from_seed_len;
  err = fd_bincode_uint64_decode( &from_seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += from_seed_len;
  if( from_seed_len ) {
    err = fd_bincode_bytes_decode_footprint( from_seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - from_seed_len, from_seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_system_program_instruction_transfer_with_seed_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_transfer_with_seed_t * self = (fd_system_program_instruction_transfer_with_seed_t *)mem;
  fd_system_program_instruction_transfer_with_seed_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_transfer_with_seed_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_transfer_with_seed_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_transfer_with_seed_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_transfer_with_seed_t * self = (fd_system_program_instruction_transfer_with_seed_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->from_seed_len, ctx );
  if( self->from_seed_len ) {
    self->from_seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->from_seed, self->from_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->from_seed_len;
  } else
    self->from_seed = NULL;
  fd_pubkey_decode_inner( &self->from_owner, alloc_mem, ctx );
}
void * fd_system_program_instruction_transfer_with_seed_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_transfer_with_seed_global_t * self = (fd_system_program_instruction_transfer_with_seed_global_t *)mem;
  fd_system_program_instruction_transfer_with_seed_new( (fd_system_program_instruction_transfer_with_seed_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_transfer_with_seed_global_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_transfer_with_seed_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_transfer_with_seed_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_transfer_with_seed_global_t * self = (fd_system_program_instruction_transfer_with_seed_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->lamports, ctx );
  fd_bincode_uint64_decode_unsafe( &self->from_seed_len, ctx );
  if( self->from_seed_len ) {
    self->from_seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->from_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->from_seed_len;
  } else
    self->from_seed_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->from_owner, alloc_mem, ctx );
}
int fd_system_program_instruction_transfer_with_seed_convert_global_to_local( void const * global_self, fd_system_program_instruction_transfer_with_seed_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_system_program_instruction_transfer_with_seed_global_t const * mem = (fd_system_program_instruction_transfer_with_seed_global_t const *)global_self;
  self->lamports = mem->lamports;
  self->from_seed_len = mem->from_seed_len;
  self->from_seed     = fd_wksp_laddr_fast( ctx->wksp, mem->from_seed_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->from_owner, &self->from_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_system_program_instruction_transfer_with_seed_new(fd_system_program_instruction_transfer_with_seed_t * self) {
  fd_memset( self, 0, sizeof(fd_system_program_instruction_transfer_with_seed_t) );
  fd_pubkey_new( &self->from_owner );
}
void fd_system_program_instruction_transfer_with_seed_destroy( fd_system_program_instruction_transfer_with_seed_t * self ) {
  if( self->from_seed ) {
    self->from_seed = NULL;
  }
  fd_pubkey_destroy( &self->from_owner );
}

ulong fd_system_program_instruction_transfer_with_seed_footprint( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_TRANSFER_WITH_SEED_FOOTPRINT; }
ulong fd_system_program_instruction_transfer_with_seed_align( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_TRANSFER_WITH_SEED_ALIGN; }

void fd_system_program_instruction_transfer_with_seed_walk( void * w, fd_system_program_instruction_transfer_with_seed_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_system_program_instruction_transfer_with_seed", level++ );
  fun( w, &self->lamports, "lamports", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun(w, self->from_seed, "from_seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->from_owner, fun, "from_owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_system_program_instruction_transfer_with_seed", level-- );
}
ulong fd_system_program_instruction_transfer_with_seed_size( fd_system_program_instruction_transfer_with_seed_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    size += self->from_seed_len;
  } while(0);
  size += fd_pubkey_size( &self->from_owner );
  return size;
}

FD_FN_PURE uchar fd_system_program_instruction_is_create_account(fd_system_program_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_system_program_instruction_is_assign(fd_system_program_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_system_program_instruction_is_transfer(fd_system_program_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_system_program_instruction_is_create_account_with_seed(fd_system_program_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_system_program_instruction_is_advance_nonce_account(fd_system_program_instruction_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_system_program_instruction_is_withdraw_nonce_account(fd_system_program_instruction_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_system_program_instruction_is_initialize_nonce_account(fd_system_program_instruction_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_system_program_instruction_is_authorize_nonce_account(fd_system_program_instruction_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_system_program_instruction_is_allocate(fd_system_program_instruction_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_system_program_instruction_is_allocate_with_seed(fd_system_program_instruction_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_system_program_instruction_is_assign_with_seed(fd_system_program_instruction_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_system_program_instruction_is_transfer_with_seed(fd_system_program_instruction_t const * self) {
  return self->discriminant == 11;
}
FD_FN_PURE uchar fd_system_program_instruction_is_upgrade_nonce_account(fd_system_program_instruction_t const * self) {
  return self->discriminant == 12;
}
void fd_system_program_instruction_inner_new( fd_system_program_instruction_inner_t * self, uint discriminant );
int fd_system_program_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_system_program_instruction_create_account_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_system_program_instruction_create_account_with_seed_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    err = fd_system_program_instruction_allocate_with_seed_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    err = fd_system_program_instruction_assign_with_seed_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    err = fd_system_program_instruction_transfer_with_seed_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 12: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_system_program_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_program_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_system_program_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_program_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_system_program_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_system_program_instruction_inner_decode_inner( fd_system_program_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_system_program_instruction_create_account_decode_inner( &self->create_account, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_pubkey_decode_inner( &self->assign, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_bincode_uint64_decode_unsafe( &self->transfer, ctx );
    break;
  }
  case 3: {
    fd_system_program_instruction_create_account_with_seed_decode_inner( &self->create_account_with_seed, alloc_mem, ctx );
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    fd_bincode_uint64_decode_unsafe( &self->withdraw_nonce_account, ctx );
    break;
  }
  case 6: {
    fd_pubkey_decode_inner( &self->initialize_nonce_account, alloc_mem, ctx );
    break;
  }
  case 7: {
    fd_pubkey_decode_inner( &self->authorize_nonce_account, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_bincode_uint64_decode_unsafe( &self->allocate, ctx );
    break;
  }
  case 9: {
    fd_system_program_instruction_allocate_with_seed_decode_inner( &self->allocate_with_seed, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_system_program_instruction_assign_with_seed_decode_inner( &self->assign_with_seed, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_system_program_instruction_transfer_with_seed_decode_inner( &self->transfer_with_seed, alloc_mem, ctx );
    break;
  }
  case 12: {
    break;
  }
  }
}
void fd_system_program_instruction_inner_decode_inner_global( fd_system_program_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_system_program_instruction_create_account_decode_inner_global( &self->create_account, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_pubkey_decode_inner_global( &self->assign, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_bincode_uint64_decode_unsafe( &self->transfer, ctx );
    break;
  }
  case 3: {
    fd_system_program_instruction_create_account_with_seed_decode_inner_global( &self->create_account_with_seed, alloc_mem, ctx );
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    fd_bincode_uint64_decode_unsafe( &self->withdraw_nonce_account, ctx );
    break;
  }
  case 6: {
    fd_pubkey_decode_inner_global( &self->initialize_nonce_account, alloc_mem, ctx );
    break;
  }
  case 7: {
    fd_pubkey_decode_inner_global( &self->authorize_nonce_account, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_bincode_uint64_decode_unsafe( &self->allocate, ctx );
    break;
  }
  case 9: {
    fd_system_program_instruction_allocate_with_seed_decode_inner_global( &self->allocate_with_seed, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_system_program_instruction_assign_with_seed_decode_inner_global( &self->assign_with_seed, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_system_program_instruction_transfer_with_seed_decode_inner_global( &self->transfer_with_seed, alloc_mem, ctx );
    break;
  }
  case 12: {
    break;
  }
  }
}
int fd_system_program_instruction_convert_global_to_local_inner( fd_system_program_instruction_inner_global_t const * mem, fd_system_program_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_system_program_instruction_create_account_convert_global_to_local( &mem->create_account, &self->create_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_pubkey_convert_global_to_local( &mem->assign, &self->assign, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    self->transfer = mem->transfer;
    break;
  }
  case 3: {
    err = fd_system_program_instruction_create_account_with_seed_convert_global_to_local( &mem->create_account_with_seed, &self->create_account_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    self->withdraw_nonce_account = mem->withdraw_nonce_account;
    break;
  }
  case 6: {
    err = fd_pubkey_convert_global_to_local( &mem->initialize_nonce_account, &self->initialize_nonce_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    err = fd_pubkey_convert_global_to_local( &mem->authorize_nonce_account, &self->authorize_nonce_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    self->allocate = mem->allocate;
    break;
  }
  case 9: {
    err = fd_system_program_instruction_allocate_with_seed_convert_global_to_local( &mem->allocate_with_seed, &self->allocate_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_system_program_instruction_assign_with_seed_convert_global_to_local( &mem->assign_with_seed, &self->assign_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_system_program_instruction_transfer_with_seed_convert_global_to_local( &mem->transfer_with_seed, &self->transfer_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_convert_global_to_local( void const * global_self, fd_system_program_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_global_t const * mem = (fd_system_program_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_system_program_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_system_program_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_t * self = (fd_system_program_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_system_program_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_system_program_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_t * self = (fd_system_program_instruction_t *)mem;
  fd_system_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_system_program_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_t * self = (fd_system_program_instruction_t *)mem;
  fd_system_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_system_program_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_program_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_program_instruction_global_t * self = (fd_system_program_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_system_program_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_system_program_instruction_inner_new( fd_system_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_system_program_instruction_create_account_new( &self->create_account );
    break;
  }
  case 1: {
    fd_pubkey_new( &self->assign );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    fd_system_program_instruction_create_account_with_seed_new( &self->create_account_with_seed );
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_pubkey_new( &self->initialize_nonce_account );
    break;
  }
  case 7: {
    fd_pubkey_new( &self->authorize_nonce_account );
    break;
  }
  case 8: {
    break;
  }
  case 9: {
    fd_system_program_instruction_allocate_with_seed_new( &self->allocate_with_seed );
    break;
  }
  case 10: {
    fd_system_program_instruction_assign_with_seed_new( &self->assign_with_seed );
    break;
  }
  case 11: {
    fd_system_program_instruction_transfer_with_seed_new( &self->transfer_with_seed );
    break;
  }
  case 12: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_system_program_instruction_new_disc( fd_system_program_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_system_program_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_system_program_instruction_new( fd_system_program_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_system_program_instruction_t) );
  fd_system_program_instruction_new_disc( self, UINT_MAX );
}
void fd_system_program_instruction_inner_destroy( fd_system_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_system_program_instruction_create_account_destroy( &self->create_account );
    break;
  }
  case 1: {
    fd_pubkey_destroy( &self->assign );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    fd_system_program_instruction_create_account_with_seed_destroy( &self->create_account_with_seed );
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_pubkey_destroy( &self->initialize_nonce_account );
    break;
  }
  case 7: {
    fd_pubkey_destroy( &self->authorize_nonce_account );
    break;
  }
  case 8: {
    break;
  }
  case 9: {
    fd_system_program_instruction_allocate_with_seed_destroy( &self->allocate_with_seed );
    break;
  }
  case 10: {
    fd_system_program_instruction_assign_with_seed_destroy( &self->assign_with_seed );
    break;
  }
  case 11: {
    fd_system_program_instruction_transfer_with_seed_destroy( &self->transfer_with_seed );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_system_program_instruction_destroy( fd_system_program_instruction_t * self ) {
  fd_system_program_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_system_program_instruction_footprint( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_FOOTPRINT; }
ulong fd_system_program_instruction_align( void ){ return FD_SYSTEM_PROGRAM_INSTRUCTION_ALIGN; }

void fd_system_program_instruction_walk( void * w, fd_system_program_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_system_program_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "create_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_system_program_instruction_create_account_walk( w, &self->inner.create_account, fun, "create_account", level );
    break;
  }
  case 1: {
    fun( w, self, "assign", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_pubkey_walk( w, &self->inner.assign, fun, "assign", level );
    break;
  }
  case 2: {
    fun( w, self, "transfer", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.transfer, "transfer", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 3: {
    fun( w, self, "create_account_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_system_program_instruction_create_account_with_seed_walk( w, &self->inner.create_account_with_seed, fun, "create_account_with_seed", level );
    break;
  }
  case 4: {
    fun( w, self, "advance_nonce_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "withdraw_nonce_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.withdraw_nonce_account, "withdraw_nonce_account", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 6: {
    fun( w, self, "initialize_nonce_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_pubkey_walk( w, &self->inner.initialize_nonce_account, fun, "initialize_nonce_account", level );
    break;
  }
  case 7: {
    fun( w, self, "authorize_nonce_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_pubkey_walk( w, &self->inner.authorize_nonce_account, fun, "authorize_nonce_account", level );
    break;
  }
  case 8: {
    fun( w, self, "allocate", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.allocate, "allocate", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 9: {
    fun( w, self, "allocate_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_system_program_instruction_allocate_with_seed_walk( w, &self->inner.allocate_with_seed, fun, "allocate_with_seed", level );
    break;
  }
  case 10: {
    fun( w, self, "assign_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_system_program_instruction_assign_with_seed_walk( w, &self->inner.assign_with_seed, fun, "assign_with_seed", level );
    break;
  }
  case 11: {
    fun( w, self, "transfer_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_system_program_instruction_transfer_with_seed_walk( w, &self->inner.transfer_with_seed, fun, "transfer_with_seed", level );
    break;
  }
  case 12: {
    fun( w, self, "upgrade_nonce_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_system_program_instruction", level-- );
}
ulong fd_system_program_instruction_size( fd_system_program_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_system_program_instruction_create_account_size( &self->inner.create_account );
    break;
  }
  case 1: {
    size += fd_pubkey_size( &self->inner.assign );
    break;
  }
  case 2: {
    size += sizeof(ulong);
    break;
  }
  case 3: {
    size += fd_system_program_instruction_create_account_with_seed_size( &self->inner.create_account_with_seed );
    break;
  }
  case 5: {
    size += sizeof(ulong);
    break;
  }
  case 6: {
    size += fd_pubkey_size( &self->inner.initialize_nonce_account );
    break;
  }
  case 7: {
    size += fd_pubkey_size( &self->inner.authorize_nonce_account );
    break;
  }
  case 8: {
    size += sizeof(ulong);
    break;
  }
  case 9: {
    size += fd_system_program_instruction_allocate_with_seed_size( &self->inner.allocate_with_seed );
    break;
  }
  case 10: {
    size += fd_system_program_instruction_assign_with_seed_size( &self->inner.assign_with_seed );
    break;
  }
  case 11: {
    size += fd_system_program_instruction_transfer_with_seed_size( &self->inner.transfer_with_seed );
    break;
  }
  }
  return size;
}

int fd_system_program_instruction_inner_encode( fd_system_program_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_system_program_instruction_create_account_encode( &self->create_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_pubkey_encode( &self->assign, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_bincode_uint64_encode( self->transfer, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_system_program_instruction_create_account_with_seed_encode( &self->create_account_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 5: {
    err = fd_bincode_uint64_encode( self->withdraw_nonce_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 6: {
    err = fd_pubkey_encode( &self->initialize_nonce_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    err = fd_pubkey_encode( &self->authorize_nonce_account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_bincode_uint64_encode( self->allocate, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_system_program_instruction_allocate_with_seed_encode( &self->allocate_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_system_program_instruction_assign_with_seed_encode( &self->assign_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_system_program_instruction_transfer_with_seed_encode( &self->transfer_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_system_program_instruction_encode( fd_system_program_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_system_program_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

FD_FN_PURE uchar fd_system_error_is_account_already_in_use(fd_system_error_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_system_error_is_result_with_negative_lamports(fd_system_error_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_system_error_is_invalid_program_id(fd_system_error_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_system_error_is_invalid_account_data_length(fd_system_error_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_system_error_is_max_seed_length_exceeded(fd_system_error_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_system_error_is_address_with_seed_mismatch(fd_system_error_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_system_error_is_nonce_no_recent_blockhashes(fd_system_error_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_system_error_is_nonce_blockhash_not_expired(fd_system_error_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_system_error_is_nonce_unexpected_blockhash_value(fd_system_error_t const * self) {
  return self->discriminant == 8;
}
void fd_system_error_inner_new( fd_system_error_inner_t * self, uint discriminant );
int fd_system_error_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_system_error_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_system_error_t);
  void const * start_data = ctx->data;
  int err =  fd_system_error_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_system_error_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_system_error_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_system_error_inner_decode_inner( fd_system_error_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  }
}
void fd_system_error_inner_decode_inner_global( fd_system_error_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  }
}
int fd_system_error_convert_global_to_local_inner( fd_system_error_inner_global_t const * mem, fd_system_error_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_system_error_convert_global_to_local( void const * global_self, fd_system_error_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_error_global_t const * mem = (fd_system_error_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_system_error_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_system_error_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_error_t * self = (fd_system_error_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_system_error_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_system_error_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_error_t * self = (fd_system_error_t *)mem;
  fd_system_error_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_error_t);
  void * * alloc_mem = &alloc_region;
  fd_system_error_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_system_error_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_error_t * self = (fd_system_error_t *)mem;
  fd_system_error_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_system_error_t);
  void * * alloc_mem = &alloc_region;
  fd_system_error_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_system_error_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_system_error_global_t * self = (fd_system_error_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_system_error_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_system_error_inner_new( fd_system_error_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_system_error_new_disc( fd_system_error_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_system_error_inner_new( &self->inner, self->discriminant );
}
void fd_system_error_new( fd_system_error_t * self ) {
  fd_memset( self, 0, sizeof(fd_system_error_t) );
  fd_system_error_new_disc( self, UINT_MAX );
}
void fd_system_error_inner_destroy( fd_system_error_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_system_error_destroy( fd_system_error_t * self ) {
  fd_system_error_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_system_error_footprint( void ){ return FD_SYSTEM_ERROR_FOOTPRINT; }
ulong fd_system_error_align( void ){ return FD_SYSTEM_ERROR_ALIGN; }

void fd_system_error_walk( void * w, fd_system_error_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_system_error", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "account_already_in_use", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "result_with_negative_lamports", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "invalid_program_id", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "invalid_account_data_length", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "max_seed_length_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "address_with_seed_mismatch", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 6: {
    fun( w, self, "nonce_no_recent_blockhashes", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 7: {
    fun( w, self, "nonce_blockhash_not_expired", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 8: {
    fun( w, self, "nonce_unexpected_blockhash_value", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_system_error", level-- );
}
ulong fd_system_error_size( fd_system_error_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  }
  return size;
}

int fd_system_error_inner_encode( fd_system_error_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  return FD_BINCODE_SUCCESS;
}
int fd_system_error_encode( fd_system_error_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_system_error_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_stake_authorized_encode( fd_stake_authorized_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->staker, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_authorized_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_authorized_t);
  void const * start_data = ctx->data;
  int err = fd_stake_authorized_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_authorized_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_authorized_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorized_t * self = (fd_stake_authorized_t *)mem;
  fd_stake_authorized_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_authorized_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_authorized_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_authorized_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorized_t * self = (fd_stake_authorized_t *)struct_mem;
  fd_pubkey_decode_inner( &self->staker, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->withdrawer, alloc_mem, ctx );
}
void * fd_stake_authorized_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorized_global_t * self = (fd_stake_authorized_global_t *)mem;
  fd_stake_authorized_new( (fd_stake_authorized_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_authorized_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_authorized_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_authorized_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorized_global_t * self = (fd_stake_authorized_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->staker, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->withdrawer, alloc_mem, ctx );
}
int fd_stake_authorized_convert_global_to_local( void const * global_self, fd_stake_authorized_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_authorized_global_t const * mem = (fd_stake_authorized_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->staker, &self->staker, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->withdrawer, &self->withdrawer, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_authorized_new(fd_stake_authorized_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_authorized_t) );
  fd_pubkey_new( &self->staker );
  fd_pubkey_new( &self->withdrawer );
}
void fd_stake_authorized_destroy( fd_stake_authorized_t * self ) {
  fd_pubkey_destroy( &self->staker );
  fd_pubkey_destroy( &self->withdrawer );
}

ulong fd_stake_authorized_footprint( void ){ return FD_STAKE_AUTHORIZED_FOOTPRINT; }
ulong fd_stake_authorized_align( void ){ return FD_STAKE_AUTHORIZED_ALIGN; }

void fd_stake_authorized_walk( void * w, fd_stake_authorized_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_authorized", level++ );
  fd_pubkey_walk( w, &self->staker, fun, "staker", level );
  fd_pubkey_walk( w, &self->withdrawer, fun, "withdrawer", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_authorized", level-- );
}
ulong fd_stake_authorized_size( fd_stake_authorized_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->staker );
  size += fd_pubkey_size( &self->withdrawer );
  return size;
}

int fd_stake_lockup_encode( fd_stake_lockup_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( (ulong)self->unix_timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->epoch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->custodian, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_lockup_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_lockup_t);
  void const * start_data = ctx->data;
  int err = fd_stake_lockup_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_lockup_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_lockup_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_t * self = (fd_stake_lockup_t *)mem;
  fd_stake_lockup_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_lockup_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_lockup_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_lockup_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_t * self = (fd_stake_lockup_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->unix_timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_pubkey_decode_inner( &self->custodian, alloc_mem, ctx );
}
void * fd_stake_lockup_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_global_t * self = (fd_stake_lockup_global_t *)mem;
  fd_stake_lockup_new( (fd_stake_lockup_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_lockup_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_lockup_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_lockup_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_global_t * self = (fd_stake_lockup_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->unix_timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->epoch, ctx );
  fd_pubkey_decode_inner_global( &self->custodian, alloc_mem, ctx );
}
int fd_stake_lockup_convert_global_to_local( void const * global_self, fd_stake_lockup_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_lockup_global_t const * mem = (fd_stake_lockup_global_t const *)global_self;
  self->unix_timestamp = mem->unix_timestamp;
  self->epoch = mem->epoch;
  err = fd_pubkey_convert_global_to_local( &mem->custodian, &self->custodian, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_lockup_new(fd_stake_lockup_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_lockup_t) );
  fd_pubkey_new( &self->custodian );
}
void fd_stake_lockup_destroy( fd_stake_lockup_t * self ) {
  fd_pubkey_destroy( &self->custodian );
}

ulong fd_stake_lockup_footprint( void ){ return FD_STAKE_LOCKUP_FOOTPRINT; }
ulong fd_stake_lockup_align( void ){ return FD_STAKE_LOCKUP_ALIGN; }

void fd_stake_lockup_walk( void * w, fd_stake_lockup_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_lockup", level++ );
  fun( w, &self->unix_timestamp, "unix_timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, &self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->custodian, fun, "custodian", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_lockup", level-- );
}
ulong fd_stake_lockup_size( fd_stake_lockup_t const * self ) {
  ulong size = 0;
  size += sizeof(long);
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->custodian );
  return size;
}

int fd_stake_instruction_initialize_encode( fd_stake_instruction_initialize_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stake_authorized_encode( &self->authorized, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_lockup_encode( &self->lockup, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_instruction_initialize_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_instruction_initialize_t);
  void const * start_data = ctx->data;
  int err = fd_stake_instruction_initialize_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_instruction_initialize_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stake_authorized_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_lockup_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_instruction_initialize_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_initialize_t * self = (fd_stake_instruction_initialize_t *)mem;
  fd_stake_instruction_initialize_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_instruction_initialize_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_instruction_initialize_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_instruction_initialize_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_initialize_t * self = (fd_stake_instruction_initialize_t *)struct_mem;
  fd_stake_authorized_decode_inner( &self->authorized, alloc_mem, ctx );
  fd_stake_lockup_decode_inner( &self->lockup, alloc_mem, ctx );
}
void * fd_stake_instruction_initialize_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_initialize_global_t * self = (fd_stake_instruction_initialize_global_t *)mem;
  fd_stake_instruction_initialize_new( (fd_stake_instruction_initialize_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_instruction_initialize_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_instruction_initialize_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_instruction_initialize_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_initialize_global_t * self = (fd_stake_instruction_initialize_global_t *)struct_mem;
  fd_stake_authorized_decode_inner_global( &self->authorized, alloc_mem, ctx );
  fd_stake_lockup_decode_inner_global( &self->lockup, alloc_mem, ctx );
}
int fd_stake_instruction_initialize_convert_global_to_local( void const * global_self, fd_stake_instruction_initialize_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_instruction_initialize_global_t const * mem = (fd_stake_instruction_initialize_global_t const *)global_self;
  err = fd_stake_authorized_convert_global_to_local( &mem->authorized, &self->authorized, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_lockup_convert_global_to_local( &mem->lockup, &self->lockup, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_instruction_initialize_new(fd_stake_instruction_initialize_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_instruction_initialize_t) );
  fd_stake_authorized_new( &self->authorized );
  fd_stake_lockup_new( &self->lockup );
}
void fd_stake_instruction_initialize_destroy( fd_stake_instruction_initialize_t * self ) {
  fd_stake_authorized_destroy( &self->authorized );
  fd_stake_lockup_destroy( &self->lockup );
}

ulong fd_stake_instruction_initialize_footprint( void ){ return FD_STAKE_INSTRUCTION_INITIALIZE_FOOTPRINT; }
ulong fd_stake_instruction_initialize_align( void ){ return FD_STAKE_INSTRUCTION_INITIALIZE_ALIGN; }

void fd_stake_instruction_initialize_walk( void * w, fd_stake_instruction_initialize_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_instruction_initialize", level++ );
  fd_stake_authorized_walk( w, &self->authorized, fun, "authorized", level );
  fd_stake_lockup_walk( w, &self->lockup, fun, "lockup", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_instruction_initialize", level-- );
}
ulong fd_stake_instruction_initialize_size( fd_stake_instruction_initialize_t const * self ) {
  ulong size = 0;
  size += fd_stake_authorized_size( &self->authorized );
  size += fd_stake_lockup_size( &self->lockup );
  return size;
}

int fd_stake_lockup_custodian_args_encode( fd_stake_lockup_custodian_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stake_lockup_encode( &self->lockup, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_clock_encode( &self->clock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->custodian != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_pubkey_encode( self->custodian, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_lockup_custodian_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_lockup_custodian_args_t);
  void const * start_data = ctx->data;
  int err = fd_stake_lockup_custodian_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_lockup_custodian_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stake_lockup_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_clock_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT;
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_stake_lockup_custodian_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_custodian_args_t * self = (fd_stake_lockup_custodian_args_t *)mem;
  fd_stake_lockup_custodian_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_lockup_custodian_args_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_lockup_custodian_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_lockup_custodian_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_custodian_args_t * self = (fd_stake_lockup_custodian_args_t *)struct_mem;
  fd_stake_lockup_decode_inner( &self->lockup, alloc_mem, ctx );
  fd_sol_sysvar_clock_decode_inner( &self->clock, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->custodian = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_new( self->custodian );
      fd_pubkey_decode_inner( self->custodian, alloc_mem, ctx );
    } else {
      self->custodian = NULL;
    }
  }
}
void * fd_stake_lockup_custodian_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_custodian_args_global_t * self = (fd_stake_lockup_custodian_args_global_t *)mem;
  fd_stake_lockup_custodian_args_new( (fd_stake_lockup_custodian_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_lockup_custodian_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_lockup_custodian_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_lockup_custodian_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_lockup_custodian_args_global_t * self = (fd_stake_lockup_custodian_args_global_t *)struct_mem;
  fd_stake_lockup_decode_inner_global( &self->lockup, alloc_mem, ctx );
  fd_sol_sysvar_clock_decode_inner_global( &self->clock, alloc_mem, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->custodian_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_pubkey_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->custodian_gaddr ), alloc_mem, ctx );
    } else {
      self->custodian_gaddr = 0UL;
    }
  }
}
int fd_stake_lockup_custodian_args_convert_global_to_local( void const * global_self, fd_stake_lockup_custodian_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_lockup_custodian_args_global_t const * mem = (fd_stake_lockup_custodian_args_global_t const *)global_self;
  err = fd_stake_lockup_convert_global_to_local( &mem->lockup, &self->lockup, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_sol_sysvar_clock_convert_global_to_local( &mem->clock, &self->clock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->custodian = fd_wksp_laddr_fast( ctx->wksp, mem->custodian_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_stake_lockup_custodian_args_new(fd_stake_lockup_custodian_args_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_lockup_custodian_args_t) );
  fd_stake_lockup_new( &self->lockup );
  fd_sol_sysvar_clock_new( &self->clock );
}
void fd_stake_lockup_custodian_args_destroy( fd_stake_lockup_custodian_args_t * self ) {
  fd_stake_lockup_destroy( &self->lockup );
  fd_sol_sysvar_clock_destroy( &self->clock );
  if( self->custodian ) {
    fd_pubkey_destroy( self->custodian );
    self->custodian = NULL;
  }
}

ulong fd_stake_lockup_custodian_args_footprint( void ){ return FD_STAKE_LOCKUP_CUSTODIAN_ARGS_FOOTPRINT; }
ulong fd_stake_lockup_custodian_args_align( void ){ return FD_STAKE_LOCKUP_CUSTODIAN_ARGS_ALIGN; }

void fd_stake_lockup_custodian_args_walk( void * w, fd_stake_lockup_custodian_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_lockup_custodian_args", level++ );
  fd_stake_lockup_walk( w, &self->lockup, fun, "lockup", level );
  fd_sol_sysvar_clock_walk( w, &self->clock, fun, "clock", level );
  if( !self->custodian ) {
    fun( w, NULL, "custodian", FD_FLAMENCO_TYPE_NULL, "pubkey", level );
  } else {
    fd_pubkey_walk( w, self->custodian, fun, "custodian", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_lockup_custodian_args", level-- );
}
ulong fd_stake_lockup_custodian_args_size( fd_stake_lockup_custodian_args_t const * self ) {
  ulong size = 0;
  size += fd_stake_lockup_size( &self->lockup );
  size += fd_sol_sysvar_clock_size( &self->clock );
  size += sizeof(char);
  if( NULL !=  self->custodian ) {
    size += fd_pubkey_size( self->custodian );
  }
  return size;
}

FD_FN_PURE uchar fd_stake_authorize_is_staker(fd_stake_authorize_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_stake_authorize_is_withdrawer(fd_stake_authorize_t const * self) {
  return self->discriminant == 1;
}
void fd_stake_authorize_inner_new( fd_stake_authorize_inner_t * self, uint discriminant );
int fd_stake_authorize_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_stake_authorize_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_authorize_t);
  void const * start_data = ctx->data;
  int err =  fd_stake_authorize_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_authorize_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_stake_authorize_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_stake_authorize_inner_decode_inner( fd_stake_authorize_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  }
}
void fd_stake_authorize_inner_decode_inner_global( fd_stake_authorize_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  }
}
int fd_stake_authorize_convert_global_to_local_inner( fd_stake_authorize_inner_global_t const * mem, fd_stake_authorize_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_authorize_convert_global_to_local( void const * global_self, fd_stake_authorize_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorize_global_t const * mem = (fd_stake_authorize_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_stake_authorize_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_stake_authorize_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorize_t * self = (fd_stake_authorize_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_stake_authorize_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_stake_authorize_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorize_t * self = (fd_stake_authorize_t *)mem;
  fd_stake_authorize_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_authorize_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_authorize_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_stake_authorize_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorize_t * self = (fd_stake_authorize_t *)mem;
  fd_stake_authorize_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_authorize_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_authorize_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_authorize_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_authorize_global_t * self = (fd_stake_authorize_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_stake_authorize_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_stake_authorize_inner_new( fd_stake_authorize_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_stake_authorize_new_disc( fd_stake_authorize_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_stake_authorize_inner_new( &self->inner, self->discriminant );
}
void fd_stake_authorize_new( fd_stake_authorize_t * self ) {
  fd_memset( self, 0, sizeof(fd_stake_authorize_t) );
  fd_stake_authorize_new_disc( self, UINT_MAX );
}
void fd_stake_authorize_inner_destroy( fd_stake_authorize_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_stake_authorize_destroy( fd_stake_authorize_t * self ) {
  fd_stake_authorize_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_stake_authorize_footprint( void ){ return FD_STAKE_AUTHORIZE_FOOTPRINT; }
ulong fd_stake_authorize_align( void ){ return FD_STAKE_AUTHORIZE_ALIGN; }

void fd_stake_authorize_walk( void * w, fd_stake_authorize_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_stake_authorize", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "staker", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "withdrawer", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_stake_authorize", level-- );
}
ulong fd_stake_authorize_size( fd_stake_authorize_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  }
  return size;
}

int fd_stake_authorize_inner_encode( fd_stake_authorize_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  return FD_BINCODE_SUCCESS;
}
int fd_stake_authorize_encode( fd_stake_authorize_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_stake_authorize_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_stake_instruction_authorize_encode( fd_stake_instruction_authorize_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorize_encode( &self->stake_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_instruction_authorize_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_instruction_authorize_t);
  void const * start_data = ctx->data;
  int err = fd_stake_instruction_authorize_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_instruction_authorize_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorize_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_instruction_authorize_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_authorize_t * self = (fd_stake_instruction_authorize_t *)mem;
  fd_stake_instruction_authorize_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_instruction_authorize_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_instruction_authorize_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_instruction_authorize_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_authorize_t * self = (fd_stake_instruction_authorize_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_stake_authorize_decode_inner( &self->stake_authorize, alloc_mem, ctx );
}
void * fd_stake_instruction_authorize_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_authorize_global_t * self = (fd_stake_instruction_authorize_global_t *)mem;
  fd_stake_instruction_authorize_new( (fd_stake_instruction_authorize_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_instruction_authorize_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_instruction_authorize_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_instruction_authorize_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_authorize_global_t * self = (fd_stake_instruction_authorize_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_stake_authorize_decode_inner_global( &self->stake_authorize, alloc_mem, ctx );
}
int fd_stake_instruction_authorize_convert_global_to_local( void const * global_self, fd_stake_instruction_authorize_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_instruction_authorize_global_t const * mem = (fd_stake_instruction_authorize_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorize_convert_global_to_local( &mem->stake_authorize, &self->stake_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_instruction_authorize_new(fd_stake_instruction_authorize_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_instruction_authorize_t) );
  fd_pubkey_new( &self->pubkey );
  fd_stake_authorize_new( &self->stake_authorize );
}
void fd_stake_instruction_authorize_destroy( fd_stake_instruction_authorize_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  fd_stake_authorize_destroy( &self->stake_authorize );
}

ulong fd_stake_instruction_authorize_footprint( void ){ return FD_STAKE_INSTRUCTION_AUTHORIZE_FOOTPRINT; }
ulong fd_stake_instruction_authorize_align( void ){ return FD_STAKE_INSTRUCTION_AUTHORIZE_ALIGN; }

void fd_stake_instruction_authorize_walk( void * w, fd_stake_instruction_authorize_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_instruction_authorize", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fd_stake_authorize_walk( w, &self->stake_authorize, fun, "stake_authorize", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_instruction_authorize", level-- );
}
ulong fd_stake_instruction_authorize_size( fd_stake_instruction_authorize_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += fd_stake_authorize_size( &self->stake_authorize );
  return size;
}

int fd_authorize_with_seed_args_encode( fd_authorize_with_seed_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->new_authorized_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorize_encode( &self->stake_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->authority_seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->authority_seed_len ) {
    err = fd_bincode_bytes_encode( self->authority_seed, self->authority_seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->authority_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_authorize_with_seed_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_authorize_with_seed_args_t);
  void const * start_data = ctx->data;
  int err = fd_authorize_with_seed_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_authorize_with_seed_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorize_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong authority_seed_len;
  err = fd_bincode_uint64_decode( &authority_seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += authority_seed_len;
  if( authority_seed_len ) {
    err = fd_bincode_bytes_decode_footprint( authority_seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - authority_seed_len, authority_seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_authorize_with_seed_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_with_seed_args_t * self = (fd_authorize_with_seed_args_t *)mem;
  fd_authorize_with_seed_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_authorize_with_seed_args_t);
  void * * alloc_mem = &alloc_region;
  fd_authorize_with_seed_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_authorize_with_seed_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_with_seed_args_t * self = (fd_authorize_with_seed_args_t *)struct_mem;
  fd_pubkey_decode_inner( &self->new_authorized_pubkey, alloc_mem, ctx );
  fd_stake_authorize_decode_inner( &self->stake_authorize, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->authority_seed_len, ctx );
  if( self->authority_seed_len ) {
    self->authority_seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->authority_seed, self->authority_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->authority_seed_len;
  } else
    self->authority_seed = NULL;
  fd_pubkey_decode_inner( &self->authority_owner, alloc_mem, ctx );
}
void * fd_authorize_with_seed_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_with_seed_args_global_t * self = (fd_authorize_with_seed_args_global_t *)mem;
  fd_authorize_with_seed_args_new( (fd_authorize_with_seed_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_authorize_with_seed_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_authorize_with_seed_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_authorize_with_seed_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_with_seed_args_global_t * self = (fd_authorize_with_seed_args_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->new_authorized_pubkey, alloc_mem, ctx );
  fd_stake_authorize_decode_inner_global( &self->stake_authorize, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->authority_seed_len, ctx );
  if( self->authority_seed_len ) {
    self->authority_seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->authority_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->authority_seed_len;
  } else
    self->authority_seed_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->authority_owner, alloc_mem, ctx );
}
int fd_authorize_with_seed_args_convert_global_to_local( void const * global_self, fd_authorize_with_seed_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_authorize_with_seed_args_global_t const * mem = (fd_authorize_with_seed_args_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->new_authorized_pubkey, &self->new_authorized_pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorize_convert_global_to_local( &mem->stake_authorize, &self->stake_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->authority_seed_len = mem->authority_seed_len;
  self->authority_seed     = fd_wksp_laddr_fast( ctx->wksp, mem->authority_seed_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->authority_owner, &self->authority_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_authorize_with_seed_args_new(fd_authorize_with_seed_args_t * self) {
  fd_memset( self, 0, sizeof(fd_authorize_with_seed_args_t) );
  fd_pubkey_new( &self->new_authorized_pubkey );
  fd_stake_authorize_new( &self->stake_authorize );
  fd_pubkey_new( &self->authority_owner );
}
void fd_authorize_with_seed_args_destroy( fd_authorize_with_seed_args_t * self ) {
  fd_pubkey_destroy( &self->new_authorized_pubkey );
  fd_stake_authorize_destroy( &self->stake_authorize );
  if( self->authority_seed ) {
    self->authority_seed = NULL;
  }
  fd_pubkey_destroy( &self->authority_owner );
}

ulong fd_authorize_with_seed_args_footprint( void ){ return FD_AUTHORIZE_WITH_SEED_ARGS_FOOTPRINT; }
ulong fd_authorize_with_seed_args_align( void ){ return FD_AUTHORIZE_WITH_SEED_ARGS_ALIGN; }

void fd_authorize_with_seed_args_walk( void * w, fd_authorize_with_seed_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_authorize_with_seed_args", level++ );
  fd_pubkey_walk( w, &self->new_authorized_pubkey, fun, "new_authorized_pubkey", level );
  fd_stake_authorize_walk( w, &self->stake_authorize, fun, "stake_authorize", level );
  fun(w, self->authority_seed, "authority_seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->authority_owner, fun, "authority_owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_authorize_with_seed_args", level-- );
}
ulong fd_authorize_with_seed_args_size( fd_authorize_with_seed_args_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->new_authorized_pubkey );
  size += fd_stake_authorize_size( &self->stake_authorize );
  do {
    size += sizeof(ulong);
    size += self->authority_seed_len;
  } while(0);
  size += fd_pubkey_size( &self->authority_owner );
  return size;
}

int fd_authorize_checked_with_seed_args_encode( fd_authorize_checked_with_seed_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stake_authorize_encode( &self->stake_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->authority_seed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->authority_seed_len ) {
    err = fd_bincode_bytes_encode( self->authority_seed, self->authority_seed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_pubkey_encode( &self->authority_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_authorize_checked_with_seed_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_authorize_checked_with_seed_args_t);
  void const * start_data = ctx->data;
  int err = fd_authorize_checked_with_seed_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_authorize_checked_with_seed_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stake_authorize_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong authority_seed_len;
  err = fd_bincode_uint64_decode( &authority_seed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += authority_seed_len;
  if( authority_seed_len ) {
    err = fd_bincode_bytes_decode_footprint( authority_seed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - authority_seed_len, authority_seed_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_authorize_checked_with_seed_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_checked_with_seed_args_t * self = (fd_authorize_checked_with_seed_args_t *)mem;
  fd_authorize_checked_with_seed_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_authorize_checked_with_seed_args_t);
  void * * alloc_mem = &alloc_region;
  fd_authorize_checked_with_seed_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_authorize_checked_with_seed_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_checked_with_seed_args_t * self = (fd_authorize_checked_with_seed_args_t *)struct_mem;
  fd_stake_authorize_decode_inner( &self->stake_authorize, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->authority_seed_len, ctx );
  if( self->authority_seed_len ) {
    self->authority_seed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->authority_seed, self->authority_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->authority_seed_len;
  } else
    self->authority_seed = NULL;
  fd_pubkey_decode_inner( &self->authority_owner, alloc_mem, ctx );
}
void * fd_authorize_checked_with_seed_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_checked_with_seed_args_global_t * self = (fd_authorize_checked_with_seed_args_global_t *)mem;
  fd_authorize_checked_with_seed_args_new( (fd_authorize_checked_with_seed_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_authorize_checked_with_seed_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_authorize_checked_with_seed_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_authorize_checked_with_seed_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_authorize_checked_with_seed_args_global_t * self = (fd_authorize_checked_with_seed_args_global_t *)struct_mem;
  fd_stake_authorize_decode_inner_global( &self->stake_authorize, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->authority_seed_len, ctx );
  if( self->authority_seed_len ) {
    self->authority_seed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->authority_seed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->authority_seed_len;
  } else
    self->authority_seed_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->authority_owner, alloc_mem, ctx );
}
int fd_authorize_checked_with_seed_args_convert_global_to_local( void const * global_self, fd_authorize_checked_with_seed_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_authorize_checked_with_seed_args_global_t const * mem = (fd_authorize_checked_with_seed_args_global_t const *)global_self;
  err = fd_stake_authorize_convert_global_to_local( &mem->stake_authorize, &self->stake_authorize, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->authority_seed_len = mem->authority_seed_len;
  self->authority_seed     = fd_wksp_laddr_fast( ctx->wksp, mem->authority_seed_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->authority_owner, &self->authority_owner, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_authorize_checked_with_seed_args_new(fd_authorize_checked_with_seed_args_t * self) {
  fd_memset( self, 0, sizeof(fd_authorize_checked_with_seed_args_t) );
  fd_stake_authorize_new( &self->stake_authorize );
  fd_pubkey_new( &self->authority_owner );
}
void fd_authorize_checked_with_seed_args_destroy( fd_authorize_checked_with_seed_args_t * self ) {
  fd_stake_authorize_destroy( &self->stake_authorize );
  if( self->authority_seed ) {
    self->authority_seed = NULL;
  }
  fd_pubkey_destroy( &self->authority_owner );
}

ulong fd_authorize_checked_with_seed_args_footprint( void ){ return FD_AUTHORIZE_CHECKED_WITH_SEED_ARGS_FOOTPRINT; }
ulong fd_authorize_checked_with_seed_args_align( void ){ return FD_AUTHORIZE_CHECKED_WITH_SEED_ARGS_ALIGN; }

void fd_authorize_checked_with_seed_args_walk( void * w, fd_authorize_checked_with_seed_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_authorize_checked_with_seed_args", level++ );
  fd_stake_authorize_walk( w, &self->stake_authorize, fun, "stake_authorize", level );
  fun(w, self->authority_seed, "authority_seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->authority_owner, fun, "authority_owner", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_authorize_checked_with_seed_args", level-- );
}
ulong fd_authorize_checked_with_seed_args_size( fd_authorize_checked_with_seed_args_t const * self ) {
  ulong size = 0;
  size += fd_stake_authorize_size( &self->stake_authorize );
  do {
    size += sizeof(ulong);
    size += self->authority_seed_len;
  } while(0);
  size += fd_pubkey_size( &self->authority_owner );
  return size;
}

int fd_lockup_checked_args_encode( fd_lockup_checked_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->unix_timestamp != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_int64_encode( self->unix_timestamp[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  if( self->epoch != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_uint64_encode( self->epoch[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_lockup_checked_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_lockup_checked_args_t);
  void const * start_data = ctx->data;
  int err = fd_lockup_checked_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_lockup_checked_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(long);
      err = fd_bincode_int64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(ulong);
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_lockup_checked_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_checked_args_t * self = (fd_lockup_checked_args_t *)mem;
  fd_lockup_checked_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lockup_checked_args_t);
  void * * alloc_mem = &alloc_region;
  fd_lockup_checked_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_lockup_checked_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_checked_args_t * self = (fd_lockup_checked_args_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->unix_timestamp = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(long);
      fd_bincode_int64_decode_unsafe( self->unix_timestamp, ctx );
    } else {
      self->unix_timestamp = NULL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->epoch = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
      fd_bincode_uint64_decode_unsafe( self->epoch, ctx );
    } else {
      self->epoch = NULL;
    }
  }
}
void * fd_lockup_checked_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_checked_args_global_t * self = (fd_lockup_checked_args_global_t *)mem;
  fd_lockup_checked_args_new( (fd_lockup_checked_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lockup_checked_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_lockup_checked_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_lockup_checked_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_checked_args_global_t * self = (fd_lockup_checked_args_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->unix_timestamp_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_int64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(long);
    } else {
      self->unix_timestamp_gaddr = 0UL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->epoch_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_uint64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
    } else {
      self->epoch_gaddr = 0UL;
    }
  }
}
int fd_lockup_checked_args_convert_global_to_local( void const * global_self, fd_lockup_checked_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_lockup_checked_args_global_t const * mem = (fd_lockup_checked_args_global_t const *)global_self;
  self->unix_timestamp = fd_wksp_laddr_fast( ctx->wksp, mem->unix_timestamp_gaddr );
  self->epoch = fd_wksp_laddr_fast( ctx->wksp, mem->epoch_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_lockup_checked_args_new(fd_lockup_checked_args_t * self) {
  fd_memset( self, 0, sizeof(fd_lockup_checked_args_t) );
}
void fd_lockup_checked_args_destroy( fd_lockup_checked_args_t * self ) {
  if( self->unix_timestamp ) {
    self->unix_timestamp = NULL;
  }
  if( self->epoch ) {
    self->epoch = NULL;
  }
}

ulong fd_lockup_checked_args_footprint( void ){ return FD_LOCKUP_CHECKED_ARGS_FOOTPRINT; }
ulong fd_lockup_checked_args_align( void ){ return FD_LOCKUP_CHECKED_ARGS_ALIGN; }

void fd_lockup_checked_args_walk( void * w, fd_lockup_checked_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_lockup_checked_args", level++ );
  if( !self->unix_timestamp ) {
    fun( w, NULL, "unix_timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, self->unix_timestamp, "unix_timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  if( !self->epoch ) {
    fun( w, NULL, "epoch", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_lockup_checked_args", level-- );
}
ulong fd_lockup_checked_args_size( fd_lockup_checked_args_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( NULL !=  self->unix_timestamp ) {
    size += sizeof(long);
  }
  size += sizeof(char);
  if( NULL !=  self->epoch ) {
    size += sizeof(ulong);
  }
  return size;
}

int fd_lockup_args_encode( fd_lockup_args_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->unix_timestamp != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_int64_encode( self->unix_timestamp[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  if( self->epoch != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_uint64_encode( self->epoch[0], ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  if( self->custodian != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_pubkey_encode( self->custodian, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_lockup_args_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_lockup_args_t);
  void const * start_data = ctx->data;
  int err = fd_lockup_args_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_lockup_args_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(long);
      err = fd_bincode_int64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += 8UL + sizeof(ulong);
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT;
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_lockup_args_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_args_t * self = (fd_lockup_args_t *)mem;
  fd_lockup_args_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lockup_args_t);
  void * * alloc_mem = &alloc_region;
  fd_lockup_args_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_lockup_args_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_args_t * self = (fd_lockup_args_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->unix_timestamp = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(long);
      fd_bincode_int64_decode_unsafe( self->unix_timestamp, ctx );
    } else {
      self->unix_timestamp = NULL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->epoch = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
      fd_bincode_uint64_decode_unsafe( self->epoch, ctx );
    } else {
      self->epoch = NULL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->custodian = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_new( self->custodian );
      fd_pubkey_decode_inner( self->custodian, alloc_mem, ctx );
    } else {
      self->custodian = NULL;
    }
  }
}
void * fd_lockup_args_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_args_global_t * self = (fd_lockup_args_global_t *)mem;
  fd_lockup_args_new( (fd_lockup_args_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lockup_args_global_t);
  void * * alloc_mem = &alloc_region;
  fd_lockup_args_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_lockup_args_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lockup_args_global_t * self = (fd_lockup_args_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->unix_timestamp_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_int64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(long);
    } else {
      self->unix_timestamp_gaddr = 0UL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, 8UL );
      self->epoch_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_bincode_uint64_decode_unsafe( *alloc_mem, ctx );
      *alloc_mem = (uchar *)*alloc_mem + sizeof(ulong);
    } else {
      self->epoch_gaddr = 0UL;
    }
  }
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->custodian_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_pubkey_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->custodian_gaddr ), alloc_mem, ctx );
    } else {
      self->custodian_gaddr = 0UL;
    }
  }
}
int fd_lockup_args_convert_global_to_local( void const * global_self, fd_lockup_args_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_lockup_args_global_t const * mem = (fd_lockup_args_global_t const *)global_self;
  self->unix_timestamp = fd_wksp_laddr_fast( ctx->wksp, mem->unix_timestamp_gaddr );
  self->epoch = fd_wksp_laddr_fast( ctx->wksp, mem->epoch_gaddr );
  self->custodian = fd_wksp_laddr_fast( ctx->wksp, mem->custodian_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_lockup_args_new(fd_lockup_args_t * self) {
  fd_memset( self, 0, sizeof(fd_lockup_args_t) );
}
void fd_lockup_args_destroy( fd_lockup_args_t * self ) {
  if( self->unix_timestamp ) {
    self->unix_timestamp = NULL;
  }
  if( self->epoch ) {
    self->epoch = NULL;
  }
  if( self->custodian ) {
    fd_pubkey_destroy( self->custodian );
    self->custodian = NULL;
  }
}

ulong fd_lockup_args_footprint( void ){ return FD_LOCKUP_ARGS_FOOTPRINT; }
ulong fd_lockup_args_align( void ){ return FD_LOCKUP_ARGS_ALIGN; }

void fd_lockup_args_walk( void * w, fd_lockup_args_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_lockup_args", level++ );
  if( !self->unix_timestamp ) {
    fun( w, NULL, "unix_timestamp", FD_FLAMENCO_TYPE_NULL, "long", level );
  } else {
    fun( w, self->unix_timestamp, "unix_timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  }
  if( !self->epoch ) {
    fun( w, NULL, "epoch", FD_FLAMENCO_TYPE_NULL, "ulong", level );
  } else {
    fun( w, self->epoch, "epoch", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  }
  if( !self->custodian ) {
    fun( w, NULL, "custodian", FD_FLAMENCO_TYPE_NULL, "pubkey", level );
  } else {
    fd_pubkey_walk( w, self->custodian, fun, "custodian", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_lockup_args", level-- );
}
ulong fd_lockup_args_size( fd_lockup_args_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( NULL !=  self->unix_timestamp ) {
    size += sizeof(long);
  }
  size += sizeof(char);
  if( NULL !=  self->epoch ) {
    size += sizeof(ulong);
  }
  size += sizeof(char);
  if( NULL !=  self->custodian ) {
    size += fd_pubkey_size( self->custodian );
  }
  return size;
}

FD_FN_PURE uchar fd_stake_instruction_is_initialize(fd_stake_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_stake_instruction_is_authorize(fd_stake_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_stake_instruction_is_delegate_stake(fd_stake_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_stake_instruction_is_split(fd_stake_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_stake_instruction_is_withdraw(fd_stake_instruction_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_stake_instruction_is_deactivate(fd_stake_instruction_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_stake_instruction_is_set_lockup(fd_stake_instruction_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_stake_instruction_is_merge(fd_stake_instruction_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_stake_instruction_is_authorize_with_seed(fd_stake_instruction_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_stake_instruction_is_initialize_checked(fd_stake_instruction_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_stake_instruction_is_authorize_checked(fd_stake_instruction_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_stake_instruction_is_authorize_checked_with_seed(fd_stake_instruction_t const * self) {
  return self->discriminant == 11;
}
FD_FN_PURE uchar fd_stake_instruction_is_set_lockup_checked(fd_stake_instruction_t const * self) {
  return self->discriminant == 12;
}
FD_FN_PURE uchar fd_stake_instruction_is_get_minimum_delegation(fd_stake_instruction_t const * self) {
  return self->discriminant == 13;
}
FD_FN_PURE uchar fd_stake_instruction_is_deactivate_delinquent(fd_stake_instruction_t const * self) {
  return self->discriminant == 14;
}
FD_FN_PURE uchar fd_stake_instruction_is_redelegate(fd_stake_instruction_t const * self) {
  return self->discriminant == 15;
}
FD_FN_PURE uchar fd_stake_instruction_is_move_stake(fd_stake_instruction_t const * self) {
  return self->discriminant == 16;
}
FD_FN_PURE uchar fd_stake_instruction_is_move_lamports(fd_stake_instruction_t const * self) {
  return self->discriminant == 17;
}
void fd_stake_instruction_inner_new( fd_stake_instruction_inner_t * self, uint discriminant );
int fd_stake_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_stake_instruction_initialize_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_stake_instruction_authorize_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    err = fd_lockup_args_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    err = fd_authorize_with_seed_args_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    err = fd_stake_authorize_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    err = fd_authorize_checked_with_seed_args_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 12: {
    err = fd_lockup_checked_args_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 13: {
    return FD_BINCODE_SUCCESS;
  }
  case 14: {
    return FD_BINCODE_SUCCESS;
  }
  case 15: {
    return FD_BINCODE_SUCCESS;
  }
  case 16: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 17: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_stake_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_stake_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_stake_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_stake_instruction_inner_decode_inner( fd_stake_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_stake_instruction_initialize_decode_inner( &self->initialize, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_stake_instruction_authorize_decode_inner( &self->authorize, alloc_mem, ctx );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    fd_bincode_uint64_decode_unsafe( &self->split, ctx );
    break;
  }
  case 4: {
    fd_bincode_uint64_decode_unsafe( &self->withdraw, ctx );
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_lockup_args_decode_inner( &self->set_lockup, alloc_mem, ctx );
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    fd_authorize_with_seed_args_decode_inner( &self->authorize_with_seed, alloc_mem, ctx );
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    fd_stake_authorize_decode_inner( &self->authorize_checked, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_authorize_checked_with_seed_args_decode_inner( &self->authorize_checked_with_seed, alloc_mem, ctx );
    break;
  }
  case 12: {
    fd_lockup_checked_args_decode_inner( &self->set_lockup_checked, alloc_mem, ctx );
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    fd_bincode_uint64_decode_unsafe( &self->move_stake, ctx );
    break;
  }
  case 17: {
    fd_bincode_uint64_decode_unsafe( &self->move_lamports, ctx );
    break;
  }
  }
}
void fd_stake_instruction_inner_decode_inner_global( fd_stake_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_stake_instruction_initialize_decode_inner_global( &self->initialize, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_stake_instruction_authorize_decode_inner_global( &self->authorize, alloc_mem, ctx );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    fd_bincode_uint64_decode_unsafe( &self->split, ctx );
    break;
  }
  case 4: {
    fd_bincode_uint64_decode_unsafe( &self->withdraw, ctx );
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_lockup_args_decode_inner_global( &self->set_lockup, alloc_mem, ctx );
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    fd_authorize_with_seed_args_decode_inner_global( &self->authorize_with_seed, alloc_mem, ctx );
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    fd_stake_authorize_decode_inner_global( &self->authorize_checked, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_authorize_checked_with_seed_args_decode_inner_global( &self->authorize_checked_with_seed, alloc_mem, ctx );
    break;
  }
  case 12: {
    fd_lockup_checked_args_decode_inner_global( &self->set_lockup_checked, alloc_mem, ctx );
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    fd_bincode_uint64_decode_unsafe( &self->move_stake, ctx );
    break;
  }
  case 17: {
    fd_bincode_uint64_decode_unsafe( &self->move_lamports, ctx );
    break;
  }
  }
}
int fd_stake_instruction_convert_global_to_local_inner( fd_stake_instruction_inner_global_t const * mem, fd_stake_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_stake_instruction_initialize_convert_global_to_local( &mem->initialize, &self->initialize, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_stake_instruction_authorize_convert_global_to_local( &mem->authorize, &self->authorize, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    self->split = mem->split;
    break;
  }
  case 4: {
    self->withdraw = mem->withdraw;
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    err = fd_lockup_args_convert_global_to_local( &mem->set_lockup, &self->set_lockup, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    err = fd_authorize_with_seed_args_convert_global_to_local( &mem->authorize_with_seed, &self->authorize_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    err = fd_stake_authorize_convert_global_to_local( &mem->authorize_checked, &self->authorize_checked, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_authorize_checked_with_seed_args_convert_global_to_local( &mem->authorize_checked_with_seed, &self->authorize_checked_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    err = fd_lockup_checked_args_convert_global_to_local( &mem->set_lockup_checked, &self->set_lockup_checked, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    self->move_stake = mem->move_stake;
    break;
  }
  case 17: {
    self->move_lamports = mem->move_lamports;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_instruction_convert_global_to_local( void const * global_self, fd_stake_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_global_t const * mem = (fd_stake_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_stake_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_stake_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_t * self = (fd_stake_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_stake_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_stake_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_t * self = (fd_stake_instruction_t *)mem;
  fd_stake_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_stake_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_t * self = (fd_stake_instruction_t *)mem;
  fd_stake_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_instruction_global_t * self = (fd_stake_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_stake_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_stake_instruction_inner_new( fd_stake_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_stake_instruction_initialize_new( &self->initialize );
    break;
  }
  case 1: {
    fd_stake_instruction_authorize_new( &self->authorize );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_lockup_args_new( &self->set_lockup );
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    fd_authorize_with_seed_args_new( &self->authorize_with_seed );
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    fd_stake_authorize_new( &self->authorize_checked );
    break;
  }
  case 11: {
    fd_authorize_checked_with_seed_args_new( &self->authorize_checked_with_seed );
    break;
  }
  case 12: {
    fd_lockup_checked_args_new( &self->set_lockup_checked );
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_stake_instruction_new_disc( fd_stake_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_stake_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_stake_instruction_new( fd_stake_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_stake_instruction_t) );
  fd_stake_instruction_new_disc( self, UINT_MAX );
}
void fd_stake_instruction_inner_destroy( fd_stake_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_stake_instruction_initialize_destroy( &self->initialize );
    break;
  }
  case 1: {
    fd_stake_instruction_authorize_destroy( &self->authorize );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 6: {
    fd_lockup_args_destroy( &self->set_lockup );
    break;
  }
  case 8: {
    fd_authorize_with_seed_args_destroy( &self->authorize_with_seed );
    break;
  }
  case 10: {
    fd_stake_authorize_destroy( &self->authorize_checked );
    break;
  }
  case 11: {
    fd_authorize_checked_with_seed_args_destroy( &self->authorize_checked_with_seed );
    break;
  }
  case 12: {
    fd_lockup_checked_args_destroy( &self->set_lockup_checked );
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_stake_instruction_destroy( fd_stake_instruction_t * self ) {
  fd_stake_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_stake_instruction_footprint( void ){ return FD_STAKE_INSTRUCTION_FOOTPRINT; }
ulong fd_stake_instruction_align( void ){ return FD_STAKE_INSTRUCTION_ALIGN; }

void fd_stake_instruction_walk( void * w, fd_stake_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_stake_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "initialize", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_stake_instruction_initialize_walk( w, &self->inner.initialize, fun, "initialize", level );
    break;
  }
  case 1: {
    fun( w, self, "authorize", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_stake_instruction_authorize_walk( w, &self->inner.authorize, fun, "authorize", level );
    break;
  }
  case 2: {
    fun( w, self, "delegate_stake", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "split", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.split, "split", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 4: {
    fun( w, self, "withdraw", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.withdraw, "withdraw", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 5: {
    fun( w, self, "deactivate", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 6: {
    fun( w, self, "set_lockup", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_lockup_args_walk( w, &self->inner.set_lockup, fun, "set_lockup", level );
    break;
  }
  case 7: {
    fun( w, self, "merge", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 8: {
    fun( w, self, "authorize_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_authorize_with_seed_args_walk( w, &self->inner.authorize_with_seed, fun, "authorize_with_seed", level );
    break;
  }
  case 9: {
    fun( w, self, "initialize_checked", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 10: {
    fun( w, self, "authorize_checked", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_stake_authorize_walk( w, &self->inner.authorize_checked, fun, "authorize_checked", level );
    break;
  }
  case 11: {
    fun( w, self, "authorize_checked_with_seed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_authorize_checked_with_seed_args_walk( w, &self->inner.authorize_checked_with_seed, fun, "authorize_checked_with_seed", level );
    break;
  }
  case 12: {
    fun( w, self, "set_lockup_checked", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_lockup_checked_args_walk( w, &self->inner.set_lockup_checked, fun, "set_lockup_checked", level );
    break;
  }
  case 13: {
    fun( w, self, "get_minimum_delegation", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 14: {
    fun( w, self, "deactivate_delinquent", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 15: {
    fun( w, self, "redelegate", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 16: {
    fun( w, self, "move_stake", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.move_stake, "move_stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 17: {
    fun( w, self, "move_lamports", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.move_lamports, "move_lamports", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_stake_instruction", level-- );
}
ulong fd_stake_instruction_size( fd_stake_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_stake_instruction_initialize_size( &self->inner.initialize );
    break;
  }
  case 1: {
    size += fd_stake_instruction_authorize_size( &self->inner.authorize );
    break;
  }
  case 3: {
    size += sizeof(ulong);
    break;
  }
  case 4: {
    size += sizeof(ulong);
    break;
  }
  case 6: {
    size += fd_lockup_args_size( &self->inner.set_lockup );
    break;
  }
  case 8: {
    size += fd_authorize_with_seed_args_size( &self->inner.authorize_with_seed );
    break;
  }
  case 10: {
    size += fd_stake_authorize_size( &self->inner.authorize_checked );
    break;
  }
  case 11: {
    size += fd_authorize_checked_with_seed_args_size( &self->inner.authorize_checked_with_seed );
    break;
  }
  case 12: {
    size += fd_lockup_checked_args_size( &self->inner.set_lockup_checked );
    break;
  }
  case 16: {
    size += sizeof(ulong);
    break;
  }
  case 17: {
    size += sizeof(ulong);
    break;
  }
  }
  return size;
}

int fd_stake_instruction_inner_encode( fd_stake_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_stake_instruction_initialize_encode( &self->initialize, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_stake_instruction_authorize_encode( &self->authorize, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_bincode_uint64_encode( self->split, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    err = fd_bincode_uint64_encode( self->withdraw, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 6: {
    err = fd_lockup_args_encode( &self->set_lockup, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_authorize_with_seed_args_encode( &self->authorize_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_stake_authorize_encode( &self->authorize_checked, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_authorize_checked_with_seed_args_encode( &self->authorize_checked_with_seed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    err = fd_lockup_checked_args_encode( &self->set_lockup_checked, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 16: {
    err = fd_bincode_uint64_encode( self->move_stake, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 17: {
    err = fd_bincode_uint64_encode( self->move_lamports, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_instruction_encode( fd_stake_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_stake_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_stake_meta_encode( fd_stake_meta_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->rent_exempt_reserve, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_authorized_encode( &self->authorized, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_lockup_encode( &self->lockup, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_meta_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_meta_t);
  void const * start_data = ctx->data;
  int err = fd_stake_meta_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_meta_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_stake_authorized_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_lockup_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_meta_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_meta_t * self = (fd_stake_meta_t *)mem;
  fd_stake_meta_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_meta_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_meta_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_meta_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_meta_t * self = (fd_stake_meta_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->rent_exempt_reserve, ctx );
  fd_stake_authorized_decode_inner( &self->authorized, alloc_mem, ctx );
  fd_stake_lockup_decode_inner( &self->lockup, alloc_mem, ctx );
}
void * fd_stake_meta_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_meta_global_t * self = (fd_stake_meta_global_t *)mem;
  fd_stake_meta_new( (fd_stake_meta_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_meta_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_meta_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_meta_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_meta_global_t * self = (fd_stake_meta_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->rent_exempt_reserve, ctx );
  fd_stake_authorized_decode_inner_global( &self->authorized, alloc_mem, ctx );
  fd_stake_lockup_decode_inner_global( &self->lockup, alloc_mem, ctx );
}
int fd_stake_meta_convert_global_to_local( void const * global_self, fd_stake_meta_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_meta_global_t const * mem = (fd_stake_meta_global_t const *)global_self;
  self->rent_exempt_reserve = mem->rent_exempt_reserve;
  err = fd_stake_authorized_convert_global_to_local( &mem->authorized, &self->authorized, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_lockup_convert_global_to_local( &mem->lockup, &self->lockup, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_meta_new(fd_stake_meta_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_meta_t) );
  fd_stake_authorized_new( &self->authorized );
  fd_stake_lockup_new( &self->lockup );
}
void fd_stake_meta_destroy( fd_stake_meta_t * self ) {
  fd_stake_authorized_destroy( &self->authorized );
  fd_stake_lockup_destroy( &self->lockup );
}

ulong fd_stake_meta_footprint( void ){ return FD_STAKE_META_FOOTPRINT; }
ulong fd_stake_meta_align( void ){ return FD_STAKE_META_ALIGN; }

void fd_stake_meta_walk( void * w, fd_stake_meta_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_meta", level++ );
  fun( w, &self->rent_exempt_reserve, "rent_exempt_reserve", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_stake_authorized_walk( w, &self->authorized, fun, "authorized", level );
  fd_stake_lockup_walk( w, &self->lockup, fun, "lockup", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_meta", level-- );
}
ulong fd_stake_meta_size( fd_stake_meta_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_stake_authorized_size( &self->authorized );
  size += fd_stake_lockup_size( &self->lockup );
  return size;
}

int fd_stake_flags_encode( fd_stake_flags_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->bits), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_flags_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_flags_t);
  void const * start_data = ctx->data;
  int err = fd_stake_flags_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_flags_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_flags_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_flags_t * self = (fd_stake_flags_t *)mem;
  fd_stake_flags_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_flags_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_flags_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_flags_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_flags_t * self = (fd_stake_flags_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->bits, ctx );
}
void * fd_stake_flags_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_flags_global_t * self = (fd_stake_flags_global_t *)mem;
  fd_stake_flags_new( (fd_stake_flags_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_flags_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_flags_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_flags_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_flags_global_t * self = (fd_stake_flags_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->bits, ctx );
}
int fd_stake_flags_convert_global_to_local( void const * global_self, fd_stake_flags_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_flags_global_t const * mem = (fd_stake_flags_global_t const *)global_self;
  self->bits = mem->bits;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_flags_new(fd_stake_flags_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_flags_t) );
}
void fd_stake_flags_destroy( fd_stake_flags_t * self ) {
}

ulong fd_stake_flags_footprint( void ){ return FD_STAKE_FLAGS_FOOTPRINT; }
ulong fd_stake_flags_align( void ){ return FD_STAKE_FLAGS_ALIGN; }

void fd_stake_flags_walk( void * w, fd_stake_flags_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_flags", level++ );
  fun( w, &self->bits, "bits", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_flags", level-- );
}
ulong fd_stake_flags_size( fd_stake_flags_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  return size;
}

int fd_stake_state_v2_initialized_encode( fd_stake_state_v2_initialized_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stake_meta_encode( &self->meta, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_state_v2_initialized_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_state_v2_initialized_t);
  void const * start_data = ctx->data;
  int err = fd_stake_state_v2_initialized_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_state_v2_initialized_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stake_meta_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_state_v2_initialized_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_initialized_t * self = (fd_stake_state_v2_initialized_t *)mem;
  fd_stake_state_v2_initialized_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_state_v2_initialized_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_state_v2_initialized_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_state_v2_initialized_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_initialized_t * self = (fd_stake_state_v2_initialized_t *)struct_mem;
  fd_stake_meta_decode_inner( &self->meta, alloc_mem, ctx );
}
void * fd_stake_state_v2_initialized_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_initialized_global_t * self = (fd_stake_state_v2_initialized_global_t *)mem;
  fd_stake_state_v2_initialized_new( (fd_stake_state_v2_initialized_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_state_v2_initialized_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_state_v2_initialized_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_state_v2_initialized_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_initialized_global_t * self = (fd_stake_state_v2_initialized_global_t *)struct_mem;
  fd_stake_meta_decode_inner_global( &self->meta, alloc_mem, ctx );
}
int fd_stake_state_v2_initialized_convert_global_to_local( void const * global_self, fd_stake_state_v2_initialized_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_state_v2_initialized_global_t const * mem = (fd_stake_state_v2_initialized_global_t const *)global_self;
  err = fd_stake_meta_convert_global_to_local( &mem->meta, &self->meta, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_state_v2_initialized_new(fd_stake_state_v2_initialized_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_state_v2_initialized_t) );
  fd_stake_meta_new( &self->meta );
}
void fd_stake_state_v2_initialized_destroy( fd_stake_state_v2_initialized_t * self ) {
  fd_stake_meta_destroy( &self->meta );
}

ulong fd_stake_state_v2_initialized_footprint( void ){ return FD_STAKE_STATE_V2_INITIALIZED_FOOTPRINT; }
ulong fd_stake_state_v2_initialized_align( void ){ return FD_STAKE_STATE_V2_INITIALIZED_ALIGN; }

void fd_stake_state_v2_initialized_walk( void * w, fd_stake_state_v2_initialized_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_state_v2_initialized", level++ );
  fd_stake_meta_walk( w, &self->meta, fun, "meta", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_state_v2_initialized", level-- );
}
ulong fd_stake_state_v2_initialized_size( fd_stake_state_v2_initialized_t const * self ) {
  ulong size = 0;
  size += fd_stake_meta_size( &self->meta );
  return size;
}

int fd_stake_state_v2_stake_encode( fd_stake_state_v2_stake_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_stake_meta_encode( &self->meta, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_encode( &self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_flags_encode( &self->stake_flags, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_stake_state_v2_stake_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_state_v2_stake_t);
  void const * start_data = ctx->data;
  int err = fd_stake_state_v2_stake_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_state_v2_stake_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_stake_meta_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_flags_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_stake_state_v2_stake_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_stake_t * self = (fd_stake_state_v2_stake_t *)mem;
  fd_stake_state_v2_stake_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_state_v2_stake_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_state_v2_stake_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_state_v2_stake_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_stake_t * self = (fd_stake_state_v2_stake_t *)struct_mem;
  fd_stake_meta_decode_inner( &self->meta, alloc_mem, ctx );
  fd_stake_decode_inner( &self->stake, alloc_mem, ctx );
  fd_stake_flags_decode_inner( &self->stake_flags, alloc_mem, ctx );
}
void * fd_stake_state_v2_stake_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_stake_global_t * self = (fd_stake_state_v2_stake_global_t *)mem;
  fd_stake_state_v2_stake_new( (fd_stake_state_v2_stake_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_state_v2_stake_global_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_state_v2_stake_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_state_v2_stake_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_stake_global_t * self = (fd_stake_state_v2_stake_global_t *)struct_mem;
  fd_stake_meta_decode_inner_global( &self->meta, alloc_mem, ctx );
  fd_stake_decode_inner_global( &self->stake, alloc_mem, ctx );
  fd_stake_flags_decode_inner_global( &self->stake_flags, alloc_mem, ctx );
}
int fd_stake_state_v2_stake_convert_global_to_local( void const * global_self, fd_stake_state_v2_stake_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_stake_state_v2_stake_global_t const * mem = (fd_stake_state_v2_stake_global_t const *)global_self;
  err = fd_stake_meta_convert_global_to_local( &mem->meta, &self->meta, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_convert_global_to_local( &mem->stake, &self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_flags_convert_global_to_local( &mem->stake_flags, &self->stake_flags, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_stake_state_v2_stake_new(fd_stake_state_v2_stake_t * self) {
  fd_memset( self, 0, sizeof(fd_stake_state_v2_stake_t) );
  fd_stake_meta_new( &self->meta );
  fd_stake_new( &self->stake );
  fd_stake_flags_new( &self->stake_flags );
}
void fd_stake_state_v2_stake_destroy( fd_stake_state_v2_stake_t * self ) {
  fd_stake_meta_destroy( &self->meta );
  fd_stake_destroy( &self->stake );
  fd_stake_flags_destroy( &self->stake_flags );
}

ulong fd_stake_state_v2_stake_footprint( void ){ return FD_STAKE_STATE_V2_STAKE_FOOTPRINT; }
ulong fd_stake_state_v2_stake_align( void ){ return FD_STAKE_STATE_V2_STAKE_ALIGN; }

void fd_stake_state_v2_stake_walk( void * w, fd_stake_state_v2_stake_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_stake_state_v2_stake", level++ );
  fd_stake_meta_walk( w, &self->meta, fun, "meta", level );
  fd_stake_walk( w, &self->stake, fun, "stake", level );
  fd_stake_flags_walk( w, &self->stake_flags, fun, "stake_flags", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_stake_state_v2_stake", level-- );
}
ulong fd_stake_state_v2_stake_size( fd_stake_state_v2_stake_t const * self ) {
  ulong size = 0;
  size += fd_stake_meta_size( &self->meta );
  size += fd_stake_size( &self->stake );
  size += fd_stake_flags_size( &self->stake_flags );
  return size;
}

FD_FN_PURE uchar fd_stake_state_v2_is_uninitialized(fd_stake_state_v2_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_stake_state_v2_is_initialized(fd_stake_state_v2_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_stake_state_v2_is_stake(fd_stake_state_v2_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_stake_state_v2_is_rewards_pool(fd_stake_state_v2_t const * self) {
  return self->discriminant == 3;
}
void fd_stake_state_v2_inner_new( fd_stake_state_v2_inner_t * self, uint discriminant );
int fd_stake_state_v2_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_stake_state_v2_initialized_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_stake_state_v2_stake_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_stake_state_v2_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_stake_state_v2_t);
  void const * start_data = ctx->data;
  int err =  fd_stake_state_v2_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_stake_state_v2_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_stake_state_v2_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_stake_state_v2_inner_decode_inner( fd_stake_state_v2_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_stake_state_v2_initialized_decode_inner( &self->initialized, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_stake_state_v2_stake_decode_inner( &self->stake, alloc_mem, ctx );
    break;
  }
  case 3: {
    break;
  }
  }
}
void fd_stake_state_v2_inner_decode_inner_global( fd_stake_state_v2_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_stake_state_v2_initialized_decode_inner_global( &self->initialized, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_stake_state_v2_stake_decode_inner_global( &self->stake, alloc_mem, ctx );
    break;
  }
  case 3: {
    break;
  }
  }
}
int fd_stake_state_v2_convert_global_to_local_inner( fd_stake_state_v2_inner_global_t const * mem, fd_stake_state_v2_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_stake_state_v2_initialized_convert_global_to_local( &mem->initialized, &self->initialized, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_stake_state_v2_stake_convert_global_to_local( &mem->stake, &self->stake, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_state_v2_convert_global_to_local( void const * global_self, fd_stake_state_v2_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_global_t const * mem = (fd_stake_state_v2_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_stake_state_v2_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_stake_state_v2_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_t * self = (fd_stake_state_v2_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_stake_state_v2_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_stake_state_v2_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_t * self = (fd_stake_state_v2_t *)mem;
  fd_stake_state_v2_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_state_v2_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_state_v2_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_stake_state_v2_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_t * self = (fd_stake_state_v2_t *)mem;
  fd_stake_state_v2_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_stake_state_v2_t);
  void * * alloc_mem = &alloc_region;
  fd_stake_state_v2_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_stake_state_v2_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_stake_state_v2_global_t * self = (fd_stake_state_v2_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_stake_state_v2_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_stake_state_v2_inner_new( fd_stake_state_v2_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_stake_state_v2_initialized_new( &self->initialized );
    break;
  }
  case 2: {
    fd_stake_state_v2_stake_new( &self->stake );
    break;
  }
  case 3: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_stake_state_v2_new_disc( fd_stake_state_v2_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_stake_state_v2_inner_new( &self->inner, self->discriminant );
}
void fd_stake_state_v2_new( fd_stake_state_v2_t * self ) {
  fd_memset( self, 0, sizeof(fd_stake_state_v2_t) );
  fd_stake_state_v2_new_disc( self, UINT_MAX );
}
void fd_stake_state_v2_inner_destroy( fd_stake_state_v2_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_stake_state_v2_initialized_destroy( &self->initialized );
    break;
  }
  case 2: {
    fd_stake_state_v2_stake_destroy( &self->stake );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_stake_state_v2_destroy( fd_stake_state_v2_t * self ) {
  fd_stake_state_v2_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_stake_state_v2_footprint( void ){ return FD_STAKE_STATE_V2_FOOTPRINT; }
ulong fd_stake_state_v2_align( void ){ return FD_STAKE_STATE_V2_ALIGN; }

void fd_stake_state_v2_walk( void * w, fd_stake_state_v2_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_stake_state_v2", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "uninitialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "initialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_stake_state_v2_initialized_walk( w, &self->inner.initialized, fun, "initialized", level );
    break;
  }
  case 2: {
    fun( w, self, "stake", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_stake_state_v2_stake_walk( w, &self->inner.stake, fun, "stake", level );
    break;
  }
  case 3: {
    fun( w, self, "rewards_pool", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_stake_state_v2", level-- );
}
ulong fd_stake_state_v2_size( fd_stake_state_v2_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_stake_state_v2_initialized_size( &self->inner.initialized );
    break;
  }
  case 2: {
    size += fd_stake_state_v2_stake_size( &self->inner.stake );
    break;
  }
  }
  return size;
}

int fd_stake_state_v2_inner_encode( fd_stake_state_v2_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_stake_state_v2_initialized_encode( &self->initialized, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_stake_state_v2_stake_encode( &self->stake, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_stake_state_v2_encode( fd_stake_state_v2_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_stake_state_v2_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_nonce_data_encode( fd_nonce_data_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->authority, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->durable_nonce, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_encode( &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_nonce_data_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_nonce_data_t);
  void const * start_data = ctx->data;
  int err = fd_nonce_data_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_nonce_data_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_nonce_data_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_data_t * self = (fd_nonce_data_t *)mem;
  fd_nonce_data_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_nonce_data_t);
  void * * alloc_mem = &alloc_region;
  fd_nonce_data_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_nonce_data_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_data_t * self = (fd_nonce_data_t *)struct_mem;
  fd_pubkey_decode_inner( &self->authority, alloc_mem, ctx );
  fd_hash_decode_inner( &self->durable_nonce, alloc_mem, ctx );
  fd_fee_calculator_decode_inner( &self->fee_calculator, alloc_mem, ctx );
}
void * fd_nonce_data_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_data_global_t * self = (fd_nonce_data_global_t *)mem;
  fd_nonce_data_new( (fd_nonce_data_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_nonce_data_global_t);
  void * * alloc_mem = &alloc_region;
  fd_nonce_data_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_nonce_data_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_data_global_t * self = (fd_nonce_data_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->authority, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->durable_nonce, alloc_mem, ctx );
  fd_fee_calculator_decode_inner_global( &self->fee_calculator, alloc_mem, ctx );
}
int fd_nonce_data_convert_global_to_local( void const * global_self, fd_nonce_data_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_nonce_data_global_t const * mem = (fd_nonce_data_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->authority, &self->authority, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->durable_nonce, &self->durable_nonce, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_fee_calculator_convert_global_to_local( &mem->fee_calculator, &self->fee_calculator, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_nonce_data_new(fd_nonce_data_t * self) {
  fd_memset( self, 0, sizeof(fd_nonce_data_t) );
  fd_pubkey_new( &self->authority );
  fd_hash_new( &self->durable_nonce );
  fd_fee_calculator_new( &self->fee_calculator );
}
void fd_nonce_data_destroy( fd_nonce_data_t * self ) {
  fd_pubkey_destroy( &self->authority );
  fd_hash_destroy( &self->durable_nonce );
  fd_fee_calculator_destroy( &self->fee_calculator );
}

ulong fd_nonce_data_footprint( void ){ return FD_NONCE_DATA_FOOTPRINT; }
ulong fd_nonce_data_align( void ){ return FD_NONCE_DATA_ALIGN; }

void fd_nonce_data_walk( void * w, fd_nonce_data_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_nonce_data", level++ );
  fd_pubkey_walk( w, &self->authority, fun, "authority", level );
  fd_hash_walk( w, &self->durable_nonce, fun, "durable_nonce", level );
  fd_fee_calculator_walk( w, &self->fee_calculator, fun, "fee_calculator", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_nonce_data", level-- );
}
ulong fd_nonce_data_size( fd_nonce_data_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->authority );
  size += fd_hash_size( &self->durable_nonce );
  size += fd_fee_calculator_size( &self->fee_calculator );
  return size;
}

FD_FN_PURE uchar fd_nonce_state_is_uninitialized(fd_nonce_state_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_nonce_state_is_initialized(fd_nonce_state_t const * self) {
  return self->discriminant == 1;
}
void fd_nonce_state_inner_new( fd_nonce_state_inner_t * self, uint discriminant );
int fd_nonce_state_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_nonce_data_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_nonce_state_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_nonce_state_t);
  void const * start_data = ctx->data;
  int err =  fd_nonce_state_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_nonce_state_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_nonce_state_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_nonce_state_inner_decode_inner( fd_nonce_state_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_nonce_data_decode_inner( &self->initialized, alloc_mem, ctx );
    break;
  }
  }
}
void fd_nonce_state_inner_decode_inner_global( fd_nonce_state_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_nonce_data_decode_inner_global( &self->initialized, alloc_mem, ctx );
    break;
  }
  }
}
int fd_nonce_state_convert_global_to_local_inner( fd_nonce_state_inner_global_t const * mem, fd_nonce_state_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_nonce_data_convert_global_to_local( &mem->initialized, &self->initialized, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_nonce_state_convert_global_to_local( void const * global_self, fd_nonce_state_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_global_t const * mem = (fd_nonce_state_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_nonce_state_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_nonce_state_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_t * self = (fd_nonce_state_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_nonce_state_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_nonce_state_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_t * self = (fd_nonce_state_t *)mem;
  fd_nonce_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_nonce_state_t);
  void * * alloc_mem = &alloc_region;
  fd_nonce_state_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_nonce_state_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_t * self = (fd_nonce_state_t *)mem;
  fd_nonce_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_nonce_state_t);
  void * * alloc_mem = &alloc_region;
  fd_nonce_state_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_nonce_state_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_global_t * self = (fd_nonce_state_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_nonce_state_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_nonce_state_inner_new( fd_nonce_state_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_nonce_data_new( &self->initialized );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_nonce_state_new_disc( fd_nonce_state_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_nonce_state_inner_new( &self->inner, self->discriminant );
}
void fd_nonce_state_new( fd_nonce_state_t * self ) {
  fd_memset( self, 0, sizeof(fd_nonce_state_t) );
  fd_nonce_state_new_disc( self, UINT_MAX );
}
void fd_nonce_state_inner_destroy( fd_nonce_state_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_nonce_data_destroy( &self->initialized );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_nonce_state_destroy( fd_nonce_state_t * self ) {
  fd_nonce_state_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_nonce_state_footprint( void ){ return FD_NONCE_STATE_FOOTPRINT; }
ulong fd_nonce_state_align( void ){ return FD_NONCE_STATE_ALIGN; }

void fd_nonce_state_walk( void * w, fd_nonce_state_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_nonce_state", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "uninitialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "initialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_nonce_data_walk( w, &self->inner.initialized, fun, "initialized", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_nonce_state", level-- );
}
ulong fd_nonce_state_size( fd_nonce_state_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_nonce_data_size( &self->inner.initialized );
    break;
  }
  }
  return size;
}

int fd_nonce_state_inner_encode( fd_nonce_state_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_nonce_data_encode( &self->initialized, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_nonce_state_encode( fd_nonce_state_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_nonce_state_inner_encode( &self->inner, self->discriminant, ctx );
}

FD_FN_PURE uchar fd_nonce_state_versions_is_legacy(fd_nonce_state_versions_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_nonce_state_versions_is_current(fd_nonce_state_versions_t const * self) {
  return self->discriminant == 1;
}
void fd_nonce_state_versions_inner_new( fd_nonce_state_versions_inner_t * self, uint discriminant );
int fd_nonce_state_versions_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_nonce_state_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_nonce_state_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_nonce_state_versions_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_nonce_state_versions_t);
  void const * start_data = ctx->data;
  int err =  fd_nonce_state_versions_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_nonce_state_versions_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_nonce_state_versions_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_nonce_state_versions_inner_decode_inner( fd_nonce_state_versions_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_nonce_state_decode_inner( &self->legacy, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_nonce_state_decode_inner( &self->current, alloc_mem, ctx );
    break;
  }
  }
}
void fd_nonce_state_versions_inner_decode_inner_global( fd_nonce_state_versions_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_nonce_state_decode_inner_global( &self->legacy, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_nonce_state_decode_inner_global( &self->current, alloc_mem, ctx );
    break;
  }
  }
}
int fd_nonce_state_versions_convert_global_to_local_inner( fd_nonce_state_versions_inner_global_t const * mem, fd_nonce_state_versions_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_nonce_state_convert_global_to_local( &mem->legacy, &self->legacy, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_nonce_state_convert_global_to_local( &mem->current, &self->current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_nonce_state_versions_convert_global_to_local( void const * global_self, fd_nonce_state_versions_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_versions_global_t const * mem = (fd_nonce_state_versions_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_nonce_state_versions_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_nonce_state_versions_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_versions_t * self = (fd_nonce_state_versions_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_nonce_state_versions_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_nonce_state_versions_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_versions_t * self = (fd_nonce_state_versions_t *)mem;
  fd_nonce_state_versions_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_nonce_state_versions_t);
  void * * alloc_mem = &alloc_region;
  fd_nonce_state_versions_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_nonce_state_versions_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_versions_t * self = (fd_nonce_state_versions_t *)mem;
  fd_nonce_state_versions_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_nonce_state_versions_t);
  void * * alloc_mem = &alloc_region;
  fd_nonce_state_versions_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_nonce_state_versions_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_nonce_state_versions_global_t * self = (fd_nonce_state_versions_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_nonce_state_versions_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_nonce_state_versions_inner_new( fd_nonce_state_versions_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_nonce_state_new( &self->legacy );
    break;
  }
  case 1: {
    fd_nonce_state_new( &self->current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_nonce_state_versions_new_disc( fd_nonce_state_versions_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_nonce_state_versions_inner_new( &self->inner, self->discriminant );
}
void fd_nonce_state_versions_new( fd_nonce_state_versions_t * self ) {
  fd_memset( self, 0, sizeof(fd_nonce_state_versions_t) );
  fd_nonce_state_versions_new_disc( self, UINT_MAX );
}
void fd_nonce_state_versions_inner_destroy( fd_nonce_state_versions_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_nonce_state_destroy( &self->legacy );
    break;
  }
  case 1: {
    fd_nonce_state_destroy( &self->current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_nonce_state_versions_destroy( fd_nonce_state_versions_t * self ) {
  fd_nonce_state_versions_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_nonce_state_versions_footprint( void ){ return FD_NONCE_STATE_VERSIONS_FOOTPRINT; }
ulong fd_nonce_state_versions_align( void ){ return FD_NONCE_STATE_VERSIONS_ALIGN; }

void fd_nonce_state_versions_walk( void * w, fd_nonce_state_versions_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_nonce_state_versions", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "legacy", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_nonce_state_walk( w, &self->inner.legacy, fun, "legacy", level );
    break;
  }
  case 1: {
    fun( w, self, "current", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_nonce_state_walk( w, &self->inner.current, fun, "current", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_nonce_state_versions", level-- );
}
ulong fd_nonce_state_versions_size( fd_nonce_state_versions_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_nonce_state_size( &self->inner.legacy );
    break;
  }
  case 1: {
    size += fd_nonce_state_size( &self->inner.current );
    break;
  }
  }
  return size;
}

int fd_nonce_state_versions_inner_encode( fd_nonce_state_versions_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_nonce_state_encode( &self->legacy, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_nonce_state_encode( &self->current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_nonce_state_versions_encode( fd_nonce_state_versions_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_nonce_state_versions_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_compute_budget_program_instruction_request_units_deprecated_encode( fd_compute_budget_program_instruction_request_units_deprecated_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint32_encode( self->units, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->additional_fee, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_compute_budget_program_instruction_request_units_deprecated_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_compute_budget_program_instruction_request_units_deprecated_t);
  void const * start_data = ctx->data;
  int err = fd_compute_budget_program_instruction_request_units_deprecated_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_compute_budget_program_instruction_request_units_deprecated_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_compute_budget_program_instruction_request_units_deprecated_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_request_units_deprecated_t * self = (fd_compute_budget_program_instruction_request_units_deprecated_t *)mem;
  fd_compute_budget_program_instruction_request_units_deprecated_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compute_budget_program_instruction_request_units_deprecated_t);
  void * * alloc_mem = &alloc_region;
  fd_compute_budget_program_instruction_request_units_deprecated_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_compute_budget_program_instruction_request_units_deprecated_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_request_units_deprecated_t * self = (fd_compute_budget_program_instruction_request_units_deprecated_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->units, ctx );
  fd_bincode_uint32_decode_unsafe( &self->additional_fee, ctx );
}
void * fd_compute_budget_program_instruction_request_units_deprecated_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_request_units_deprecated_global_t * self = (fd_compute_budget_program_instruction_request_units_deprecated_global_t *)mem;
  fd_compute_budget_program_instruction_request_units_deprecated_new( (fd_compute_budget_program_instruction_request_units_deprecated_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compute_budget_program_instruction_request_units_deprecated_global_t);
  void * * alloc_mem = &alloc_region;
  fd_compute_budget_program_instruction_request_units_deprecated_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_compute_budget_program_instruction_request_units_deprecated_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_request_units_deprecated_global_t * self = (fd_compute_budget_program_instruction_request_units_deprecated_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->units, ctx );
  fd_bincode_uint32_decode_unsafe( &self->additional_fee, ctx );
}
int fd_compute_budget_program_instruction_request_units_deprecated_convert_global_to_local( void const * global_self, fd_compute_budget_program_instruction_request_units_deprecated_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_compute_budget_program_instruction_request_units_deprecated_global_t const * mem = (fd_compute_budget_program_instruction_request_units_deprecated_global_t const *)global_self;
  self->units = mem->units;
  self->additional_fee = mem->additional_fee;
  return FD_BINCODE_SUCCESS;
}
void fd_compute_budget_program_instruction_request_units_deprecated_new(fd_compute_budget_program_instruction_request_units_deprecated_t * self) {
  fd_memset( self, 0, sizeof(fd_compute_budget_program_instruction_request_units_deprecated_t) );
}
void fd_compute_budget_program_instruction_request_units_deprecated_destroy( fd_compute_budget_program_instruction_request_units_deprecated_t * self ) {
}

ulong fd_compute_budget_program_instruction_request_units_deprecated_footprint( void ){ return FD_COMPUTE_BUDGET_PROGRAM_INSTRUCTION_REQUEST_UNITS_DEPRECATED_FOOTPRINT; }
ulong fd_compute_budget_program_instruction_request_units_deprecated_align( void ){ return FD_COMPUTE_BUDGET_PROGRAM_INSTRUCTION_REQUEST_UNITS_DEPRECATED_ALIGN; }

void fd_compute_budget_program_instruction_request_units_deprecated_walk( void * w, fd_compute_budget_program_instruction_request_units_deprecated_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_compute_budget_program_instruction_request_units_deprecated", level++ );
  fun( w, &self->units, "units", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, &self->additional_fee, "additional_fee", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_compute_budget_program_instruction_request_units_deprecated", level-- );
}
ulong fd_compute_budget_program_instruction_request_units_deprecated_size( fd_compute_budget_program_instruction_request_units_deprecated_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  size += sizeof(uint);
  return size;
}

FD_FN_PURE uchar fd_compute_budget_program_instruction_is_request_units_deprecated(fd_compute_budget_program_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_compute_budget_program_instruction_is_request_heap_frame(fd_compute_budget_program_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_compute_budget_program_instruction_is_set_compute_unit_limit(fd_compute_budget_program_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_compute_budget_program_instruction_is_set_compute_unit_price(fd_compute_budget_program_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_compute_budget_program_instruction_is_set_loaded_accounts_data_size_limit(fd_compute_budget_program_instruction_t const * self) {
  return self->discriminant == 4;
}
void fd_compute_budget_program_instruction_inner_new( fd_compute_budget_program_instruction_inner_t * self, uint discriminant );
int fd_compute_budget_program_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_compute_budget_program_instruction_request_units_deprecated_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_bincode_uint64_decode_footprint( ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_compute_budget_program_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_compute_budget_program_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_compute_budget_program_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_compute_budget_program_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ushort discriminant = 0;
  int err = fd_bincode_compact_u16_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_compute_budget_program_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_compute_budget_program_instruction_inner_decode_inner( fd_compute_budget_program_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_compute_budget_program_instruction_request_units_deprecated_decode_inner( &self->request_units_deprecated, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_bincode_uint32_decode_unsafe( &self->request_heap_frame, ctx );
    break;
  }
  case 2: {
    fd_bincode_uint32_decode_unsafe( &self->set_compute_unit_limit, ctx );
    break;
  }
  case 3: {
    fd_bincode_uint64_decode_unsafe( &self->set_compute_unit_price, ctx );
    break;
  }
  case 4: {
    fd_bincode_uint32_decode_unsafe( &self->set_loaded_accounts_data_size_limit, ctx );
    break;
  }
  }
}
void fd_compute_budget_program_instruction_inner_decode_inner_global( fd_compute_budget_program_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_compute_budget_program_instruction_request_units_deprecated_decode_inner_global( &self->request_units_deprecated, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_bincode_uint32_decode_unsafe( &self->request_heap_frame, ctx );
    break;
  }
  case 2: {
    fd_bincode_uint32_decode_unsafe( &self->set_compute_unit_limit, ctx );
    break;
  }
  case 3: {
    fd_bincode_uint64_decode_unsafe( &self->set_compute_unit_price, ctx );
    break;
  }
  case 4: {
    fd_bincode_uint32_decode_unsafe( &self->set_loaded_accounts_data_size_limit, ctx );
    break;
  }
  }
}
int fd_compute_budget_program_instruction_convert_global_to_local_inner( fd_compute_budget_program_instruction_inner_global_t const * mem, fd_compute_budget_program_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_compute_budget_program_instruction_request_units_deprecated_convert_global_to_local( &mem->request_units_deprecated, &self->request_units_deprecated, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    self->request_heap_frame = mem->request_heap_frame;
    break;
  }
  case 2: {
    self->set_compute_unit_limit = mem->set_compute_unit_limit;
    break;
  }
  case 3: {
    self->set_compute_unit_price = mem->set_compute_unit_price;
    break;
  }
  case 4: {
    self->set_loaded_accounts_data_size_limit = mem->set_loaded_accounts_data_size_limit;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_compute_budget_program_instruction_convert_global_to_local( void const * global_self, fd_compute_budget_program_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_global_t const * mem = (fd_compute_budget_program_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_compute_budget_program_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_compute_budget_program_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_t * self = (fd_compute_budget_program_instruction_t *)struct_mem;
  ushort tmp = 0;
  fd_bincode_compact_u16_decode_unsafe( &tmp, ctx );
  self->discriminant = tmp;
  fd_compute_budget_program_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_compute_budget_program_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_t * self = (fd_compute_budget_program_instruction_t *)mem;
  fd_compute_budget_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compute_budget_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_compute_budget_program_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_compute_budget_program_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_t * self = (fd_compute_budget_program_instruction_t *)mem;
  fd_compute_budget_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_compute_budget_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_compute_budget_program_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_compute_budget_program_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_compute_budget_program_instruction_global_t * self = (fd_compute_budget_program_instruction_global_t *)struct_mem;
  ushort tmp = 0;
  fd_bincode_compact_u16_decode_unsafe( &tmp, ctx );
  self->discriminant = tmp;
  fd_compute_budget_program_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_compute_budget_program_instruction_inner_new( fd_compute_budget_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_compute_budget_program_instruction_request_units_deprecated_new( &self->request_units_deprecated );
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_compute_budget_program_instruction_new_disc( fd_compute_budget_program_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_compute_budget_program_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_compute_budget_program_instruction_new( fd_compute_budget_program_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_compute_budget_program_instruction_t) );
  fd_compute_budget_program_instruction_new_disc( self, UINT_MAX );
}
void fd_compute_budget_program_instruction_inner_destroy( fd_compute_budget_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_compute_budget_program_instruction_request_units_deprecated_destroy( &self->request_units_deprecated );
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_compute_budget_program_instruction_destroy( fd_compute_budget_program_instruction_t * self ) {
  fd_compute_budget_program_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_compute_budget_program_instruction_footprint( void ){ return FD_COMPUTE_BUDGET_PROGRAM_INSTRUCTION_FOOTPRINT; }
ulong fd_compute_budget_program_instruction_align( void ){ return FD_COMPUTE_BUDGET_PROGRAM_INSTRUCTION_ALIGN; }

void fd_compute_budget_program_instruction_walk( void * w, fd_compute_budget_program_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_compute_budget_program_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "request_units_deprecated", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_compute_budget_program_instruction_request_units_deprecated_walk( w, &self->inner.request_units_deprecated, fun, "request_units_deprecated", level );
    break;
  }
  case 1: {
    fun( w, self, "request_heap_frame", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.request_heap_frame, "request_heap_frame", FD_FLAMENCO_TYPE_UINT, "uint", level );
    break;
  }
  case 2: {
    fun( w, self, "set_compute_unit_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.set_compute_unit_limit, "set_compute_unit_limit", FD_FLAMENCO_TYPE_UINT, "uint", level );
    break;
  }
  case 3: {
    fun( w, self, "set_compute_unit_price", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.set_compute_unit_price, "set_compute_unit_price", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
    break;
  }
  case 4: {
    fun( w, self, "set_loaded_accounts_data_size_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.set_loaded_accounts_data_size_limit, "set_loaded_accounts_data_size_limit", FD_FLAMENCO_TYPE_UINT, "uint", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_compute_budget_program_instruction", level-- );
}
ulong fd_compute_budget_program_instruction_size( fd_compute_budget_program_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_compute_budget_program_instruction_request_units_deprecated_size( &self->inner.request_units_deprecated );
    break;
  }
  case 1: {
    size += sizeof(uint);
    break;
  }
  case 2: {
    size += sizeof(uint);
    break;
  }
  case 3: {
    size += sizeof(ulong);
    break;
  }
  case 4: {
    size += sizeof(uint);
    break;
  }
  }
  return size;
}

int fd_compute_budget_program_instruction_inner_encode( fd_compute_budget_program_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_compute_budget_program_instruction_request_units_deprecated_encode( &self->request_units_deprecated, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_bincode_uint32_encode( self->request_heap_frame, ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_bincode_uint32_encode( self->set_compute_unit_limit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_bincode_uint64_encode( self->set_compute_unit_price, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    err = fd_bincode_uint32_encode( self->set_loaded_accounts_data_size_limit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_compute_budget_program_instruction_encode( fd_compute_budget_program_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_compute_budget_program_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_config_keys_encode( fd_config_keys_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_compact_u16_encode( &self->keys_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->keys_len ) {
    for( ulong i=0; i < self->keys_len; i++ ) {
      err = fd_config_keys_pair_encode( self->keys + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_config_keys_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_config_keys_t);
  void const * start_data = ctx->data;
  int err = fd_config_keys_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_config_keys_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ushort keys_len;
  err = fd_bincode_compact_u16_decode( &keys_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( keys_len ) {
    *total_sz += FD_CONFIG_KEYS_PAIR_ALIGN + FD_CONFIG_KEYS_PAIR_FOOTPRINT*keys_len;
    for( ulong i=0; i < keys_len; i++ ) {
      err = fd_config_keys_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_config_keys_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_t * self = (fd_config_keys_t *)mem;
  fd_config_keys_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_config_keys_t);
  void * * alloc_mem = &alloc_region;
  fd_config_keys_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_config_keys_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_t * self = (fd_config_keys_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->keys_len, ctx );
  if( self->keys_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CONFIG_KEYS_PAIR_ALIGN );
    self->keys = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CONFIG_KEYS_PAIR_FOOTPRINT*self->keys_len;
    for( ulong i=0; i < self->keys_len; i++ ) {
      fd_config_keys_pair_new( self->keys + i );
      fd_config_keys_pair_decode_inner( self->keys + i, alloc_mem, ctx );
    }
  } else
    self->keys = NULL;
}
void * fd_config_keys_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_global_t * self = (fd_config_keys_global_t *)mem;
  fd_config_keys_new( (fd_config_keys_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_config_keys_global_t);
  void * * alloc_mem = &alloc_region;
  fd_config_keys_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_config_keys_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_config_keys_global_t * self = (fd_config_keys_global_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->keys_len, ctx );
  if( self->keys_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CONFIG_KEYS_PAIR_ALIGN );
    self->keys_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CONFIG_KEYS_PAIR_FOOTPRINT*self->keys_len;
    for( ulong i=0; i < self->keys_len; i++ ) {
      fd_config_keys_pair_new( (fd_config_keys_pair_t *)(cur_mem + FD_CONFIG_KEYS_PAIR_FOOTPRINT * i) );
      fd_config_keys_pair_decode_inner_global( cur_mem + FD_CONFIG_KEYS_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->keys_gaddr = 0UL;
}
int fd_config_keys_convert_global_to_local( void const * global_self, fd_config_keys_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_config_keys_global_t const * mem = (fd_config_keys_global_t const *)global_self;
  self->keys_len = mem->keys_len;
  self->keys     = fd_wksp_laddr_fast( ctx->wksp, mem->keys_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_config_keys_new(fd_config_keys_t * self) {
  fd_memset( self, 0, sizeof(fd_config_keys_t) );
}
void fd_config_keys_destroy( fd_config_keys_t * self ) {
  if( self->keys ) {
    for( ulong i=0; i < self->keys_len; i++ )
      fd_config_keys_pair_destroy( self->keys + i );
    self->keys = NULL;
  }
}

ulong fd_config_keys_footprint( void ){ return FD_CONFIG_KEYS_FOOTPRINT; }
ulong fd_config_keys_align( void ){ return FD_CONFIG_KEYS_ALIGN; }

void fd_config_keys_walk( void * w, fd_config_keys_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_config_keys", level++ );
  if( self->keys_len ) {
    fun( w, NULL, "keys", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->keys_len; i++ )
      fd_config_keys_pair_walk(w, self->keys + i, fun, "config_keys_pair", level );
    fun( w, NULL, "keys", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_config_keys", level-- );
}
ulong fd_config_keys_size( fd_config_keys_t const * self ) {
  ulong size = 0;
  do {
    ushort tmp = (ushort)self->keys_len;
    size += fd_bincode_compact_u16_size( &tmp );
    for( ulong i=0; i < self->keys_len; i++ )
      size += fd_config_keys_pair_size( self->keys + i );
  } while(0);
  return size;
}

int fd_bpf_loader_program_instruction_write_encode( fd_bpf_loader_program_instruction_write_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint32_encode( self->offset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->bytes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->bytes_len ) {
    err = fd_bincode_bytes_encode( self->bytes, self->bytes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_loader_program_instruction_write_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_loader_program_instruction_write_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_loader_program_instruction_write_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_loader_program_instruction_write_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong bytes_len;
  err = fd_bincode_uint64_decode( &bytes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( bytes_len ) {
    *total_sz += 8UL + bytes_len;
    err = fd_bincode_bytes_decode_footprint( bytes_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_bpf_loader_program_instruction_write_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_write_t * self = (fd_bpf_loader_program_instruction_write_t *)mem;
  fd_bpf_loader_program_instruction_write_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_loader_program_instruction_write_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_loader_program_instruction_write_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_loader_program_instruction_write_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_write_t * self = (fd_bpf_loader_program_instruction_write_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint64_decode_unsafe( &self->bytes_len, ctx );
  if( self->bytes_len ) {
    self->bytes = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->bytes, self->bytes_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bytes_len;
  } else
    self->bytes = NULL;
}
void * fd_bpf_loader_program_instruction_write_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_write_global_t * self = (fd_bpf_loader_program_instruction_write_global_t *)mem;
  fd_bpf_loader_program_instruction_write_new( (fd_bpf_loader_program_instruction_write_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_loader_program_instruction_write_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_loader_program_instruction_write_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_loader_program_instruction_write_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_write_global_t * self = (fd_bpf_loader_program_instruction_write_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint64_decode_unsafe( &self->bytes_len, ctx );
  if( self->bytes_len ) {
    self->bytes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->bytes_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bytes_len;
  } else
    self->bytes_gaddr = 0UL;
}
int fd_bpf_loader_program_instruction_write_convert_global_to_local( void const * global_self, fd_bpf_loader_program_instruction_write_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_loader_program_instruction_write_global_t const * mem = (fd_bpf_loader_program_instruction_write_global_t const *)global_self;
  self->offset = mem->offset;
  self->bytes_len = mem->bytes_len;
  self->bytes     = fd_wksp_laddr_fast( ctx->wksp, mem->bytes_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_loader_program_instruction_write_new(fd_bpf_loader_program_instruction_write_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_loader_program_instruction_write_t) );
}
void fd_bpf_loader_program_instruction_write_destroy( fd_bpf_loader_program_instruction_write_t * self ) {
  if( self->bytes ) {
    self->bytes = NULL;
  }
}

ulong fd_bpf_loader_program_instruction_write_footprint( void ){ return FD_BPF_LOADER_PROGRAM_INSTRUCTION_WRITE_FOOTPRINT; }
ulong fd_bpf_loader_program_instruction_write_align( void ){ return FD_BPF_LOADER_PROGRAM_INSTRUCTION_WRITE_ALIGN; }

void fd_bpf_loader_program_instruction_write_walk( void * w, fd_bpf_loader_program_instruction_write_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_loader_program_instruction_write", level++ );
  fun( w, &self->offset, "offset", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun(w, self->bytes, "bytes", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_loader_program_instruction_write", level-- );
}
ulong fd_bpf_loader_program_instruction_write_size( fd_bpf_loader_program_instruction_write_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  do {
    size += sizeof(ulong);
    size += self->bytes_len;
  } while(0);
  return size;
}

FD_FN_PURE uchar fd_bpf_loader_program_instruction_is_write(fd_bpf_loader_program_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_bpf_loader_program_instruction_is_finalize(fd_bpf_loader_program_instruction_t const * self) {
  return self->discriminant == 1;
}
void fd_bpf_loader_program_instruction_inner_new( fd_bpf_loader_program_instruction_inner_t * self, uint discriminant );
int fd_bpf_loader_program_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_bpf_loader_program_instruction_write_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_bpf_loader_program_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_loader_program_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_bpf_loader_program_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_loader_program_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_bpf_loader_program_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_bpf_loader_program_instruction_inner_decode_inner( fd_bpf_loader_program_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_bpf_loader_program_instruction_write_decode_inner( &self->write, alloc_mem, ctx );
    break;
  }
  case 1: {
    break;
  }
  }
}
void fd_bpf_loader_program_instruction_inner_decode_inner_global( fd_bpf_loader_program_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_bpf_loader_program_instruction_write_decode_inner_global( &self->write, alloc_mem, ctx );
    break;
  }
  case 1: {
    break;
  }
  }
}
int fd_bpf_loader_program_instruction_convert_global_to_local_inner( fd_bpf_loader_program_instruction_inner_global_t const * mem, fd_bpf_loader_program_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_bpf_loader_program_instruction_write_convert_global_to_local( &mem->write, &self->write, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_loader_program_instruction_convert_global_to_local( void const * global_self, fd_bpf_loader_program_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_global_t const * mem = (fd_bpf_loader_program_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_bpf_loader_program_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_loader_program_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_t * self = (fd_bpf_loader_program_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_bpf_loader_program_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_bpf_loader_program_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_t * self = (fd_bpf_loader_program_instruction_t *)mem;
  fd_bpf_loader_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_loader_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_loader_program_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_bpf_loader_program_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_t * self = (fd_bpf_loader_program_instruction_t *)mem;
  fd_bpf_loader_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_loader_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_loader_program_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_loader_program_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_loader_program_instruction_global_t * self = (fd_bpf_loader_program_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_bpf_loader_program_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_bpf_loader_program_instruction_inner_new( fd_bpf_loader_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_bpf_loader_program_instruction_write_new( &self->write );
    break;
  }
  case 1: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_bpf_loader_program_instruction_new_disc( fd_bpf_loader_program_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_bpf_loader_program_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_bpf_loader_program_instruction_new( fd_bpf_loader_program_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_bpf_loader_program_instruction_t) );
  fd_bpf_loader_program_instruction_new_disc( self, UINT_MAX );
}
void fd_bpf_loader_program_instruction_inner_destroy( fd_bpf_loader_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_bpf_loader_program_instruction_write_destroy( &self->write );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_bpf_loader_program_instruction_destroy( fd_bpf_loader_program_instruction_t * self ) {
  fd_bpf_loader_program_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_bpf_loader_program_instruction_footprint( void ){ return FD_BPF_LOADER_PROGRAM_INSTRUCTION_FOOTPRINT; }
ulong fd_bpf_loader_program_instruction_align( void ){ return FD_BPF_LOADER_PROGRAM_INSTRUCTION_ALIGN; }

void fd_bpf_loader_program_instruction_walk( void * w, fd_bpf_loader_program_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_bpf_loader_program_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "write", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_loader_program_instruction_write_walk( w, &self->inner.write, fun, "write", level );
    break;
  }
  case 1: {
    fun( w, self, "finalize", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_bpf_loader_program_instruction", level-- );
}
ulong fd_bpf_loader_program_instruction_size( fd_bpf_loader_program_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_bpf_loader_program_instruction_write_size( &self->inner.write );
    break;
  }
  }
  return size;
}

int fd_bpf_loader_program_instruction_inner_encode( fd_bpf_loader_program_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_bpf_loader_program_instruction_write_encode( &self->write, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_loader_program_instruction_encode( fd_bpf_loader_program_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_bpf_loader_program_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_loader_v4_program_instruction_write_encode( fd_loader_v4_program_instruction_write_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint32_encode( self->offset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->bytes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->bytes_len ) {
    err = fd_bincode_bytes_encode( self->bytes, self->bytes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_loader_v4_program_instruction_write_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_loader_v4_program_instruction_write_t);
  void const * start_data = ctx->data;
  int err = fd_loader_v4_program_instruction_write_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_loader_v4_program_instruction_write_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong bytes_len;
  err = fd_bincode_uint64_decode( &bytes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( bytes_len ) {
    *total_sz += 8UL + bytes_len;
    err = fd_bincode_bytes_decode_footprint( bytes_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_loader_v4_program_instruction_write_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_write_t * self = (fd_loader_v4_program_instruction_write_t *)mem;
  fd_loader_v4_program_instruction_write_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_program_instruction_write_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_program_instruction_write_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_program_instruction_write_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_write_t * self = (fd_loader_v4_program_instruction_write_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint64_decode_unsafe( &self->bytes_len, ctx );
  if( self->bytes_len ) {
    self->bytes = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->bytes, self->bytes_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bytes_len;
  } else
    self->bytes = NULL;
}
void * fd_loader_v4_program_instruction_write_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_write_global_t * self = (fd_loader_v4_program_instruction_write_global_t *)mem;
  fd_loader_v4_program_instruction_write_new( (fd_loader_v4_program_instruction_write_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_program_instruction_write_global_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_program_instruction_write_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_program_instruction_write_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_write_global_t * self = (fd_loader_v4_program_instruction_write_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint64_decode_unsafe( &self->bytes_len, ctx );
  if( self->bytes_len ) {
    self->bytes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->bytes_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bytes_len;
  } else
    self->bytes_gaddr = 0UL;
}
int fd_loader_v4_program_instruction_write_convert_global_to_local( void const * global_self, fd_loader_v4_program_instruction_write_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_loader_v4_program_instruction_write_global_t const * mem = (fd_loader_v4_program_instruction_write_global_t const *)global_self;
  self->offset = mem->offset;
  self->bytes_len = mem->bytes_len;
  self->bytes     = fd_wksp_laddr_fast( ctx->wksp, mem->bytes_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_loader_v4_program_instruction_write_new(fd_loader_v4_program_instruction_write_t * self) {
  fd_memset( self, 0, sizeof(fd_loader_v4_program_instruction_write_t) );
}
void fd_loader_v4_program_instruction_write_destroy( fd_loader_v4_program_instruction_write_t * self ) {
  if( self->bytes ) {
    self->bytes = NULL;
  }
}

ulong fd_loader_v4_program_instruction_write_footprint( void ){ return FD_LOADER_V4_PROGRAM_INSTRUCTION_WRITE_FOOTPRINT; }
ulong fd_loader_v4_program_instruction_write_align( void ){ return FD_LOADER_V4_PROGRAM_INSTRUCTION_WRITE_ALIGN; }

void fd_loader_v4_program_instruction_write_walk( void * w, fd_loader_v4_program_instruction_write_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_loader_v4_program_instruction_write", level++ );
  fun( w, &self->offset, "offset", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun(w, self->bytes, "bytes", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_loader_v4_program_instruction_write", level-- );
}
ulong fd_loader_v4_program_instruction_write_size( fd_loader_v4_program_instruction_write_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  do {
    size += sizeof(ulong);
    size += self->bytes_len;
  } while(0);
  return size;
}

int fd_loader_v4_program_instruction_truncate_encode( fd_loader_v4_program_instruction_truncate_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint32_encode( self->new_size, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_loader_v4_program_instruction_truncate_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_loader_v4_program_instruction_truncate_t);
  void const * start_data = ctx->data;
  int err = fd_loader_v4_program_instruction_truncate_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_loader_v4_program_instruction_truncate_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_loader_v4_program_instruction_truncate_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_truncate_t * self = (fd_loader_v4_program_instruction_truncate_t *)mem;
  fd_loader_v4_program_instruction_truncate_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_program_instruction_truncate_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_program_instruction_truncate_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_program_instruction_truncate_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_truncate_t * self = (fd_loader_v4_program_instruction_truncate_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->new_size, ctx );
}
void * fd_loader_v4_program_instruction_truncate_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_truncate_global_t * self = (fd_loader_v4_program_instruction_truncate_global_t *)mem;
  fd_loader_v4_program_instruction_truncate_new( (fd_loader_v4_program_instruction_truncate_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_program_instruction_truncate_global_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_program_instruction_truncate_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_program_instruction_truncate_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_truncate_global_t * self = (fd_loader_v4_program_instruction_truncate_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->new_size, ctx );
}
int fd_loader_v4_program_instruction_truncate_convert_global_to_local( void const * global_self, fd_loader_v4_program_instruction_truncate_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_loader_v4_program_instruction_truncate_global_t const * mem = (fd_loader_v4_program_instruction_truncate_global_t const *)global_self;
  self->new_size = mem->new_size;
  return FD_BINCODE_SUCCESS;
}
void fd_loader_v4_program_instruction_truncate_new(fd_loader_v4_program_instruction_truncate_t * self) {
  fd_memset( self, 0, sizeof(fd_loader_v4_program_instruction_truncate_t) );
}
void fd_loader_v4_program_instruction_truncate_destroy( fd_loader_v4_program_instruction_truncate_t * self ) {
}

ulong fd_loader_v4_program_instruction_truncate_footprint( void ){ return FD_LOADER_V4_PROGRAM_INSTRUCTION_TRUNCATE_FOOTPRINT; }
ulong fd_loader_v4_program_instruction_truncate_align( void ){ return FD_LOADER_V4_PROGRAM_INSTRUCTION_TRUNCATE_ALIGN; }

void fd_loader_v4_program_instruction_truncate_walk( void * w, fd_loader_v4_program_instruction_truncate_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_loader_v4_program_instruction_truncate", level++ );
  fun( w, &self->new_size, "new_size", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_loader_v4_program_instruction_truncate", level-- );
}
ulong fd_loader_v4_program_instruction_truncate_size( fd_loader_v4_program_instruction_truncate_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  return size;
}

FD_FN_PURE uchar fd_loader_v4_program_instruction_is_write(fd_loader_v4_program_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_loader_v4_program_instruction_is_truncate(fd_loader_v4_program_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_loader_v4_program_instruction_is_deploy(fd_loader_v4_program_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_loader_v4_program_instruction_is_retract(fd_loader_v4_program_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_loader_v4_program_instruction_is_transfer_authority(fd_loader_v4_program_instruction_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_loader_v4_program_instruction_is_finalize(fd_loader_v4_program_instruction_t const * self) {
  return self->discriminant == 5;
}
void fd_loader_v4_program_instruction_inner_new( fd_loader_v4_program_instruction_inner_t * self, uint discriminant );
int fd_loader_v4_program_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_loader_v4_program_instruction_write_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_loader_v4_program_instruction_truncate_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_loader_v4_program_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_loader_v4_program_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_loader_v4_program_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_loader_v4_program_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_loader_v4_program_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_loader_v4_program_instruction_inner_decode_inner( fd_loader_v4_program_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_loader_v4_program_instruction_write_decode_inner( &self->write, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_loader_v4_program_instruction_truncate_decode_inner( &self->truncate, alloc_mem, ctx );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  }
}
void fd_loader_v4_program_instruction_inner_decode_inner_global( fd_loader_v4_program_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_loader_v4_program_instruction_write_decode_inner_global( &self->write, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_loader_v4_program_instruction_truncate_decode_inner_global( &self->truncate, alloc_mem, ctx );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  }
}
int fd_loader_v4_program_instruction_convert_global_to_local_inner( fd_loader_v4_program_instruction_inner_global_t const * mem, fd_loader_v4_program_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_loader_v4_program_instruction_write_convert_global_to_local( &mem->write, &self->write, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_loader_v4_program_instruction_truncate_convert_global_to_local( &mem->truncate, &self->truncate, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_loader_v4_program_instruction_convert_global_to_local( void const * global_self, fd_loader_v4_program_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_global_t const * mem = (fd_loader_v4_program_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_loader_v4_program_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_loader_v4_program_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_t * self = (fd_loader_v4_program_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_loader_v4_program_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_loader_v4_program_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_t * self = (fd_loader_v4_program_instruction_t *)mem;
  fd_loader_v4_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_program_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_loader_v4_program_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_t * self = (fd_loader_v4_program_instruction_t *)mem;
  fd_loader_v4_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_program_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_program_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_program_instruction_global_t * self = (fd_loader_v4_program_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_loader_v4_program_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_loader_v4_program_instruction_inner_new( fd_loader_v4_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_loader_v4_program_instruction_write_new( &self->write );
    break;
  }
  case 1: {
    fd_loader_v4_program_instruction_truncate_new( &self->truncate );
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_loader_v4_program_instruction_new_disc( fd_loader_v4_program_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_loader_v4_program_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_loader_v4_program_instruction_new( fd_loader_v4_program_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_loader_v4_program_instruction_t) );
  fd_loader_v4_program_instruction_new_disc( self, UINT_MAX );
}
void fd_loader_v4_program_instruction_inner_destroy( fd_loader_v4_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_loader_v4_program_instruction_write_destroy( &self->write );
    break;
  }
  case 1: {
    fd_loader_v4_program_instruction_truncate_destroy( &self->truncate );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_loader_v4_program_instruction_destroy( fd_loader_v4_program_instruction_t * self ) {
  fd_loader_v4_program_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_loader_v4_program_instruction_footprint( void ){ return FD_LOADER_V4_PROGRAM_INSTRUCTION_FOOTPRINT; }
ulong fd_loader_v4_program_instruction_align( void ){ return FD_LOADER_V4_PROGRAM_INSTRUCTION_ALIGN; }

void fd_loader_v4_program_instruction_walk( void * w, fd_loader_v4_program_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_loader_v4_program_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "write", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_loader_v4_program_instruction_write_walk( w, &self->inner.write, fun, "write", level );
    break;
  }
  case 1: {
    fun( w, self, "truncate", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_loader_v4_program_instruction_truncate_walk( w, &self->inner.truncate, fun, "truncate", level );
    break;
  }
  case 2: {
    fun( w, self, "deploy", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "retract", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "transfer_authority", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "finalize", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_loader_v4_program_instruction", level-- );
}
ulong fd_loader_v4_program_instruction_size( fd_loader_v4_program_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_loader_v4_program_instruction_write_size( &self->inner.write );
    break;
  }
  case 1: {
    size += fd_loader_v4_program_instruction_truncate_size( &self->inner.truncate );
    break;
  }
  }
  return size;
}

int fd_loader_v4_program_instruction_inner_encode( fd_loader_v4_program_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_loader_v4_program_instruction_write_encode( &self->write, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_loader_v4_program_instruction_truncate_encode( &self->truncate, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_loader_v4_program_instruction_encode( fd_loader_v4_program_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_loader_v4_program_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_bpf_upgradeable_loader_program_instruction_write_encode( fd_bpf_upgradeable_loader_program_instruction_write_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint32_encode( self->offset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->bytes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->bytes_len ) {
    err = fd_bincode_bytes_encode( self->bytes, self->bytes_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_program_instruction_write_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_program_instruction_write_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_upgradeable_loader_program_instruction_write_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_program_instruction_write_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong bytes_len;
  err = fd_bincode_uint64_decode( &bytes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( bytes_len ) {
    *total_sz += 8UL + bytes_len;
    err = fd_bincode_bytes_decode_footprint( bytes_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_bpf_upgradeable_loader_program_instruction_write_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_write_t * self = (fd_bpf_upgradeable_loader_program_instruction_write_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_write_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_write_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_write_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_write_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_write_t * self = (fd_bpf_upgradeable_loader_program_instruction_write_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint64_decode_unsafe( &self->bytes_len, ctx );
  if( self->bytes_len ) {
    self->bytes = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->bytes, self->bytes_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bytes_len;
  } else
    self->bytes = NULL;
}
void * fd_bpf_upgradeable_loader_program_instruction_write_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_write_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_write_global_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_write_new( (fd_bpf_upgradeable_loader_program_instruction_write_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_write_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_write_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_write_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_write_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_write_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->offset, ctx );
  fd_bincode_uint64_decode_unsafe( &self->bytes_len, ctx );
  if( self->bytes_len ) {
    self->bytes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->bytes_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bytes_len;
  } else
    self->bytes_gaddr = 0UL;
}
int fd_bpf_upgradeable_loader_program_instruction_write_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_program_instruction_write_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_upgradeable_loader_program_instruction_write_global_t const * mem = (fd_bpf_upgradeable_loader_program_instruction_write_global_t const *)global_self;
  self->offset = mem->offset;
  self->bytes_len = mem->bytes_len;
  self->bytes     = fd_wksp_laddr_fast( ctx->wksp, mem->bytes_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_program_instruction_write_new(fd_bpf_upgradeable_loader_program_instruction_write_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_program_instruction_write_t) );
}
void fd_bpf_upgradeable_loader_program_instruction_write_destroy( fd_bpf_upgradeable_loader_program_instruction_write_t * self ) {
  if( self->bytes ) {
    self->bytes = NULL;
  }
}

ulong fd_bpf_upgradeable_loader_program_instruction_write_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_WRITE_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_program_instruction_write_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_WRITE_ALIGN; }

void fd_bpf_upgradeable_loader_program_instruction_write_walk( void * w, fd_bpf_upgradeable_loader_program_instruction_write_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_upgradeable_loader_program_instruction_write", level++ );
  fun( w, &self->offset, "offset", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun(w, self->bytes, "bytes", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_upgradeable_loader_program_instruction_write", level-- );
}
ulong fd_bpf_upgradeable_loader_program_instruction_write_size( fd_bpf_upgradeable_loader_program_instruction_write_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  do {
    size += sizeof(ulong);
    size += self->bytes_len;
  } while(0);
  return size;
}

int fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_encode( fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->max_data_len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t * self = (fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t * self = (fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->max_data_len, ctx );
}
void * fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_new( (fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->max_data_len, ctx );
}
int fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t const * mem = (fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_global_t const *)global_self;
  self->max_data_len = mem->max_data_len;
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_new(fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t) );
}
void fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_destroy( fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t * self ) {
}

ulong fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_DEPLOY_WITH_MAX_DATA_LEN_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_DEPLOY_WITH_MAX_DATA_LEN_ALIGN; }

void fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_walk( void * w, fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len", level++ );
  fun( w, &self->max_data_len, "max_data_len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len", level-- );
}
ulong fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_size( fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  return size;
}

int fd_bpf_upgradeable_loader_program_instruction_extend_program_encode( fd_bpf_upgradeable_loader_program_instruction_extend_program_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint32_encode( self->additional_bytes, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_program_instruction_extend_program_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_bpf_upgradeable_loader_program_instruction_extend_program_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_extend_program_t * self = (fd_bpf_upgradeable_loader_program_instruction_extend_program_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_extend_program_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_extend_program_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_extend_program_t * self = (fd_bpf_upgradeable_loader_program_instruction_extend_program_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->additional_bytes, ctx );
}
void * fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_extend_program_new( (fd_bpf_upgradeable_loader_program_instruction_extend_program_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->additional_bytes, ctx );
}
int fd_bpf_upgradeable_loader_program_instruction_extend_program_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_program_instruction_extend_program_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t const * mem = (fd_bpf_upgradeable_loader_program_instruction_extend_program_global_t const *)global_self;
  self->additional_bytes = mem->additional_bytes;
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_program_instruction_extend_program_new(fd_bpf_upgradeable_loader_program_instruction_extend_program_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_program_instruction_extend_program_t) );
}
void fd_bpf_upgradeable_loader_program_instruction_extend_program_destroy( fd_bpf_upgradeable_loader_program_instruction_extend_program_t * self ) {
}

ulong fd_bpf_upgradeable_loader_program_instruction_extend_program_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_EXTEND_PROGRAM_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_program_instruction_extend_program_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_EXTEND_PROGRAM_ALIGN; }

void fd_bpf_upgradeable_loader_program_instruction_extend_program_walk( void * w, fd_bpf_upgradeable_loader_program_instruction_extend_program_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_upgradeable_loader_program_instruction_extend_program", level++ );
  fun( w, &self->additional_bytes, "additional_bytes", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_upgradeable_loader_program_instruction_extend_program", level-- );
}
ulong fd_bpf_upgradeable_loader_program_instruction_extend_program_size( fd_bpf_upgradeable_loader_program_instruction_extend_program_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  return size;
}

FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_initialize_buffer(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_write(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_deploy_with_max_data_len(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_upgrade(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_set_authority(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_close(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_extend_program(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_program_instruction_is_set_authority_checked(fd_bpf_upgradeable_loader_program_instruction_t const * self) {
  return self->discriminant == 7;
}
void fd_bpf_upgradeable_loader_program_instruction_inner_new( fd_bpf_upgradeable_loader_program_instruction_inner_t * self, uint discriminant );
int fd_bpf_upgradeable_loader_program_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_bpf_upgradeable_loader_program_instruction_write_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    err = fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_bpf_upgradeable_loader_program_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_program_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_bpf_upgradeable_loader_program_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_program_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_bpf_upgradeable_loader_program_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_bpf_upgradeable_loader_program_instruction_inner_decode_inner( fd_bpf_upgradeable_loader_program_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_bpf_upgradeable_loader_program_instruction_write_decode_inner( &self->write, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_inner( &self->deploy_with_max_data_len, alloc_mem, ctx );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_inner( &self->extend_program, alloc_mem, ctx );
    break;
  }
  case 7: {
    break;
  }
  }
}
void fd_bpf_upgradeable_loader_program_instruction_inner_decode_inner_global( fd_bpf_upgradeable_loader_program_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_bpf_upgradeable_loader_program_instruction_write_decode_inner_global( &self->write, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_decode_inner_global( &self->deploy_with_max_data_len, alloc_mem, ctx );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_bpf_upgradeable_loader_program_instruction_extend_program_decode_inner_global( &self->extend_program, alloc_mem, ctx );
    break;
  }
  case 7: {
    break;
  }
  }
}
int fd_bpf_upgradeable_loader_program_instruction_convert_global_to_local_inner( fd_bpf_upgradeable_loader_program_instruction_inner_global_t const * mem, fd_bpf_upgradeable_loader_program_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_bpf_upgradeable_loader_program_instruction_write_convert_global_to_local( &mem->write, &self->write, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_convert_global_to_local( &mem->deploy_with_max_data_len, &self->deploy_with_max_data_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    err = fd_bpf_upgradeable_loader_program_instruction_extend_program_convert_global_to_local( &mem->extend_program, &self->extend_program, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_program_instruction_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_program_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_global_t const * mem = (fd_bpf_upgradeable_loader_program_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_bpf_upgradeable_loader_program_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_program_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_t * self = (fd_bpf_upgradeable_loader_program_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_bpf_upgradeable_loader_program_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_bpf_upgradeable_loader_program_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_t * self = (fd_bpf_upgradeable_loader_program_instruction_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_bpf_upgradeable_loader_program_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_t * self = (fd_bpf_upgradeable_loader_program_instruction_t *)mem;
  fd_bpf_upgradeable_loader_program_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_program_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_program_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_program_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_program_instruction_global_t * self = (fd_bpf_upgradeable_loader_program_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_bpf_upgradeable_loader_program_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_bpf_upgradeable_loader_program_instruction_inner_new( fd_bpf_upgradeable_loader_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_bpf_upgradeable_loader_program_instruction_write_new( &self->write );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_new( &self->deploy_with_max_data_len );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    fd_bpf_upgradeable_loader_program_instruction_extend_program_new( &self->extend_program );
    break;
  }
  case 7: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_bpf_upgradeable_loader_program_instruction_new_disc( fd_bpf_upgradeable_loader_program_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_bpf_upgradeable_loader_program_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_bpf_upgradeable_loader_program_instruction_new( fd_bpf_upgradeable_loader_program_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_program_instruction_t) );
  fd_bpf_upgradeable_loader_program_instruction_new_disc( self, UINT_MAX );
}
void fd_bpf_upgradeable_loader_program_instruction_inner_destroy( fd_bpf_upgradeable_loader_program_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_bpf_upgradeable_loader_program_instruction_write_destroy( &self->write );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_destroy( &self->deploy_with_max_data_len );
    break;
  }
  case 6: {
    fd_bpf_upgradeable_loader_program_instruction_extend_program_destroy( &self->extend_program );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_bpf_upgradeable_loader_program_instruction_destroy( fd_bpf_upgradeable_loader_program_instruction_t * self ) {
  fd_bpf_upgradeable_loader_program_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_bpf_upgradeable_loader_program_instruction_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_program_instruction_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_PROGRAM_INSTRUCTION_ALIGN; }

void fd_bpf_upgradeable_loader_program_instruction_walk( void * w, fd_bpf_upgradeable_loader_program_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_bpf_upgradeable_loader_program_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "initialize_buffer", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "write", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_upgradeable_loader_program_instruction_write_walk( w, &self->inner.write, fun, "write", level );
    break;
  }
  case 2: {
    fun( w, self, "deploy_with_max_data_len", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_walk( w, &self->inner.deploy_with_max_data_len, fun, "deploy_with_max_data_len", level );
    break;
  }
  case 3: {
    fun( w, self, "upgrade", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "set_authority", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "close", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 6: {
    fun( w, self, "extend_program", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_upgradeable_loader_program_instruction_extend_program_walk( w, &self->inner.extend_program, fun, "extend_program", level );
    break;
  }
  case 7: {
    fun( w, self, "set_authority_checked", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_bpf_upgradeable_loader_program_instruction", level-- );
}
ulong fd_bpf_upgradeable_loader_program_instruction_size( fd_bpf_upgradeable_loader_program_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_bpf_upgradeable_loader_program_instruction_write_size( &self->inner.write );
    break;
  }
  case 2: {
    size += fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_size( &self->inner.deploy_with_max_data_len );
    break;
  }
  case 6: {
    size += fd_bpf_upgradeable_loader_program_instruction_extend_program_size( &self->inner.extend_program );
    break;
  }
  }
  return size;
}

int fd_bpf_upgradeable_loader_program_instruction_inner_encode( fd_bpf_upgradeable_loader_program_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_bpf_upgradeable_loader_program_instruction_write_encode( &self->write, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_bpf_upgradeable_loader_program_instruction_deploy_with_max_data_len_encode( &self->deploy_with_max_data_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 6: {
    err = fd_bpf_upgradeable_loader_program_instruction_extend_program_encode( &self->extend_program, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_program_instruction_encode( fd_bpf_upgradeable_loader_program_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_bpf_upgradeable_loader_program_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_bpf_upgradeable_loader_state_buffer_encode( fd_bpf_upgradeable_loader_state_buffer_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->authority_address != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_pubkey_encode( self->authority_address, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_state_buffer_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_state_buffer_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_upgradeable_loader_state_buffer_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_state_buffer_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT;
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_bpf_upgradeable_loader_state_buffer_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_buffer_t * self = (fd_bpf_upgradeable_loader_state_buffer_t *)mem;
  fd_bpf_upgradeable_loader_state_buffer_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_buffer_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_buffer_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_buffer_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_buffer_t * self = (fd_bpf_upgradeable_loader_state_buffer_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->authority_address = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_new( self->authority_address );
      fd_pubkey_decode_inner( self->authority_address, alloc_mem, ctx );
    } else {
      self->authority_address = NULL;
    }
  }
}
void * fd_bpf_upgradeable_loader_state_buffer_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_buffer_global_t * self = (fd_bpf_upgradeable_loader_state_buffer_global_t *)mem;
  fd_bpf_upgradeable_loader_state_buffer_new( (fd_bpf_upgradeable_loader_state_buffer_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_buffer_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_buffer_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_buffer_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_buffer_global_t * self = (fd_bpf_upgradeable_loader_state_buffer_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->authority_address_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_pubkey_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->authority_address_gaddr ), alloc_mem, ctx );
    } else {
      self->authority_address_gaddr = 0UL;
    }
  }
}
int fd_bpf_upgradeable_loader_state_buffer_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_state_buffer_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_upgradeable_loader_state_buffer_global_t const * mem = (fd_bpf_upgradeable_loader_state_buffer_global_t const *)global_self;
  self->authority_address = fd_wksp_laddr_fast( ctx->wksp, mem->authority_address_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_state_buffer_new(fd_bpf_upgradeable_loader_state_buffer_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_state_buffer_t) );
}
void fd_bpf_upgradeable_loader_state_buffer_destroy( fd_bpf_upgradeable_loader_state_buffer_t * self ) {
  if( self->authority_address ) {
    fd_pubkey_destroy( self->authority_address );
    self->authority_address = NULL;
  }
}

ulong fd_bpf_upgradeable_loader_state_buffer_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_BUFFER_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_state_buffer_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_BUFFER_ALIGN; }

void fd_bpf_upgradeable_loader_state_buffer_walk( void * w, fd_bpf_upgradeable_loader_state_buffer_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_upgradeable_loader_state_buffer", level++ );
  if( !self->authority_address ) {
    fun( w, NULL, "authority_address", FD_FLAMENCO_TYPE_NULL, "pubkey", level );
  } else {
    fd_pubkey_walk( w, self->authority_address, fun, "authority_address", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_upgradeable_loader_state_buffer", level-- );
}
ulong fd_bpf_upgradeable_loader_state_buffer_size( fd_bpf_upgradeable_loader_state_buffer_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( NULL !=  self->authority_address ) {
    size += fd_pubkey_size( self->authority_address );
  }
  return size;
}

int fd_bpf_upgradeable_loader_state_program_encode( fd_bpf_upgradeable_loader_state_program_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->programdata_address, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_state_program_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_state_program_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_upgradeable_loader_state_program_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_state_program_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_bpf_upgradeable_loader_state_program_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_t * self = (fd_bpf_upgradeable_loader_state_program_t *)mem;
  fd_bpf_upgradeable_loader_state_program_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_program_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_program_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_program_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_t * self = (fd_bpf_upgradeable_loader_state_program_t *)struct_mem;
  fd_pubkey_decode_inner( &self->programdata_address, alloc_mem, ctx );
}
void * fd_bpf_upgradeable_loader_state_program_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_global_t * self = (fd_bpf_upgradeable_loader_state_program_global_t *)mem;
  fd_bpf_upgradeable_loader_state_program_new( (fd_bpf_upgradeable_loader_state_program_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_program_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_program_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_program_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_global_t * self = (fd_bpf_upgradeable_loader_state_program_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->programdata_address, alloc_mem, ctx );
}
int fd_bpf_upgradeable_loader_state_program_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_state_program_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_upgradeable_loader_state_program_global_t const * mem = (fd_bpf_upgradeable_loader_state_program_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->programdata_address, &self->programdata_address, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_state_program_new(fd_bpf_upgradeable_loader_state_program_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_state_program_t) );
  fd_pubkey_new( &self->programdata_address );
}
void fd_bpf_upgradeable_loader_state_program_destroy( fd_bpf_upgradeable_loader_state_program_t * self ) {
  fd_pubkey_destroy( &self->programdata_address );
}

ulong fd_bpf_upgradeable_loader_state_program_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_PROGRAM_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_state_program_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_PROGRAM_ALIGN; }

void fd_bpf_upgradeable_loader_state_program_walk( void * w, fd_bpf_upgradeable_loader_state_program_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_upgradeable_loader_state_program", level++ );
  fd_pubkey_walk( w, &self->programdata_address, fun, "programdata_address", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_upgradeable_loader_state_program", level-- );
}
ulong fd_bpf_upgradeable_loader_state_program_size( fd_bpf_upgradeable_loader_state_program_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->programdata_address );
  return size;
}

int fd_bpf_upgradeable_loader_state_program_data_encode( fd_bpf_upgradeable_loader_state_program_data_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->upgrade_authority_address != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_pubkey_encode( self->upgrade_authority_address, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_state_program_data_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_state_program_data_t);
  void const * start_data = ctx->data;
  int err = fd_bpf_upgradeable_loader_state_program_data_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_state_program_data_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT;
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_bpf_upgradeable_loader_state_program_data_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_data_t * self = (fd_bpf_upgradeable_loader_state_program_data_t *)mem;
  fd_bpf_upgradeable_loader_state_program_data_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_program_data_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_program_data_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_program_data_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_data_t * self = (fd_bpf_upgradeable_loader_state_program_data_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->upgrade_authority_address = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_new( self->upgrade_authority_address );
      fd_pubkey_decode_inner( self->upgrade_authority_address, alloc_mem, ctx );
    } else {
      self->upgrade_authority_address = NULL;
    }
  }
}
void * fd_bpf_upgradeable_loader_state_program_data_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_data_global_t * self = (fd_bpf_upgradeable_loader_state_program_data_global_t *)mem;
  fd_bpf_upgradeable_loader_state_program_data_new( (fd_bpf_upgradeable_loader_state_program_data_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_program_data_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_program_data_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_program_data_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_program_data_global_t * self = (fd_bpf_upgradeable_loader_state_program_data_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_PUBKEY_ALIGN );
      self->upgrade_authority_address_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_pubkey_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_PUBKEY_FOOTPRINT;
      fd_pubkey_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->upgrade_authority_address_gaddr ), alloc_mem, ctx );
    } else {
      self->upgrade_authority_address_gaddr = 0UL;
    }
  }
}
int fd_bpf_upgradeable_loader_state_program_data_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_state_program_data_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bpf_upgradeable_loader_state_program_data_global_t const * mem = (fd_bpf_upgradeable_loader_state_program_data_global_t const *)global_self;
  self->slot = mem->slot;
  self->upgrade_authority_address = fd_wksp_laddr_fast( ctx->wksp, mem->upgrade_authority_address_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_state_program_data_new(fd_bpf_upgradeable_loader_state_program_data_t * self) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_state_program_data_t) );
}
void fd_bpf_upgradeable_loader_state_program_data_destroy( fd_bpf_upgradeable_loader_state_program_data_t * self ) {
  if( self->upgrade_authority_address ) {
    fd_pubkey_destroy( self->upgrade_authority_address );
    self->upgrade_authority_address = NULL;
  }
}

ulong fd_bpf_upgradeable_loader_state_program_data_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_PROGRAM_DATA_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_state_program_data_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_PROGRAM_DATA_ALIGN; }

void fd_bpf_upgradeable_loader_state_program_data_walk( void * w, fd_bpf_upgradeable_loader_state_program_data_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bpf_upgradeable_loader_state_program_data", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( !self->upgrade_authority_address ) {
    fun( w, NULL, "upgrade_authority_address", FD_FLAMENCO_TYPE_NULL, "pubkey", level );
  } else {
    fd_pubkey_walk( w, self->upgrade_authority_address, fun, "upgrade_authority_address", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bpf_upgradeable_loader_state_program_data", level-- );
}
ulong fd_bpf_upgradeable_loader_state_program_data_size( fd_bpf_upgradeable_loader_state_program_data_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(char);
  if( NULL !=  self->upgrade_authority_address ) {
    size += fd_pubkey_size( self->upgrade_authority_address );
  }
  return size;
}

FD_FN_PURE uchar fd_bpf_upgradeable_loader_state_is_uninitialized(fd_bpf_upgradeable_loader_state_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_state_is_buffer(fd_bpf_upgradeable_loader_state_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_state_is_program(fd_bpf_upgradeable_loader_state_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_bpf_upgradeable_loader_state_is_program_data(fd_bpf_upgradeable_loader_state_t const * self) {
  return self->discriminant == 3;
}
void fd_bpf_upgradeable_loader_state_inner_new( fd_bpf_upgradeable_loader_state_inner_t * self, uint discriminant );
int fd_bpf_upgradeable_loader_state_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_bpf_upgradeable_loader_state_buffer_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_bpf_upgradeable_loader_state_program_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_bpf_upgradeable_loader_state_program_data_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_bpf_upgradeable_loader_state_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bpf_upgradeable_loader_state_t);
  void const * start_data = ctx->data;
  int err =  fd_bpf_upgradeable_loader_state_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bpf_upgradeable_loader_state_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_bpf_upgradeable_loader_state_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_bpf_upgradeable_loader_state_inner_decode_inner( fd_bpf_upgradeable_loader_state_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_bpf_upgradeable_loader_state_buffer_decode_inner( &self->buffer, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_state_program_decode_inner( &self->program, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_bpf_upgradeable_loader_state_program_data_decode_inner( &self->program_data, alloc_mem, ctx );
    break;
  }
  }
}
void fd_bpf_upgradeable_loader_state_inner_decode_inner_global( fd_bpf_upgradeable_loader_state_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_bpf_upgradeable_loader_state_buffer_decode_inner_global( &self->buffer, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_state_program_decode_inner_global( &self->program, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_bpf_upgradeable_loader_state_program_data_decode_inner_global( &self->program_data, alloc_mem, ctx );
    break;
  }
  }
}
int fd_bpf_upgradeable_loader_state_convert_global_to_local_inner( fd_bpf_upgradeable_loader_state_inner_global_t const * mem, fd_bpf_upgradeable_loader_state_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_bpf_upgradeable_loader_state_buffer_convert_global_to_local( &mem->buffer, &self->buffer, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_bpf_upgradeable_loader_state_program_convert_global_to_local( &mem->program, &self->program, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_bpf_upgradeable_loader_state_program_data_convert_global_to_local( &mem->program_data, &self->program_data, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_state_convert_global_to_local( void const * global_self, fd_bpf_upgradeable_loader_state_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_global_t const * mem = (fd_bpf_upgradeable_loader_state_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_bpf_upgradeable_loader_state_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_bpf_upgradeable_loader_state_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_t * self = (fd_bpf_upgradeable_loader_state_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_bpf_upgradeable_loader_state_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_bpf_upgradeable_loader_state_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_t * self = (fd_bpf_upgradeable_loader_state_t *)mem;
  fd_bpf_upgradeable_loader_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_bpf_upgradeable_loader_state_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_t * self = (fd_bpf_upgradeable_loader_state_t *)mem;
  fd_bpf_upgradeable_loader_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bpf_upgradeable_loader_state_t);
  void * * alloc_mem = &alloc_region;
  fd_bpf_upgradeable_loader_state_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bpf_upgradeable_loader_state_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bpf_upgradeable_loader_state_global_t * self = (fd_bpf_upgradeable_loader_state_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_bpf_upgradeable_loader_state_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_bpf_upgradeable_loader_state_inner_new( fd_bpf_upgradeable_loader_state_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_bpf_upgradeable_loader_state_buffer_new( &self->buffer );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_state_program_new( &self->program );
    break;
  }
  case 3: {
    fd_bpf_upgradeable_loader_state_program_data_new( &self->program_data );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_bpf_upgradeable_loader_state_new_disc( fd_bpf_upgradeable_loader_state_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_bpf_upgradeable_loader_state_inner_new( &self->inner, self->discriminant );
}
void fd_bpf_upgradeable_loader_state_new( fd_bpf_upgradeable_loader_state_t * self ) {
  fd_memset( self, 0, sizeof(fd_bpf_upgradeable_loader_state_t) );
  fd_bpf_upgradeable_loader_state_new_disc( self, UINT_MAX );
}
void fd_bpf_upgradeable_loader_state_inner_destroy( fd_bpf_upgradeable_loader_state_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_bpf_upgradeable_loader_state_buffer_destroy( &self->buffer );
    break;
  }
  case 2: {
    fd_bpf_upgradeable_loader_state_program_destroy( &self->program );
    break;
  }
  case 3: {
    fd_bpf_upgradeable_loader_state_program_data_destroy( &self->program_data );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_bpf_upgradeable_loader_state_destroy( fd_bpf_upgradeable_loader_state_t * self ) {
  fd_bpf_upgradeable_loader_state_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_bpf_upgradeable_loader_state_footprint( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_FOOTPRINT; }
ulong fd_bpf_upgradeable_loader_state_align( void ){ return FD_BPF_UPGRADEABLE_LOADER_STATE_ALIGN; }

void fd_bpf_upgradeable_loader_state_walk( void * w, fd_bpf_upgradeable_loader_state_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_bpf_upgradeable_loader_state", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "uninitialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "buffer", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_upgradeable_loader_state_buffer_walk( w, &self->inner.buffer, fun, "buffer", level );
    break;
  }
  case 2: {
    fun( w, self, "program", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_upgradeable_loader_state_program_walk( w, &self->inner.program, fun, "program", level );
    break;
  }
  case 3: {
    fun( w, self, "program_data", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_bpf_upgradeable_loader_state_program_data_walk( w, &self->inner.program_data, fun, "program_data", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_bpf_upgradeable_loader_state", level-- );
}
ulong fd_bpf_upgradeable_loader_state_size( fd_bpf_upgradeable_loader_state_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_bpf_upgradeable_loader_state_buffer_size( &self->inner.buffer );
    break;
  }
  case 2: {
    size += fd_bpf_upgradeable_loader_state_program_size( &self->inner.program );
    break;
  }
  case 3: {
    size += fd_bpf_upgradeable_loader_state_program_data_size( &self->inner.program_data );
    break;
  }
  }
  return size;
}

int fd_bpf_upgradeable_loader_state_inner_encode( fd_bpf_upgradeable_loader_state_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_bpf_upgradeable_loader_state_buffer_encode( &self->buffer, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_bpf_upgradeable_loader_state_program_encode( &self->program, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_bpf_upgradeable_loader_state_program_data_encode( &self->program_data, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bpf_upgradeable_loader_state_encode( fd_bpf_upgradeable_loader_state_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_bpf_upgradeable_loader_state_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_loader_v4_state_encode( fd_loader_v4_state_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->authority_address_or_next_version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->status, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_loader_v4_state_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_loader_v4_state_t);
  void const * start_data = ctx->data;
  int err = fd_loader_v4_state_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_loader_v4_state_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_loader_v4_state_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_state_t * self = (fd_loader_v4_state_t *)mem;
  fd_loader_v4_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_state_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_state_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_state_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_state_t * self = (fd_loader_v4_state_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_pubkey_decode_inner( &self->authority_address_or_next_version, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->status, ctx );
}
void * fd_loader_v4_state_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_state_global_t * self = (fd_loader_v4_state_global_t *)mem;
  fd_loader_v4_state_new( (fd_loader_v4_state_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_loader_v4_state_global_t);
  void * * alloc_mem = &alloc_region;
  fd_loader_v4_state_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_loader_v4_state_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_loader_v4_state_global_t * self = (fd_loader_v4_state_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_pubkey_decode_inner_global( &self->authority_address_or_next_version, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->status, ctx );
}
int fd_loader_v4_state_convert_global_to_local( void const * global_self, fd_loader_v4_state_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_loader_v4_state_global_t const * mem = (fd_loader_v4_state_global_t const *)global_self;
  self->slot = mem->slot;
  err = fd_pubkey_convert_global_to_local( &mem->authority_address_or_next_version, &self->authority_address_or_next_version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->status = mem->status;
  return FD_BINCODE_SUCCESS;
}
void fd_loader_v4_state_new(fd_loader_v4_state_t * self) {
  fd_memset( self, 0, sizeof(fd_loader_v4_state_t) );
  fd_pubkey_new( &self->authority_address_or_next_version );
}
void fd_loader_v4_state_destroy( fd_loader_v4_state_t * self ) {
  fd_pubkey_destroy( &self->authority_address_or_next_version );
}

ulong fd_loader_v4_state_footprint( void ){ return FD_LOADER_V4_STATE_FOOTPRINT; }
ulong fd_loader_v4_state_align( void ){ return FD_LOADER_V4_STATE_ALIGN; }

void fd_loader_v4_state_walk( void * w, fd_loader_v4_state_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_loader_v4_state", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_pubkey_walk( w, &self->authority_address_or_next_version, fun, "authority_address_or_next_version", level );
  fun( w, &self->status, "status", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_loader_v4_state", level-- );
}
ulong fd_loader_v4_state_size( fd_loader_v4_state_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += fd_pubkey_size( &self->authority_address_or_next_version );
  size += sizeof(ulong);
  return size;
}

int fd_frozen_hash_status_encode( fd_frozen_hash_status_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_hash_encode( &self->frozen_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->is_duplicate_confirmed), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_frozen_hash_status_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_frozen_hash_status_t);
  void const * start_data = ctx->data;
  int err = fd_frozen_hash_status_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_frozen_hash_status_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_frozen_hash_status_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_status_t * self = (fd_frozen_hash_status_t *)mem;
  fd_frozen_hash_status_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_frozen_hash_status_t);
  void * * alloc_mem = &alloc_region;
  fd_frozen_hash_status_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_frozen_hash_status_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_status_t * self = (fd_frozen_hash_status_t *)struct_mem;
  fd_hash_decode_inner( &self->frozen_hash, alloc_mem, ctx );
  fd_bincode_bool_decode_unsafe( &self->is_duplicate_confirmed, ctx );
}
void * fd_frozen_hash_status_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_status_global_t * self = (fd_frozen_hash_status_global_t *)mem;
  fd_frozen_hash_status_new( (fd_frozen_hash_status_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_frozen_hash_status_global_t);
  void * * alloc_mem = &alloc_region;
  fd_frozen_hash_status_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_frozen_hash_status_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_status_global_t * self = (fd_frozen_hash_status_global_t *)struct_mem;
  fd_hash_decode_inner_global( &self->frozen_hash, alloc_mem, ctx );
  fd_bincode_bool_decode_unsafe( &self->is_duplicate_confirmed, ctx );
}
int fd_frozen_hash_status_convert_global_to_local( void const * global_self, fd_frozen_hash_status_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_frozen_hash_status_global_t const * mem = (fd_frozen_hash_status_global_t const *)global_self;
  err = fd_hash_convert_global_to_local( &mem->frozen_hash, &self->frozen_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->is_duplicate_confirmed = mem->is_duplicate_confirmed;
  return FD_BINCODE_SUCCESS;
}
void fd_frozen_hash_status_new(fd_frozen_hash_status_t * self) {
  fd_memset( self, 0, sizeof(fd_frozen_hash_status_t) );
  fd_hash_new( &self->frozen_hash );
}
void fd_frozen_hash_status_destroy( fd_frozen_hash_status_t * self ) {
  fd_hash_destroy( &self->frozen_hash );
}

ulong fd_frozen_hash_status_footprint( void ){ return FD_FROZEN_HASH_STATUS_FOOTPRINT; }
ulong fd_frozen_hash_status_align( void ){ return FD_FROZEN_HASH_STATUS_ALIGN; }

void fd_frozen_hash_status_walk( void * w, fd_frozen_hash_status_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_frozen_hash_status", level++ );
  fd_hash_walk( w, &self->frozen_hash, fun, "frozen_hash", level );
  fun( w, &self->is_duplicate_confirmed, "is_duplicate_confirmed", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_frozen_hash_status", level-- );
}
ulong fd_frozen_hash_status_size( fd_frozen_hash_status_t const * self ) {
  ulong size = 0;
  size += fd_hash_size( &self->frozen_hash );
  size += sizeof(char);
  return size;
}

FD_FN_PURE uchar fd_frozen_hash_versioned_is_current(fd_frozen_hash_versioned_t const * self) {
  return self->discriminant == 0;
}
void fd_frozen_hash_versioned_inner_new( fd_frozen_hash_versioned_inner_t * self, uint discriminant );
int fd_frozen_hash_versioned_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_frozen_hash_status_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_frozen_hash_versioned_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_frozen_hash_versioned_t);
  void const * start_data = ctx->data;
  int err =  fd_frozen_hash_versioned_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_frozen_hash_versioned_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_frozen_hash_versioned_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_frozen_hash_versioned_inner_decode_inner( fd_frozen_hash_versioned_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_frozen_hash_status_decode_inner( &self->current, alloc_mem, ctx );
    break;
  }
  }
}
void fd_frozen_hash_versioned_inner_decode_inner_global( fd_frozen_hash_versioned_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_frozen_hash_status_decode_inner_global( &self->current, alloc_mem, ctx );
    break;
  }
  }
}
int fd_frozen_hash_versioned_convert_global_to_local_inner( fd_frozen_hash_versioned_inner_global_t const * mem, fd_frozen_hash_versioned_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_frozen_hash_status_convert_global_to_local( &mem->current, &self->current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_frozen_hash_versioned_convert_global_to_local( void const * global_self, fd_frozen_hash_versioned_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_versioned_global_t const * mem = (fd_frozen_hash_versioned_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_frozen_hash_versioned_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_frozen_hash_versioned_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_versioned_t * self = (fd_frozen_hash_versioned_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_frozen_hash_versioned_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_frozen_hash_versioned_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_versioned_t * self = (fd_frozen_hash_versioned_t *)mem;
  fd_frozen_hash_versioned_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_frozen_hash_versioned_t);
  void * * alloc_mem = &alloc_region;
  fd_frozen_hash_versioned_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_frozen_hash_versioned_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_versioned_t * self = (fd_frozen_hash_versioned_t *)mem;
  fd_frozen_hash_versioned_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_frozen_hash_versioned_t);
  void * * alloc_mem = &alloc_region;
  fd_frozen_hash_versioned_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_frozen_hash_versioned_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_frozen_hash_versioned_global_t * self = (fd_frozen_hash_versioned_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_frozen_hash_versioned_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_frozen_hash_versioned_inner_new( fd_frozen_hash_versioned_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_frozen_hash_status_new( &self->current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_frozen_hash_versioned_new_disc( fd_frozen_hash_versioned_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_frozen_hash_versioned_inner_new( &self->inner, self->discriminant );
}
void fd_frozen_hash_versioned_new( fd_frozen_hash_versioned_t * self ) {
  fd_memset( self, 0, sizeof(fd_frozen_hash_versioned_t) );
  fd_frozen_hash_versioned_new_disc( self, UINT_MAX );
}
void fd_frozen_hash_versioned_inner_destroy( fd_frozen_hash_versioned_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_frozen_hash_status_destroy( &self->current );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_frozen_hash_versioned_destroy( fd_frozen_hash_versioned_t * self ) {
  fd_frozen_hash_versioned_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_frozen_hash_versioned_footprint( void ){ return FD_FROZEN_HASH_VERSIONED_FOOTPRINT; }
ulong fd_frozen_hash_versioned_align( void ){ return FD_FROZEN_HASH_VERSIONED_ALIGN; }

void fd_frozen_hash_versioned_walk( void * w, fd_frozen_hash_versioned_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_frozen_hash_versioned", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "current", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_frozen_hash_status_walk( w, &self->inner.current, fun, "current", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_frozen_hash_versioned", level-- );
}
ulong fd_frozen_hash_versioned_size( fd_frozen_hash_versioned_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_frozen_hash_status_size( &self->inner.current );
    break;
  }
  }
  return size;
}

int fd_frozen_hash_versioned_inner_encode( fd_frozen_hash_versioned_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_frozen_hash_status_encode( &self->current, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_frozen_hash_versioned_encode( fd_frozen_hash_versioned_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_frozen_hash_versioned_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_lookup_table_meta_encode( fd_lookup_table_meta_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->deactivation_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->last_extended_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->last_extended_slot_start_index), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_authority, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_authority ) {
    err = fd_pubkey_encode( &self->authority, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint16_encode( self->_padding, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_lookup_table_meta_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_lookup_table_meta_t);
  void const * start_data = ctx->data;
  int err = fd_lookup_table_meta_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_lookup_table_meta_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_lookup_table_meta_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lookup_table_meta_t * self = (fd_lookup_table_meta_t *)mem;
  fd_lookup_table_meta_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lookup_table_meta_t);
  void * * alloc_mem = &alloc_region;
  fd_lookup_table_meta_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_lookup_table_meta_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lookup_table_meta_t * self = (fd_lookup_table_meta_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->deactivation_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_extended_slot, ctx );
  fd_bincode_uint8_decode_unsafe( &self->last_extended_slot_start_index, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_authority = !!o;
    if( o ) {
      fd_pubkey_new( &self->authority );
      fd_pubkey_decode_inner( &self->authority, alloc_mem, ctx );
    }
  }
  fd_bincode_uint16_decode_unsafe( &self->_padding, ctx );
}
void * fd_lookup_table_meta_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lookup_table_meta_global_t * self = (fd_lookup_table_meta_global_t *)mem;
  fd_lookup_table_meta_new( (fd_lookup_table_meta_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_lookup_table_meta_global_t);
  void * * alloc_mem = &alloc_region;
  fd_lookup_table_meta_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_lookup_table_meta_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_lookup_table_meta_global_t * self = (fd_lookup_table_meta_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->deactivation_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_extended_slot, ctx );
  fd_bincode_uint8_decode_unsafe( &self->last_extended_slot_start_index, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_authority = !!o;
    if( o ) {
      fd_pubkey_new( &self->authority );
      fd_pubkey_decode_inner_global( &self->authority, alloc_mem, ctx );
    }
  }
  fd_bincode_uint16_decode_unsafe( &self->_padding, ctx );
}
int fd_lookup_table_meta_convert_global_to_local( void const * global_self, fd_lookup_table_meta_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_lookup_table_meta_global_t const * mem = (fd_lookup_table_meta_global_t const *)global_self;
  self->deactivation_slot = mem->deactivation_slot;
  self->last_extended_slot = mem->last_extended_slot;
  self->last_extended_slot_start_index = mem->last_extended_slot_start_index;
  self->authority = mem->authority;
  self->has_authority = mem->has_authority;
  self->_padding = mem->_padding;
  return FD_BINCODE_SUCCESS;
}
void fd_lookup_table_meta_new(fd_lookup_table_meta_t * self) {
  fd_memset( self, 0, sizeof(fd_lookup_table_meta_t) );
}
void fd_lookup_table_meta_destroy( fd_lookup_table_meta_t * self ) {
  if( self->has_authority ) {
    fd_pubkey_destroy( &self->authority );
    self->has_authority = 0;
  }
}

ulong fd_lookup_table_meta_footprint( void ){ return FD_LOOKUP_TABLE_META_FOOTPRINT; }
ulong fd_lookup_table_meta_align( void ){ return FD_LOOKUP_TABLE_META_ALIGN; }

void fd_lookup_table_meta_walk( void * w, fd_lookup_table_meta_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_lookup_table_meta", level++ );
  fun( w, &self->deactivation_slot, "deactivation_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->last_extended_slot, "last_extended_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->last_extended_slot_start_index, "last_extended_slot_start_index", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  if( !self->has_authority ) {
    fun( w, NULL, "authority", FD_FLAMENCO_TYPE_NULL, "pubkey", level );
  } else {
    fd_pubkey_walk( w, &self->authority, fun, "authority", level );
  }
  fun( w, &self->_padding, "_padding", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_lookup_table_meta", level-- );
}
ulong fd_lookup_table_meta_size( fd_lookup_table_meta_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(char);
  size += sizeof(char);
  if( self->has_authority ) {
    size += fd_pubkey_size( &self->authority );
  }
  size += sizeof(ushort);
  return size;
}

int fd_address_lookup_table_encode( fd_address_lookup_table_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_lookup_table_meta_encode( &self->meta, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_address_lookup_table_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_address_lookup_table_t);
  void const * start_data = ctx->data;
  int err = fd_address_lookup_table_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_address_lookup_table_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_lookup_table_meta_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_address_lookup_table_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_t * self = (fd_address_lookup_table_t *)mem;
  fd_address_lookup_table_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_address_lookup_table_t);
  void * * alloc_mem = &alloc_region;
  fd_address_lookup_table_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_address_lookup_table_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_t * self = (fd_address_lookup_table_t *)struct_mem;
  fd_lookup_table_meta_decode_inner( &self->meta, alloc_mem, ctx );
}
void * fd_address_lookup_table_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_global_t * self = (fd_address_lookup_table_global_t *)mem;
  fd_address_lookup_table_new( (fd_address_lookup_table_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_address_lookup_table_global_t);
  void * * alloc_mem = &alloc_region;
  fd_address_lookup_table_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_address_lookup_table_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_global_t * self = (fd_address_lookup_table_global_t *)struct_mem;
  fd_lookup_table_meta_decode_inner_global( &self->meta, alloc_mem, ctx );
}
int fd_address_lookup_table_convert_global_to_local( void const * global_self, fd_address_lookup_table_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_address_lookup_table_global_t const * mem = (fd_address_lookup_table_global_t const *)global_self;
  err = fd_lookup_table_meta_convert_global_to_local( &mem->meta, &self->meta, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_address_lookup_table_new(fd_address_lookup_table_t * self) {
  fd_memset( self, 0, sizeof(fd_address_lookup_table_t) );
  fd_lookup_table_meta_new( &self->meta );
}
void fd_address_lookup_table_destroy( fd_address_lookup_table_t * self ) {
  fd_lookup_table_meta_destroy( &self->meta );
}

ulong fd_address_lookup_table_footprint( void ){ return FD_ADDRESS_LOOKUP_TABLE_FOOTPRINT; }
ulong fd_address_lookup_table_align( void ){ return FD_ADDRESS_LOOKUP_TABLE_ALIGN; }

void fd_address_lookup_table_walk( void * w, fd_address_lookup_table_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_address_lookup_table", level++ );
  fd_lookup_table_meta_walk( w, &self->meta, fun, "meta", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_address_lookup_table", level-- );
}
ulong fd_address_lookup_table_size( fd_address_lookup_table_t const * self ) {
  ulong size = 0;
  size += fd_lookup_table_meta_size( &self->meta );
  return size;
}

FD_FN_PURE uchar fd_address_lookup_table_state_is_uninitialized(fd_address_lookup_table_state_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_address_lookup_table_state_is_lookup_table(fd_address_lookup_table_state_t const * self) {
  return self->discriminant == 1;
}
void fd_address_lookup_table_state_inner_new( fd_address_lookup_table_state_inner_t * self, uint discriminant );
int fd_address_lookup_table_state_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_address_lookup_table_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_address_lookup_table_state_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_address_lookup_table_state_t);
  void const * start_data = ctx->data;
  int err =  fd_address_lookup_table_state_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_address_lookup_table_state_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_address_lookup_table_state_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_address_lookup_table_state_inner_decode_inner( fd_address_lookup_table_state_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_address_lookup_table_decode_inner( &self->lookup_table, alloc_mem, ctx );
    break;
  }
  }
}
void fd_address_lookup_table_state_inner_decode_inner_global( fd_address_lookup_table_state_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_address_lookup_table_decode_inner_global( &self->lookup_table, alloc_mem, ctx );
    break;
  }
  }
}
int fd_address_lookup_table_state_convert_global_to_local_inner( fd_address_lookup_table_state_inner_global_t const * mem, fd_address_lookup_table_state_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_address_lookup_table_convert_global_to_local( &mem->lookup_table, &self->lookup_table, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_address_lookup_table_state_convert_global_to_local( void const * global_self, fd_address_lookup_table_state_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_state_global_t const * mem = (fd_address_lookup_table_state_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_address_lookup_table_state_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_address_lookup_table_state_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_state_t * self = (fd_address_lookup_table_state_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_address_lookup_table_state_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_address_lookup_table_state_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_state_t * self = (fd_address_lookup_table_state_t *)mem;
  fd_address_lookup_table_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_address_lookup_table_state_t);
  void * * alloc_mem = &alloc_region;
  fd_address_lookup_table_state_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_address_lookup_table_state_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_state_t * self = (fd_address_lookup_table_state_t *)mem;
  fd_address_lookup_table_state_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_address_lookup_table_state_t);
  void * * alloc_mem = &alloc_region;
  fd_address_lookup_table_state_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_address_lookup_table_state_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_address_lookup_table_state_global_t * self = (fd_address_lookup_table_state_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_address_lookup_table_state_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_address_lookup_table_state_inner_new( fd_address_lookup_table_state_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_address_lookup_table_new( &self->lookup_table );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_address_lookup_table_state_new_disc( fd_address_lookup_table_state_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_address_lookup_table_state_inner_new( &self->inner, self->discriminant );
}
void fd_address_lookup_table_state_new( fd_address_lookup_table_state_t * self ) {
  fd_memset( self, 0, sizeof(fd_address_lookup_table_state_t) );
  fd_address_lookup_table_state_new_disc( self, UINT_MAX );
}
void fd_address_lookup_table_state_inner_destroy( fd_address_lookup_table_state_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_address_lookup_table_destroy( &self->lookup_table );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_address_lookup_table_state_destroy( fd_address_lookup_table_state_t * self ) {
  fd_address_lookup_table_state_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_address_lookup_table_state_footprint( void ){ return FD_ADDRESS_LOOKUP_TABLE_STATE_FOOTPRINT; }
ulong fd_address_lookup_table_state_align( void ){ return FD_ADDRESS_LOOKUP_TABLE_STATE_ALIGN; }

void fd_address_lookup_table_state_walk( void * w, fd_address_lookup_table_state_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_address_lookup_table_state", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "uninitialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "lookup_table", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_address_lookup_table_walk( w, &self->inner.lookup_table, fun, "lookup_table", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_address_lookup_table_state", level-- );
}
ulong fd_address_lookup_table_state_size( fd_address_lookup_table_state_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_address_lookup_table_size( &self->inner.lookup_table );
    break;
  }
  }
  return size;
}

int fd_address_lookup_table_state_inner_encode( fd_address_lookup_table_state_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_address_lookup_table_encode( &self->lookup_table, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_address_lookup_table_state_encode( fd_address_lookup_table_state_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_address_lookup_table_state_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_gossip_bitvec_u8_inner_encode( fd_gossip_bitvec_u8_inner_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->vec_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->vec_len ) {
    err = fd_bincode_bytes_encode( self->vec, self->vec_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_bitvec_u8_inner_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_bitvec_u8_inner_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_bitvec_u8_inner_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_bitvec_u8_inner_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong vec_len;
  err = fd_bincode_uint64_decode( &vec_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( vec_len ) {
    *total_sz += 8UL + vec_len;
    err = fd_bincode_bytes_decode_footprint( vec_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_gossip_bitvec_u8_inner_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_inner_t * self = (fd_gossip_bitvec_u8_inner_t *)mem;
  fd_gossip_bitvec_u8_inner_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u8_inner_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u8_inner_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u8_inner_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_inner_t * self = (fd_gossip_bitvec_u8_inner_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->vec_len, ctx );
  if( self->vec_len ) {
    self->vec = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->vec, self->vec_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->vec_len;
  } else
    self->vec = NULL;
}
void * fd_gossip_bitvec_u8_inner_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_inner_global_t * self = (fd_gossip_bitvec_u8_inner_global_t *)mem;
  fd_gossip_bitvec_u8_inner_new( (fd_gossip_bitvec_u8_inner_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u8_inner_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u8_inner_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u8_inner_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_inner_global_t * self = (fd_gossip_bitvec_u8_inner_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->vec_len, ctx );
  if( self->vec_len ) {
    self->vec_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->vec_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->vec_len;
  } else
    self->vec_gaddr = 0UL;
}
int fd_gossip_bitvec_u8_inner_convert_global_to_local( void const * global_self, fd_gossip_bitvec_u8_inner_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_bitvec_u8_inner_global_t const * mem = (fd_gossip_bitvec_u8_inner_global_t const *)global_self;
  self->vec_len = mem->vec_len;
  self->vec     = fd_wksp_laddr_fast( ctx->wksp, mem->vec_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_bitvec_u8_inner_new(fd_gossip_bitvec_u8_inner_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_bitvec_u8_inner_t) );
}
void fd_gossip_bitvec_u8_inner_destroy( fd_gossip_bitvec_u8_inner_t * self ) {
  if( self->vec ) {
    self->vec = NULL;
  }
}

ulong fd_gossip_bitvec_u8_inner_footprint( void ){ return FD_GOSSIP_BITVEC_U8_INNER_FOOTPRINT; }
ulong fd_gossip_bitvec_u8_inner_align( void ){ return FD_GOSSIP_BITVEC_U8_INNER_ALIGN; }

void fd_gossip_bitvec_u8_inner_walk( void * w, fd_gossip_bitvec_u8_inner_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_bitvec_u8_inner", level++ );
  fun(w, self->vec, "vec", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_bitvec_u8_inner", level-- );
}
ulong fd_gossip_bitvec_u8_inner_size( fd_gossip_bitvec_u8_inner_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->vec_len;
  } while(0);
  return size;
}

int fd_gossip_bitvec_u8_encode( fd_gossip_bitvec_u8_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_bool_encode( self->has_bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_bits ) {
    err = fd_gossip_bitvec_u8_inner_encode( &self->bits, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_bitvec_u8_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_bitvec_u8_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_bitvec_u8_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_bitvec_u8_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_gossip_bitvec_u8_inner_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_bitvec_u8_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_t * self = (fd_gossip_bitvec_u8_t *)mem;
  fd_gossip_bitvec_u8_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u8_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u8_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u8_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_t * self = (fd_gossip_bitvec_u8_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_bits = !!o;
    if( o ) {
      fd_gossip_bitvec_u8_inner_new( &self->bits );
      fd_gossip_bitvec_u8_inner_decode_inner( &self->bits, alloc_mem, ctx );
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
void * fd_gossip_bitvec_u8_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_global_t * self = (fd_gossip_bitvec_u8_global_t *)mem;
  fd_gossip_bitvec_u8_new( (fd_gossip_bitvec_u8_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u8_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u8_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u8_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u8_global_t * self = (fd_gossip_bitvec_u8_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_bits = !!o;
    if( o ) {
      fd_gossip_bitvec_u8_inner_new( &self->bits );
      fd_gossip_bitvec_u8_inner_decode_inner_global( &self->bits, alloc_mem, ctx );
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
int fd_gossip_bitvec_u8_convert_global_to_local( void const * global_self, fd_gossip_bitvec_u8_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_bitvec_u8_global_t const * mem = (fd_gossip_bitvec_u8_global_t const *)global_self;
  self->bits = mem->bits;
  self->has_bits = mem->has_bits;
  self->len = mem->len;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_bitvec_u8_new(fd_gossip_bitvec_u8_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_bitvec_u8_t) );
}
void fd_gossip_bitvec_u8_destroy( fd_gossip_bitvec_u8_t * self ) {
  if( self->has_bits ) {
    fd_gossip_bitvec_u8_inner_destroy( &self->bits );
    self->has_bits = 0;
  }
}

ulong fd_gossip_bitvec_u8_footprint( void ){ return FD_GOSSIP_BITVEC_U8_FOOTPRINT; }
ulong fd_gossip_bitvec_u8_align( void ){ return FD_GOSSIP_BITVEC_U8_ALIGN; }

void fd_gossip_bitvec_u8_walk( void * w, fd_gossip_bitvec_u8_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_bitvec_u8", level++ );
  if( !self->has_bits ) {
    fun( w, NULL, "bits", FD_FLAMENCO_TYPE_NULL, "gossip_bitvec_u8_inner", level );
  } else {
    fd_gossip_bitvec_u8_inner_walk( w, &self->bits, fun, "bits", level );
  }
  fun( w, &self->len, "len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_bitvec_u8", level-- );
}
ulong fd_gossip_bitvec_u8_size( fd_gossip_bitvec_u8_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( self->has_bits ) {
    size += fd_gossip_bitvec_u8_inner_size( &self->bits );
  }
  size += sizeof(ulong);
  return size;
}

int fd_gossip_bitvec_u64_inner_encode( fd_gossip_bitvec_u64_inner_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->vec_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->vec_len ) {
    for( ulong i=0; i < self->vec_len; i++ ) {
      err = fd_bincode_uint64_encode( self->vec[i], ctx );
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_bitvec_u64_inner_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_bitvec_u64_inner_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_bitvec_u64_inner_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_bitvec_u64_inner_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong vec_len;
  err = fd_bincode_uint64_decode( &vec_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( vec_len ) {
    *total_sz += 8UL + sizeof(ulong)*vec_len;
    for( ulong i=0; i < vec_len; i++ ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_gossip_bitvec_u64_inner_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_inner_t * self = (fd_gossip_bitvec_u64_inner_t *)mem;
  fd_gossip_bitvec_u64_inner_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u64_inner_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u64_inner_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u64_inner_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_inner_t * self = (fd_gossip_bitvec_u64_inner_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->vec_len, ctx );
  if( self->vec_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->vec = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->vec_len;
    for( ulong i=0; i < self->vec_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( self->vec + i, ctx );
    }
  } else
    self->vec = NULL;
}
void * fd_gossip_bitvec_u64_inner_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_inner_global_t * self = (fd_gossip_bitvec_u64_inner_global_t *)mem;
  fd_gossip_bitvec_u64_inner_new( (fd_gossip_bitvec_u64_inner_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u64_inner_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u64_inner_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u64_inner_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_inner_global_t * self = (fd_gossip_bitvec_u64_inner_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->vec_len, ctx );
  if( self->vec_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->vec_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->vec_len;
    for( ulong i=0; i < self->vec_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( (ulong*)(cur_mem + sizeof(ulong) * i), ctx );
    }
  } else
    self->vec_gaddr = 0UL;
}
int fd_gossip_bitvec_u64_inner_convert_global_to_local( void const * global_self, fd_gossip_bitvec_u64_inner_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_bitvec_u64_inner_global_t const * mem = (fd_gossip_bitvec_u64_inner_global_t const *)global_self;
  self->vec_len = mem->vec_len;
  self->vec     = fd_wksp_laddr_fast( ctx->wksp, mem->vec_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_bitvec_u64_inner_new(fd_gossip_bitvec_u64_inner_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_bitvec_u64_inner_t) );
}
void fd_gossip_bitvec_u64_inner_destroy( fd_gossip_bitvec_u64_inner_t * self ) {
  if( self->vec ) {
    self->vec = NULL;
  }
}

ulong fd_gossip_bitvec_u64_inner_footprint( void ){ return FD_GOSSIP_BITVEC_U64_INNER_FOOTPRINT; }
ulong fd_gossip_bitvec_u64_inner_align( void ){ return FD_GOSSIP_BITVEC_U64_INNER_ALIGN; }

void fd_gossip_bitvec_u64_inner_walk( void * w, fd_gossip_bitvec_u64_inner_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_bitvec_u64_inner", level++ );
  if( self->vec_len ) {
    fun( w, NULL, "vec", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->vec_len; i++ )
      fun( w, self->vec + i, "vec", FD_FLAMENCO_TYPE_ULONG,   "ulong",   level );
    fun( w, NULL, "vec", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_bitvec_u64_inner", level-- );
}
ulong fd_gossip_bitvec_u64_inner_size( fd_gossip_bitvec_u64_inner_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->vec_len * sizeof(ulong);
  } while(0);
  return size;
}

int fd_gossip_bitvec_u64_encode( fd_gossip_bitvec_u64_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_bool_encode( self->has_bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_bits ) {
    err = fd_gossip_bitvec_u64_inner_encode( &self->bits, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_bitvec_u64_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_bitvec_u64_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_bitvec_u64_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_bitvec_u64_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_gossip_bitvec_u64_inner_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_bitvec_u64_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_t * self = (fd_gossip_bitvec_u64_t *)mem;
  fd_gossip_bitvec_u64_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u64_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u64_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u64_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_t * self = (fd_gossip_bitvec_u64_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_bits = !!o;
    if( o ) {
      fd_gossip_bitvec_u64_inner_new( &self->bits );
      fd_gossip_bitvec_u64_inner_decode_inner( &self->bits, alloc_mem, ctx );
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
void * fd_gossip_bitvec_u64_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_global_t * self = (fd_gossip_bitvec_u64_global_t *)mem;
  fd_gossip_bitvec_u64_new( (fd_gossip_bitvec_u64_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_bitvec_u64_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_bitvec_u64_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_bitvec_u64_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_bitvec_u64_global_t * self = (fd_gossip_bitvec_u64_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_bits = !!o;
    if( o ) {
      fd_gossip_bitvec_u64_inner_new( &self->bits );
      fd_gossip_bitvec_u64_inner_decode_inner_global( &self->bits, alloc_mem, ctx );
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
int fd_gossip_bitvec_u64_convert_global_to_local( void const * global_self, fd_gossip_bitvec_u64_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_bitvec_u64_global_t const * mem = (fd_gossip_bitvec_u64_global_t const *)global_self;
  self->bits = mem->bits;
  self->has_bits = mem->has_bits;
  self->len = mem->len;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_bitvec_u64_new(fd_gossip_bitvec_u64_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_bitvec_u64_t) );
}
void fd_gossip_bitvec_u64_destroy( fd_gossip_bitvec_u64_t * self ) {
  if( self->has_bits ) {
    fd_gossip_bitvec_u64_inner_destroy( &self->bits );
    self->has_bits = 0;
  }
}

ulong fd_gossip_bitvec_u64_footprint( void ){ return FD_GOSSIP_BITVEC_U64_FOOTPRINT; }
ulong fd_gossip_bitvec_u64_align( void ){ return FD_GOSSIP_BITVEC_U64_ALIGN; }

void fd_gossip_bitvec_u64_walk( void * w, fd_gossip_bitvec_u64_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_bitvec_u64", level++ );
  if( !self->has_bits ) {
    fun( w, NULL, "bits", FD_FLAMENCO_TYPE_NULL, "gossip_bitvec_u64_inner", level );
  } else {
    fd_gossip_bitvec_u64_inner_walk( w, &self->bits, fun, "bits", level );
  }
  fun( w, &self->len, "len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_bitvec_u64", level-- );
}
ulong fd_gossip_bitvec_u64_size( fd_gossip_bitvec_u64_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( self->has_bits ) {
    size += fd_gossip_bitvec_u64_inner_size( &self->bits );
  }
  size += sizeof(ulong);
  return size;
}

int fd_gossip_ping_encode( fd_gossip_ping_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->token, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_signature_encode( &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_ping_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_ping_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_ping_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_ping_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_signature_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_ping_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ping_t * self = (fd_gossip_ping_t *)mem;
  fd_gossip_ping_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_ping_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_ping_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_ping_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ping_t * self = (fd_gossip_ping_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_hash_decode_inner( &self->token, alloc_mem, ctx );
  fd_signature_decode_inner( &self->signature, alloc_mem, ctx );
}
void * fd_gossip_ping_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ping_global_t * self = (fd_gossip_ping_global_t *)mem;
  fd_gossip_ping_new( (fd_gossip_ping_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_ping_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_ping_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_ping_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ping_global_t * self = (fd_gossip_ping_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_hash_decode_inner_global( &self->token, alloc_mem, ctx );
  fd_signature_decode_inner_global( &self->signature, alloc_mem, ctx );
}
int fd_gossip_ping_convert_global_to_local( void const * global_self, fd_gossip_ping_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_ping_global_t const * mem = (fd_gossip_ping_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_convert_global_to_local( &mem->token, &self->token, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_signature_convert_global_to_local( &mem->signature, &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_ping_new(fd_gossip_ping_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_ping_t) );
  fd_pubkey_new( &self->from );
  fd_hash_new( &self->token );
  fd_signature_new( &self->signature );
}
void fd_gossip_ping_destroy( fd_gossip_ping_t * self ) {
  fd_pubkey_destroy( &self->from );
  fd_hash_destroy( &self->token );
  fd_signature_destroy( &self->signature );
}

ulong fd_gossip_ping_footprint( void ){ return FD_GOSSIP_PING_FOOTPRINT; }
ulong fd_gossip_ping_align( void ){ return FD_GOSSIP_PING_ALIGN; }

void fd_gossip_ping_walk( void * w, fd_gossip_ping_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_ping", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fd_hash_walk( w, &self->token, fun, "token", level );
  fd_signature_walk( w, &self->signature, fun, "signature", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_ping", level-- );
}
ulong fd_gossip_ping_size( fd_gossip_ping_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += fd_hash_size( &self->token );
  size += fd_signature_size( &self->signature );
  return size;
}

FD_FN_PURE uchar fd_gossip_ip_addr_is_ip4(fd_gossip_ip_addr_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_gossip_ip_addr_is_ip6(fd_gossip_ip_addr_t const * self) {
  return self->discriminant == 1;
}
void fd_gossip_ip_addr_inner_new( fd_gossip_ip_addr_inner_t * self, uint discriminant );
int fd_gossip_ip_addr_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_ip4_addr_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_gossip_ip6_addr_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_gossip_ip_addr_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_ip_addr_t);
  void const * start_data = ctx->data;
  int err =  fd_gossip_ip_addr_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_ip_addr_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_ip_addr_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_gossip_ip_addr_inner_decode_inner( fd_gossip_ip_addr_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_ip4_addr_decode_inner( &self->ip4, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_ip6_addr_decode_inner( &self->ip6, alloc_mem, ctx );
    break;
  }
  }
}
void fd_gossip_ip_addr_inner_decode_inner_global( fd_gossip_ip_addr_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_ip4_addr_decode_inner_global( &self->ip4, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_ip6_addr_decode_inner_global( &self->ip6, alloc_mem, ctx );
    break;
  }
  }
}
int fd_gossip_ip_addr_convert_global_to_local_inner( fd_gossip_ip_addr_inner_global_t const * mem, fd_gossip_ip_addr_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_gossip_ip4_addr_convert_global_to_local( &mem->ip4, &self->ip4, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_ip6_addr_convert_global_to_local( &mem->ip6, &self->ip6, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_ip_addr_convert_global_to_local( void const * global_self, fd_gossip_ip_addr_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ip_addr_global_t const * mem = (fd_gossip_ip_addr_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_gossip_ip_addr_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_ip_addr_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ip_addr_t * self = (fd_gossip_ip_addr_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_ip_addr_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_gossip_ip_addr_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ip_addr_t * self = (fd_gossip_ip_addr_t *)mem;
  fd_gossip_ip_addr_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_ip_addr_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_ip_addr_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_gossip_ip_addr_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ip_addr_t * self = (fd_gossip_ip_addr_t *)mem;
  fd_gossip_ip_addr_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_ip_addr_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_ip_addr_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_ip_addr_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_ip_addr_global_t * self = (fd_gossip_ip_addr_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_ip_addr_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_gossip_ip_addr_inner_new( fd_gossip_ip_addr_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_ip4_addr_new( &self->ip4 );
    break;
  }
  case 1: {
    fd_gossip_ip6_addr_new( &self->ip6 );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_gossip_ip_addr_new_disc( fd_gossip_ip_addr_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_gossip_ip_addr_inner_new( &self->inner, self->discriminant );
}
void fd_gossip_ip_addr_new( fd_gossip_ip_addr_t * self ) {
  fd_memset( self, 0, sizeof(fd_gossip_ip_addr_t) );
  fd_gossip_ip_addr_new_disc( self, UINT_MAX );
}
void fd_gossip_ip_addr_inner_destroy( fd_gossip_ip_addr_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_ip4_addr_destroy( &self->ip4 );
    break;
  }
  case 1: {
    fd_gossip_ip6_addr_destroy( &self->ip6 );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_gossip_ip_addr_destroy( fd_gossip_ip_addr_t * self ) {
  fd_gossip_ip_addr_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_gossip_ip_addr_footprint( void ){ return FD_GOSSIP_IP_ADDR_FOOTPRINT; }
ulong fd_gossip_ip_addr_align( void ){ return FD_GOSSIP_IP_ADDR_ALIGN; }

void fd_gossip_ip_addr_walk( void * w, fd_gossip_ip_addr_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_gossip_ip_addr", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "ip4", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_ip4_addr_walk( w, &self->inner.ip4, fun, "ip4", level );
    break;
  }
  case 1: {
    fun( w, self, "ip6", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_ip6_addr_walk( w, &self->inner.ip6, fun, "ip6", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_gossip_ip_addr", level-- );
}
ulong fd_gossip_ip_addr_size( fd_gossip_ip_addr_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_gossip_ip4_addr_size( &self->inner.ip4 );
    break;
  }
  case 1: {
    size += fd_gossip_ip6_addr_size( &self->inner.ip6 );
    break;
  }
  }
  return size;
}

int fd_gossip_ip_addr_inner_encode( fd_gossip_ip_addr_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_ip4_addr_encode( &self->ip4, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_ip6_addr_encode( &self->ip6, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_ip_addr_encode( fd_gossip_ip_addr_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_ip_addr_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_gossip_prune_data_encode( fd_gossip_prune_data_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->prunes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->prunes_len ) {
    for( ulong i=0; i < self->prunes_len; i++ ) {
      err = fd_pubkey_encode( self->prunes + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_signature_encode( &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->destination, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_prune_data_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_prune_data_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_prune_data_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_prune_data_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong prunes_len;
  err = fd_bincode_uint64_decode( &prunes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( prunes_len ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT*prunes_len;
    for( ulong i=0; i < prunes_len; i++ ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_signature_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_prune_data_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_data_t * self = (fd_gossip_prune_data_t *)mem;
  fd_gossip_prune_data_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_data_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_data_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_data_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_data_t * self = (fd_gossip_prune_data_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prunes_len, ctx );
  if( self->prunes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->prunes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->prunes_len;
    for( ulong i=0; i < self->prunes_len; i++ ) {
      fd_pubkey_new( self->prunes + i );
      fd_pubkey_decode_inner( self->prunes + i, alloc_mem, ctx );
    }
  } else
    self->prunes = NULL;
  fd_signature_decode_inner( &self->signature, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->destination, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_prune_data_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_data_global_t * self = (fd_gossip_prune_data_global_t *)mem;
  fd_gossip_prune_data_new( (fd_gossip_prune_data_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_data_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_data_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_data_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_data_global_t * self = (fd_gossip_prune_data_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prunes_len, ctx );
  if( self->prunes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->prunes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->prunes_len;
    for( ulong i=0; i < self->prunes_len; i++ ) {
      fd_pubkey_new( (fd_pubkey_t *)(cur_mem + FD_PUBKEY_FOOTPRINT * i) );
      fd_pubkey_decode_inner_global( cur_mem + FD_PUBKEY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->prunes_gaddr = 0UL;
  fd_signature_decode_inner_global( &self->signature, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->destination, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_prune_data_convert_global_to_local( void const * global_self, fd_gossip_prune_data_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_prune_data_global_t const * mem = (fd_gossip_prune_data_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->prunes_len = mem->prunes_len;
  self->prunes     = fd_wksp_laddr_fast( ctx->wksp, mem->prunes_gaddr );
  err = fd_signature_convert_global_to_local( &mem->signature, &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->destination, &self->destination, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_prune_data_new(fd_gossip_prune_data_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_prune_data_t) );
  fd_pubkey_new( &self->pubkey );
  fd_signature_new( &self->signature );
  fd_pubkey_new( &self->destination );
}
void fd_gossip_prune_data_destroy( fd_gossip_prune_data_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  if( self->prunes ) {
    for( ulong i=0; i < self->prunes_len; i++ )
      fd_pubkey_destroy( self->prunes + i );
    self->prunes = NULL;
  }
  fd_signature_destroy( &self->signature );
  fd_pubkey_destroy( &self->destination );
}

ulong fd_gossip_prune_data_footprint( void ){ return FD_GOSSIP_PRUNE_DATA_FOOTPRINT; }
ulong fd_gossip_prune_data_align( void ){ return FD_GOSSIP_PRUNE_DATA_ALIGN; }

void fd_gossip_prune_data_walk( void * w, fd_gossip_prune_data_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_prune_data", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  if( self->prunes_len ) {
    fun( w, NULL, "prunes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->prunes_len; i++ )
      fd_pubkey_walk(w, self->prunes + i, fun, "pubkey", level );
    fun( w, NULL, "prunes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fd_signature_walk( w, &self->signature, fun, "signature", level );
  fd_pubkey_walk( w, &self->destination, fun, "destination", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_prune_data", level-- );
}
ulong fd_gossip_prune_data_size( fd_gossip_prune_data_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->prunes_len; i++ )
      size += fd_pubkey_size( self->prunes + i );
  } while(0);
  size += fd_signature_size( &self->signature );
  size += fd_pubkey_size( &self->destination );
  size += sizeof(ulong);
  return size;
}

int fd_gossip_prune_sign_data_encode( fd_gossip_prune_sign_data_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->prunes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->prunes_len ) {
    for( ulong i=0; i < self->prunes_len; i++ ) {
      err = fd_pubkey_encode( self->prunes + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_pubkey_encode( &self->destination, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_prune_sign_data_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_prune_sign_data_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_prune_sign_data_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_prune_sign_data_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong prunes_len;
  err = fd_bincode_uint64_decode( &prunes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( prunes_len ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT*prunes_len;
    for( ulong i=0; i < prunes_len; i++ ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_prune_sign_data_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_t * self = (fd_gossip_prune_sign_data_t *)mem;
  fd_gossip_prune_sign_data_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_sign_data_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_sign_data_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_sign_data_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_t * self = (fd_gossip_prune_sign_data_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prunes_len, ctx );
  if( self->prunes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->prunes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->prunes_len;
    for( ulong i=0; i < self->prunes_len; i++ ) {
      fd_pubkey_new( self->prunes + i );
      fd_pubkey_decode_inner( self->prunes + i, alloc_mem, ctx );
    }
  } else
    self->prunes = NULL;
  fd_pubkey_decode_inner( &self->destination, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_prune_sign_data_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_global_t * self = (fd_gossip_prune_sign_data_global_t *)mem;
  fd_gossip_prune_sign_data_new( (fd_gossip_prune_sign_data_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_sign_data_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_sign_data_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_sign_data_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_global_t * self = (fd_gossip_prune_sign_data_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->prunes_len, ctx );
  if( self->prunes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->prunes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->prunes_len;
    for( ulong i=0; i < self->prunes_len; i++ ) {
      fd_pubkey_new( (fd_pubkey_t *)(cur_mem + FD_PUBKEY_FOOTPRINT * i) );
      fd_pubkey_decode_inner_global( cur_mem + FD_PUBKEY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->prunes_gaddr = 0UL;
  fd_pubkey_decode_inner_global( &self->destination, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_prune_sign_data_convert_global_to_local( void const * global_self, fd_gossip_prune_sign_data_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_prune_sign_data_global_t const * mem = (fd_gossip_prune_sign_data_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->prunes_len = mem->prunes_len;
  self->prunes     = fd_wksp_laddr_fast( ctx->wksp, mem->prunes_gaddr );
  err = fd_pubkey_convert_global_to_local( &mem->destination, &self->destination, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_prune_sign_data_new(fd_gossip_prune_sign_data_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_prune_sign_data_t) );
  fd_pubkey_new( &self->pubkey );
  fd_pubkey_new( &self->destination );
}
void fd_gossip_prune_sign_data_destroy( fd_gossip_prune_sign_data_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  if( self->prunes ) {
    for( ulong i=0; i < self->prunes_len; i++ )
      fd_pubkey_destroy( self->prunes + i );
    self->prunes = NULL;
  }
  fd_pubkey_destroy( &self->destination );
}

ulong fd_gossip_prune_sign_data_footprint( void ){ return FD_GOSSIP_PRUNE_SIGN_DATA_FOOTPRINT; }
ulong fd_gossip_prune_sign_data_align( void ){ return FD_GOSSIP_PRUNE_SIGN_DATA_ALIGN; }

void fd_gossip_prune_sign_data_walk( void * w, fd_gossip_prune_sign_data_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_prune_sign_data", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  if( self->prunes_len ) {
    fun( w, NULL, "prunes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->prunes_len; i++ )
      fd_pubkey_walk(w, self->prunes + i, fun, "pubkey", level );
    fun( w, NULL, "prunes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fd_pubkey_walk( w, &self->destination, fun, "destination", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_prune_sign_data", level-- );
}
ulong fd_gossip_prune_sign_data_size( fd_gossip_prune_sign_data_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->prunes_len; i++ )
      size += fd_pubkey_size( self->prunes + i );
  } while(0);
  size += fd_pubkey_size( &self->destination );
  size += sizeof(ulong);
  return size;
}

int fd_gossip_prune_sign_data_with_prefix_encode( fd_gossip_prune_sign_data_with_prefix_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->prefix_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->prefix_len ) {
    err = fd_bincode_bytes_encode( self->prefix, self->prefix_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_gossip_prune_sign_data_encode( &self->data, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_prune_sign_data_with_prefix_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_prune_sign_data_with_prefix_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_prune_sign_data_with_prefix_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_prune_sign_data_with_prefix_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong prefix_len;
  err = fd_bincode_uint64_decode( &prefix_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  *total_sz += prefix_len;
  if( prefix_len ) {
    err = fd_bincode_bytes_decode_footprint( prefix_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = !fd_utf8_verify( (char const *) ctx->data - prefix_len, prefix_len );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  err = fd_gossip_prune_sign_data_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_prune_sign_data_with_prefix_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_with_prefix_t * self = (fd_gossip_prune_sign_data_with_prefix_t *)mem;
  fd_gossip_prune_sign_data_with_prefix_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_sign_data_with_prefix_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_sign_data_with_prefix_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_sign_data_with_prefix_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_with_prefix_t * self = (fd_gossip_prune_sign_data_with_prefix_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->prefix_len, ctx );
  if( self->prefix_len ) {
    self->prefix = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->prefix, self->prefix_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->prefix_len;
  } else
    self->prefix = NULL;
  fd_gossip_prune_sign_data_decode_inner( &self->data, alloc_mem, ctx );
}
void * fd_gossip_prune_sign_data_with_prefix_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_with_prefix_global_t * self = (fd_gossip_prune_sign_data_with_prefix_global_t *)mem;
  fd_gossip_prune_sign_data_with_prefix_new( (fd_gossip_prune_sign_data_with_prefix_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_sign_data_with_prefix_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_sign_data_with_prefix_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_sign_data_with_prefix_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_sign_data_with_prefix_global_t * self = (fd_gossip_prune_sign_data_with_prefix_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->prefix_len, ctx );
  if( self->prefix_len ) {
    self->prefix_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->prefix_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->prefix_len;
  } else
    self->prefix_gaddr = 0UL;
  fd_gossip_prune_sign_data_decode_inner_global( &self->data, alloc_mem, ctx );
}
int fd_gossip_prune_sign_data_with_prefix_convert_global_to_local( void const * global_self, fd_gossip_prune_sign_data_with_prefix_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_prune_sign_data_with_prefix_global_t const * mem = (fd_gossip_prune_sign_data_with_prefix_global_t const *)global_self;
  self->prefix_len = mem->prefix_len;
  self->prefix     = fd_wksp_laddr_fast( ctx->wksp, mem->prefix_gaddr );
  err = fd_gossip_prune_sign_data_convert_global_to_local( &mem->data, &self->data, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_prune_sign_data_with_prefix_new(fd_gossip_prune_sign_data_with_prefix_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_prune_sign_data_with_prefix_t) );
  fd_gossip_prune_sign_data_new( &self->data );
}
void fd_gossip_prune_sign_data_with_prefix_destroy( fd_gossip_prune_sign_data_with_prefix_t * self ) {
  if( self->prefix ) {
    self->prefix = NULL;
  }
  fd_gossip_prune_sign_data_destroy( &self->data );
}

ulong fd_gossip_prune_sign_data_with_prefix_footprint( void ){ return FD_GOSSIP_PRUNE_SIGN_DATA_WITH_PREFIX_FOOTPRINT; }
ulong fd_gossip_prune_sign_data_with_prefix_align( void ){ return FD_GOSSIP_PRUNE_SIGN_DATA_WITH_PREFIX_ALIGN; }

void fd_gossip_prune_sign_data_with_prefix_walk( void * w, fd_gossip_prune_sign_data_with_prefix_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_prune_sign_data_with_prefix", level++ );
  fun(w, self->prefix, "prefix", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_gossip_prune_sign_data_walk( w, &self->data, fun, "data", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_prune_sign_data_with_prefix", level-- );
}
ulong fd_gossip_prune_sign_data_with_prefix_size( fd_gossip_prune_sign_data_with_prefix_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->prefix_len;
  } while(0);
  size += fd_gossip_prune_sign_data_size( &self->data );
  return size;
}

int fd_gossip_socket_addr_old_encode( fd_gossip_socket_addr_old_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_gossip_ip_addr_encode( &self->addr, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->port, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_socket_addr_old_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_socket_addr_old_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_socket_addr_old_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_socket_addr_old_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_gossip_ip_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_socket_addr_old_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_old_t * self = (fd_gossip_socket_addr_old_t *)mem;
  fd_gossip_socket_addr_old_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_old_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_old_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_old_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_old_t * self = (fd_gossip_socket_addr_old_t *)struct_mem;
  fd_gossip_ip_addr_decode_inner( &self->addr, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->port, ctx );
}
void * fd_gossip_socket_addr_old_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_old_global_t * self = (fd_gossip_socket_addr_old_global_t *)mem;
  fd_gossip_socket_addr_old_new( (fd_gossip_socket_addr_old_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_old_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_old_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_old_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_old_global_t * self = (fd_gossip_socket_addr_old_global_t *)struct_mem;
  fd_gossip_ip_addr_decode_inner_global( &self->addr, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->port, ctx );
}
int fd_gossip_socket_addr_old_convert_global_to_local( void const * global_self, fd_gossip_socket_addr_old_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_socket_addr_old_global_t const * mem = (fd_gossip_socket_addr_old_global_t const *)global_self;
  err = fd_gossip_ip_addr_convert_global_to_local( &mem->addr, &self->addr, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->port = mem->port;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_socket_addr_old_new(fd_gossip_socket_addr_old_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_socket_addr_old_t) );
  fd_gossip_ip_addr_new( &self->addr );
}
void fd_gossip_socket_addr_old_destroy( fd_gossip_socket_addr_old_t * self ) {
  fd_gossip_ip_addr_destroy( &self->addr );
}

ulong fd_gossip_socket_addr_old_footprint( void ){ return FD_GOSSIP_SOCKET_ADDR_OLD_FOOTPRINT; }
ulong fd_gossip_socket_addr_old_align( void ){ return FD_GOSSIP_SOCKET_ADDR_OLD_ALIGN; }

void fd_gossip_socket_addr_old_walk( void * w, fd_gossip_socket_addr_old_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_socket_addr_old", level++ );
  fd_gossip_ip_addr_walk( w, &self->addr, fun, "addr", level );
  fun( w, &self->port, "port", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_socket_addr_old", level-- );
}
ulong fd_gossip_socket_addr_old_size( fd_gossip_socket_addr_old_t const * self ) {
  ulong size = 0;
  size += fd_gossip_ip_addr_size( &self->addr );
  size += sizeof(ushort);
  return size;
}

int fd_gossip_socket_addr_ip4_encode( fd_gossip_socket_addr_ip4_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_gossip_ip4_addr_encode( &self->addr, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->port, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_socket_addr_ip4_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_socket_addr_ip4_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_socket_addr_ip4_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_socket_addr_ip4_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_gossip_ip4_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_socket_addr_ip4_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip4_t * self = (fd_gossip_socket_addr_ip4_t *)mem;
  fd_gossip_socket_addr_ip4_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_ip4_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_ip4_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_ip4_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip4_t * self = (fd_gossip_socket_addr_ip4_t *)struct_mem;
  fd_gossip_ip4_addr_decode_inner( &self->addr, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->port, ctx );
}
void * fd_gossip_socket_addr_ip4_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip4_global_t * self = (fd_gossip_socket_addr_ip4_global_t *)mem;
  fd_gossip_socket_addr_ip4_new( (fd_gossip_socket_addr_ip4_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_ip4_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_ip4_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_ip4_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip4_global_t * self = (fd_gossip_socket_addr_ip4_global_t *)struct_mem;
  fd_gossip_ip4_addr_decode_inner_global( &self->addr, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->port, ctx );
}
int fd_gossip_socket_addr_ip4_convert_global_to_local( void const * global_self, fd_gossip_socket_addr_ip4_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_socket_addr_ip4_global_t const * mem = (fd_gossip_socket_addr_ip4_global_t const *)global_self;
  err = fd_gossip_ip4_addr_convert_global_to_local( &mem->addr, &self->addr, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->port = mem->port;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_socket_addr_ip4_new(fd_gossip_socket_addr_ip4_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_socket_addr_ip4_t) );
  fd_gossip_ip4_addr_new( &self->addr );
}
void fd_gossip_socket_addr_ip4_destroy( fd_gossip_socket_addr_ip4_t * self ) {
  fd_gossip_ip4_addr_destroy( &self->addr );
}

ulong fd_gossip_socket_addr_ip4_footprint( void ){ return FD_GOSSIP_SOCKET_ADDR_IP4_FOOTPRINT; }
ulong fd_gossip_socket_addr_ip4_align( void ){ return FD_GOSSIP_SOCKET_ADDR_IP4_ALIGN; }

void fd_gossip_socket_addr_ip4_walk( void * w, fd_gossip_socket_addr_ip4_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_socket_addr_ip4", level++ );
  fd_gossip_ip4_addr_walk( w, &self->addr, fun, "addr", level );
  fun( w, &self->port, "port", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_socket_addr_ip4", level-- );
}
ulong fd_gossip_socket_addr_ip4_size( fd_gossip_socket_addr_ip4_t const * self ) {
  ulong size = 0;
  size += fd_gossip_ip4_addr_size( &self->addr );
  size += sizeof(ushort);
  return size;
}

int fd_gossip_socket_addr_ip6_encode( fd_gossip_socket_addr_ip6_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_gossip_ip6_addr_encode( &self->addr, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->port, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->flowinfo, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->scope_id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_socket_addr_ip6_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_socket_addr_ip6_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_socket_addr_ip6_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_socket_addr_ip6_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_gossip_ip6_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_socket_addr_ip6_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip6_t * self = (fd_gossip_socket_addr_ip6_t *)mem;
  fd_gossip_socket_addr_ip6_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_ip6_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_ip6_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_ip6_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip6_t * self = (fd_gossip_socket_addr_ip6_t *)struct_mem;
  fd_gossip_ip6_addr_decode_inner( &self->addr, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->port, ctx );
  fd_bincode_uint32_decode_unsafe( &self->flowinfo, ctx );
  fd_bincode_uint32_decode_unsafe( &self->scope_id, ctx );
}
void * fd_gossip_socket_addr_ip6_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip6_global_t * self = (fd_gossip_socket_addr_ip6_global_t *)mem;
  fd_gossip_socket_addr_ip6_new( (fd_gossip_socket_addr_ip6_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_ip6_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_ip6_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_ip6_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_ip6_global_t * self = (fd_gossip_socket_addr_ip6_global_t *)struct_mem;
  fd_gossip_ip6_addr_decode_inner_global( &self->addr, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->port, ctx );
  fd_bincode_uint32_decode_unsafe( &self->flowinfo, ctx );
  fd_bincode_uint32_decode_unsafe( &self->scope_id, ctx );
}
int fd_gossip_socket_addr_ip6_convert_global_to_local( void const * global_self, fd_gossip_socket_addr_ip6_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_socket_addr_ip6_global_t const * mem = (fd_gossip_socket_addr_ip6_global_t const *)global_self;
  err = fd_gossip_ip6_addr_convert_global_to_local( &mem->addr, &self->addr, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->port = mem->port;
  self->flowinfo = mem->flowinfo;
  self->scope_id = mem->scope_id;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_socket_addr_ip6_new(fd_gossip_socket_addr_ip6_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_socket_addr_ip6_t) );
  fd_gossip_ip6_addr_new( &self->addr );
}
void fd_gossip_socket_addr_ip6_destroy( fd_gossip_socket_addr_ip6_t * self ) {
  fd_gossip_ip6_addr_destroy( &self->addr );
}

ulong fd_gossip_socket_addr_ip6_footprint( void ){ return FD_GOSSIP_SOCKET_ADDR_IP6_FOOTPRINT; }
ulong fd_gossip_socket_addr_ip6_align( void ){ return FD_GOSSIP_SOCKET_ADDR_IP6_ALIGN; }

void fd_gossip_socket_addr_ip6_walk( void * w, fd_gossip_socket_addr_ip6_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_socket_addr_ip6", level++ );
  fd_gossip_ip6_addr_walk( w, &self->addr, fun, "addr", level );
  fun( w, &self->port, "port", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->flowinfo, "flowinfo", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, &self->scope_id, "scope_id", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_socket_addr_ip6", level-- );
}
ulong fd_gossip_socket_addr_ip6_size( fd_gossip_socket_addr_ip6_t const * self ) {
  ulong size = 0;
  size += fd_gossip_ip6_addr_size( &self->addr );
  size += sizeof(ushort);
  size += sizeof(uint);
  size += sizeof(uint);
  return size;
}

FD_FN_PURE uchar fd_gossip_socket_addr_is_ip4(fd_gossip_socket_addr_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_gossip_socket_addr_is_ip6(fd_gossip_socket_addr_t const * self) {
  return self->discriminant == 1;
}
void fd_gossip_socket_addr_inner_new( fd_gossip_socket_addr_inner_t * self, uint discriminant );
int fd_gossip_socket_addr_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_socket_addr_ip4_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_gossip_socket_addr_ip6_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_gossip_socket_addr_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_socket_addr_t);
  void const * start_data = ctx->data;
  int err =  fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_socket_addr_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_socket_addr_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_gossip_socket_addr_inner_decode_inner( fd_gossip_socket_addr_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_socket_addr_ip4_decode_inner( &self->ip4, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_socket_addr_ip6_decode_inner( &self->ip6, alloc_mem, ctx );
    break;
  }
  }
}
void fd_gossip_socket_addr_inner_decode_inner_global( fd_gossip_socket_addr_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_socket_addr_ip4_decode_inner_global( &self->ip4, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_socket_addr_ip6_decode_inner_global( &self->ip6, alloc_mem, ctx );
    break;
  }
  }
}
int fd_gossip_socket_addr_convert_global_to_local_inner( fd_gossip_socket_addr_inner_global_t const * mem, fd_gossip_socket_addr_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_gossip_socket_addr_ip4_convert_global_to_local( &mem->ip4, &self->ip4, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_socket_addr_ip6_convert_global_to_local( &mem->ip6, &self->ip6, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_socket_addr_convert_global_to_local( void const * global_self, fd_gossip_socket_addr_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_global_t const * mem = (fd_gossip_socket_addr_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_gossip_socket_addr_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_socket_addr_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_t * self = (fd_gossip_socket_addr_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_socket_addr_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_gossip_socket_addr_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_t * self = (fd_gossip_socket_addr_t *)mem;
  fd_gossip_socket_addr_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_gossip_socket_addr_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_t * self = (fd_gossip_socket_addr_t *)mem;
  fd_gossip_socket_addr_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_addr_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_addr_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_addr_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_addr_global_t * self = (fd_gossip_socket_addr_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_socket_addr_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_gossip_socket_addr_inner_new( fd_gossip_socket_addr_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_socket_addr_ip4_new( &self->ip4 );
    break;
  }
  case 1: {
    fd_gossip_socket_addr_ip6_new( &self->ip6 );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_gossip_socket_addr_new_disc( fd_gossip_socket_addr_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_gossip_socket_addr_inner_new( &self->inner, self->discriminant );
}
void fd_gossip_socket_addr_new( fd_gossip_socket_addr_t * self ) {
  fd_memset( self, 0, sizeof(fd_gossip_socket_addr_t) );
  fd_gossip_socket_addr_new_disc( self, UINT_MAX );
}
void fd_gossip_socket_addr_inner_destroy( fd_gossip_socket_addr_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_socket_addr_ip4_destroy( &self->ip4 );
    break;
  }
  case 1: {
    fd_gossip_socket_addr_ip6_destroy( &self->ip6 );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_gossip_socket_addr_destroy( fd_gossip_socket_addr_t * self ) {
  fd_gossip_socket_addr_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_gossip_socket_addr_footprint( void ){ return FD_GOSSIP_SOCKET_ADDR_FOOTPRINT; }
ulong fd_gossip_socket_addr_align( void ){ return FD_GOSSIP_SOCKET_ADDR_ALIGN; }

void fd_gossip_socket_addr_walk( void * w, fd_gossip_socket_addr_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_gossip_socket_addr", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "ip4", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_socket_addr_ip4_walk( w, &self->inner.ip4, fun, "ip4", level );
    break;
  }
  case 1: {
    fun( w, self, "ip6", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_socket_addr_ip6_walk( w, &self->inner.ip6, fun, "ip6", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_gossip_socket_addr", level-- );
}
ulong fd_gossip_socket_addr_size( fd_gossip_socket_addr_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_gossip_socket_addr_ip4_size( &self->inner.ip4 );
    break;
  }
  case 1: {
    size += fd_gossip_socket_addr_ip6_size( &self->inner.ip6 );
    break;
  }
  }
  return size;
}

int fd_gossip_socket_addr_inner_encode( fd_gossip_socket_addr_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_socket_addr_ip4_encode( &self->ip4, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_socket_addr_ip6_encode( &self->ip6, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_socket_addr_encode( fd_gossip_socket_addr_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_socket_addr_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_gossip_contact_info_v1_encode( fd_gossip_contact_info_v1_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->gossip, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->tvu, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->tvu_fwd, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->repair, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->tpu, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->tpu_fwd, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->tpu_vote, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->rpc, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->rpc_pubsub, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_encode( &self->serve_repair, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->shred_version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_contact_info_v1_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_contact_info_v1_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_contact_info_v1_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_contact_info_v1_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_contact_info_v1_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v1_t * self = (fd_gossip_contact_info_v1_t *)mem;
  fd_gossip_contact_info_v1_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_contact_info_v1_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_contact_info_v1_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_contact_info_v1_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v1_t * self = (fd_gossip_contact_info_v1_t *)struct_mem;
  fd_pubkey_decode_inner( &self->id, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->gossip, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->tvu, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->tvu_fwd, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->repair, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->tpu, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->tpu_fwd, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->tpu_vote, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->rpc, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->rpc_pubsub, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner( &self->serve_repair, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
}
void * fd_gossip_contact_info_v1_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v1_global_t * self = (fd_gossip_contact_info_v1_global_t *)mem;
  fd_gossip_contact_info_v1_new( (fd_gossip_contact_info_v1_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_contact_info_v1_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_contact_info_v1_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_contact_info_v1_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v1_global_t * self = (fd_gossip_contact_info_v1_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->id, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->gossip, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->tvu, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->tvu_fwd, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->repair, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->tpu, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->tpu_fwd, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->tpu_vote, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->rpc, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->rpc_pubsub, alloc_mem, ctx );
  fd_gossip_socket_addr_decode_inner_global( &self->serve_repair, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
}
int fd_gossip_contact_info_v1_convert_global_to_local( void const * global_self, fd_gossip_contact_info_v1_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_contact_info_v1_global_t const * mem = (fd_gossip_contact_info_v1_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->id, &self->id, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->gossip, &self->gossip, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->tvu, &self->tvu, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->tvu_fwd, &self->tvu_fwd, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->repair, &self->repair, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->tpu, &self->tpu, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->tpu_fwd, &self->tpu_fwd, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->tpu_vote, &self->tpu_vote, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->rpc, &self->rpc, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->rpc_pubsub, &self->rpc_pubsub, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_socket_addr_convert_global_to_local( &mem->serve_repair, &self->serve_repair, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->shred_version = mem->shred_version;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_contact_info_v1_new(fd_gossip_contact_info_v1_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_contact_info_v1_t) );
  fd_pubkey_new( &self->id );
  fd_gossip_socket_addr_new( &self->gossip );
  fd_gossip_socket_addr_new( &self->tvu );
  fd_gossip_socket_addr_new( &self->tvu_fwd );
  fd_gossip_socket_addr_new( &self->repair );
  fd_gossip_socket_addr_new( &self->tpu );
  fd_gossip_socket_addr_new( &self->tpu_fwd );
  fd_gossip_socket_addr_new( &self->tpu_vote );
  fd_gossip_socket_addr_new( &self->rpc );
  fd_gossip_socket_addr_new( &self->rpc_pubsub );
  fd_gossip_socket_addr_new( &self->serve_repair );
}
void fd_gossip_contact_info_v1_destroy( fd_gossip_contact_info_v1_t * self ) {
  fd_pubkey_destroy( &self->id );
  fd_gossip_socket_addr_destroy( &self->gossip );
  fd_gossip_socket_addr_destroy( &self->tvu );
  fd_gossip_socket_addr_destroy( &self->tvu_fwd );
  fd_gossip_socket_addr_destroy( &self->repair );
  fd_gossip_socket_addr_destroy( &self->tpu );
  fd_gossip_socket_addr_destroy( &self->tpu_fwd );
  fd_gossip_socket_addr_destroy( &self->tpu_vote );
  fd_gossip_socket_addr_destroy( &self->rpc );
  fd_gossip_socket_addr_destroy( &self->rpc_pubsub );
  fd_gossip_socket_addr_destroy( &self->serve_repair );
}

ulong fd_gossip_contact_info_v1_footprint( void ){ return FD_GOSSIP_CONTACT_INFO_V1_FOOTPRINT; }
ulong fd_gossip_contact_info_v1_align( void ){ return FD_GOSSIP_CONTACT_INFO_V1_ALIGN; }

void fd_gossip_contact_info_v1_walk( void * w, fd_gossip_contact_info_v1_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_contact_info_v1", level++ );
  fd_pubkey_walk( w, &self->id, fun, "id", level );
  fd_gossip_socket_addr_walk( w, &self->gossip, fun, "gossip", level );
  fd_gossip_socket_addr_walk( w, &self->tvu, fun, "tvu", level );
  fd_gossip_socket_addr_walk( w, &self->tvu_fwd, fun, "tvu_fwd", level );
  fd_gossip_socket_addr_walk( w, &self->repair, fun, "repair", level );
  fd_gossip_socket_addr_walk( w, &self->tpu, fun, "tpu", level );
  fd_gossip_socket_addr_walk( w, &self->tpu_fwd, fun, "tpu_fwd", level );
  fd_gossip_socket_addr_walk( w, &self->tpu_vote, fun, "tpu_vote", level );
  fd_gossip_socket_addr_walk( w, &self->rpc, fun, "rpc", level );
  fd_gossip_socket_addr_walk( w, &self->rpc_pubsub, fun, "rpc_pubsub", level );
  fd_gossip_socket_addr_walk( w, &self->serve_repair, fun, "serve_repair", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->shred_version, "shred_version", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_contact_info_v1", level-- );
}
ulong fd_gossip_contact_info_v1_size( fd_gossip_contact_info_v1_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->id );
  size += fd_gossip_socket_addr_size( &self->gossip );
  size += fd_gossip_socket_addr_size( &self->tvu );
  size += fd_gossip_socket_addr_size( &self->tvu_fwd );
  size += fd_gossip_socket_addr_size( &self->repair );
  size += fd_gossip_socket_addr_size( &self->tpu );
  size += fd_gossip_socket_addr_size( &self->tpu_fwd );
  size += fd_gossip_socket_addr_size( &self->tpu_vote );
  size += fd_gossip_socket_addr_size( &self->rpc );
  size += fd_gossip_socket_addr_size( &self->rpc_pubsub );
  size += fd_gossip_socket_addr_size( &self->serve_repair );
  size += sizeof(ulong);
  size += sizeof(ushort);
  return size;
}

int fd_gossip_vote_encode( fd_gossip_vote_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->index), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_flamenco_txn_encode( &self->txn, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_vote_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_vote_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_vote_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_vote_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_flamenco_txn_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_vote_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_vote_t * self = (fd_gossip_vote_t *)mem;
  fd_gossip_vote_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_vote_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_vote_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_vote_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_vote_t * self = (fd_gossip_vote_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->index, ctx );
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_flamenco_txn_decode_inner( &self->txn, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_vote_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_vote_global_t * self = (fd_gossip_vote_global_t *)mem;
  fd_gossip_vote_new( (fd_gossip_vote_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_vote_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_vote_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_vote_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_vote_global_t * self = (fd_gossip_vote_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->index, ctx );
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_flamenco_txn_decode_inner_global( &self->txn, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_vote_convert_global_to_local( void const * global_self, fd_gossip_vote_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_vote_global_t const * mem = (fd_gossip_vote_global_t const *)global_self;
  self->index = mem->index;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_flamenco_txn_convert_global_to_local( &mem->txn, &self->txn, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_vote_new(fd_gossip_vote_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_vote_t) );
  fd_pubkey_new( &self->from );
  fd_flamenco_txn_new( &self->txn );
}
void fd_gossip_vote_destroy( fd_gossip_vote_t * self ) {
  fd_pubkey_destroy( &self->from );
  fd_flamenco_txn_destroy( &self->txn );
}

ulong fd_gossip_vote_footprint( void ){ return FD_GOSSIP_VOTE_FOOTPRINT; }
ulong fd_gossip_vote_align( void ){ return FD_GOSSIP_VOTE_ALIGN; }

void fd_gossip_vote_walk( void * w, fd_gossip_vote_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_vote", level++ );
  fun( w, &self->index, "index", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fd_flamenco_txn_walk( w, &self->txn, fun, "txn", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_vote", level-- );
}
ulong fd_gossip_vote_size( fd_gossip_vote_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  size += fd_pubkey_size( &self->from );
  size += fd_flamenco_txn_size( &self->txn );
  size += sizeof(ulong);
  return size;
}

int fd_gossip_lowest_slot_encode( fd_gossip_lowest_slot_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->u8), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->root, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->lowest, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slots_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->slots_len ) {
    for( ulong i=0; i < self->slots_len; i++ ) {
      err = fd_bincode_uint64_encode( self->slots[i], ctx );
    }
  }
  err = fd_bincode_uint64_encode( self->i_dont_know, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_lowest_slot_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_lowest_slot_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_lowest_slot_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_lowest_slot_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong slots_len;
  err = fd_bincode_uint64_decode( &slots_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( slots_len ) {
    *total_sz += 8UL + sizeof(ulong)*slots_len;
    for( ulong i=0; i < slots_len; i++ ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_lowest_slot_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_lowest_slot_t * self = (fd_gossip_lowest_slot_t *)mem;
  fd_gossip_lowest_slot_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_lowest_slot_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_lowest_slot_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_lowest_slot_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_lowest_slot_t * self = (fd_gossip_lowest_slot_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->u8, ctx );
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->root, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lowest, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slots_len, ctx );
  if( self->slots_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->slots = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->slots_len;
    for( ulong i=0; i < self->slots_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( self->slots + i, ctx );
    }
  } else
    self->slots = NULL;
  fd_bincode_uint64_decode_unsafe( &self->i_dont_know, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_lowest_slot_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_lowest_slot_global_t * self = (fd_gossip_lowest_slot_global_t *)mem;
  fd_gossip_lowest_slot_new( (fd_gossip_lowest_slot_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_lowest_slot_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_lowest_slot_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_lowest_slot_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_lowest_slot_global_t * self = (fd_gossip_lowest_slot_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->u8, ctx );
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->root, ctx );
  fd_bincode_uint64_decode_unsafe( &self->lowest, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slots_len, ctx );
  if( self->slots_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->slots_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->slots_len;
    for( ulong i=0; i < self->slots_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( (ulong*)(cur_mem + sizeof(ulong) * i), ctx );
    }
  } else
    self->slots_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->i_dont_know, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_lowest_slot_convert_global_to_local( void const * global_self, fd_gossip_lowest_slot_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_lowest_slot_global_t const * mem = (fd_gossip_lowest_slot_global_t const *)global_self;
  self->u8 = mem->u8;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->root = mem->root;
  self->lowest = mem->lowest;
  self->slots_len = mem->slots_len;
  self->slots     = fd_wksp_laddr_fast( ctx->wksp, mem->slots_gaddr );
  self->i_dont_know = mem->i_dont_know;
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_lowest_slot_new(fd_gossip_lowest_slot_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_lowest_slot_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_lowest_slot_destroy( fd_gossip_lowest_slot_t * self ) {
  fd_pubkey_destroy( &self->from );
  if( self->slots ) {
    self->slots = NULL;
  }
}

ulong fd_gossip_lowest_slot_footprint( void ){ return FD_GOSSIP_LOWEST_SLOT_FOOTPRINT; }
ulong fd_gossip_lowest_slot_align( void ){ return FD_GOSSIP_LOWEST_SLOT_ALIGN; }

void fd_gossip_lowest_slot_walk( void * w, fd_gossip_lowest_slot_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_lowest_slot", level++ );
  fun( w, &self->u8, "u8", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->root, "root", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->lowest, "lowest", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->slots_len ) {
    fun( w, NULL, "slots", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->slots_len; i++ )
      fun( w, self->slots + i, "slots", FD_FLAMENCO_TYPE_ULONG,   "ulong",   level );
    fun( w, NULL, "slots", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->i_dont_know, "i_dont_know", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_lowest_slot", level-- );
}
ulong fd_gossip_lowest_slot_size( fd_gossip_lowest_slot_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    size += self->slots_len * sizeof(ulong);
  } while(0);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_gossip_slot_hashes_encode( fd_gossip_slot_hashes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->hashes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->hashes_len ) {
    for( ulong i=0; i < self->hashes_len; i++ ) {
      err = fd_slot_hash_encode( self->hashes + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_slot_hashes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_slot_hashes_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_slot_hashes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_slot_hashes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong hashes_len;
  err = fd_bincode_uint64_decode( &hashes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( hashes_len ) {
    *total_sz += FD_SLOT_HASH_ALIGN + FD_SLOT_HASH_FOOTPRINT*hashes_len;
    for( ulong i=0; i < hashes_len; i++ ) {
      err = fd_slot_hash_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_slot_hashes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slot_hashes_t * self = (fd_gossip_slot_hashes_t *)mem;
  fd_gossip_slot_hashes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_slot_hashes_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_slot_hashes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_slot_hashes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slot_hashes_t * self = (fd_gossip_slot_hashes_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_len, ctx );
  if( self->hashes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_HASH_ALIGN );
    self->hashes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_HASH_FOOTPRINT*self->hashes_len;
    for( ulong i=0; i < self->hashes_len; i++ ) {
      fd_slot_hash_new( self->hashes + i );
      fd_slot_hash_decode_inner( self->hashes + i, alloc_mem, ctx );
    }
  } else
    self->hashes = NULL;
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_slot_hashes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slot_hashes_global_t * self = (fd_gossip_slot_hashes_global_t *)mem;
  fd_gossip_slot_hashes_new( (fd_gossip_slot_hashes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_slot_hashes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_slot_hashes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_slot_hashes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slot_hashes_global_t * self = (fd_gossip_slot_hashes_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_len, ctx );
  if( self->hashes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_HASH_ALIGN );
    self->hashes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_HASH_FOOTPRINT*self->hashes_len;
    for( ulong i=0; i < self->hashes_len; i++ ) {
      fd_slot_hash_new( (fd_slot_hash_t *)(cur_mem + FD_SLOT_HASH_FOOTPRINT * i) );
      fd_slot_hash_decode_inner_global( cur_mem + FD_SLOT_HASH_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->hashes_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_slot_hashes_convert_global_to_local( void const * global_self, fd_gossip_slot_hashes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_slot_hashes_global_t const * mem = (fd_gossip_slot_hashes_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->hashes_len = mem->hashes_len;
  self->hashes     = fd_wksp_laddr_fast( ctx->wksp, mem->hashes_gaddr );
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_slot_hashes_new(fd_gossip_slot_hashes_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_slot_hashes_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_slot_hashes_destroy( fd_gossip_slot_hashes_t * self ) {
  fd_pubkey_destroy( &self->from );
  if( self->hashes ) {
    for( ulong i=0; i < self->hashes_len; i++ )
      fd_slot_hash_destroy( self->hashes + i );
    self->hashes = NULL;
  }
}

ulong fd_gossip_slot_hashes_footprint( void ){ return FD_GOSSIP_SLOT_HASHES_FOOTPRINT; }
ulong fd_gossip_slot_hashes_align( void ){ return FD_GOSSIP_SLOT_HASHES_ALIGN; }

void fd_gossip_slot_hashes_walk( void * w, fd_gossip_slot_hashes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_slot_hashes", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  if( self->hashes_len ) {
    fun( w, NULL, "hashes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->hashes_len; i++ )
      fd_slot_hash_walk(w, self->hashes + i, fun, "slot_hash", level );
    fun( w, NULL, "hashes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_slot_hashes", level-- );
}
ulong fd_gossip_slot_hashes_size( fd_gossip_slot_hashes_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->hashes_len; i++ )
      size += fd_slot_hash_size( self->hashes + i );
  } while(0);
  size += sizeof(ulong);
  return size;
}

int fd_gossip_slots_encode( fd_gossip_slots_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->first_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_bitvec_u8_encode( &self->slots, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_slots_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_slots_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_slots_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_slots_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_gossip_bitvec_u8_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_slots_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_t * self = (fd_gossip_slots_t *)mem;
  fd_gossip_slots_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_slots_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_slots_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_slots_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_t * self = (fd_gossip_slots_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->first_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num, ctx );
  fd_gossip_bitvec_u8_decode_inner( &self->slots, alloc_mem, ctx );
}
void * fd_gossip_slots_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_global_t * self = (fd_gossip_slots_global_t *)mem;
  fd_gossip_slots_new( (fd_gossip_slots_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_slots_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_slots_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_slots_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_global_t * self = (fd_gossip_slots_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->first_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num, ctx );
  fd_gossip_bitvec_u8_decode_inner_global( &self->slots, alloc_mem, ctx );
}
int fd_gossip_slots_convert_global_to_local( void const * global_self, fd_gossip_slots_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_slots_global_t const * mem = (fd_gossip_slots_global_t const *)global_self;
  self->first_slot = mem->first_slot;
  self->num = mem->num;
  err = fd_gossip_bitvec_u8_convert_global_to_local( &mem->slots, &self->slots, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_slots_new(fd_gossip_slots_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_slots_t) );
  fd_gossip_bitvec_u8_new( &self->slots );
}
void fd_gossip_slots_destroy( fd_gossip_slots_t * self ) {
  fd_gossip_bitvec_u8_destroy( &self->slots );
}

ulong fd_gossip_slots_footprint( void ){ return FD_GOSSIP_SLOTS_FOOTPRINT; }
ulong fd_gossip_slots_align( void ){ return FD_GOSSIP_SLOTS_ALIGN; }

void fd_gossip_slots_walk( void * w, fd_gossip_slots_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_slots", level++ );
  fun( w, &self->first_slot, "first_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->num, "num", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_gossip_bitvec_u8_walk( w, &self->slots, fun, "slots", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_slots", level-- );
}
ulong fd_gossip_slots_size( fd_gossip_slots_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_gossip_bitvec_u8_size( &self->slots );
  return size;
}

int fd_gossip_flate2_slots_encode( fd_gossip_flate2_slots_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->first_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->compressed_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->compressed_len ) {
    err = fd_bincode_bytes_encode( self->compressed, self->compressed_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_flate2_slots_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_flate2_slots_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_flate2_slots_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_flate2_slots_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong compressed_len;
  err = fd_bincode_uint64_decode( &compressed_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( compressed_len ) {
    *total_sz += 8UL + compressed_len;
    err = fd_bincode_bytes_decode_footprint( compressed_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_gossip_flate2_slots_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_flate2_slots_t * self = (fd_gossip_flate2_slots_t *)mem;
  fd_gossip_flate2_slots_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_flate2_slots_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_flate2_slots_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_flate2_slots_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_flate2_slots_t * self = (fd_gossip_flate2_slots_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->first_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num, ctx );
  fd_bincode_uint64_decode_unsafe( &self->compressed_len, ctx );
  if( self->compressed_len ) {
    self->compressed = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->compressed, self->compressed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->compressed_len;
  } else
    self->compressed = NULL;
}
void * fd_gossip_flate2_slots_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_flate2_slots_global_t * self = (fd_gossip_flate2_slots_global_t *)mem;
  fd_gossip_flate2_slots_new( (fd_gossip_flate2_slots_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_flate2_slots_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_flate2_slots_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_flate2_slots_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_flate2_slots_global_t * self = (fd_gossip_flate2_slots_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->first_slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num, ctx );
  fd_bincode_uint64_decode_unsafe( &self->compressed_len, ctx );
  if( self->compressed_len ) {
    self->compressed_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->compressed_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->compressed_len;
  } else
    self->compressed_gaddr = 0UL;
}
int fd_gossip_flate2_slots_convert_global_to_local( void const * global_self, fd_gossip_flate2_slots_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_flate2_slots_global_t const * mem = (fd_gossip_flate2_slots_global_t const *)global_self;
  self->first_slot = mem->first_slot;
  self->num = mem->num;
  self->compressed_len = mem->compressed_len;
  self->compressed     = fd_wksp_laddr_fast( ctx->wksp, mem->compressed_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_flate2_slots_new(fd_gossip_flate2_slots_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_flate2_slots_t) );
}
void fd_gossip_flate2_slots_destroy( fd_gossip_flate2_slots_t * self ) {
  if( self->compressed ) {
    self->compressed = NULL;
  }
}

ulong fd_gossip_flate2_slots_footprint( void ){ return FD_GOSSIP_FLATE2_SLOTS_FOOTPRINT; }
ulong fd_gossip_flate2_slots_align( void ){ return FD_GOSSIP_FLATE2_SLOTS_ALIGN; }

void fd_gossip_flate2_slots_walk( void * w, fd_gossip_flate2_slots_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_flate2_slots", level++ );
  fun( w, &self->first_slot, "first_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->num, "num", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun(w, self->compressed, "compressed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_flate2_slots", level-- );
}
ulong fd_gossip_flate2_slots_size( fd_gossip_flate2_slots_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    size += self->compressed_len;
  } while(0);
  return size;
}

FD_FN_PURE uchar fd_gossip_slots_enum_is_flate2(fd_gossip_slots_enum_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_gossip_slots_enum_is_uncompressed(fd_gossip_slots_enum_t const * self) {
  return self->discriminant == 1;
}
void fd_gossip_slots_enum_inner_new( fd_gossip_slots_enum_inner_t * self, uint discriminant );
int fd_gossip_slots_enum_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_flate2_slots_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_gossip_slots_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_gossip_slots_enum_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_slots_enum_t);
  void const * start_data = ctx->data;
  int err =  fd_gossip_slots_enum_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_slots_enum_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_slots_enum_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_gossip_slots_enum_inner_decode_inner( fd_gossip_slots_enum_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_flate2_slots_decode_inner( &self->flate2, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_slots_decode_inner( &self->uncompressed, alloc_mem, ctx );
    break;
  }
  }
}
void fd_gossip_slots_enum_inner_decode_inner_global( fd_gossip_slots_enum_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_flate2_slots_decode_inner_global( &self->flate2, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_slots_decode_inner_global( &self->uncompressed, alloc_mem, ctx );
    break;
  }
  }
}
int fd_gossip_slots_enum_convert_global_to_local_inner( fd_gossip_slots_enum_inner_global_t const * mem, fd_gossip_slots_enum_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_gossip_flate2_slots_convert_global_to_local( &mem->flate2, &self->flate2, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_slots_convert_global_to_local( &mem->uncompressed, &self->uncompressed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_slots_enum_convert_global_to_local( void const * global_self, fd_gossip_slots_enum_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_enum_global_t const * mem = (fd_gossip_slots_enum_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_gossip_slots_enum_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_slots_enum_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_enum_t * self = (fd_gossip_slots_enum_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_slots_enum_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_gossip_slots_enum_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_enum_t * self = (fd_gossip_slots_enum_t *)mem;
  fd_gossip_slots_enum_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_slots_enum_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_slots_enum_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_gossip_slots_enum_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_enum_t * self = (fd_gossip_slots_enum_t *)mem;
  fd_gossip_slots_enum_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_slots_enum_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_slots_enum_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_slots_enum_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_slots_enum_global_t * self = (fd_gossip_slots_enum_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_slots_enum_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_gossip_slots_enum_inner_new( fd_gossip_slots_enum_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_flate2_slots_new( &self->flate2 );
    break;
  }
  case 1: {
    fd_gossip_slots_new( &self->uncompressed );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_gossip_slots_enum_new_disc( fd_gossip_slots_enum_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_gossip_slots_enum_inner_new( &self->inner, self->discriminant );
}
void fd_gossip_slots_enum_new( fd_gossip_slots_enum_t * self ) {
  fd_memset( self, 0, sizeof(fd_gossip_slots_enum_t) );
  fd_gossip_slots_enum_new_disc( self, UINT_MAX );
}
void fd_gossip_slots_enum_inner_destroy( fd_gossip_slots_enum_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_flate2_slots_destroy( &self->flate2 );
    break;
  }
  case 1: {
    fd_gossip_slots_destroy( &self->uncompressed );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_gossip_slots_enum_destroy( fd_gossip_slots_enum_t * self ) {
  fd_gossip_slots_enum_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_gossip_slots_enum_footprint( void ){ return FD_GOSSIP_SLOTS_ENUM_FOOTPRINT; }
ulong fd_gossip_slots_enum_align( void ){ return FD_GOSSIP_SLOTS_ENUM_ALIGN; }

void fd_gossip_slots_enum_walk( void * w, fd_gossip_slots_enum_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_gossip_slots_enum", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "flate2", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_flate2_slots_walk( w, &self->inner.flate2, fun, "flate2", level );
    break;
  }
  case 1: {
    fun( w, self, "uncompressed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_slots_walk( w, &self->inner.uncompressed, fun, "uncompressed", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_gossip_slots_enum", level-- );
}
ulong fd_gossip_slots_enum_size( fd_gossip_slots_enum_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_gossip_flate2_slots_size( &self->inner.flate2 );
    break;
  }
  case 1: {
    size += fd_gossip_slots_size( &self->inner.uncompressed );
    break;
  }
  }
  return size;
}

int fd_gossip_slots_enum_inner_encode( fd_gossip_slots_enum_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_flate2_slots_encode( &self->flate2, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_slots_encode( &self->uncompressed, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_slots_enum_encode( fd_gossip_slots_enum_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_slots_enum_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_gossip_epoch_slots_encode( fd_gossip_epoch_slots_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->u8), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slots_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->slots_len ) {
    for( ulong i=0; i < self->slots_len; i++ ) {
      err = fd_gossip_slots_enum_encode( self->slots + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_epoch_slots_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_epoch_slots_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_epoch_slots_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_epoch_slots_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong slots_len;
  err = fd_bincode_uint64_decode( &slots_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( slots_len ) {
    *total_sz += FD_GOSSIP_SLOTS_ENUM_ALIGN + FD_GOSSIP_SLOTS_ENUM_FOOTPRINT*slots_len;
    for( ulong i=0; i < slots_len; i++ ) {
      err = fd_gossip_slots_enum_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_epoch_slots_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_epoch_slots_t * self = (fd_gossip_epoch_slots_t *)mem;
  fd_gossip_epoch_slots_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_epoch_slots_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_epoch_slots_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_epoch_slots_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_epoch_slots_t * self = (fd_gossip_epoch_slots_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->u8, ctx );
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slots_len, ctx );
  if( self->slots_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_GOSSIP_SLOTS_ENUM_ALIGN );
    self->slots = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_GOSSIP_SLOTS_ENUM_FOOTPRINT*self->slots_len;
    for( ulong i=0; i < self->slots_len; i++ ) {
      fd_gossip_slots_enum_new( self->slots + i );
      fd_gossip_slots_enum_decode_inner( self->slots + i, alloc_mem, ctx );
    }
  } else
    self->slots = NULL;
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_epoch_slots_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_epoch_slots_global_t * self = (fd_gossip_epoch_slots_global_t *)mem;
  fd_gossip_epoch_slots_new( (fd_gossip_epoch_slots_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_epoch_slots_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_epoch_slots_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_epoch_slots_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_epoch_slots_global_t * self = (fd_gossip_epoch_slots_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->u8, ctx );
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slots_len, ctx );
  if( self->slots_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_GOSSIP_SLOTS_ENUM_ALIGN );
    self->slots_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_GOSSIP_SLOTS_ENUM_FOOTPRINT*self->slots_len;
    for( ulong i=0; i < self->slots_len; i++ ) {
      fd_gossip_slots_enum_new( (fd_gossip_slots_enum_t *)(cur_mem + FD_GOSSIP_SLOTS_ENUM_FOOTPRINT * i) );
      fd_gossip_slots_enum_decode_inner_global( cur_mem + FD_GOSSIP_SLOTS_ENUM_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->slots_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_epoch_slots_convert_global_to_local( void const * global_self, fd_gossip_epoch_slots_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_epoch_slots_global_t const * mem = (fd_gossip_epoch_slots_global_t const *)global_self;
  self->u8 = mem->u8;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slots_len = mem->slots_len;
  self->slots     = fd_wksp_laddr_fast( ctx->wksp, mem->slots_gaddr );
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_epoch_slots_new(fd_gossip_epoch_slots_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_epoch_slots_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_epoch_slots_destroy( fd_gossip_epoch_slots_t * self ) {
  fd_pubkey_destroy( &self->from );
  if( self->slots ) {
    for( ulong i=0; i < self->slots_len; i++ )
      fd_gossip_slots_enum_destroy( self->slots + i );
    self->slots = NULL;
  }
}

ulong fd_gossip_epoch_slots_footprint( void ){ return FD_GOSSIP_EPOCH_SLOTS_FOOTPRINT; }
ulong fd_gossip_epoch_slots_align( void ){ return FD_GOSSIP_EPOCH_SLOTS_ALIGN; }

void fd_gossip_epoch_slots_walk( void * w, fd_gossip_epoch_slots_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_epoch_slots", level++ );
  fun( w, &self->u8, "u8", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  if( self->slots_len ) {
    fun( w, NULL, "slots", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->slots_len; i++ )
      fd_gossip_slots_enum_walk(w, self->slots + i, fun, "gossip_slots_enum", level );
    fun( w, NULL, "slots", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_epoch_slots", level-- );
}
ulong fd_gossip_epoch_slots_size( fd_gossip_epoch_slots_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  size += fd_pubkey_size( &self->from );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->slots_len; i++ )
      size += fd_gossip_slots_enum_size( self->slots + i );
  } while(0);
  size += sizeof(ulong);
  return size;
}

int fd_gossip_version_v1_encode( fd_gossip_version_v1_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->major, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->minor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->patch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_commit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_commit ) {
    err = fd_bincode_uint32_encode( self->commit, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_version_v1_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_version_v1_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_version_v1_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_version_v1_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint32_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_gossip_version_v1_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v1_t * self = (fd_gossip_version_v1_t *)mem;
  fd_gossip_version_v1_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_version_v1_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_version_v1_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_version_v1_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v1_t * self = (fd_gossip_version_v1_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint16_decode_unsafe( &self->major, ctx );
  fd_bincode_uint16_decode_unsafe( &self->minor, ctx );
  fd_bincode_uint16_decode_unsafe( &self->patch, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_commit = !!o;
    if( o ) {
      fd_bincode_uint32_decode_unsafe( &self->commit, ctx );
    }
  }
}
void * fd_gossip_version_v1_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v1_global_t * self = (fd_gossip_version_v1_global_t *)mem;
  fd_gossip_version_v1_new( (fd_gossip_version_v1_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_version_v1_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_version_v1_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_version_v1_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v1_global_t * self = (fd_gossip_version_v1_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint16_decode_unsafe( &self->major, ctx );
  fd_bincode_uint16_decode_unsafe( &self->minor, ctx );
  fd_bincode_uint16_decode_unsafe( &self->patch, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_commit = !!o;
    if( o ) {
      fd_bincode_uint32_decode_unsafe( &self->commit, ctx );
    }
  }
}
int fd_gossip_version_v1_convert_global_to_local( void const * global_self, fd_gossip_version_v1_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_version_v1_global_t const * mem = (fd_gossip_version_v1_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->major = mem->major;
  self->minor = mem->minor;
  self->patch = mem->patch;
  self->commit = mem->commit;
  self->has_commit = mem->has_commit;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_version_v1_new(fd_gossip_version_v1_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_version_v1_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_version_v1_destroy( fd_gossip_version_v1_t * self ) {
  fd_pubkey_destroy( &self->from );
  if( self->has_commit ) {
    self->has_commit = 0;
  }
}

ulong fd_gossip_version_v1_footprint( void ){ return FD_GOSSIP_VERSION_V1_FOOTPRINT; }
ulong fd_gossip_version_v1_align( void ){ return FD_GOSSIP_VERSION_V1_ALIGN; }

void fd_gossip_version_v1_walk( void * w, fd_gossip_version_v1_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_version_v1", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->major, "major", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->minor, "minor", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->patch, "patch", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  if( !self->has_commit ) {
    fun( w, NULL, "commit", FD_FLAMENCO_TYPE_NULL, "uint", level );
  } else {
    fun( w, &self->commit, "commit", FD_FLAMENCO_TYPE_UINT, "uint", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_version_v1", level-- );
}
ulong fd_gossip_version_v1_size( fd_gossip_version_v1_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += sizeof(ushort);
  size += sizeof(ushort);
  size += sizeof(ushort);
  size += sizeof(char);
  if( self->has_commit ) {
    size += sizeof(uint);
  }
  return size;
}

int fd_gossip_version_v2_encode( fd_gossip_version_v2_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->major, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->minor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->patch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( self->has_commit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_commit ) {
    err = fd_bincode_uint32_encode( self->commit, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint32_encode( self->feature_set, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_version_v2_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_version_v2_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_version_v2_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_version_v2_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_bincode_uint32_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_version_v2_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v2_t * self = (fd_gossip_version_v2_t *)mem;
  fd_gossip_version_v2_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_version_v2_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_version_v2_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_version_v2_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v2_t * self = (fd_gossip_version_v2_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint16_decode_unsafe( &self->major, ctx );
  fd_bincode_uint16_decode_unsafe( &self->minor, ctx );
  fd_bincode_uint16_decode_unsafe( &self->patch, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_commit = !!o;
    if( o ) {
      fd_bincode_uint32_decode_unsafe( &self->commit, ctx );
    }
  }
  fd_bincode_uint32_decode_unsafe( &self->feature_set, ctx );
}
void * fd_gossip_version_v2_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v2_global_t * self = (fd_gossip_version_v2_global_t *)mem;
  fd_gossip_version_v2_new( (fd_gossip_version_v2_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_version_v2_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_version_v2_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_version_v2_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v2_global_t * self = (fd_gossip_version_v2_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint16_decode_unsafe( &self->major, ctx );
  fd_bincode_uint16_decode_unsafe( &self->minor, ctx );
  fd_bincode_uint16_decode_unsafe( &self->patch, ctx );
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_commit = !!o;
    if( o ) {
      fd_bincode_uint32_decode_unsafe( &self->commit, ctx );
    }
  }
  fd_bincode_uint32_decode_unsafe( &self->feature_set, ctx );
}
int fd_gossip_version_v2_convert_global_to_local( void const * global_self, fd_gossip_version_v2_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_version_v2_global_t const * mem = (fd_gossip_version_v2_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->major = mem->major;
  self->minor = mem->minor;
  self->patch = mem->patch;
  self->commit = mem->commit;
  self->has_commit = mem->has_commit;
  self->feature_set = mem->feature_set;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_version_v2_new(fd_gossip_version_v2_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_version_v2_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_version_v2_destroy( fd_gossip_version_v2_t * self ) {
  fd_pubkey_destroy( &self->from );
  if( self->has_commit ) {
    self->has_commit = 0;
  }
}

ulong fd_gossip_version_v2_footprint( void ){ return FD_GOSSIP_VERSION_V2_FOOTPRINT; }
ulong fd_gossip_version_v2_align( void ){ return FD_GOSSIP_VERSION_V2_ALIGN; }

void fd_gossip_version_v2_walk( void * w, fd_gossip_version_v2_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_version_v2", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->major, "major", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->minor, "minor", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->patch, "patch", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  if( !self->has_commit ) {
    fun( w, NULL, "commit", FD_FLAMENCO_TYPE_NULL, "uint", level );
  } else {
    fun( w, &self->commit, "commit", FD_FLAMENCO_TYPE_UINT, "uint", level );
  }
  fun( w, &self->feature_set, "feature_set", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_version_v2", level-- );
}
ulong fd_gossip_version_v2_size( fd_gossip_version_v2_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += sizeof(ushort);
  size += sizeof(ushort);
  size += sizeof(ushort);
  size += sizeof(char);
  if( self->has_commit ) {
    size += sizeof(uint);
  }
  size += sizeof(uint);
  return size;
}

int fd_gossip_version_v3_encode( fd_gossip_version_v3_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_compact_u16_encode( &self->major, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_compact_u16_encode( &self->minor, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_compact_u16_encode( &self->patch, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->commit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->feature_set, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_compact_u16_encode( &self->client, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_version_v3_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_version_v3_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_version_v3_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_version_v3_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  do { ushort _tmp; err = fd_bincode_compact_u16_decode( &_tmp, ctx ); } while(0);
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  do { ushort _tmp; err = fd_bincode_compact_u16_decode( &_tmp, ctx ); } while(0);
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  do { ushort _tmp; err = fd_bincode_compact_u16_decode( &_tmp, ctx ); } while(0);
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  do { ushort _tmp; err = fd_bincode_compact_u16_decode( &_tmp, ctx ); } while(0);
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_version_v3_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v3_t * self = (fd_gossip_version_v3_t *)mem;
  fd_gossip_version_v3_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_version_v3_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_version_v3_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_version_v3_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v3_t * self = (fd_gossip_version_v3_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->major, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->minor, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->patch, ctx );
  fd_bincode_uint32_decode_unsafe( &self->commit, ctx );
  fd_bincode_uint32_decode_unsafe( &self->feature_set, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->client, ctx );
}
void * fd_gossip_version_v3_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v3_global_t * self = (fd_gossip_version_v3_global_t *)mem;
  fd_gossip_version_v3_new( (fd_gossip_version_v3_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_version_v3_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_version_v3_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_version_v3_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_version_v3_global_t * self = (fd_gossip_version_v3_global_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->major, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->minor, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->patch, ctx );
  fd_bincode_uint32_decode_unsafe( &self->commit, ctx );
  fd_bincode_uint32_decode_unsafe( &self->feature_set, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->client, ctx );
}
int fd_gossip_version_v3_convert_global_to_local( void const * global_self, fd_gossip_version_v3_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_version_v3_global_t const * mem = (fd_gossip_version_v3_global_t const *)global_self;
  self->major = mem->major;
  self->minor = mem->minor;
  self->patch = mem->patch;
  self->commit = mem->commit;
  self->feature_set = mem->feature_set;
  self->client = mem->client;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_version_v3_new(fd_gossip_version_v3_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_version_v3_t) );
}
void fd_gossip_version_v3_destroy( fd_gossip_version_v3_t * self ) {
}

ulong fd_gossip_version_v3_footprint( void ){ return FD_GOSSIP_VERSION_V3_FOOTPRINT; }
ulong fd_gossip_version_v3_align( void ){ return FD_GOSSIP_VERSION_V3_ALIGN; }

void fd_gossip_version_v3_walk( void * w, fd_gossip_version_v3_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_version_v3", level++ );
  fun( w, &self->major, "major", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->minor, "minor", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->patch, "patch", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, &self->commit, "commit", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, &self->feature_set, "feature_set", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, &self->client, "client", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_version_v3", level-- );
}
ulong fd_gossip_version_v3_size( fd_gossip_version_v3_t const * self ) {
  ulong size = 0;
  size += fd_bincode_compact_u16_size( &self->major );
  size += fd_bincode_compact_u16_size( &self->minor );
  size += fd_bincode_compact_u16_size( &self->patch );
  size += sizeof(uint);
  size += sizeof(uint);
  size += fd_bincode_compact_u16_size( &self->client );
  return size;
}

int fd_gossip_node_instance_encode( fd_gossip_node_instance_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->token, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_node_instance_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_node_instance_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_node_instance_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_node_instance_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_node_instance_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_node_instance_t * self = (fd_gossip_node_instance_t *)mem;
  fd_gossip_node_instance_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_node_instance_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_node_instance_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_node_instance_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_node_instance_t * self = (fd_gossip_node_instance_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->token, ctx );
}
void * fd_gossip_node_instance_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_node_instance_global_t * self = (fd_gossip_node_instance_global_t *)mem;
  fd_gossip_node_instance_new( (fd_gossip_node_instance_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_node_instance_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_node_instance_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_node_instance_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_node_instance_global_t * self = (fd_gossip_node_instance_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
  fd_bincode_uint64_decode_unsafe( &self->token, ctx );
}
int fd_gossip_node_instance_convert_global_to_local( void const * global_self, fd_gossip_node_instance_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_node_instance_global_t const * mem = (fd_gossip_node_instance_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->timestamp = mem->timestamp;
  self->token = mem->token;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_node_instance_new(fd_gossip_node_instance_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_node_instance_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_node_instance_destroy( fd_gossip_node_instance_t * self ) {
  fd_pubkey_destroy( &self->from );
}

ulong fd_gossip_node_instance_footprint( void ){ return FD_GOSSIP_NODE_INSTANCE_FOOTPRINT; }
ulong fd_gossip_node_instance_align( void ){ return FD_GOSSIP_NODE_INSTANCE_ALIGN; }

void fd_gossip_node_instance_walk( void * w, fd_gossip_node_instance_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_node_instance", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, &self->token, "token", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_node_instance", level-- );
}
ulong fd_gossip_node_instance_size( fd_gossip_node_instance_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += sizeof(long);
  size += sizeof(ulong);
  return size;
}

int fd_gossip_duplicate_shred_encode( fd_gossip_duplicate_shred_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint16_encode( self->duplicate_shred_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->_unused, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->_unused_shred_type), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->num_chunks), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->chunk_index), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->chunk_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->chunk_len ) {
    err = fd_bincode_bytes_encode( self->chunk, self->chunk_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_duplicate_shred_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_duplicate_shred_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_duplicate_shred_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_duplicate_shred_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong chunk_len;
  err = fd_bincode_uint64_decode( &chunk_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( chunk_len ) {
    *total_sz += 8UL + chunk_len;
    err = fd_bincode_bytes_decode_footprint( chunk_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_gossip_duplicate_shred_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_duplicate_shred_t * self = (fd_gossip_duplicate_shred_t *)mem;
  fd_gossip_duplicate_shred_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_duplicate_shred_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_duplicate_shred_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_duplicate_shred_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_duplicate_shred_t * self = (fd_gossip_duplicate_shred_t *)struct_mem;
  fd_bincode_uint16_decode_unsafe( &self->duplicate_shred_index, ctx );
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint32_decode_unsafe( &self->_unused, ctx );
  fd_bincode_uint8_decode_unsafe( &self->_unused_shred_type, ctx );
  fd_bincode_uint8_decode_unsafe( &self->num_chunks, ctx );
  fd_bincode_uint8_decode_unsafe( &self->chunk_index, ctx );
  fd_bincode_uint64_decode_unsafe( &self->chunk_len, ctx );
  if( self->chunk_len ) {
    self->chunk = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->chunk, self->chunk_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->chunk_len;
  } else
    self->chunk = NULL;
}
void * fd_gossip_duplicate_shred_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_duplicate_shred_global_t * self = (fd_gossip_duplicate_shred_global_t *)mem;
  fd_gossip_duplicate_shred_new( (fd_gossip_duplicate_shred_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_duplicate_shred_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_duplicate_shred_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_duplicate_shred_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_duplicate_shred_global_t * self = (fd_gossip_duplicate_shred_global_t *)struct_mem;
  fd_bincode_uint16_decode_unsafe( &self->duplicate_shred_index, ctx );
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint32_decode_unsafe( &self->_unused, ctx );
  fd_bincode_uint8_decode_unsafe( &self->_unused_shred_type, ctx );
  fd_bincode_uint8_decode_unsafe( &self->num_chunks, ctx );
  fd_bincode_uint8_decode_unsafe( &self->chunk_index, ctx );
  fd_bincode_uint64_decode_unsafe( &self->chunk_len, ctx );
  if( self->chunk_len ) {
    self->chunk_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->chunk_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->chunk_len;
  } else
    self->chunk_gaddr = 0UL;
}
int fd_gossip_duplicate_shred_convert_global_to_local( void const * global_self, fd_gossip_duplicate_shred_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_duplicate_shred_global_t const * mem = (fd_gossip_duplicate_shred_global_t const *)global_self;
  self->duplicate_shred_index = mem->duplicate_shred_index;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->slot = mem->slot;
  self->_unused = mem->_unused;
  self->_unused_shred_type = mem->_unused_shred_type;
  self->num_chunks = mem->num_chunks;
  self->chunk_index = mem->chunk_index;
  self->chunk_len = mem->chunk_len;
  self->chunk     = fd_wksp_laddr_fast( ctx->wksp, mem->chunk_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_duplicate_shred_new(fd_gossip_duplicate_shred_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_duplicate_shred_t) );
  fd_pubkey_new( &self->from );
}
void fd_gossip_duplicate_shred_destroy( fd_gossip_duplicate_shred_t * self ) {
  fd_pubkey_destroy( &self->from );
  if( self->chunk ) {
    self->chunk = NULL;
  }
}

ulong fd_gossip_duplicate_shred_footprint( void ){ return FD_GOSSIP_DUPLICATE_SHRED_FOOTPRINT; }
ulong fd_gossip_duplicate_shred_align( void ){ return FD_GOSSIP_DUPLICATE_SHRED_ALIGN; }

void fd_gossip_duplicate_shred_walk( void * w, fd_gossip_duplicate_shred_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_duplicate_shred", level++ );
  fun( w, &self->duplicate_shred_index, "duplicate_shred_index", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->_unused, "_unused", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, &self->_unused_shred_type, "_unused_shred_type", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->num_chunks, "num_chunks", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->chunk_index, "chunk_index", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun(w, self->chunk, "chunk", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_duplicate_shred", level-- );
}
ulong fd_gossip_duplicate_shred_size( fd_gossip_duplicate_shred_t const * self ) {
  ulong size = 0;
  size += sizeof(ushort);
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(uint);
  size += sizeof(char);
  size += sizeof(char);
  size += sizeof(char);
  do {
    size += sizeof(ulong);
    size += self->chunk_len;
  } while(0);
  return size;
}

int fd_gossip_incremental_snapshot_hashes_encode( fd_gossip_incremental_snapshot_hashes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_slot_hash_encode( &self->base_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->hashes_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->hashes_len ) {
    for( ulong i=0; i < self->hashes_len; i++ ) {
      err = fd_slot_hash_encode( self->hashes + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_incremental_snapshot_hashes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_incremental_snapshot_hashes_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_incremental_snapshot_hashes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_incremental_snapshot_hashes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_slot_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong hashes_len;
  err = fd_bincode_uint64_decode( &hashes_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( hashes_len ) {
    *total_sz += FD_SLOT_HASH_ALIGN + FD_SLOT_HASH_FOOTPRINT*hashes_len;
    for( ulong i=0; i < hashes_len; i++ ) {
      err = fd_slot_hash_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_incremental_snapshot_hashes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_incremental_snapshot_hashes_t * self = (fd_gossip_incremental_snapshot_hashes_t *)mem;
  fd_gossip_incremental_snapshot_hashes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_incremental_snapshot_hashes_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_incremental_snapshot_hashes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_incremental_snapshot_hashes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_incremental_snapshot_hashes_t * self = (fd_gossip_incremental_snapshot_hashes_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_slot_hash_decode_inner( &self->base_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_len, ctx );
  if( self->hashes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_HASH_ALIGN );
    self->hashes = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_HASH_FOOTPRINT*self->hashes_len;
    for( ulong i=0; i < self->hashes_len; i++ ) {
      fd_slot_hash_new( self->hashes + i );
      fd_slot_hash_decode_inner( self->hashes + i, alloc_mem, ctx );
    }
  } else
    self->hashes = NULL;
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
void * fd_gossip_incremental_snapshot_hashes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_incremental_snapshot_hashes_global_t * self = (fd_gossip_incremental_snapshot_hashes_global_t *)mem;
  fd_gossip_incremental_snapshot_hashes_new( (fd_gossip_incremental_snapshot_hashes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_incremental_snapshot_hashes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_incremental_snapshot_hashes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_incremental_snapshot_hashes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_incremental_snapshot_hashes_global_t * self = (fd_gossip_incremental_snapshot_hashes_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_slot_hash_decode_inner_global( &self->base_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->hashes_len, ctx );
  if( self->hashes_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_HASH_ALIGN );
    self->hashes_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_HASH_FOOTPRINT*self->hashes_len;
    for( ulong i=0; i < self->hashes_len; i++ ) {
      fd_slot_hash_new( (fd_slot_hash_t *)(cur_mem + FD_SLOT_HASH_FOOTPRINT * i) );
      fd_slot_hash_decode_inner_global( cur_mem + FD_SLOT_HASH_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->hashes_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
}
int fd_gossip_incremental_snapshot_hashes_convert_global_to_local( void const * global_self, fd_gossip_incremental_snapshot_hashes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_incremental_snapshot_hashes_global_t const * mem = (fd_gossip_incremental_snapshot_hashes_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_slot_hash_convert_global_to_local( &mem->base_hash, &self->base_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->hashes_len = mem->hashes_len;
  self->hashes     = fd_wksp_laddr_fast( ctx->wksp, mem->hashes_gaddr );
  self->wallclock = mem->wallclock;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_incremental_snapshot_hashes_new(fd_gossip_incremental_snapshot_hashes_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_incremental_snapshot_hashes_t) );
  fd_pubkey_new( &self->from );
  fd_slot_hash_new( &self->base_hash );
}
void fd_gossip_incremental_snapshot_hashes_destroy( fd_gossip_incremental_snapshot_hashes_t * self ) {
  fd_pubkey_destroy( &self->from );
  fd_slot_hash_destroy( &self->base_hash );
  if( self->hashes ) {
    for( ulong i=0; i < self->hashes_len; i++ )
      fd_slot_hash_destroy( self->hashes + i );
    self->hashes = NULL;
  }
}

ulong fd_gossip_incremental_snapshot_hashes_footprint( void ){ return FD_GOSSIP_INCREMENTAL_SNAPSHOT_HASHES_FOOTPRINT; }
ulong fd_gossip_incremental_snapshot_hashes_align( void ){ return FD_GOSSIP_INCREMENTAL_SNAPSHOT_HASHES_ALIGN; }

void fd_gossip_incremental_snapshot_hashes_walk( void * w, fd_gossip_incremental_snapshot_hashes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_incremental_snapshot_hashes", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fd_slot_hash_walk( w, &self->base_hash, fun, "base_hash", level );
  if( self->hashes_len ) {
    fun( w, NULL, "hashes", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->hashes_len; i++ )
      fd_slot_hash_walk(w, self->hashes + i, fun, "slot_hash", level );
    fun( w, NULL, "hashes", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_incremental_snapshot_hashes", level-- );
}
ulong fd_gossip_incremental_snapshot_hashes_size( fd_gossip_incremental_snapshot_hashes_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += fd_slot_hash_size( &self->base_hash );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->hashes_len; i++ )
      size += fd_slot_hash_size( self->hashes + i );
  } while(0);
  size += sizeof(ulong);
  return size;
}

int fd_gossip_socket_entry_encode( fd_gossip_socket_entry_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->key), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->index), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_compact_u16_encode( &self->offset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_socket_entry_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_socket_entry_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_socket_entry_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_socket_entry_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  do { ushort _tmp; err = fd_bincode_compact_u16_decode( &_tmp, ctx ); } while(0);
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_socket_entry_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_entry_t * self = (fd_gossip_socket_entry_t *)mem;
  fd_gossip_socket_entry_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_entry_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_entry_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_entry_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_entry_t * self = (fd_gossip_socket_entry_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->key, ctx );
  fd_bincode_uint8_decode_unsafe( &self->index, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->offset, ctx );
}
void * fd_gossip_socket_entry_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_entry_global_t * self = (fd_gossip_socket_entry_global_t *)mem;
  fd_gossip_socket_entry_new( (fd_gossip_socket_entry_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_socket_entry_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_socket_entry_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_socket_entry_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_socket_entry_global_t * self = (fd_gossip_socket_entry_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->key, ctx );
  fd_bincode_uint8_decode_unsafe( &self->index, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->offset, ctx );
}
int fd_gossip_socket_entry_convert_global_to_local( void const * global_self, fd_gossip_socket_entry_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_socket_entry_global_t const * mem = (fd_gossip_socket_entry_global_t const *)global_self;
  self->key = mem->key;
  self->index = mem->index;
  self->offset = mem->offset;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_socket_entry_new(fd_gossip_socket_entry_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_socket_entry_t) );
}
void fd_gossip_socket_entry_destroy( fd_gossip_socket_entry_t * self ) {
}

ulong fd_gossip_socket_entry_footprint( void ){ return FD_GOSSIP_SOCKET_ENTRY_FOOTPRINT; }
ulong fd_gossip_socket_entry_align( void ){ return FD_GOSSIP_SOCKET_ENTRY_ALIGN; }

void fd_gossip_socket_entry_walk( void * w, fd_gossip_socket_entry_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_socket_entry", level++ );
  fun( w, &self->key, "key", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->index, "index", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, &self->offset, "offset", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_socket_entry", level-- );
}
ulong fd_gossip_socket_entry_size( fd_gossip_socket_entry_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  size += sizeof(char);
  size += fd_bincode_compact_u16_size( &self->offset );
  return size;
}

int fd_gossip_contact_info_v2_encode( fd_gossip_contact_info_v2_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_varint_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->outset, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->shred_version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_version_v3_encode( &self->version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_compact_u16_encode( &self->addrs_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->addrs_len ) {
    for( ulong i=0; i < self->addrs_len; i++ ) {
      err = fd_gossip_ip_addr_encode( self->addrs + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_compact_u16_encode( &self->sockets_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->sockets_len ) {
    for( ulong i=0; i < self->sockets_len; i++ ) {
      err = fd_gossip_socket_entry_encode( self->sockets + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  err = fd_bincode_compact_u16_encode( &self->extensions_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->extensions_len ) {
    for( ulong i=0; i < self->extensions_len; i++ ) {
      err = fd_bincode_uint32_encode( self->extensions[i], ctx );
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_contact_info_v2_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_contact_info_v2_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_contact_info_v2_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_contact_info_v2_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_varint_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_gossip_version_v3_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ushort addrs_len;
  err = fd_bincode_compact_u16_decode( &addrs_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( addrs_len ) {
    *total_sz += FD_GOSSIP_IP_ADDR_ALIGN + FD_GOSSIP_IP_ADDR_FOOTPRINT*addrs_len;
    for( ulong i=0; i < addrs_len; i++ ) {
      err = fd_gossip_ip_addr_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ushort sockets_len;
  err = fd_bincode_compact_u16_decode( &sockets_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( sockets_len ) {
    *total_sz += FD_GOSSIP_SOCKET_ENTRY_ALIGN + FD_GOSSIP_SOCKET_ENTRY_FOOTPRINT*sockets_len;
    for( ulong i=0; i < sockets_len; i++ ) {
      err = fd_gossip_socket_entry_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ushort extensions_len;
  err = fd_bincode_compact_u16_decode( &extensions_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( extensions_len ) {
    *total_sz += 8UL + sizeof(uint)*extensions_len;
    for( ulong i=0; i < extensions_len; i++ ) {
      err = fd_bincode_uint32_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_gossip_contact_info_v2_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v2_t * self = (fd_gossip_contact_info_v2_t *)mem;
  fd_gossip_contact_info_v2_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_contact_info_v2_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_contact_info_v2_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_contact_info_v2_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v2_t * self = (fd_gossip_contact_info_v2_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_varint_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( &self->outset, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
  fd_gossip_version_v3_decode_inner( &self->version, alloc_mem, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->addrs_len, ctx );
  if( self->addrs_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_GOSSIP_IP_ADDR_ALIGN );
    self->addrs = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_GOSSIP_IP_ADDR_FOOTPRINT*self->addrs_len;
    for( ulong i=0; i < self->addrs_len; i++ ) {
      fd_gossip_ip_addr_new( self->addrs + i );
      fd_gossip_ip_addr_decode_inner( self->addrs + i, alloc_mem, ctx );
    }
  } else
    self->addrs = NULL;
  fd_bincode_compact_u16_decode_unsafe( &self->sockets_len, ctx );
  if( self->sockets_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_GOSSIP_SOCKET_ENTRY_ALIGN );
    self->sockets = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_GOSSIP_SOCKET_ENTRY_FOOTPRINT*self->sockets_len;
    for( ulong i=0; i < self->sockets_len; i++ ) {
      fd_gossip_socket_entry_new( self->sockets + i );
      fd_gossip_socket_entry_decode_inner( self->sockets + i, alloc_mem, ctx );
    }
  } else
    self->sockets = NULL;
  fd_bincode_compact_u16_decode_unsafe( &self->extensions_len, ctx );
  if( self->extensions_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->extensions = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(uint)*self->extensions_len;
    for( ulong i=0; i < self->extensions_len; i++ ) {
      fd_bincode_uint32_decode_unsafe( self->extensions + i, ctx );
    }
  } else
    self->extensions = NULL;
}
void * fd_gossip_contact_info_v2_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v2_global_t * self = (fd_gossip_contact_info_v2_global_t *)mem;
  fd_gossip_contact_info_v2_new( (fd_gossip_contact_info_v2_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_contact_info_v2_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_contact_info_v2_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_contact_info_v2_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_contact_info_v2_global_t * self = (fd_gossip_contact_info_v2_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_varint_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( &self->outset, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
  fd_gossip_version_v3_decode_inner_global( &self->version, alloc_mem, ctx );
  fd_bincode_compact_u16_decode_unsafe( &self->addrs_len, ctx );
  if( self->addrs_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_GOSSIP_IP_ADDR_ALIGN );
    self->addrs_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_GOSSIP_IP_ADDR_FOOTPRINT*self->addrs_len;
    for( ulong i=0; i < self->addrs_len; i++ ) {
      fd_gossip_ip_addr_new( (fd_gossip_ip_addr_t *)(cur_mem + FD_GOSSIP_IP_ADDR_FOOTPRINT * i) );
      fd_gossip_ip_addr_decode_inner_global( cur_mem + FD_GOSSIP_IP_ADDR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->addrs_gaddr = 0UL;
  fd_bincode_compact_u16_decode_unsafe( &self->sockets_len, ctx );
  if( self->sockets_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_GOSSIP_SOCKET_ENTRY_ALIGN );
    self->sockets_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_GOSSIP_SOCKET_ENTRY_FOOTPRINT*self->sockets_len;
    for( ulong i=0; i < self->sockets_len; i++ ) {
      fd_gossip_socket_entry_new( (fd_gossip_socket_entry_t *)(cur_mem + FD_GOSSIP_SOCKET_ENTRY_FOOTPRINT * i) );
      fd_gossip_socket_entry_decode_inner_global( cur_mem + FD_GOSSIP_SOCKET_ENTRY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->sockets_gaddr = 0UL;
  fd_bincode_compact_u16_decode_unsafe( &self->extensions_len, ctx );
  if( self->extensions_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->extensions_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(uint)*self->extensions_len;
    for( ulong i=0; i < self->extensions_len; i++ ) {
      fd_bincode_uint32_decode_unsafe( (uint*)(cur_mem + sizeof(uint) * i), ctx );
    }
  } else
    self->extensions_gaddr = 0UL;
}
int fd_gossip_contact_info_v2_convert_global_to_local( void const * global_self, fd_gossip_contact_info_v2_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_contact_info_v2_global_t const * mem = (fd_gossip_contact_info_v2_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->outset = mem->outset;
  self->shred_version = mem->shred_version;
  err = fd_gossip_version_v3_convert_global_to_local( &mem->version, &self->version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->addrs_len = mem->addrs_len;
  self->addrs     = fd_wksp_laddr_fast( ctx->wksp, mem->addrs_gaddr );
  self->sockets_len = mem->sockets_len;
  self->sockets     = fd_wksp_laddr_fast( ctx->wksp, mem->sockets_gaddr );
  self->extensions_len = mem->extensions_len;
  self->extensions     = fd_wksp_laddr_fast( ctx->wksp, mem->extensions_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_contact_info_v2_new(fd_gossip_contact_info_v2_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_contact_info_v2_t) );
  fd_pubkey_new( &self->from );
  fd_gossip_version_v3_new( &self->version );
}
void fd_gossip_contact_info_v2_destroy( fd_gossip_contact_info_v2_t * self ) {
  fd_pubkey_destroy( &self->from );
  fd_gossip_version_v3_destroy( &self->version );
  if( self->addrs ) {
    for( ulong i=0; i < self->addrs_len; i++ )
      fd_gossip_ip_addr_destroy( self->addrs + i );
    self->addrs = NULL;
  }
  if( self->sockets ) {
    for( ulong i=0; i < self->sockets_len; i++ )
      fd_gossip_socket_entry_destroy( self->sockets + i );
    self->sockets = NULL;
  }
  if( self->extensions ) {
    self->extensions = NULL;
  }
}

ulong fd_gossip_contact_info_v2_footprint( void ){ return FD_GOSSIP_CONTACT_INFO_V2_FOOTPRINT; }
ulong fd_gossip_contact_info_v2_align( void ){ return FD_GOSSIP_CONTACT_INFO_V2_ALIGN; }

void fd_gossip_contact_info_v2_walk( void * w, fd_gossip_contact_info_v2_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_contact_info_v2", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->outset, "outset", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->shred_version, "shred_version", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fd_gossip_version_v3_walk( w, &self->version, fun, "version", level );
  if( self->addrs_len ) {
    fun( w, NULL, "addrs", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->addrs_len; i++ )
      fd_gossip_ip_addr_walk(w, self->addrs + i, fun, "gossip_ip_addr", level );
    fun( w, NULL, "addrs", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->sockets_len ) {
    fun( w, NULL, "sockets", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->sockets_len; i++ )
      fd_gossip_socket_entry_walk(w, self->sockets + i, fun, "gossip_socket_entry", level );
    fun( w, NULL, "sockets", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->extensions_len ) {
    fun( w, NULL, "extensions", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->extensions_len; i++ )
      fun( w, self->extensions + i, "extensions", FD_FLAMENCO_TYPE_UINT,    "uint",    level );
    fun( w, NULL, "extensions", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_contact_info_v2", level-- );
}
ulong fd_gossip_contact_info_v2_size( fd_gossip_contact_info_v2_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += fd_bincode_varint_size( self->wallclock );
  size += sizeof(ulong);
  size += sizeof(ushort);
  size += fd_gossip_version_v3_size( &self->version );
  do {
    ushort tmp = (ushort)self->addrs_len;
    size += fd_bincode_compact_u16_size( &tmp );
    for( ulong i=0; i < self->addrs_len; i++ )
      size += fd_gossip_ip_addr_size( self->addrs + i );
  } while(0);
  do {
    ushort tmp = (ushort)self->sockets_len;
    size += fd_bincode_compact_u16_size( &tmp );
    for( ulong i=0; i < self->sockets_len; i++ )
      size += fd_gossip_socket_entry_size( self->sockets + i );
  } while(0);
  do {
    ushort tmp = (ushort)self->extensions_len;
    size += fd_bincode_compact_u16_size( &tmp );
    size += self->extensions_len * sizeof(uint);
  } while(0);
  return size;
}

int fd_restart_run_length_encoding_inner_encode( fd_restart_run_length_encoding_inner_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_compact_u16_encode( &self->bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_restart_run_length_encoding_inner_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_restart_run_length_encoding_inner_t);
  void const * start_data = ctx->data;
  int err = fd_restart_run_length_encoding_inner_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_restart_run_length_encoding_inner_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  do { ushort _tmp; err = fd_bincode_compact_u16_decode( &_tmp, ctx ); } while(0);
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_restart_run_length_encoding_inner_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_inner_t * self = (fd_restart_run_length_encoding_inner_t *)mem;
  fd_restart_run_length_encoding_inner_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_run_length_encoding_inner_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_run_length_encoding_inner_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_run_length_encoding_inner_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_inner_t * self = (fd_restart_run_length_encoding_inner_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->bits, ctx );
}
void * fd_restart_run_length_encoding_inner_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_inner_global_t * self = (fd_restart_run_length_encoding_inner_global_t *)mem;
  fd_restart_run_length_encoding_inner_new( (fd_restart_run_length_encoding_inner_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_run_length_encoding_inner_global_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_run_length_encoding_inner_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_run_length_encoding_inner_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_inner_global_t * self = (fd_restart_run_length_encoding_inner_global_t *)struct_mem;
  fd_bincode_compact_u16_decode_unsafe( &self->bits, ctx );
}
int fd_restart_run_length_encoding_inner_convert_global_to_local( void const * global_self, fd_restart_run_length_encoding_inner_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_restart_run_length_encoding_inner_global_t const * mem = (fd_restart_run_length_encoding_inner_global_t const *)global_self;
  self->bits = mem->bits;
  return FD_BINCODE_SUCCESS;
}
void fd_restart_run_length_encoding_inner_new(fd_restart_run_length_encoding_inner_t * self) {
  fd_memset( self, 0, sizeof(fd_restart_run_length_encoding_inner_t) );
}
void fd_restart_run_length_encoding_inner_destroy( fd_restart_run_length_encoding_inner_t * self ) {
}

ulong fd_restart_run_length_encoding_inner_footprint( void ){ return FD_RESTART_RUN_LENGTH_ENCODING_INNER_FOOTPRINT; }
ulong fd_restart_run_length_encoding_inner_align( void ){ return FD_RESTART_RUN_LENGTH_ENCODING_INNER_ALIGN; }

void fd_restart_run_length_encoding_inner_walk( void * w, fd_restart_run_length_encoding_inner_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_restart_run_length_encoding_inner", level++ );
  fun( w, &self->bits, "bits", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_restart_run_length_encoding_inner", level-- );
}
ulong fd_restart_run_length_encoding_inner_size( fd_restart_run_length_encoding_inner_t const * self ) {
  ulong size = 0;
  size += fd_bincode_compact_u16_size( &self->bits );
  return size;
}

int fd_restart_run_length_encoding_encode( fd_restart_run_length_encoding_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->offsets_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->offsets_len ) {
    for( ulong i=0; i < self->offsets_len; i++ ) {
      err = fd_restart_run_length_encoding_inner_encode( self->offsets + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_restart_run_length_encoding_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_restart_run_length_encoding_t);
  void const * start_data = ctx->data;
  int err = fd_restart_run_length_encoding_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_restart_run_length_encoding_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong offsets_len;
  err = fd_bincode_uint64_decode( &offsets_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( offsets_len ) {
    *total_sz += FD_RESTART_RUN_LENGTH_ENCODING_INNER_ALIGN + FD_RESTART_RUN_LENGTH_ENCODING_INNER_FOOTPRINT*offsets_len;
    for( ulong i=0; i < offsets_len; i++ ) {
      err = fd_restart_run_length_encoding_inner_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_restart_run_length_encoding_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_t * self = (fd_restart_run_length_encoding_t *)mem;
  fd_restart_run_length_encoding_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_run_length_encoding_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_run_length_encoding_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_run_length_encoding_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_t * self = (fd_restart_run_length_encoding_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->offsets_len, ctx );
  if( self->offsets_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_RESTART_RUN_LENGTH_ENCODING_INNER_ALIGN );
    self->offsets = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_RESTART_RUN_LENGTH_ENCODING_INNER_FOOTPRINT*self->offsets_len;
    for( ulong i=0; i < self->offsets_len; i++ ) {
      fd_restart_run_length_encoding_inner_new( self->offsets + i );
      fd_restart_run_length_encoding_inner_decode_inner( self->offsets + i, alloc_mem, ctx );
    }
  } else
    self->offsets = NULL;
}
void * fd_restart_run_length_encoding_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_global_t * self = (fd_restart_run_length_encoding_global_t *)mem;
  fd_restart_run_length_encoding_new( (fd_restart_run_length_encoding_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_run_length_encoding_global_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_run_length_encoding_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_run_length_encoding_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_run_length_encoding_global_t * self = (fd_restart_run_length_encoding_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->offsets_len, ctx );
  if( self->offsets_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_RESTART_RUN_LENGTH_ENCODING_INNER_ALIGN );
    self->offsets_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_RESTART_RUN_LENGTH_ENCODING_INNER_FOOTPRINT*self->offsets_len;
    for( ulong i=0; i < self->offsets_len; i++ ) {
      fd_restart_run_length_encoding_inner_new( (fd_restart_run_length_encoding_inner_t *)(cur_mem + FD_RESTART_RUN_LENGTH_ENCODING_INNER_FOOTPRINT * i) );
      fd_restart_run_length_encoding_inner_decode_inner_global( cur_mem + FD_RESTART_RUN_LENGTH_ENCODING_INNER_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->offsets_gaddr = 0UL;
}
int fd_restart_run_length_encoding_convert_global_to_local( void const * global_self, fd_restart_run_length_encoding_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_restart_run_length_encoding_global_t const * mem = (fd_restart_run_length_encoding_global_t const *)global_self;
  self->offsets_len = mem->offsets_len;
  self->offsets     = fd_wksp_laddr_fast( ctx->wksp, mem->offsets_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_restart_run_length_encoding_new(fd_restart_run_length_encoding_t * self) {
  fd_memset( self, 0, sizeof(fd_restart_run_length_encoding_t) );
}
void fd_restart_run_length_encoding_destroy( fd_restart_run_length_encoding_t * self ) {
  if( self->offsets ) {
    for( ulong i=0; i < self->offsets_len; i++ )
      fd_restart_run_length_encoding_inner_destroy( self->offsets + i );
    self->offsets = NULL;
  }
}

ulong fd_restart_run_length_encoding_footprint( void ){ return FD_RESTART_RUN_LENGTH_ENCODING_FOOTPRINT; }
ulong fd_restart_run_length_encoding_align( void ){ return FD_RESTART_RUN_LENGTH_ENCODING_ALIGN; }

void fd_restart_run_length_encoding_walk( void * w, fd_restart_run_length_encoding_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_restart_run_length_encoding", level++ );
  if( self->offsets_len ) {
    fun( w, NULL, "offsets", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->offsets_len; i++ )
      fd_restart_run_length_encoding_inner_walk(w, self->offsets + i, fun, "restart_run_length_encoding_inner", level );
    fun( w, NULL, "offsets", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_restart_run_length_encoding", level-- );
}
ulong fd_restart_run_length_encoding_size( fd_restart_run_length_encoding_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->offsets_len; i++ )
      size += fd_restart_run_length_encoding_inner_size( self->offsets + i );
  } while(0);
  return size;
}

int fd_restart_raw_offsets_bitvec_u8_inner_encode( fd_restart_raw_offsets_bitvec_u8_inner_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->bits_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->bits_len ) {
    err = fd_bincode_bytes_encode( self->bits, self->bits_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_restart_raw_offsets_bitvec_u8_inner_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_restart_raw_offsets_bitvec_u8_inner_t);
  void const * start_data = ctx->data;
  int err = fd_restart_raw_offsets_bitvec_u8_inner_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_restart_raw_offsets_bitvec_u8_inner_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong bits_len;
  err = fd_bincode_uint64_decode( &bits_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( bits_len ) {
    *total_sz += 8UL + bits_len;
    err = fd_bincode_bytes_decode_footprint( bits_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_restart_raw_offsets_bitvec_u8_inner_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_u8_inner_t * self = (fd_restart_raw_offsets_bitvec_u8_inner_t *)mem;
  fd_restart_raw_offsets_bitvec_u8_inner_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_raw_offsets_bitvec_u8_inner_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_raw_offsets_bitvec_u8_inner_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_raw_offsets_bitvec_u8_inner_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_u8_inner_t * self = (fd_restart_raw_offsets_bitvec_u8_inner_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->bits_len, ctx );
  if( self->bits_len ) {
    self->bits = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->bits, self->bits_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bits_len;
  } else
    self->bits = NULL;
}
void * fd_restart_raw_offsets_bitvec_u8_inner_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_u8_inner_global_t * self = (fd_restart_raw_offsets_bitvec_u8_inner_global_t *)mem;
  fd_restart_raw_offsets_bitvec_u8_inner_new( (fd_restart_raw_offsets_bitvec_u8_inner_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_raw_offsets_bitvec_u8_inner_global_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_raw_offsets_bitvec_u8_inner_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_raw_offsets_bitvec_u8_inner_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_u8_inner_global_t * self = (fd_restart_raw_offsets_bitvec_u8_inner_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->bits_len, ctx );
  if( self->bits_len ) {
    self->bits_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->bits_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->bits_len;
  } else
    self->bits_gaddr = 0UL;
}
int fd_restart_raw_offsets_bitvec_u8_inner_convert_global_to_local( void const * global_self, fd_restart_raw_offsets_bitvec_u8_inner_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_restart_raw_offsets_bitvec_u8_inner_global_t const * mem = (fd_restart_raw_offsets_bitvec_u8_inner_global_t const *)global_self;
  self->bits_len = mem->bits_len;
  self->bits     = fd_wksp_laddr_fast( ctx->wksp, mem->bits_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_restart_raw_offsets_bitvec_u8_inner_new(fd_restart_raw_offsets_bitvec_u8_inner_t * self) {
  fd_memset( self, 0, sizeof(fd_restart_raw_offsets_bitvec_u8_inner_t) );
}
void fd_restart_raw_offsets_bitvec_u8_inner_destroy( fd_restart_raw_offsets_bitvec_u8_inner_t * self ) {
  if( self->bits ) {
    self->bits = NULL;
  }
}

ulong fd_restart_raw_offsets_bitvec_u8_inner_footprint( void ){ return FD_RESTART_RAW_OFFSETS_BITVEC_U8_INNER_FOOTPRINT; }
ulong fd_restart_raw_offsets_bitvec_u8_inner_align( void ){ return FD_RESTART_RAW_OFFSETS_BITVEC_U8_INNER_ALIGN; }

void fd_restart_raw_offsets_bitvec_u8_inner_walk( void * w, fd_restart_raw_offsets_bitvec_u8_inner_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_restart_raw_offsets_bitvec_u8_inner", level++ );
  fun(w, self->bits, "bits", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_restart_raw_offsets_bitvec_u8_inner", level-- );
}
ulong fd_restart_raw_offsets_bitvec_u8_inner_size( fd_restart_raw_offsets_bitvec_u8_inner_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->bits_len;
  } while(0);
  return size;
}

int fd_restart_raw_offsets_bitvec_encode( fd_restart_raw_offsets_bitvec_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_bool_encode( self->has_bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  if( self->has_bits ) {
    err = fd_restart_raw_offsets_bitvec_u8_inner_encode( &self->bits, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->len, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_restart_raw_offsets_bitvec_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_restart_raw_offsets_bitvec_t);
  void const * start_data = ctx->data;
  int err = fd_restart_raw_offsets_bitvec_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_restart_raw_offsets_bitvec_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
      err = fd_restart_raw_offsets_bitvec_u8_inner_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_restart_raw_offsets_bitvec_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_t * self = (fd_restart_raw_offsets_bitvec_t *)mem;
  fd_restart_raw_offsets_bitvec_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_raw_offsets_bitvec_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_raw_offsets_bitvec_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_raw_offsets_bitvec_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_t * self = (fd_restart_raw_offsets_bitvec_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_bits = !!o;
    if( o ) {
      fd_restart_raw_offsets_bitvec_u8_inner_new( &self->bits );
      fd_restart_raw_offsets_bitvec_u8_inner_decode_inner( &self->bits, alloc_mem, ctx );
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
void * fd_restart_raw_offsets_bitvec_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_global_t * self = (fd_restart_raw_offsets_bitvec_global_t *)mem;
  fd_restart_raw_offsets_bitvec_new( (fd_restart_raw_offsets_bitvec_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_raw_offsets_bitvec_global_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_raw_offsets_bitvec_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_raw_offsets_bitvec_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_bitvec_global_t * self = (fd_restart_raw_offsets_bitvec_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    self->has_bits = !!o;
    if( o ) {
      fd_restart_raw_offsets_bitvec_u8_inner_new( &self->bits );
      fd_restart_raw_offsets_bitvec_u8_inner_decode_inner_global( &self->bits, alloc_mem, ctx );
    }
  }
  fd_bincode_uint64_decode_unsafe( &self->len, ctx );
}
int fd_restart_raw_offsets_bitvec_convert_global_to_local( void const * global_self, fd_restart_raw_offsets_bitvec_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_restart_raw_offsets_bitvec_global_t const * mem = (fd_restart_raw_offsets_bitvec_global_t const *)global_self;
  self->bits = mem->bits;
  self->has_bits = mem->has_bits;
  self->len = mem->len;
  return FD_BINCODE_SUCCESS;
}
void fd_restart_raw_offsets_bitvec_new(fd_restart_raw_offsets_bitvec_t * self) {
  fd_memset( self, 0, sizeof(fd_restart_raw_offsets_bitvec_t) );
}
void fd_restart_raw_offsets_bitvec_destroy( fd_restart_raw_offsets_bitvec_t * self ) {
  if( self->has_bits ) {
    fd_restart_raw_offsets_bitvec_u8_inner_destroy( &self->bits );
    self->has_bits = 0;
  }
}

ulong fd_restart_raw_offsets_bitvec_footprint( void ){ return FD_RESTART_RAW_OFFSETS_BITVEC_FOOTPRINT; }
ulong fd_restart_raw_offsets_bitvec_align( void ){ return FD_RESTART_RAW_OFFSETS_BITVEC_ALIGN; }

void fd_restart_raw_offsets_bitvec_walk( void * w, fd_restart_raw_offsets_bitvec_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_restart_raw_offsets_bitvec", level++ );
  if( !self->has_bits ) {
    fun( w, NULL, "bits", FD_FLAMENCO_TYPE_NULL, "restart_raw_offsets_bitvec_u8_inner", level );
  } else {
    fd_restart_raw_offsets_bitvec_u8_inner_walk( w, &self->bits, fun, "bits", level );
  }
  fun( w, &self->len, "len", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_restart_raw_offsets_bitvec", level-- );
}
ulong fd_restart_raw_offsets_bitvec_size( fd_restart_raw_offsets_bitvec_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( self->has_bits ) {
    size += fd_restart_raw_offsets_bitvec_u8_inner_size( &self->bits );
  }
  size += sizeof(ulong);
  return size;
}

int fd_restart_raw_offsets_encode( fd_restart_raw_offsets_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_restart_raw_offsets_bitvec_encode( &self->offsets, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_restart_raw_offsets_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_restart_raw_offsets_t);
  void const * start_data = ctx->data;
  int err = fd_restart_raw_offsets_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_restart_raw_offsets_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_restart_raw_offsets_bitvec_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_restart_raw_offsets_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_t * self = (fd_restart_raw_offsets_t *)mem;
  fd_restart_raw_offsets_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_raw_offsets_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_raw_offsets_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_raw_offsets_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_t * self = (fd_restart_raw_offsets_t *)struct_mem;
  fd_restart_raw_offsets_bitvec_decode_inner( &self->offsets, alloc_mem, ctx );
}
void * fd_restart_raw_offsets_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_global_t * self = (fd_restart_raw_offsets_global_t *)mem;
  fd_restart_raw_offsets_new( (fd_restart_raw_offsets_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_raw_offsets_global_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_raw_offsets_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_raw_offsets_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_raw_offsets_global_t * self = (fd_restart_raw_offsets_global_t *)struct_mem;
  fd_restart_raw_offsets_bitvec_decode_inner_global( &self->offsets, alloc_mem, ctx );
}
int fd_restart_raw_offsets_convert_global_to_local( void const * global_self, fd_restart_raw_offsets_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_restart_raw_offsets_global_t const * mem = (fd_restart_raw_offsets_global_t const *)global_self;
  err = fd_restart_raw_offsets_bitvec_convert_global_to_local( &mem->offsets, &self->offsets, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_restart_raw_offsets_new(fd_restart_raw_offsets_t * self) {
  fd_memset( self, 0, sizeof(fd_restart_raw_offsets_t) );
  fd_restart_raw_offsets_bitvec_new( &self->offsets );
}
void fd_restart_raw_offsets_destroy( fd_restart_raw_offsets_t * self ) {
  fd_restart_raw_offsets_bitvec_destroy( &self->offsets );
}

ulong fd_restart_raw_offsets_footprint( void ){ return FD_RESTART_RAW_OFFSETS_FOOTPRINT; }
ulong fd_restart_raw_offsets_align( void ){ return FD_RESTART_RAW_OFFSETS_ALIGN; }

void fd_restart_raw_offsets_walk( void * w, fd_restart_raw_offsets_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_restart_raw_offsets", level++ );
  fd_restart_raw_offsets_bitvec_walk( w, &self->offsets, fun, "offsets", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_restart_raw_offsets", level-- );
}
ulong fd_restart_raw_offsets_size( fd_restart_raw_offsets_t const * self ) {
  ulong size = 0;
  size += fd_restart_raw_offsets_bitvec_size( &self->offsets );
  return size;
}

FD_FN_PURE uchar fd_restart_slots_offsets_is_run_length_encoding(fd_restart_slots_offsets_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_restart_slots_offsets_is_raw_offsets(fd_restart_slots_offsets_t const * self) {
  return self->discriminant == 1;
}
void fd_restart_slots_offsets_inner_new( fd_restart_slots_offsets_inner_t * self, uint discriminant );
int fd_restart_slots_offsets_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_restart_run_length_encoding_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_restart_raw_offsets_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_restart_slots_offsets_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_restart_slots_offsets_t);
  void const * start_data = ctx->data;
  int err =  fd_restart_slots_offsets_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_restart_slots_offsets_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_restart_slots_offsets_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_restart_slots_offsets_inner_decode_inner( fd_restart_slots_offsets_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_restart_run_length_encoding_decode_inner( &self->run_length_encoding, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_restart_raw_offsets_decode_inner( &self->raw_offsets, alloc_mem, ctx );
    break;
  }
  }
}
void fd_restart_slots_offsets_inner_decode_inner_global( fd_restart_slots_offsets_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_restart_run_length_encoding_decode_inner_global( &self->run_length_encoding, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_restart_raw_offsets_decode_inner_global( &self->raw_offsets, alloc_mem, ctx );
    break;
  }
  }
}
int fd_restart_slots_offsets_convert_global_to_local_inner( fd_restart_slots_offsets_inner_global_t const * mem, fd_restart_slots_offsets_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_restart_run_length_encoding_convert_global_to_local( &mem->run_length_encoding, &self->run_length_encoding, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_restart_raw_offsets_convert_global_to_local( &mem->raw_offsets, &self->raw_offsets, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_restart_slots_offsets_convert_global_to_local( void const * global_self, fd_restart_slots_offsets_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_slots_offsets_global_t const * mem = (fd_restart_slots_offsets_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_restart_slots_offsets_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_restart_slots_offsets_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_slots_offsets_t * self = (fd_restart_slots_offsets_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_restart_slots_offsets_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_restart_slots_offsets_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_slots_offsets_t * self = (fd_restart_slots_offsets_t *)mem;
  fd_restart_slots_offsets_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_slots_offsets_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_slots_offsets_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_restart_slots_offsets_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_slots_offsets_t * self = (fd_restart_slots_offsets_t *)mem;
  fd_restart_slots_offsets_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_restart_slots_offsets_t);
  void * * alloc_mem = &alloc_region;
  fd_restart_slots_offsets_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_restart_slots_offsets_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_restart_slots_offsets_global_t * self = (fd_restart_slots_offsets_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_restart_slots_offsets_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_restart_slots_offsets_inner_new( fd_restart_slots_offsets_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_restart_run_length_encoding_new( &self->run_length_encoding );
    break;
  }
  case 1: {
    fd_restart_raw_offsets_new( &self->raw_offsets );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_restart_slots_offsets_new_disc( fd_restart_slots_offsets_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_restart_slots_offsets_inner_new( &self->inner, self->discriminant );
}
void fd_restart_slots_offsets_new( fd_restart_slots_offsets_t * self ) {
  fd_memset( self, 0, sizeof(fd_restart_slots_offsets_t) );
  fd_restart_slots_offsets_new_disc( self, UINT_MAX );
}
void fd_restart_slots_offsets_inner_destroy( fd_restart_slots_offsets_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_restart_run_length_encoding_destroy( &self->run_length_encoding );
    break;
  }
  case 1: {
    fd_restart_raw_offsets_destroy( &self->raw_offsets );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_restart_slots_offsets_destroy( fd_restart_slots_offsets_t * self ) {
  fd_restart_slots_offsets_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_restart_slots_offsets_footprint( void ){ return FD_RESTART_SLOTS_OFFSETS_FOOTPRINT; }
ulong fd_restart_slots_offsets_align( void ){ return FD_RESTART_SLOTS_OFFSETS_ALIGN; }

void fd_restart_slots_offsets_walk( void * w, fd_restart_slots_offsets_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_restart_slots_offsets", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "run_length_encoding", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_restart_run_length_encoding_walk( w, &self->inner.run_length_encoding, fun, "run_length_encoding", level );
    break;
  }
  case 1: {
    fun( w, self, "raw_offsets", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_restart_raw_offsets_walk( w, &self->inner.raw_offsets, fun, "raw_offsets", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_restart_slots_offsets", level-- );
}
ulong fd_restart_slots_offsets_size( fd_restart_slots_offsets_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_restart_run_length_encoding_size( &self->inner.run_length_encoding );
    break;
  }
  case 1: {
    size += fd_restart_raw_offsets_size( &self->inner.raw_offsets );
    break;
  }
  }
  return size;
}

int fd_restart_slots_offsets_inner_encode( fd_restart_slots_offsets_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_restart_run_length_encoding_encode( &self->run_length_encoding, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_restart_raw_offsets_encode( &self->raw_offsets, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_restart_slots_offsets_encode( fd_restart_slots_offsets_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_restart_slots_offsets_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_gossip_restart_last_voted_fork_slots_encode( fd_gossip_restart_last_voted_fork_slots_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_restart_slots_offsets_encode( &self->offsets, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->last_voted_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->last_voted_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->shred_version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_restart_last_voted_fork_slots_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_restart_last_voted_fork_slots_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_restart_last_voted_fork_slots_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_restart_last_voted_fork_slots_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_restart_slots_offsets_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_restart_last_voted_fork_slots_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_last_voted_fork_slots_t * self = (fd_gossip_restart_last_voted_fork_slots_t *)mem;
  fd_gossip_restart_last_voted_fork_slots_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_restart_last_voted_fork_slots_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_restart_last_voted_fork_slots_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_restart_last_voted_fork_slots_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_last_voted_fork_slots_t * self = (fd_gossip_restart_last_voted_fork_slots_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_restart_slots_offsets_decode_inner( &self->offsets, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_voted_slot, ctx );
  fd_hash_decode_inner( &self->last_voted_hash, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
}
void * fd_gossip_restart_last_voted_fork_slots_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_last_voted_fork_slots_global_t * self = (fd_gossip_restart_last_voted_fork_slots_global_t *)mem;
  fd_gossip_restart_last_voted_fork_slots_new( (fd_gossip_restart_last_voted_fork_slots_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_restart_last_voted_fork_slots_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_restart_last_voted_fork_slots_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_restart_last_voted_fork_slots_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_last_voted_fork_slots_global_t * self = (fd_gossip_restart_last_voted_fork_slots_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_restart_slots_offsets_decode_inner_global( &self->offsets, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_voted_slot, ctx );
  fd_hash_decode_inner_global( &self->last_voted_hash, alloc_mem, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
}
int fd_gossip_restart_last_voted_fork_slots_convert_global_to_local( void const * global_self, fd_gossip_restart_last_voted_fork_slots_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_restart_last_voted_fork_slots_global_t const * mem = (fd_gossip_restart_last_voted_fork_slots_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  err = fd_restart_slots_offsets_convert_global_to_local( &mem->offsets, &self->offsets, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->last_voted_slot = mem->last_voted_slot;
  err = fd_hash_convert_global_to_local( &mem->last_voted_hash, &self->last_voted_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->shred_version = mem->shred_version;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_restart_last_voted_fork_slots_new(fd_gossip_restart_last_voted_fork_slots_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_restart_last_voted_fork_slots_t) );
  fd_pubkey_new( &self->from );
  fd_restart_slots_offsets_new( &self->offsets );
  fd_hash_new( &self->last_voted_hash );
}
void fd_gossip_restart_last_voted_fork_slots_destroy( fd_gossip_restart_last_voted_fork_slots_t * self ) {
  fd_pubkey_destroy( &self->from );
  fd_restart_slots_offsets_destroy( &self->offsets );
  fd_hash_destroy( &self->last_voted_hash );
}

ulong fd_gossip_restart_last_voted_fork_slots_footprint( void ){ return FD_GOSSIP_RESTART_LAST_VOTED_FORK_SLOTS_FOOTPRINT; }
ulong fd_gossip_restart_last_voted_fork_slots_align( void ){ return FD_GOSSIP_RESTART_LAST_VOTED_FORK_SLOTS_ALIGN; }

void fd_gossip_restart_last_voted_fork_slots_walk( void * w, fd_gossip_restart_last_voted_fork_slots_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_restart_last_voted_fork_slots", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_restart_slots_offsets_walk( w, &self->offsets, fun, "offsets", level );
  fun( w, &self->last_voted_slot, "last_voted_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->last_voted_hash, fun, "last_voted_hash", level );
  fun( w, &self->shred_version, "shred_version", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_restart_last_voted_fork_slots", level-- );
}
ulong fd_gossip_restart_last_voted_fork_slots_size( fd_gossip_restart_last_voted_fork_slots_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += fd_restart_slots_offsets_size( &self->offsets );
  size += sizeof(ulong);
  size += fd_hash_size( &self->last_voted_hash );
  size += sizeof(ushort);
  return size;
}

int fd_gossip_restart_heaviest_fork_encode( fd_gossip_restart_heaviest_fork_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->wallclock, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->last_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_hash_encode( &self->last_slot_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->observed_stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint16_encode( self->shred_version, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_restart_heaviest_fork_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_restart_heaviest_fork_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_restart_heaviest_fork_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_restart_heaviest_fork_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint16_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_gossip_restart_heaviest_fork_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_heaviest_fork_t * self = (fd_gossip_restart_heaviest_fork_t *)mem;
  fd_gossip_restart_heaviest_fork_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_restart_heaviest_fork_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_restart_heaviest_fork_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_restart_heaviest_fork_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_heaviest_fork_t * self = (fd_gossip_restart_heaviest_fork_t *)struct_mem;
  fd_pubkey_decode_inner( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_slot, ctx );
  fd_hash_decode_inner( &self->last_slot_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->observed_stake, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
}
void * fd_gossip_restart_heaviest_fork_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_heaviest_fork_global_t * self = (fd_gossip_restart_heaviest_fork_global_t *)mem;
  fd_gossip_restart_heaviest_fork_new( (fd_gossip_restart_heaviest_fork_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_restart_heaviest_fork_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_restart_heaviest_fork_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_restart_heaviest_fork_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_restart_heaviest_fork_global_t * self = (fd_gossip_restart_heaviest_fork_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->from, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->wallclock, ctx );
  fd_bincode_uint64_decode_unsafe( &self->last_slot, ctx );
  fd_hash_decode_inner_global( &self->last_slot_hash, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->observed_stake, ctx );
  fd_bincode_uint16_decode_unsafe( &self->shred_version, ctx );
}
int fd_gossip_restart_heaviest_fork_convert_global_to_local( void const * global_self, fd_gossip_restart_heaviest_fork_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_restart_heaviest_fork_global_t const * mem = (fd_gossip_restart_heaviest_fork_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->from, &self->from, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->wallclock = mem->wallclock;
  self->last_slot = mem->last_slot;
  err = fd_hash_convert_global_to_local( &mem->last_slot_hash, &self->last_slot_hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->observed_stake = mem->observed_stake;
  self->shred_version = mem->shred_version;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_restart_heaviest_fork_new(fd_gossip_restart_heaviest_fork_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_restart_heaviest_fork_t) );
  fd_pubkey_new( &self->from );
  fd_hash_new( &self->last_slot_hash );
}
void fd_gossip_restart_heaviest_fork_destroy( fd_gossip_restart_heaviest_fork_t * self ) {
  fd_pubkey_destroy( &self->from );
  fd_hash_destroy( &self->last_slot_hash );
}

ulong fd_gossip_restart_heaviest_fork_footprint( void ){ return FD_GOSSIP_RESTART_HEAVIEST_FORK_FOOTPRINT; }
ulong fd_gossip_restart_heaviest_fork_align( void ){ return FD_GOSSIP_RESTART_HEAVIEST_FORK_ALIGN; }

void fd_gossip_restart_heaviest_fork_walk( void * w, fd_gossip_restart_heaviest_fork_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_restart_heaviest_fork", level++ );
  fd_pubkey_walk( w, &self->from, fun, "from", level );
  fun( w, &self->wallclock, "wallclock", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->last_slot, "last_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_hash_walk( w, &self->last_slot_hash, fun, "last_slot_hash", level );
  fun( w, &self->observed_stake, "observed_stake", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->shred_version, "shred_version", FD_FLAMENCO_TYPE_USHORT, "ushort", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_restart_heaviest_fork", level-- );
}
ulong fd_gossip_restart_heaviest_fork_size( fd_gossip_restart_heaviest_fork_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->from );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_hash_size( &self->last_slot_hash );
  size += sizeof(ulong);
  size += sizeof(ushort);
  return size;
}

FD_FN_PURE uchar fd_crds_data_is_contact_info_v1(fd_crds_data_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_crds_data_is_vote(fd_crds_data_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_crds_data_is_lowest_slot(fd_crds_data_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_crds_data_is_snapshot_hashes(fd_crds_data_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_crds_data_is_accounts_hashes(fd_crds_data_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_crds_data_is_epoch_slots(fd_crds_data_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_crds_data_is_version_v1(fd_crds_data_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_crds_data_is_version_v2(fd_crds_data_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_crds_data_is_node_instance(fd_crds_data_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_crds_data_is_duplicate_shred(fd_crds_data_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_crds_data_is_incremental_snapshot_hashes(fd_crds_data_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_crds_data_is_contact_info_v2(fd_crds_data_t const * self) {
  return self->discriminant == 11;
}
FD_FN_PURE uchar fd_crds_data_is_restart_last_voted_fork_slots(fd_crds_data_t const * self) {
  return self->discriminant == 12;
}
FD_FN_PURE uchar fd_crds_data_is_restart_heaviest_fork(fd_crds_data_t const * self) {
  return self->discriminant == 13;
}
void fd_crds_data_inner_new( fd_crds_data_inner_t * self, uint discriminant );
int fd_crds_data_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_contact_info_v1_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_gossip_vote_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_gossip_lowest_slot_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_gossip_slot_hashes_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    err = fd_gossip_slot_hashes_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    err = fd_gossip_epoch_slots_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    err = fd_gossip_version_v1_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    err = fd_gossip_version_v2_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    err = fd_gossip_node_instance_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    err = fd_gossip_duplicate_shred_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    err = fd_gossip_incremental_snapshot_hashes_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    err = fd_gossip_contact_info_v2_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 12: {
    err = fd_gossip_restart_last_voted_fork_slots_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 13: {
    err = fd_gossip_restart_heaviest_fork_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_crds_data_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_crds_data_t);
  void const * start_data = ctx->data;
  int err =  fd_crds_data_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_crds_data_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_crds_data_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_crds_data_inner_decode_inner( fd_crds_data_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_contact_info_v1_decode_inner( &self->contact_info_v1, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_vote_decode_inner( &self->vote, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_gossip_lowest_slot_decode_inner( &self->lowest_slot, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_gossip_slot_hashes_decode_inner( &self->snapshot_hashes, alloc_mem, ctx );
    break;
  }
  case 4: {
    fd_gossip_slot_hashes_decode_inner( &self->accounts_hashes, alloc_mem, ctx );
    break;
  }
  case 5: {
    fd_gossip_epoch_slots_decode_inner( &self->epoch_slots, alloc_mem, ctx );
    break;
  }
  case 6: {
    fd_gossip_version_v1_decode_inner( &self->version_v1, alloc_mem, ctx );
    break;
  }
  case 7: {
    fd_gossip_version_v2_decode_inner( &self->version_v2, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_gossip_node_instance_decode_inner( &self->node_instance, alloc_mem, ctx );
    break;
  }
  case 9: {
    fd_gossip_duplicate_shred_decode_inner( &self->duplicate_shred, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_gossip_incremental_snapshot_hashes_decode_inner( &self->incremental_snapshot_hashes, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_gossip_contact_info_v2_decode_inner( &self->contact_info_v2, alloc_mem, ctx );
    break;
  }
  case 12: {
    fd_gossip_restart_last_voted_fork_slots_decode_inner( &self->restart_last_voted_fork_slots, alloc_mem, ctx );
    break;
  }
  case 13: {
    fd_gossip_restart_heaviest_fork_decode_inner( &self->restart_heaviest_fork, alloc_mem, ctx );
    break;
  }
  }
}
void fd_crds_data_inner_decode_inner_global( fd_crds_data_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_contact_info_v1_decode_inner_global( &self->contact_info_v1, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_vote_decode_inner_global( &self->vote, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_gossip_lowest_slot_decode_inner_global( &self->lowest_slot, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_gossip_slot_hashes_decode_inner_global( &self->snapshot_hashes, alloc_mem, ctx );
    break;
  }
  case 4: {
    fd_gossip_slot_hashes_decode_inner_global( &self->accounts_hashes, alloc_mem, ctx );
    break;
  }
  case 5: {
    fd_gossip_epoch_slots_decode_inner_global( &self->epoch_slots, alloc_mem, ctx );
    break;
  }
  case 6: {
    fd_gossip_version_v1_decode_inner_global( &self->version_v1, alloc_mem, ctx );
    break;
  }
  case 7: {
    fd_gossip_version_v2_decode_inner_global( &self->version_v2, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_gossip_node_instance_decode_inner_global( &self->node_instance, alloc_mem, ctx );
    break;
  }
  case 9: {
    fd_gossip_duplicate_shred_decode_inner_global( &self->duplicate_shred, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_gossip_incremental_snapshot_hashes_decode_inner_global( &self->incremental_snapshot_hashes, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_gossip_contact_info_v2_decode_inner_global( &self->contact_info_v2, alloc_mem, ctx );
    break;
  }
  case 12: {
    fd_gossip_restart_last_voted_fork_slots_decode_inner_global( &self->restart_last_voted_fork_slots, alloc_mem, ctx );
    break;
  }
  case 13: {
    fd_gossip_restart_heaviest_fork_decode_inner_global( &self->restart_heaviest_fork, alloc_mem, ctx );
    break;
  }
  }
}
int fd_crds_data_convert_global_to_local_inner( fd_crds_data_inner_global_t const * mem, fd_crds_data_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_gossip_contact_info_v1_convert_global_to_local( &mem->contact_info_v1, &self->contact_info_v1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_vote_convert_global_to_local( &mem->vote, &self->vote, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_gossip_lowest_slot_convert_global_to_local( &mem->lowest_slot, &self->lowest_slot, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_gossip_slot_hashes_convert_global_to_local( &mem->snapshot_hashes, &self->snapshot_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    err = fd_gossip_slot_hashes_convert_global_to_local( &mem->accounts_hashes, &self->accounts_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 5: {
    err = fd_gossip_epoch_slots_convert_global_to_local( &mem->epoch_slots, &self->epoch_slots, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 6: {
    err = fd_gossip_version_v1_convert_global_to_local( &mem->version_v1, &self->version_v1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    err = fd_gossip_version_v2_convert_global_to_local( &mem->version_v2, &self->version_v2, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_gossip_node_instance_convert_global_to_local( &mem->node_instance, &self->node_instance, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_gossip_duplicate_shred_convert_global_to_local( &mem->duplicate_shred, &self->duplicate_shred, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_gossip_incremental_snapshot_hashes_convert_global_to_local( &mem->incremental_snapshot_hashes, &self->incremental_snapshot_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_gossip_contact_info_v2_convert_global_to_local( &mem->contact_info_v2, &self->contact_info_v2, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    err = fd_gossip_restart_last_voted_fork_slots_convert_global_to_local( &mem->restart_last_voted_fork_slots, &self->restart_last_voted_fork_slots, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 13: {
    err = fd_gossip_restart_heaviest_fork_convert_global_to_local( &mem->restart_heaviest_fork, &self->restart_heaviest_fork, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_crds_data_convert_global_to_local( void const * global_self, fd_crds_data_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_data_global_t const * mem = (fd_crds_data_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_crds_data_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_crds_data_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_data_t * self = (fd_crds_data_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_crds_data_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_crds_data_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_data_t * self = (fd_crds_data_t *)mem;
  fd_crds_data_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_data_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_data_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_crds_data_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_data_t * self = (fd_crds_data_t *)mem;
  fd_crds_data_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_data_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_data_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_data_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_data_global_t * self = (fd_crds_data_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_crds_data_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_crds_data_inner_new( fd_crds_data_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_contact_info_v1_new( &self->contact_info_v1 );
    break;
  }
  case 1: {
    fd_gossip_vote_new( &self->vote );
    break;
  }
  case 2: {
    fd_gossip_lowest_slot_new( &self->lowest_slot );
    break;
  }
  case 3: {
    fd_gossip_slot_hashes_new( &self->snapshot_hashes );
    break;
  }
  case 4: {
    fd_gossip_slot_hashes_new( &self->accounts_hashes );
    break;
  }
  case 5: {
    fd_gossip_epoch_slots_new( &self->epoch_slots );
    break;
  }
  case 6: {
    fd_gossip_version_v1_new( &self->version_v1 );
    break;
  }
  case 7: {
    fd_gossip_version_v2_new( &self->version_v2 );
    break;
  }
  case 8: {
    fd_gossip_node_instance_new( &self->node_instance );
    break;
  }
  case 9: {
    fd_gossip_duplicate_shred_new( &self->duplicate_shred );
    break;
  }
  case 10: {
    fd_gossip_incremental_snapshot_hashes_new( &self->incremental_snapshot_hashes );
    break;
  }
  case 11: {
    fd_gossip_contact_info_v2_new( &self->contact_info_v2 );
    break;
  }
  case 12: {
    fd_gossip_restart_last_voted_fork_slots_new( &self->restart_last_voted_fork_slots );
    break;
  }
  case 13: {
    fd_gossip_restart_heaviest_fork_new( &self->restart_heaviest_fork );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_crds_data_new_disc( fd_crds_data_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_crds_data_inner_new( &self->inner, self->discriminant );
}
void fd_crds_data_new( fd_crds_data_t * self ) {
  fd_memset( self, 0, sizeof(fd_crds_data_t) );
  fd_crds_data_new_disc( self, UINT_MAX );
}
void fd_crds_data_inner_destroy( fd_crds_data_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_contact_info_v1_destroy( &self->contact_info_v1 );
    break;
  }
  case 1: {
    fd_gossip_vote_destroy( &self->vote );
    break;
  }
  case 2: {
    fd_gossip_lowest_slot_destroy( &self->lowest_slot );
    break;
  }
  case 3: {
    fd_gossip_slot_hashes_destroy( &self->snapshot_hashes );
    break;
  }
  case 4: {
    fd_gossip_slot_hashes_destroy( &self->accounts_hashes );
    break;
  }
  case 5: {
    fd_gossip_epoch_slots_destroy( &self->epoch_slots );
    break;
  }
  case 6: {
    fd_gossip_version_v1_destroy( &self->version_v1 );
    break;
  }
  case 7: {
    fd_gossip_version_v2_destroy( &self->version_v2 );
    break;
  }
  case 8: {
    fd_gossip_node_instance_destroy( &self->node_instance );
    break;
  }
  case 9: {
    fd_gossip_duplicate_shred_destroy( &self->duplicate_shred );
    break;
  }
  case 10: {
    fd_gossip_incremental_snapshot_hashes_destroy( &self->incremental_snapshot_hashes );
    break;
  }
  case 11: {
    fd_gossip_contact_info_v2_destroy( &self->contact_info_v2 );
    break;
  }
  case 12: {
    fd_gossip_restart_last_voted_fork_slots_destroy( &self->restart_last_voted_fork_slots );
    break;
  }
  case 13: {
    fd_gossip_restart_heaviest_fork_destroy( &self->restart_heaviest_fork );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_crds_data_destroy( fd_crds_data_t * self ) {
  fd_crds_data_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_crds_data_footprint( void ){ return FD_CRDS_DATA_FOOTPRINT; }
ulong fd_crds_data_align( void ){ return FD_CRDS_DATA_ALIGN; }

void fd_crds_data_walk( void * w, fd_crds_data_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_crds_data", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "contact_info_v1", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_contact_info_v1_walk( w, &self->inner.contact_info_v1, fun, "contact_info_v1", level );
    break;
  }
  case 1: {
    fun( w, self, "vote", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_vote_walk( w, &self->inner.vote, fun, "vote", level );
    break;
  }
  case 2: {
    fun( w, self, "lowest_slot", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_lowest_slot_walk( w, &self->inner.lowest_slot, fun, "lowest_slot", level );
    break;
  }
  case 3: {
    fun( w, self, "snapshot_hashes", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_slot_hashes_walk( w, &self->inner.snapshot_hashes, fun, "snapshot_hashes", level );
    break;
  }
  case 4: {
    fun( w, self, "accounts_hashes", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_slot_hashes_walk( w, &self->inner.accounts_hashes, fun, "accounts_hashes", level );
    break;
  }
  case 5: {
    fun( w, self, "epoch_slots", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_epoch_slots_walk( w, &self->inner.epoch_slots, fun, "epoch_slots", level );
    break;
  }
  case 6: {
    fun( w, self, "version_v1", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_version_v1_walk( w, &self->inner.version_v1, fun, "version_v1", level );
    break;
  }
  case 7: {
    fun( w, self, "version_v2", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_version_v2_walk( w, &self->inner.version_v2, fun, "version_v2", level );
    break;
  }
  case 8: {
    fun( w, self, "node_instance", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_node_instance_walk( w, &self->inner.node_instance, fun, "node_instance", level );
    break;
  }
  case 9: {
    fun( w, self, "duplicate_shred", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_duplicate_shred_walk( w, &self->inner.duplicate_shred, fun, "duplicate_shred", level );
    break;
  }
  case 10: {
    fun( w, self, "incremental_snapshot_hashes", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_incremental_snapshot_hashes_walk( w, &self->inner.incremental_snapshot_hashes, fun, "incremental_snapshot_hashes", level );
    break;
  }
  case 11: {
    fun( w, self, "contact_info_v2", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_contact_info_v2_walk( w, &self->inner.contact_info_v2, fun, "contact_info_v2", level );
    break;
  }
  case 12: {
    fun( w, self, "restart_last_voted_fork_slots", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_restart_last_voted_fork_slots_walk( w, &self->inner.restart_last_voted_fork_slots, fun, "restart_last_voted_fork_slots", level );
    break;
  }
  case 13: {
    fun( w, self, "restart_heaviest_fork", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_restart_heaviest_fork_walk( w, &self->inner.restart_heaviest_fork, fun, "restart_heaviest_fork", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_crds_data", level-- );
}
ulong fd_crds_data_size( fd_crds_data_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_gossip_contact_info_v1_size( &self->inner.contact_info_v1 );
    break;
  }
  case 1: {
    size += fd_gossip_vote_size( &self->inner.vote );
    break;
  }
  case 2: {
    size += fd_gossip_lowest_slot_size( &self->inner.lowest_slot );
    break;
  }
  case 3: {
    size += fd_gossip_slot_hashes_size( &self->inner.snapshot_hashes );
    break;
  }
  case 4: {
    size += fd_gossip_slot_hashes_size( &self->inner.accounts_hashes );
    break;
  }
  case 5: {
    size += fd_gossip_epoch_slots_size( &self->inner.epoch_slots );
    break;
  }
  case 6: {
    size += fd_gossip_version_v1_size( &self->inner.version_v1 );
    break;
  }
  case 7: {
    size += fd_gossip_version_v2_size( &self->inner.version_v2 );
    break;
  }
  case 8: {
    size += fd_gossip_node_instance_size( &self->inner.node_instance );
    break;
  }
  case 9: {
    size += fd_gossip_duplicate_shred_size( &self->inner.duplicate_shred );
    break;
  }
  case 10: {
    size += fd_gossip_incremental_snapshot_hashes_size( &self->inner.incremental_snapshot_hashes );
    break;
  }
  case 11: {
    size += fd_gossip_contact_info_v2_size( &self->inner.contact_info_v2 );
    break;
  }
  case 12: {
    size += fd_gossip_restart_last_voted_fork_slots_size( &self->inner.restart_last_voted_fork_slots );
    break;
  }
  case 13: {
    size += fd_gossip_restart_heaviest_fork_size( &self->inner.restart_heaviest_fork );
    break;
  }
  }
  return size;
}

int fd_crds_data_inner_encode( fd_crds_data_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_contact_info_v1_encode( &self->contact_info_v1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_vote_encode( &self->vote, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_gossip_lowest_slot_encode( &self->lowest_slot, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_gossip_slot_hashes_encode( &self->snapshot_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    err = fd_gossip_slot_hashes_encode( &self->accounts_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 5: {
    err = fd_gossip_epoch_slots_encode( &self->epoch_slots, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 6: {
    err = fd_gossip_version_v1_encode( &self->version_v1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 7: {
    err = fd_gossip_version_v2_encode( &self->version_v2, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_gossip_node_instance_encode( &self->node_instance, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_gossip_duplicate_shred_encode( &self->duplicate_shred, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_gossip_incremental_snapshot_hashes_encode( &self->incremental_snapshot_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_gossip_contact_info_v2_encode( &self->contact_info_v2, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 12: {
    err = fd_gossip_restart_last_voted_fork_slots_encode( &self->restart_last_voted_fork_slots, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 13: {
    err = fd_gossip_restart_heaviest_fork_encode( &self->restart_heaviest_fork, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_crds_data_encode( fd_crds_data_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_crds_data_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_crds_bloom_encode( fd_crds_bloom_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->keys_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->keys_len ) {
    for( ulong i=0; i < self->keys_len; i++ ) {
      err = fd_bincode_uint64_encode( self->keys[i], ctx );
    }
  }
  err = fd_gossip_bitvec_u64_encode( &self->bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->num_bits_set, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_crds_bloom_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_crds_bloom_t);
  void const * start_data = ctx->data;
  int err = fd_crds_bloom_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_crds_bloom_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong keys_len;
  err = fd_bincode_uint64_decode( &keys_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( keys_len ) {
    *total_sz += 8UL + sizeof(ulong)*keys_len;
    for( ulong i=0; i < keys_len; i++ ) {
      err = fd_bincode_uint64_decode_footprint( ctx );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  err = fd_gossip_bitvec_u64_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_crds_bloom_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_bloom_t * self = (fd_crds_bloom_t *)mem;
  fd_crds_bloom_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_bloom_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_bloom_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_bloom_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_bloom_t * self = (fd_crds_bloom_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->keys_len, ctx );
  if( self->keys_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->keys = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->keys_len;
    for( ulong i=0; i < self->keys_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( self->keys + i, ctx );
    }
  } else
    self->keys = NULL;
  fd_gossip_bitvec_u64_decode_inner( &self->bits, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_bits_set, ctx );
}
void * fd_crds_bloom_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_bloom_global_t * self = (fd_crds_bloom_global_t *)mem;
  fd_crds_bloom_new( (fd_crds_bloom_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_bloom_global_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_bloom_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_bloom_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_bloom_global_t * self = (fd_crds_bloom_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->keys_len, ctx );
  if( self->keys_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), 8UL );
    self->keys_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + sizeof(ulong)*self->keys_len;
    for( ulong i=0; i < self->keys_len; i++ ) {
      fd_bincode_uint64_decode_unsafe( (ulong*)(cur_mem + sizeof(ulong) * i), ctx );
    }
  } else
    self->keys_gaddr = 0UL;
  fd_gossip_bitvec_u64_decode_inner_global( &self->bits, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->num_bits_set, ctx );
}
int fd_crds_bloom_convert_global_to_local( void const * global_self, fd_crds_bloom_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_crds_bloom_global_t const * mem = (fd_crds_bloom_global_t const *)global_self;
  self->keys_len = mem->keys_len;
  self->keys     = fd_wksp_laddr_fast( ctx->wksp, mem->keys_gaddr );
  err = fd_gossip_bitvec_u64_convert_global_to_local( &mem->bits, &self->bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->num_bits_set = mem->num_bits_set;
  return FD_BINCODE_SUCCESS;
}
void fd_crds_bloom_new(fd_crds_bloom_t * self) {
  fd_memset( self, 0, sizeof(fd_crds_bloom_t) );
  fd_gossip_bitvec_u64_new( &self->bits );
}
void fd_crds_bloom_destroy( fd_crds_bloom_t * self ) {
  if( self->keys ) {
    self->keys = NULL;
  }
  fd_gossip_bitvec_u64_destroy( &self->bits );
}

ulong fd_crds_bloom_footprint( void ){ return FD_CRDS_BLOOM_FOOTPRINT; }
ulong fd_crds_bloom_align( void ){ return FD_CRDS_BLOOM_ALIGN; }

void fd_crds_bloom_walk( void * w, fd_crds_bloom_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_crds_bloom", level++ );
  if( self->keys_len ) {
    fun( w, NULL, "keys", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->keys_len; i++ )
      fun( w, self->keys + i, "keys", FD_FLAMENCO_TYPE_ULONG,   "ulong",   level );
    fun( w, NULL, "keys", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fd_gossip_bitvec_u64_walk( w, &self->bits, fun, "bits", level );
  fun( w, &self->num_bits_set, "num_bits_set", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_crds_bloom", level-- );
}
ulong fd_crds_bloom_size( fd_crds_bloom_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->keys_len * sizeof(ulong);
  } while(0);
  size += fd_gossip_bitvec_u64_size( &self->bits );
  size += sizeof(ulong);
  return size;
}

int fd_crds_filter_encode( fd_crds_filter_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_crds_bloom_encode( &self->filter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->mask, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->mask_bits, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_crds_filter_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_crds_filter_t);
  void const * start_data = ctx->data;
  int err = fd_crds_filter_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_crds_filter_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_crds_bloom_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_crds_filter_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_filter_t * self = (fd_crds_filter_t *)mem;
  fd_crds_filter_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_filter_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_filter_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_filter_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_filter_t * self = (fd_crds_filter_t *)struct_mem;
  fd_crds_bloom_decode_inner( &self->filter, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->mask, ctx );
  fd_bincode_uint32_decode_unsafe( &self->mask_bits, ctx );
}
void * fd_crds_filter_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_filter_global_t * self = (fd_crds_filter_global_t *)mem;
  fd_crds_filter_new( (fd_crds_filter_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_filter_global_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_filter_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_filter_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_filter_global_t * self = (fd_crds_filter_global_t *)struct_mem;
  fd_crds_bloom_decode_inner_global( &self->filter, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->mask, ctx );
  fd_bincode_uint32_decode_unsafe( &self->mask_bits, ctx );
}
int fd_crds_filter_convert_global_to_local( void const * global_self, fd_crds_filter_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_crds_filter_global_t const * mem = (fd_crds_filter_global_t const *)global_self;
  err = fd_crds_bloom_convert_global_to_local( &mem->filter, &self->filter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->mask = mem->mask;
  self->mask_bits = mem->mask_bits;
  return FD_BINCODE_SUCCESS;
}
void fd_crds_filter_new(fd_crds_filter_t * self) {
  fd_memset( self, 0, sizeof(fd_crds_filter_t) );
  fd_crds_bloom_new( &self->filter );
}
void fd_crds_filter_destroy( fd_crds_filter_t * self ) {
  fd_crds_bloom_destroy( &self->filter );
}

ulong fd_crds_filter_footprint( void ){ return FD_CRDS_FILTER_FOOTPRINT; }
ulong fd_crds_filter_align( void ){ return FD_CRDS_FILTER_ALIGN; }

void fd_crds_filter_walk( void * w, fd_crds_filter_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_crds_filter", level++ );
  fd_crds_bloom_walk( w, &self->filter, fun, "filter", level );
  fun( w, &self->mask, "mask", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->mask_bits, "mask_bits", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_crds_filter", level-- );
}
ulong fd_crds_filter_size( fd_crds_filter_t const * self ) {
  ulong size = 0;
  size += fd_crds_bloom_size( &self->filter );
  size += sizeof(ulong);
  size += sizeof(uint);
  return size;
}

int fd_crds_value_encode( fd_crds_value_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_signature_encode( &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_crds_data_encode( &self->data, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_crds_value_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_crds_value_t);
  void const * start_data = ctx->data;
  int err = fd_crds_value_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_crds_value_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_signature_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_crds_data_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_crds_value_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_value_t * self = (fd_crds_value_t *)mem;
  fd_crds_value_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_value_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_value_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_value_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_value_t * self = (fd_crds_value_t *)struct_mem;
  fd_signature_decode_inner( &self->signature, alloc_mem, ctx );
  fd_crds_data_decode_inner( &self->data, alloc_mem, ctx );
}
void * fd_crds_value_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_value_global_t * self = (fd_crds_value_global_t *)mem;
  fd_crds_value_new( (fd_crds_value_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_crds_value_global_t);
  void * * alloc_mem = &alloc_region;
  fd_crds_value_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_crds_value_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_crds_value_global_t * self = (fd_crds_value_global_t *)struct_mem;
  fd_signature_decode_inner_global( &self->signature, alloc_mem, ctx );
  fd_crds_data_decode_inner_global( &self->data, alloc_mem, ctx );
}
int fd_crds_value_convert_global_to_local( void const * global_self, fd_crds_value_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_crds_value_global_t const * mem = (fd_crds_value_global_t const *)global_self;
  err = fd_signature_convert_global_to_local( &mem->signature, &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_crds_data_convert_global_to_local( &mem->data, &self->data, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_crds_value_new(fd_crds_value_t * self) {
  fd_memset( self, 0, sizeof(fd_crds_value_t) );
  fd_signature_new( &self->signature );
  fd_crds_data_new( &self->data );
}
void fd_crds_value_destroy( fd_crds_value_t * self ) {
  fd_signature_destroy( &self->signature );
  fd_crds_data_destroy( &self->data );
}

ulong fd_crds_value_footprint( void ){ return FD_CRDS_VALUE_FOOTPRINT; }
ulong fd_crds_value_align( void ){ return FD_CRDS_VALUE_ALIGN; }

void fd_crds_value_walk( void * w, fd_crds_value_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_crds_value", level++ );
  fd_signature_walk( w, &self->signature, fun, "signature", level );
  fd_crds_data_walk( w, &self->data, fun, "data", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_crds_value", level-- );
}
ulong fd_crds_value_size( fd_crds_value_t const * self ) {
  ulong size = 0;
  size += fd_signature_size( &self->signature );
  size += fd_crds_data_size( &self->data );
  return size;
}

int fd_gossip_pull_req_encode( fd_gossip_pull_req_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_crds_filter_encode( &self->filter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_crds_value_encode( &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_pull_req_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_pull_req_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_pull_req_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_pull_req_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_crds_filter_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_crds_value_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_pull_req_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_req_t * self = (fd_gossip_pull_req_t *)mem;
  fd_gossip_pull_req_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_pull_req_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_pull_req_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_pull_req_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_req_t * self = (fd_gossip_pull_req_t *)struct_mem;
  fd_crds_filter_decode_inner( &self->filter, alloc_mem, ctx );
  fd_crds_value_decode_inner( &self->value, alloc_mem, ctx );
}
void * fd_gossip_pull_req_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_req_global_t * self = (fd_gossip_pull_req_global_t *)mem;
  fd_gossip_pull_req_new( (fd_gossip_pull_req_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_pull_req_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_pull_req_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_pull_req_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_req_global_t * self = (fd_gossip_pull_req_global_t *)struct_mem;
  fd_crds_filter_decode_inner_global( &self->filter, alloc_mem, ctx );
  fd_crds_value_decode_inner_global( &self->value, alloc_mem, ctx );
}
int fd_gossip_pull_req_convert_global_to_local( void const * global_self, fd_gossip_pull_req_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_pull_req_global_t const * mem = (fd_gossip_pull_req_global_t const *)global_self;
  err = fd_crds_filter_convert_global_to_local( &mem->filter, &self->filter, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_crds_value_convert_global_to_local( &mem->value, &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_pull_req_new(fd_gossip_pull_req_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_pull_req_t) );
  fd_crds_filter_new( &self->filter );
  fd_crds_value_new( &self->value );
}
void fd_gossip_pull_req_destroy( fd_gossip_pull_req_t * self ) {
  fd_crds_filter_destroy( &self->filter );
  fd_crds_value_destroy( &self->value );
}

ulong fd_gossip_pull_req_footprint( void ){ return FD_GOSSIP_PULL_REQ_FOOTPRINT; }
ulong fd_gossip_pull_req_align( void ){ return FD_GOSSIP_PULL_REQ_ALIGN; }

void fd_gossip_pull_req_walk( void * w, fd_gossip_pull_req_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_pull_req", level++ );
  fd_crds_filter_walk( w, &self->filter, fun, "filter", level );
  fd_crds_value_walk( w, &self->value, fun, "value", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_pull_req", level-- );
}
ulong fd_gossip_pull_req_size( fd_gossip_pull_req_t const * self ) {
  ulong size = 0;
  size += fd_crds_filter_size( &self->filter );
  size += fd_crds_value_size( &self->value );
  return size;
}

int fd_gossip_pull_resp_encode( fd_gossip_pull_resp_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->crds_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->crds_len ) {
    for( ulong i=0; i < self->crds_len; i++ ) {
      err = fd_crds_value_encode( self->crds + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_pull_resp_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_pull_resp_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_pull_resp_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_pull_resp_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong crds_len;
  err = fd_bincode_uint64_decode( &crds_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( crds_len ) {
    *total_sz += FD_CRDS_VALUE_ALIGN + FD_CRDS_VALUE_FOOTPRINT*crds_len;
    for( ulong i=0; i < crds_len; i++ ) {
      err = fd_crds_value_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_gossip_pull_resp_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_resp_t * self = (fd_gossip_pull_resp_t *)mem;
  fd_gossip_pull_resp_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_pull_resp_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_pull_resp_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_pull_resp_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_resp_t * self = (fd_gossip_pull_resp_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->crds_len, ctx );
  if( self->crds_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CRDS_VALUE_ALIGN );
    self->crds = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CRDS_VALUE_FOOTPRINT*self->crds_len;
    for( ulong i=0; i < self->crds_len; i++ ) {
      fd_crds_value_new( self->crds + i );
      fd_crds_value_decode_inner( self->crds + i, alloc_mem, ctx );
    }
  } else
    self->crds = NULL;
}
void * fd_gossip_pull_resp_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_resp_global_t * self = (fd_gossip_pull_resp_global_t *)mem;
  fd_gossip_pull_resp_new( (fd_gossip_pull_resp_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_pull_resp_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_pull_resp_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_pull_resp_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_pull_resp_global_t * self = (fd_gossip_pull_resp_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->crds_len, ctx );
  if( self->crds_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CRDS_VALUE_ALIGN );
    self->crds_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CRDS_VALUE_FOOTPRINT*self->crds_len;
    for( ulong i=0; i < self->crds_len; i++ ) {
      fd_crds_value_new( (fd_crds_value_t *)(cur_mem + FD_CRDS_VALUE_FOOTPRINT * i) );
      fd_crds_value_decode_inner_global( cur_mem + FD_CRDS_VALUE_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->crds_gaddr = 0UL;
}
int fd_gossip_pull_resp_convert_global_to_local( void const * global_self, fd_gossip_pull_resp_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_pull_resp_global_t const * mem = (fd_gossip_pull_resp_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->crds_len = mem->crds_len;
  self->crds     = fd_wksp_laddr_fast( ctx->wksp, mem->crds_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_pull_resp_new(fd_gossip_pull_resp_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_pull_resp_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_gossip_pull_resp_destroy( fd_gossip_pull_resp_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  if( self->crds ) {
    for( ulong i=0; i < self->crds_len; i++ )
      fd_crds_value_destroy( self->crds + i );
    self->crds = NULL;
  }
}

ulong fd_gossip_pull_resp_footprint( void ){ return FD_GOSSIP_PULL_RESP_FOOTPRINT; }
ulong fd_gossip_pull_resp_align( void ){ return FD_GOSSIP_PULL_RESP_ALIGN; }

void fd_gossip_pull_resp_walk( void * w, fd_gossip_pull_resp_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_pull_resp", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  if( self->crds_len ) {
    fun( w, NULL, "crds", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->crds_len; i++ )
      fd_crds_value_walk(w, self->crds + i, fun, "crds_value", level );
    fun( w, NULL, "crds", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_pull_resp", level-- );
}
ulong fd_gossip_pull_resp_size( fd_gossip_pull_resp_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->crds_len; i++ )
      size += fd_crds_value_size( self->crds + i );
  } while(0);
  return size;
}

int fd_gossip_push_msg_encode( fd_gossip_push_msg_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->crds_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->crds_len ) {
    for( ulong i=0; i < self->crds_len; i++ ) {
      err = fd_crds_value_encode( self->crds + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_push_msg_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_push_msg_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_push_msg_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_push_msg_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  ulong crds_len;
  err = fd_bincode_uint64_decode( &crds_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( crds_len ) {
    *total_sz += FD_CRDS_VALUE_ALIGN + FD_CRDS_VALUE_FOOTPRINT*crds_len;
    for( ulong i=0; i < crds_len; i++ ) {
      err = fd_crds_value_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_gossip_push_msg_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_push_msg_t * self = (fd_gossip_push_msg_t *)mem;
  fd_gossip_push_msg_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_push_msg_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_push_msg_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_push_msg_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_push_msg_t * self = (fd_gossip_push_msg_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->crds_len, ctx );
  if( self->crds_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CRDS_VALUE_ALIGN );
    self->crds = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CRDS_VALUE_FOOTPRINT*self->crds_len;
    for( ulong i=0; i < self->crds_len; i++ ) {
      fd_crds_value_new( self->crds + i );
      fd_crds_value_decode_inner( self->crds + i, alloc_mem, ctx );
    }
  } else
    self->crds = NULL;
}
void * fd_gossip_push_msg_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_push_msg_global_t * self = (fd_gossip_push_msg_global_t *)mem;
  fd_gossip_push_msg_new( (fd_gossip_push_msg_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_push_msg_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_push_msg_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_push_msg_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_push_msg_global_t * self = (fd_gossip_push_msg_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->crds_len, ctx );
  if( self->crds_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CRDS_VALUE_ALIGN );
    self->crds_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CRDS_VALUE_FOOTPRINT*self->crds_len;
    for( ulong i=0; i < self->crds_len; i++ ) {
      fd_crds_value_new( (fd_crds_value_t *)(cur_mem + FD_CRDS_VALUE_FOOTPRINT * i) );
      fd_crds_value_decode_inner_global( cur_mem + FD_CRDS_VALUE_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->crds_gaddr = 0UL;
}
int fd_gossip_push_msg_convert_global_to_local( void const * global_self, fd_gossip_push_msg_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_push_msg_global_t const * mem = (fd_gossip_push_msg_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->crds_len = mem->crds_len;
  self->crds     = fd_wksp_laddr_fast( ctx->wksp, mem->crds_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_push_msg_new(fd_gossip_push_msg_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_push_msg_t) );
  fd_pubkey_new( &self->pubkey );
}
void fd_gossip_push_msg_destroy( fd_gossip_push_msg_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  if( self->crds ) {
    for( ulong i=0; i < self->crds_len; i++ )
      fd_crds_value_destroy( self->crds + i );
    self->crds = NULL;
  }
}

ulong fd_gossip_push_msg_footprint( void ){ return FD_GOSSIP_PUSH_MSG_FOOTPRINT; }
ulong fd_gossip_push_msg_align( void ){ return FD_GOSSIP_PUSH_MSG_ALIGN; }

void fd_gossip_push_msg_walk( void * w, fd_gossip_push_msg_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_push_msg", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  if( self->crds_len ) {
    fun( w, NULL, "crds", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->crds_len; i++ )
      fd_crds_value_walk(w, self->crds + i, fun, "crds_value", level );
    fun( w, NULL, "crds", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_push_msg", level-- );
}
ulong fd_gossip_push_msg_size( fd_gossip_push_msg_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->crds_len; i++ )
      size += fd_crds_value_size( self->crds + i );
  } while(0);
  return size;
}

int fd_gossip_prune_msg_encode( fd_gossip_prune_msg_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_prune_data_encode( &self->data, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_prune_msg_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_prune_msg_t);
  void const * start_data = ctx->data;
  int err = fd_gossip_prune_msg_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_prune_msg_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_prune_data_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_gossip_prune_msg_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_msg_t * self = (fd_gossip_prune_msg_t *)mem;
  fd_gossip_prune_msg_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_msg_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_msg_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_msg_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_msg_t * self = (fd_gossip_prune_msg_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_gossip_prune_data_decode_inner( &self->data, alloc_mem, ctx );
}
void * fd_gossip_prune_msg_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_msg_global_t * self = (fd_gossip_prune_msg_global_t *)mem;
  fd_gossip_prune_msg_new( (fd_gossip_prune_msg_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_prune_msg_global_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_prune_msg_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_prune_msg_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_prune_msg_global_t * self = (fd_gossip_prune_msg_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_gossip_prune_data_decode_inner_global( &self->data, alloc_mem, ctx );
}
int fd_gossip_prune_msg_convert_global_to_local( void const * global_self, fd_gossip_prune_msg_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_gossip_prune_msg_global_t const * mem = (fd_gossip_prune_msg_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_gossip_prune_data_convert_global_to_local( &mem->data, &self->data, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_prune_msg_new(fd_gossip_prune_msg_t * self) {
  fd_memset( self, 0, sizeof(fd_gossip_prune_msg_t) );
  fd_pubkey_new( &self->pubkey );
  fd_gossip_prune_data_new( &self->data );
}
void fd_gossip_prune_msg_destroy( fd_gossip_prune_msg_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  fd_gossip_prune_data_destroy( &self->data );
}

ulong fd_gossip_prune_msg_footprint( void ){ return FD_GOSSIP_PRUNE_MSG_FOOTPRINT; }
ulong fd_gossip_prune_msg_align( void ){ return FD_GOSSIP_PRUNE_MSG_ALIGN; }

void fd_gossip_prune_msg_walk( void * w, fd_gossip_prune_msg_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_gossip_prune_msg", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fd_gossip_prune_data_walk( w, &self->data, fun, "data", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_gossip_prune_msg", level-- );
}
ulong fd_gossip_prune_msg_size( fd_gossip_prune_msg_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += fd_gossip_prune_data_size( &self->data );
  return size;
}

FD_FN_PURE uchar fd_gossip_msg_is_pull_req(fd_gossip_msg_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_gossip_msg_is_pull_resp(fd_gossip_msg_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_gossip_msg_is_push_msg(fd_gossip_msg_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_gossip_msg_is_prune_msg(fd_gossip_msg_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_gossip_msg_is_ping(fd_gossip_msg_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_gossip_msg_is_pong(fd_gossip_msg_t const * self) {
  return self->discriminant == 5;
}
void fd_gossip_msg_inner_new( fd_gossip_msg_inner_t * self, uint discriminant );
int fd_gossip_msg_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_pull_req_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_gossip_pull_resp_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_gossip_push_msg_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    err = fd_gossip_prune_msg_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    err = fd_gossip_ping_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    err = fd_gossip_ping_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_gossip_msg_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_gossip_msg_t);
  void const * start_data = ctx->data;
  int err =  fd_gossip_msg_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_gossip_msg_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_msg_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_gossip_msg_inner_decode_inner( fd_gossip_msg_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_pull_req_decode_inner( &self->pull_req, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_pull_resp_decode_inner( &self->pull_resp, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_gossip_push_msg_decode_inner( &self->push_msg, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_gossip_prune_msg_decode_inner( &self->prune_msg, alloc_mem, ctx );
    break;
  }
  case 4: {
    fd_gossip_ping_decode_inner( &self->ping, alloc_mem, ctx );
    break;
  }
  case 5: {
    fd_gossip_ping_decode_inner( &self->pong, alloc_mem, ctx );
    break;
  }
  }
}
void fd_gossip_msg_inner_decode_inner_global( fd_gossip_msg_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_pull_req_decode_inner_global( &self->pull_req, alloc_mem, ctx );
    break;
  }
  case 1: {
    fd_gossip_pull_resp_decode_inner_global( &self->pull_resp, alloc_mem, ctx );
    break;
  }
  case 2: {
    fd_gossip_push_msg_decode_inner_global( &self->push_msg, alloc_mem, ctx );
    break;
  }
  case 3: {
    fd_gossip_prune_msg_decode_inner_global( &self->prune_msg, alloc_mem, ctx );
    break;
  }
  case 4: {
    fd_gossip_ping_decode_inner_global( &self->ping, alloc_mem, ctx );
    break;
  }
  case 5: {
    fd_gossip_ping_decode_inner_global( &self->pong, alloc_mem, ctx );
    break;
  }
  }
}
int fd_gossip_msg_convert_global_to_local_inner( fd_gossip_msg_inner_global_t const * mem, fd_gossip_msg_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_gossip_pull_req_convert_global_to_local( &mem->pull_req, &self->pull_req, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_pull_resp_convert_global_to_local( &mem->pull_resp, &self->pull_resp, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_gossip_push_msg_convert_global_to_local( &mem->push_msg, &self->push_msg, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_gossip_prune_msg_convert_global_to_local( &mem->prune_msg, &self->prune_msg, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    err = fd_gossip_ping_convert_global_to_local( &mem->ping, &self->ping, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 5: {
    err = fd_gossip_ping_convert_global_to_local( &mem->pong, &self->pong, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_msg_convert_global_to_local( void const * global_self, fd_gossip_msg_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_msg_global_t const * mem = (fd_gossip_msg_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_gossip_msg_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_gossip_msg_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_msg_t * self = (fd_gossip_msg_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_msg_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_gossip_msg_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_msg_t * self = (fd_gossip_msg_t *)mem;
  fd_gossip_msg_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_msg_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_msg_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_gossip_msg_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_msg_t * self = (fd_gossip_msg_t *)mem;
  fd_gossip_msg_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_gossip_msg_t);
  void * * alloc_mem = &alloc_region;
  fd_gossip_msg_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_gossip_msg_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_gossip_msg_global_t * self = (fd_gossip_msg_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_gossip_msg_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_gossip_msg_inner_new( fd_gossip_msg_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_pull_req_new( &self->pull_req );
    break;
  }
  case 1: {
    fd_gossip_pull_resp_new( &self->pull_resp );
    break;
  }
  case 2: {
    fd_gossip_push_msg_new( &self->push_msg );
    break;
  }
  case 3: {
    fd_gossip_prune_msg_new( &self->prune_msg );
    break;
  }
  case 4: {
    fd_gossip_ping_new( &self->ping );
    break;
  }
  case 5: {
    fd_gossip_ping_new( &self->pong );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_gossip_msg_new_disc( fd_gossip_msg_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_gossip_msg_inner_new( &self->inner, self->discriminant );
}
void fd_gossip_msg_new( fd_gossip_msg_t * self ) {
  fd_memset( self, 0, sizeof(fd_gossip_msg_t) );
  fd_gossip_msg_new_disc( self, UINT_MAX );
}
void fd_gossip_msg_inner_destroy( fd_gossip_msg_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_pull_req_destroy( &self->pull_req );
    break;
  }
  case 1: {
    fd_gossip_pull_resp_destroy( &self->pull_resp );
    break;
  }
  case 2: {
    fd_gossip_push_msg_destroy( &self->push_msg );
    break;
  }
  case 3: {
    fd_gossip_prune_msg_destroy( &self->prune_msg );
    break;
  }
  case 4: {
    fd_gossip_ping_destroy( &self->ping );
    break;
  }
  case 5: {
    fd_gossip_ping_destroy( &self->pong );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_gossip_msg_destroy( fd_gossip_msg_t * self ) {
  fd_gossip_msg_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_gossip_msg_footprint( void ){ return FD_GOSSIP_MSG_FOOTPRINT; }
ulong fd_gossip_msg_align( void ){ return FD_GOSSIP_MSG_ALIGN; }

void fd_gossip_msg_walk( void * w, fd_gossip_msg_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_gossip_msg", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "pull_req", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_pull_req_walk( w, &self->inner.pull_req, fun, "pull_req", level );
    break;
  }
  case 1: {
    fun( w, self, "pull_resp", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_pull_resp_walk( w, &self->inner.pull_resp, fun, "pull_resp", level );
    break;
  }
  case 2: {
    fun( w, self, "push_msg", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_push_msg_walk( w, &self->inner.push_msg, fun, "push_msg", level );
    break;
  }
  case 3: {
    fun( w, self, "prune_msg", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_prune_msg_walk( w, &self->inner.prune_msg, fun, "prune_msg", level );
    break;
  }
  case 4: {
    fun( w, self, "ping", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_ping_walk( w, &self->inner.ping, fun, "ping", level );
    break;
  }
  case 5: {
    fun( w, self, "pong", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_ping_walk( w, &self->inner.pong, fun, "pong", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_gossip_msg", level-- );
}
ulong fd_gossip_msg_size( fd_gossip_msg_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_gossip_pull_req_size( &self->inner.pull_req );
    break;
  }
  case 1: {
    size += fd_gossip_pull_resp_size( &self->inner.pull_resp );
    break;
  }
  case 2: {
    size += fd_gossip_push_msg_size( &self->inner.push_msg );
    break;
  }
  case 3: {
    size += fd_gossip_prune_msg_size( &self->inner.prune_msg );
    break;
  }
  case 4: {
    size += fd_gossip_ping_size( &self->inner.ping );
    break;
  }
  case 5: {
    size += fd_gossip_ping_size( &self->inner.pong );
    break;
  }
  }
  return size;
}

int fd_gossip_msg_inner_encode( fd_gossip_msg_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_pull_req_encode( &self->pull_req, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    err = fd_gossip_pull_resp_encode( &self->pull_resp, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_gossip_push_msg_encode( &self->push_msg, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    err = fd_gossip_prune_msg_encode( &self->prune_msg, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 4: {
    err = fd_gossip_ping_encode( &self->ping, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 5: {
    err = fd_gossip_ping_encode( &self->pong, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_gossip_msg_encode( fd_gossip_msg_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_gossip_msg_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_addrlut_create_encode( fd_addrlut_create_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->recent_slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->bump_seed), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_addrlut_create_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_addrlut_create_t);
  void const * start_data = ctx->data;
  int err = fd_addrlut_create_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_addrlut_create_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_addrlut_create_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_create_t * self = (fd_addrlut_create_t *)mem;
  fd_addrlut_create_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_addrlut_create_t);
  void * * alloc_mem = &alloc_region;
  fd_addrlut_create_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_addrlut_create_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_create_t * self = (fd_addrlut_create_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->recent_slot, ctx );
  fd_bincode_uint8_decode_unsafe( &self->bump_seed, ctx );
}
void * fd_addrlut_create_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_create_global_t * self = (fd_addrlut_create_global_t *)mem;
  fd_addrlut_create_new( (fd_addrlut_create_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_addrlut_create_global_t);
  void * * alloc_mem = &alloc_region;
  fd_addrlut_create_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_addrlut_create_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_create_global_t * self = (fd_addrlut_create_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->recent_slot, ctx );
  fd_bincode_uint8_decode_unsafe( &self->bump_seed, ctx );
}
int fd_addrlut_create_convert_global_to_local( void const * global_self, fd_addrlut_create_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_addrlut_create_global_t const * mem = (fd_addrlut_create_global_t const *)global_self;
  self->recent_slot = mem->recent_slot;
  self->bump_seed = mem->bump_seed;
  return FD_BINCODE_SUCCESS;
}
void fd_addrlut_create_new(fd_addrlut_create_t * self) {
  fd_memset( self, 0, sizeof(fd_addrlut_create_t) );
}
void fd_addrlut_create_destroy( fd_addrlut_create_t * self ) {
}

ulong fd_addrlut_create_footprint( void ){ return FD_ADDRLUT_CREATE_FOOTPRINT; }
ulong fd_addrlut_create_align( void ){ return FD_ADDRLUT_CREATE_ALIGN; }

void fd_addrlut_create_walk( void * w, fd_addrlut_create_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_addrlut_create", level++ );
  fun( w, &self->recent_slot, "recent_slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->bump_seed, "bump_seed", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_addrlut_create", level-- );
}
ulong fd_addrlut_create_size( fd_addrlut_create_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(char);
  return size;
}

int fd_addrlut_extend_encode( fd_addrlut_extend_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->new_addrs_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->new_addrs_len ) {
    for( ulong i=0; i < self->new_addrs_len; i++ ) {
      err = fd_pubkey_encode( self->new_addrs + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_addrlut_extend_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_addrlut_extend_t);
  void const * start_data = ctx->data;
  int err = fd_addrlut_extend_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_addrlut_extend_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong new_addrs_len;
  err = fd_bincode_uint64_decode( &new_addrs_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( new_addrs_len ) {
    *total_sz += FD_PUBKEY_ALIGN + FD_PUBKEY_FOOTPRINT*new_addrs_len;
    for( ulong i=0; i < new_addrs_len; i++ ) {
      err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_addrlut_extend_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_extend_t * self = (fd_addrlut_extend_t *)mem;
  fd_addrlut_extend_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_addrlut_extend_t);
  void * * alloc_mem = &alloc_region;
  fd_addrlut_extend_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_addrlut_extend_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_extend_t * self = (fd_addrlut_extend_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->new_addrs_len, ctx );
  if( self->new_addrs_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->new_addrs = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->new_addrs_len;
    for( ulong i=0; i < self->new_addrs_len; i++ ) {
      fd_pubkey_new( self->new_addrs + i );
      fd_pubkey_decode_inner( self->new_addrs + i, alloc_mem, ctx );
    }
  } else
    self->new_addrs = NULL;
}
void * fd_addrlut_extend_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_extend_global_t * self = (fd_addrlut_extend_global_t *)mem;
  fd_addrlut_extend_new( (fd_addrlut_extend_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_addrlut_extend_global_t);
  void * * alloc_mem = &alloc_region;
  fd_addrlut_extend_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_addrlut_extend_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_extend_global_t * self = (fd_addrlut_extend_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->new_addrs_len, ctx );
  if( self->new_addrs_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_PUBKEY_ALIGN );
    self->new_addrs_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_PUBKEY_FOOTPRINT*self->new_addrs_len;
    for( ulong i=0; i < self->new_addrs_len; i++ ) {
      fd_pubkey_new( (fd_pubkey_t *)(cur_mem + FD_PUBKEY_FOOTPRINT * i) );
      fd_pubkey_decode_inner_global( cur_mem + FD_PUBKEY_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->new_addrs_gaddr = 0UL;
}
int fd_addrlut_extend_convert_global_to_local( void const * global_self, fd_addrlut_extend_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_addrlut_extend_global_t const * mem = (fd_addrlut_extend_global_t const *)global_self;
  self->new_addrs_len = mem->new_addrs_len;
  self->new_addrs     = fd_wksp_laddr_fast( ctx->wksp, mem->new_addrs_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_addrlut_extend_new(fd_addrlut_extend_t * self) {
  fd_memset( self, 0, sizeof(fd_addrlut_extend_t) );
}
void fd_addrlut_extend_destroy( fd_addrlut_extend_t * self ) {
  if( self->new_addrs ) {
    for( ulong i=0; i < self->new_addrs_len; i++ )
      fd_pubkey_destroy( self->new_addrs + i );
    self->new_addrs = NULL;
  }
}

ulong fd_addrlut_extend_footprint( void ){ return FD_ADDRLUT_EXTEND_FOOTPRINT; }
ulong fd_addrlut_extend_align( void ){ return FD_ADDRLUT_EXTEND_ALIGN; }

void fd_addrlut_extend_walk( void * w, fd_addrlut_extend_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_addrlut_extend", level++ );
  if( self->new_addrs_len ) {
    fun( w, NULL, "new_addrs", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->new_addrs_len; i++ )
      fd_pubkey_walk(w, self->new_addrs + i, fun, "pubkey", level );
    fun( w, NULL, "new_addrs", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_addrlut_extend", level-- );
}
ulong fd_addrlut_extend_size( fd_addrlut_extend_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->new_addrs_len; i++ )
      size += fd_pubkey_size( self->new_addrs + i );
  } while(0);
  return size;
}

FD_FN_PURE uchar fd_addrlut_instruction_is_create_lut(fd_addrlut_instruction_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_addrlut_instruction_is_freeze_lut(fd_addrlut_instruction_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_addrlut_instruction_is_extend_lut(fd_addrlut_instruction_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_addrlut_instruction_is_deactivate_lut(fd_addrlut_instruction_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_addrlut_instruction_is_close_lut(fd_addrlut_instruction_t const * self) {
  return self->discriminant == 4;
}
void fd_addrlut_instruction_inner_new( fd_addrlut_instruction_inner_t * self, uint discriminant );
int fd_addrlut_instruction_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_addrlut_create_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    err = fd_addrlut_extend_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_addrlut_instruction_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_addrlut_instruction_t);
  void const * start_data = ctx->data;
  int err =  fd_addrlut_instruction_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_addrlut_instruction_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_addrlut_instruction_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_addrlut_instruction_inner_decode_inner( fd_addrlut_instruction_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_addrlut_create_decode_inner( &self->create_lut, alloc_mem, ctx );
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    fd_addrlut_extend_decode_inner( &self->extend_lut, alloc_mem, ctx );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  }
}
void fd_addrlut_instruction_inner_decode_inner_global( fd_addrlut_instruction_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_addrlut_create_decode_inner_global( &self->create_lut, alloc_mem, ctx );
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    fd_addrlut_extend_decode_inner_global( &self->extend_lut, alloc_mem, ctx );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  }
}
int fd_addrlut_instruction_convert_global_to_local_inner( fd_addrlut_instruction_inner_global_t const * mem, fd_addrlut_instruction_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_addrlut_create_convert_global_to_local( &mem->create_lut, &self->create_lut, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    err = fd_addrlut_extend_convert_global_to_local( &mem->extend_lut, &self->extend_lut, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_addrlut_instruction_convert_global_to_local( void const * global_self, fd_addrlut_instruction_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_instruction_global_t const * mem = (fd_addrlut_instruction_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_addrlut_instruction_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_addrlut_instruction_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_instruction_t * self = (fd_addrlut_instruction_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_addrlut_instruction_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_addrlut_instruction_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_instruction_t * self = (fd_addrlut_instruction_t *)mem;
  fd_addrlut_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_addrlut_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_addrlut_instruction_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_addrlut_instruction_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_instruction_t * self = (fd_addrlut_instruction_t *)mem;
  fd_addrlut_instruction_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_addrlut_instruction_t);
  void * * alloc_mem = &alloc_region;
  fd_addrlut_instruction_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_addrlut_instruction_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_addrlut_instruction_global_t * self = (fd_addrlut_instruction_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_addrlut_instruction_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_addrlut_instruction_inner_new( fd_addrlut_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_addrlut_create_new( &self->create_lut );
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    fd_addrlut_extend_new( &self->extend_lut );
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_addrlut_instruction_new_disc( fd_addrlut_instruction_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_addrlut_instruction_inner_new( &self->inner, self->discriminant );
}
void fd_addrlut_instruction_new( fd_addrlut_instruction_t * self ) {
  fd_memset( self, 0, sizeof(fd_addrlut_instruction_t) );
  fd_addrlut_instruction_new_disc( self, UINT_MAX );
}
void fd_addrlut_instruction_inner_destroy( fd_addrlut_instruction_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_addrlut_create_destroy( &self->create_lut );
    break;
  }
  case 2: {
    fd_addrlut_extend_destroy( &self->extend_lut );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_addrlut_instruction_destroy( fd_addrlut_instruction_t * self ) {
  fd_addrlut_instruction_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_addrlut_instruction_footprint( void ){ return FD_ADDRLUT_INSTRUCTION_FOOTPRINT; }
ulong fd_addrlut_instruction_align( void ){ return FD_ADDRLUT_INSTRUCTION_ALIGN; }

void fd_addrlut_instruction_walk( void * w, fd_addrlut_instruction_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_addrlut_instruction", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "create_lut", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_addrlut_create_walk( w, &self->inner.create_lut, fun, "create_lut", level );
    break;
  }
  case 1: {
    fun( w, self, "freeze_lut", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "extend_lut", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_addrlut_extend_walk( w, &self->inner.extend_lut, fun, "extend_lut", level );
    break;
  }
  case 3: {
    fun( w, self, "deactivate_lut", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "close_lut", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_addrlut_instruction", level-- );
}
ulong fd_addrlut_instruction_size( fd_addrlut_instruction_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_addrlut_create_size( &self->inner.create_lut );
    break;
  }
  case 2: {
    size += fd_addrlut_extend_size( &self->inner.extend_lut );
    break;
  }
  }
  return size;
}

int fd_addrlut_instruction_inner_encode( fd_addrlut_instruction_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_addrlut_create_encode( &self->create_lut, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 2: {
    err = fd_addrlut_extend_encode( &self->extend_lut, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_addrlut_instruction_encode( fd_addrlut_instruction_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_addrlut_instruction_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_repair_request_header_encode( fd_repair_request_header_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_signature_encode( &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->sender, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_encode( &self->recipient, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( (ulong)self->timestamp, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_encode( self->nonce, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_repair_request_header_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_request_header_t);
  void const * start_data = ctx->data;
  int err = fd_repair_request_header_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_request_header_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_signature_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_repair_request_header_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_request_header_t * self = (fd_repair_request_header_t *)mem;
  fd_repair_request_header_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_request_header_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_request_header_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_request_header_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_request_header_t * self = (fd_repair_request_header_t *)struct_mem;
  fd_signature_decode_inner( &self->signature, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->sender, alloc_mem, ctx );
  fd_pubkey_decode_inner( &self->recipient, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
  fd_bincode_uint32_decode_unsafe( &self->nonce, ctx );
}
void * fd_repair_request_header_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_request_header_global_t * self = (fd_repair_request_header_global_t *)mem;
  fd_repair_request_header_new( (fd_repair_request_header_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_request_header_global_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_request_header_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_request_header_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_request_header_global_t * self = (fd_repair_request_header_global_t *)struct_mem;
  fd_signature_decode_inner_global( &self->signature, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->sender, alloc_mem, ctx );
  fd_pubkey_decode_inner_global( &self->recipient, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( (ulong *) &self->timestamp, ctx );
  fd_bincode_uint32_decode_unsafe( &self->nonce, ctx );
}
int fd_repair_request_header_convert_global_to_local( void const * global_self, fd_repair_request_header_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_repair_request_header_global_t const * mem = (fd_repair_request_header_global_t const *)global_self;
  err = fd_signature_convert_global_to_local( &mem->signature, &self->signature, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->sender, &self->sender, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_pubkey_convert_global_to_local( &mem->recipient, &self->recipient, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->timestamp = mem->timestamp;
  self->nonce = mem->nonce;
  return FD_BINCODE_SUCCESS;
}
void fd_repair_request_header_new(fd_repair_request_header_t * self) {
  fd_memset( self, 0, sizeof(fd_repair_request_header_t) );
  fd_signature_new( &self->signature );
  fd_pubkey_new( &self->sender );
  fd_pubkey_new( &self->recipient );
}
void fd_repair_request_header_destroy( fd_repair_request_header_t * self ) {
  fd_signature_destroy( &self->signature );
  fd_pubkey_destroy( &self->sender );
  fd_pubkey_destroy( &self->recipient );
}

ulong fd_repair_request_header_footprint( void ){ return FD_REPAIR_REQUEST_HEADER_FOOTPRINT; }
ulong fd_repair_request_header_align( void ){ return FD_REPAIR_REQUEST_HEADER_ALIGN; }

void fd_repair_request_header_walk( void * w, fd_repair_request_header_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_repair_request_header", level++ );
  fd_signature_walk( w, &self->signature, fun, "signature", level );
  fd_pubkey_walk( w, &self->sender, fun, "sender", level );
  fd_pubkey_walk( w, &self->recipient, fun, "recipient", level );
  fun( w, &self->timestamp, "timestamp", FD_FLAMENCO_TYPE_SLONG, "long", level );
  fun( w, &self->nonce, "nonce", FD_FLAMENCO_TYPE_UINT, "uint", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_repair_request_header", level-- );
}
ulong fd_repair_request_header_size( fd_repair_request_header_t const * self ) {
  ulong size = 0;
  size += fd_signature_size( &self->signature );
  size += fd_pubkey_size( &self->sender );
  size += fd_pubkey_size( &self->recipient );
  size += sizeof(long);
  size += sizeof(uint);
  return size;
}

int fd_repair_window_index_encode( fd_repair_window_index_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_repair_request_header_encode( &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->shred_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_repair_window_index_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_window_index_t);
  void const * start_data = ctx->data;
  int err = fd_repair_window_index_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_window_index_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_repair_request_header_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_repair_window_index_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_window_index_t * self = (fd_repair_window_index_t *)mem;
  fd_repair_window_index_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_window_index_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_window_index_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_window_index_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_window_index_t * self = (fd_repair_window_index_t *)struct_mem;
  fd_repair_request_header_decode_inner( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->shred_index, ctx );
}
void * fd_repair_window_index_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_window_index_global_t * self = (fd_repair_window_index_global_t *)mem;
  fd_repair_window_index_new( (fd_repair_window_index_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_window_index_global_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_window_index_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_window_index_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_window_index_global_t * self = (fd_repair_window_index_global_t *)struct_mem;
  fd_repair_request_header_decode_inner_global( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->shred_index, ctx );
}
int fd_repair_window_index_convert_global_to_local( void const * global_self, fd_repair_window_index_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_repair_window_index_global_t const * mem = (fd_repair_window_index_global_t const *)global_self;
  err = fd_repair_request_header_convert_global_to_local( &mem->header, &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slot = mem->slot;
  self->shred_index = mem->shred_index;
  return FD_BINCODE_SUCCESS;
}
void fd_repair_window_index_new(fd_repair_window_index_t * self) {
  fd_memset( self, 0, sizeof(fd_repair_window_index_t) );
  fd_repair_request_header_new( &self->header );
}
void fd_repair_window_index_destroy( fd_repair_window_index_t * self ) {
  fd_repair_request_header_destroy( &self->header );
}

ulong fd_repair_window_index_footprint( void ){ return FD_REPAIR_WINDOW_INDEX_FOOTPRINT; }
ulong fd_repair_window_index_align( void ){ return FD_REPAIR_WINDOW_INDEX_ALIGN; }

void fd_repair_window_index_walk( void * w, fd_repair_window_index_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_repair_window_index", level++ );
  fd_repair_request_header_walk( w, &self->header, fun, "header", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->shred_index, "shred_index", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_repair_window_index", level-- );
}
ulong fd_repair_window_index_size( fd_repair_window_index_t const * self ) {
  ulong size = 0;
  size += fd_repair_request_header_size( &self->header );
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_repair_highest_window_index_encode( fd_repair_highest_window_index_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_repair_request_header_encode( &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->shred_index, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_repair_highest_window_index_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_highest_window_index_t);
  void const * start_data = ctx->data;
  int err = fd_repair_highest_window_index_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_highest_window_index_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_repair_request_header_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_repair_highest_window_index_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_highest_window_index_t * self = (fd_repair_highest_window_index_t *)mem;
  fd_repair_highest_window_index_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_highest_window_index_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_highest_window_index_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_highest_window_index_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_highest_window_index_t * self = (fd_repair_highest_window_index_t *)struct_mem;
  fd_repair_request_header_decode_inner( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->shred_index, ctx );
}
void * fd_repair_highest_window_index_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_highest_window_index_global_t * self = (fd_repair_highest_window_index_global_t *)mem;
  fd_repair_highest_window_index_new( (fd_repair_highest_window_index_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_highest_window_index_global_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_highest_window_index_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_highest_window_index_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_highest_window_index_global_t * self = (fd_repair_highest_window_index_global_t *)struct_mem;
  fd_repair_request_header_decode_inner_global( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_uint64_decode_unsafe( &self->shred_index, ctx );
}
int fd_repair_highest_window_index_convert_global_to_local( void const * global_self, fd_repair_highest_window_index_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_repair_highest_window_index_global_t const * mem = (fd_repair_highest_window_index_global_t const *)global_self;
  err = fd_repair_request_header_convert_global_to_local( &mem->header, &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slot = mem->slot;
  self->shred_index = mem->shred_index;
  return FD_BINCODE_SUCCESS;
}
void fd_repair_highest_window_index_new(fd_repair_highest_window_index_t * self) {
  fd_memset( self, 0, sizeof(fd_repair_highest_window_index_t) );
  fd_repair_request_header_new( &self->header );
}
void fd_repair_highest_window_index_destroy( fd_repair_highest_window_index_t * self ) {
  fd_repair_request_header_destroy( &self->header );
}

ulong fd_repair_highest_window_index_footprint( void ){ return FD_REPAIR_HIGHEST_WINDOW_INDEX_FOOTPRINT; }
ulong fd_repair_highest_window_index_align( void ){ return FD_REPAIR_HIGHEST_WINDOW_INDEX_ALIGN; }

void fd_repair_highest_window_index_walk( void * w, fd_repair_highest_window_index_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_repair_highest_window_index", level++ );
  fd_repair_request_header_walk( w, &self->header, fun, "header", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->shred_index, "shred_index", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_repair_highest_window_index", level-- );
}
ulong fd_repair_highest_window_index_size( fd_repair_highest_window_index_t const * self ) {
  ulong size = 0;
  size += fd_repair_request_header_size( &self->header );
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_repair_orphan_encode( fd_repair_orphan_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_repair_request_header_encode( &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_repair_orphan_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_orphan_t);
  void const * start_data = ctx->data;
  int err = fd_repair_orphan_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_orphan_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_repair_request_header_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_repair_orphan_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_orphan_t * self = (fd_repair_orphan_t *)mem;
  fd_repair_orphan_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_orphan_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_orphan_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_orphan_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_orphan_t * self = (fd_repair_orphan_t *)struct_mem;
  fd_repair_request_header_decode_inner( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
void * fd_repair_orphan_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_orphan_global_t * self = (fd_repair_orphan_global_t *)mem;
  fd_repair_orphan_new( (fd_repair_orphan_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_orphan_global_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_orphan_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_orphan_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_orphan_global_t * self = (fd_repair_orphan_global_t *)struct_mem;
  fd_repair_request_header_decode_inner_global( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
int fd_repair_orphan_convert_global_to_local( void const * global_self, fd_repair_orphan_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_repair_orphan_global_t const * mem = (fd_repair_orphan_global_t const *)global_self;
  err = fd_repair_request_header_convert_global_to_local( &mem->header, &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slot = mem->slot;
  return FD_BINCODE_SUCCESS;
}
void fd_repair_orphan_new(fd_repair_orphan_t * self) {
  fd_memset( self, 0, sizeof(fd_repair_orphan_t) );
  fd_repair_request_header_new( &self->header );
}
void fd_repair_orphan_destroy( fd_repair_orphan_t * self ) {
  fd_repair_request_header_destroy( &self->header );
}

ulong fd_repair_orphan_footprint( void ){ return FD_REPAIR_ORPHAN_FOOTPRINT; }
ulong fd_repair_orphan_align( void ){ return FD_REPAIR_ORPHAN_ALIGN; }

void fd_repair_orphan_walk( void * w, fd_repair_orphan_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_repair_orphan", level++ );
  fd_repair_request_header_walk( w, &self->header, fun, "header", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_repair_orphan", level-- );
}
ulong fd_repair_orphan_size( fd_repair_orphan_t const * self ) {
  ulong size = 0;
  size += fd_repair_request_header_size( &self->header );
  size += sizeof(ulong);
  return size;
}

int fd_repair_ancestor_hashes_encode( fd_repair_ancestor_hashes_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_repair_request_header_encode( &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_repair_ancestor_hashes_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_ancestor_hashes_t);
  void const * start_data = ctx->data;
  int err = fd_repair_ancestor_hashes_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_ancestor_hashes_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_repair_request_header_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_repair_ancestor_hashes_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_ancestor_hashes_t * self = (fd_repair_ancestor_hashes_t *)mem;
  fd_repair_ancestor_hashes_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_ancestor_hashes_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_ancestor_hashes_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_ancestor_hashes_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_ancestor_hashes_t * self = (fd_repair_ancestor_hashes_t *)struct_mem;
  fd_repair_request_header_decode_inner( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
void * fd_repair_ancestor_hashes_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_ancestor_hashes_global_t * self = (fd_repair_ancestor_hashes_global_t *)mem;
  fd_repair_ancestor_hashes_new( (fd_repair_ancestor_hashes_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_ancestor_hashes_global_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_ancestor_hashes_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_ancestor_hashes_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_ancestor_hashes_global_t * self = (fd_repair_ancestor_hashes_global_t *)struct_mem;
  fd_repair_request_header_decode_inner_global( &self->header, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
}
int fd_repair_ancestor_hashes_convert_global_to_local( void const * global_self, fd_repair_ancestor_hashes_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_repair_ancestor_hashes_global_t const * mem = (fd_repair_ancestor_hashes_global_t const *)global_self;
  err = fd_repair_request_header_convert_global_to_local( &mem->header, &self->header, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->slot = mem->slot;
  return FD_BINCODE_SUCCESS;
}
void fd_repair_ancestor_hashes_new(fd_repair_ancestor_hashes_t * self) {
  fd_memset( self, 0, sizeof(fd_repair_ancestor_hashes_t) );
  fd_repair_request_header_new( &self->header );
}
void fd_repair_ancestor_hashes_destroy( fd_repair_ancestor_hashes_t * self ) {
  fd_repair_request_header_destroy( &self->header );
}

ulong fd_repair_ancestor_hashes_footprint( void ){ return FD_REPAIR_ANCESTOR_HASHES_FOOTPRINT; }
ulong fd_repair_ancestor_hashes_align( void ){ return FD_REPAIR_ANCESTOR_HASHES_ALIGN; }

void fd_repair_ancestor_hashes_walk( void * w, fd_repair_ancestor_hashes_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_repair_ancestor_hashes", level++ );
  fd_repair_request_header_walk( w, &self->header, fun, "header", level );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_repair_ancestor_hashes", level-- );
}
ulong fd_repair_ancestor_hashes_size( fd_repair_ancestor_hashes_t const * self ) {
  ulong size = 0;
  size += fd_repair_request_header_size( &self->header );
  size += sizeof(ulong);
  return size;
}

FD_FN_PURE uchar fd_repair_protocol_is_LegacyWindowIndex(fd_repair_protocol_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_repair_protocol_is_LegacyHighestWindowIndex(fd_repair_protocol_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_repair_protocol_is_LegacyOrphan(fd_repair_protocol_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_repair_protocol_is_LegacyWindowIndexWithNonce(fd_repair_protocol_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_repair_protocol_is_LegacyHighestWindowIndexWithNonce(fd_repair_protocol_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_repair_protocol_is_LegacyOrphanWithNonce(fd_repair_protocol_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_repair_protocol_is_LegacyAncestorHashes(fd_repair_protocol_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_repair_protocol_is_pong(fd_repair_protocol_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_repair_protocol_is_window_index(fd_repair_protocol_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_repair_protocol_is_highest_window_index(fd_repair_protocol_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_repair_protocol_is_orphan(fd_repair_protocol_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_repair_protocol_is_ancestor_hashes(fd_repair_protocol_t const * self) {
  return self->discriminant == 11;
}
void fd_repair_protocol_inner_new( fd_repair_protocol_inner_t * self, uint discriminant );
int fd_repair_protocol_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    err = fd_gossip_ping_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    err = fd_repair_window_index_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    err = fd_repair_highest_window_index_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    err = fd_repair_orphan_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    err = fd_repair_ancestor_hashes_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_repair_protocol_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_protocol_t);
  void const * start_data = ctx->data;
  int err =  fd_repair_protocol_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_protocol_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_repair_protocol_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_repair_protocol_inner_decode_inner( fd_repair_protocol_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    fd_gossip_ping_decode_inner( &self->pong, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_repair_window_index_decode_inner( &self->window_index, alloc_mem, ctx );
    break;
  }
  case 9: {
    fd_repair_highest_window_index_decode_inner( &self->highest_window_index, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_repair_orphan_decode_inner( &self->orphan, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_repair_ancestor_hashes_decode_inner( &self->ancestor_hashes, alloc_mem, ctx );
    break;
  }
  }
}
void fd_repair_protocol_inner_decode_inner_global( fd_repair_protocol_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    fd_gossip_ping_decode_inner_global( &self->pong, alloc_mem, ctx );
    break;
  }
  case 8: {
    fd_repair_window_index_decode_inner_global( &self->window_index, alloc_mem, ctx );
    break;
  }
  case 9: {
    fd_repair_highest_window_index_decode_inner_global( &self->highest_window_index, alloc_mem, ctx );
    break;
  }
  case 10: {
    fd_repair_orphan_decode_inner_global( &self->orphan, alloc_mem, ctx );
    break;
  }
  case 11: {
    fd_repair_ancestor_hashes_decode_inner_global( &self->ancestor_hashes, alloc_mem, ctx );
    break;
  }
  }
}
int fd_repair_protocol_convert_global_to_local_inner( fd_repair_protocol_inner_global_t const * mem, fd_repair_protocol_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    err = fd_gossip_ping_convert_global_to_local( &mem->pong, &self->pong, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_repair_window_index_convert_global_to_local( &mem->window_index, &self->window_index, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_repair_highest_window_index_convert_global_to_local( &mem->highest_window_index, &self->highest_window_index, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_repair_orphan_convert_global_to_local( &mem->orphan, &self->orphan, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_repair_ancestor_hashes_convert_global_to_local( &mem->ancestor_hashes, &self->ancestor_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_repair_protocol_convert_global_to_local( void const * global_self, fd_repair_protocol_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_protocol_global_t const * mem = (fd_repair_protocol_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_repair_protocol_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_repair_protocol_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_protocol_t * self = (fd_repair_protocol_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_repair_protocol_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_repair_protocol_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_protocol_t * self = (fd_repair_protocol_t *)mem;
  fd_repair_protocol_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_protocol_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_protocol_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_repair_protocol_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_protocol_t * self = (fd_repair_protocol_t *)mem;
  fd_repair_protocol_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_protocol_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_protocol_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_protocol_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_protocol_global_t * self = (fd_repair_protocol_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_repair_protocol_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_repair_protocol_inner_new( fd_repair_protocol_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    fd_gossip_ping_new( &self->pong );
    break;
  }
  case 8: {
    fd_repair_window_index_new( &self->window_index );
    break;
  }
  case 9: {
    fd_repair_highest_window_index_new( &self->highest_window_index );
    break;
  }
  case 10: {
    fd_repair_orphan_new( &self->orphan );
    break;
  }
  case 11: {
    fd_repair_ancestor_hashes_new( &self->ancestor_hashes );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_repair_protocol_new_disc( fd_repair_protocol_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_repair_protocol_inner_new( &self->inner, self->discriminant );
}
void fd_repair_protocol_new( fd_repair_protocol_t * self ) {
  fd_memset( self, 0, sizeof(fd_repair_protocol_t) );
  fd_repair_protocol_new_disc( self, UINT_MAX );
}
void fd_repair_protocol_inner_destroy( fd_repair_protocol_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 7: {
    fd_gossip_ping_destroy( &self->pong );
    break;
  }
  case 8: {
    fd_repair_window_index_destroy( &self->window_index );
    break;
  }
  case 9: {
    fd_repair_highest_window_index_destroy( &self->highest_window_index );
    break;
  }
  case 10: {
    fd_repair_orphan_destroy( &self->orphan );
    break;
  }
  case 11: {
    fd_repair_ancestor_hashes_destroy( &self->ancestor_hashes );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_repair_protocol_destroy( fd_repair_protocol_t * self ) {
  fd_repair_protocol_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_repair_protocol_footprint( void ){ return FD_REPAIR_PROTOCOL_FOOTPRINT; }
ulong fd_repair_protocol_align( void ){ return FD_REPAIR_PROTOCOL_ALIGN; }

void fd_repair_protocol_walk( void * w, fd_repair_protocol_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_repair_protocol", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "LegacyWindowIndex", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "LegacyHighestWindowIndex", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "LegacyOrphan", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "LegacyWindowIndexWithNonce", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "LegacyHighestWindowIndexWithNonce", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "LegacyOrphanWithNonce", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 6: {
    fun( w, self, "LegacyAncestorHashes", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 7: {
    fun( w, self, "pong", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_ping_walk( w, &self->inner.pong, fun, "pong", level );
    break;
  }
  case 8: {
    fun( w, self, "window_index", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_repair_window_index_walk( w, &self->inner.window_index, fun, "window_index", level );
    break;
  }
  case 9: {
    fun( w, self, "highest_window_index", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_repair_highest_window_index_walk( w, &self->inner.highest_window_index, fun, "highest_window_index", level );
    break;
  }
  case 10: {
    fun( w, self, "orphan", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_repair_orphan_walk( w, &self->inner.orphan, fun, "orphan", level );
    break;
  }
  case 11: {
    fun( w, self, "ancestor_hashes", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_repair_ancestor_hashes_walk( w, &self->inner.ancestor_hashes, fun, "ancestor_hashes", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_repair_protocol", level-- );
}
ulong fd_repair_protocol_size( fd_repair_protocol_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 7: {
    size += fd_gossip_ping_size( &self->inner.pong );
    break;
  }
  case 8: {
    size += fd_repair_window_index_size( &self->inner.window_index );
    break;
  }
  case 9: {
    size += fd_repair_highest_window_index_size( &self->inner.highest_window_index );
    break;
  }
  case 10: {
    size += fd_repair_orphan_size( &self->inner.orphan );
    break;
  }
  case 11: {
    size += fd_repair_ancestor_hashes_size( &self->inner.ancestor_hashes );
    break;
  }
  }
  return size;
}

int fd_repair_protocol_inner_encode( fd_repair_protocol_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 7: {
    err = fd_gossip_ping_encode( &self->pong, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 8: {
    err = fd_repair_window_index_encode( &self->window_index, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    err = fd_repair_highest_window_index_encode( &self->highest_window_index, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 10: {
    err = fd_repair_orphan_encode( &self->orphan, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 11: {
    err = fd_repair_ancestor_hashes_encode( &self->ancestor_hashes, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_repair_protocol_encode( fd_repair_protocol_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_repair_protocol_inner_encode( &self->inner, self->discriminant, ctx );
}

FD_FN_PURE uchar fd_repair_response_is_ping(fd_repair_response_t const * self) {
  return self->discriminant == 0;
}
void fd_repair_response_inner_new( fd_repair_response_inner_t * self, uint discriminant );
int fd_repair_response_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_ping_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_repair_response_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_repair_response_t);
  void const * start_data = ctx->data;
  int err =  fd_repair_response_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_repair_response_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_repair_response_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_repair_response_inner_decode_inner( fd_repair_response_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_ping_decode_inner( &self->ping, alloc_mem, ctx );
    break;
  }
  }
}
void fd_repair_response_inner_decode_inner_global( fd_repair_response_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    fd_gossip_ping_decode_inner_global( &self->ping, alloc_mem, ctx );
    break;
  }
  }
}
int fd_repair_response_convert_global_to_local_inner( fd_repair_response_inner_global_t const * mem, fd_repair_response_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    err = fd_gossip_ping_convert_global_to_local( &mem->ping, &self->ping, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_repair_response_convert_global_to_local( void const * global_self, fd_repair_response_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_response_global_t const * mem = (fd_repair_response_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_repair_response_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_repair_response_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_response_t * self = (fd_repair_response_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_repair_response_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_repair_response_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_response_t * self = (fd_repair_response_t *)mem;
  fd_repair_response_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_response_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_response_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_repair_response_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_response_t * self = (fd_repair_response_t *)mem;
  fd_repair_response_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_repair_response_t);
  void * * alloc_mem = &alloc_region;
  fd_repair_response_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_repair_response_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_repair_response_global_t * self = (fd_repair_response_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_repair_response_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_repair_response_inner_new( fd_repair_response_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_ping_new( &self->ping );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_repair_response_new_disc( fd_repair_response_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_repair_response_inner_new( &self->inner, self->discriminant );
}
void fd_repair_response_new( fd_repair_response_t * self ) {
  fd_memset( self, 0, sizeof(fd_repair_response_t) );
  fd_repair_response_new_disc( self, UINT_MAX );
}
void fd_repair_response_inner_destroy( fd_repair_response_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    fd_gossip_ping_destroy( &self->ping );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_repair_response_destroy( fd_repair_response_t * self ) {
  fd_repair_response_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_repair_response_footprint( void ){ return FD_REPAIR_RESPONSE_FOOTPRINT; }
ulong fd_repair_response_align( void ){ return FD_REPAIR_RESPONSE_ALIGN; }

void fd_repair_response_walk( void * w, fd_repair_response_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_repair_response", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "ping", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_gossip_ping_walk( w, &self->inner.ping, fun, "ping", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_repair_response", level-- );
}
ulong fd_repair_response_size( fd_repair_response_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 0: {
    size += fd_gossip_ping_size( &self->inner.ping );
    break;
  }
  }
  return size;
}

int fd_repair_response_inner_encode( fd_repair_response_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 0: {
    err = fd_gossip_ping_encode( &self->ping, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_repair_response_encode( fd_repair_response_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_repair_response_inner_encode( &self->inner, self->discriminant, ctx );
}

FD_FN_PURE uchar fd_instr_error_enum_is_generic_error(fd_instr_error_enum_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_argument(fd_instr_error_enum_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_instruction_data(fd_instr_error_enum_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_account_data(fd_instr_error_enum_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_data_too_small(fd_instr_error_enum_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_instr_error_enum_is_insufficient_funds(fd_instr_error_enum_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_instr_error_enum_is_incorrect_program_id(fd_instr_error_enum_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_instr_error_enum_is_missing_required_signature(fd_instr_error_enum_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_already_initialized(fd_instr_error_enum_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_instr_error_enum_is_uninitialized_account(fd_instr_error_enum_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_instr_error_enum_is_unbalanced_instruction(fd_instr_error_enum_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_instr_error_enum_is_modified_program_id(fd_instr_error_enum_t const * self) {
  return self->discriminant == 11;
}
FD_FN_PURE uchar fd_instr_error_enum_is_external_account_lamport_spend(fd_instr_error_enum_t const * self) {
  return self->discriminant == 12;
}
FD_FN_PURE uchar fd_instr_error_enum_is_external_account_data_modified(fd_instr_error_enum_t const * self) {
  return self->discriminant == 13;
}
FD_FN_PURE uchar fd_instr_error_enum_is_readonly_lamport_change(fd_instr_error_enum_t const * self) {
  return self->discriminant == 14;
}
FD_FN_PURE uchar fd_instr_error_enum_is_readonly_data_modified(fd_instr_error_enum_t const * self) {
  return self->discriminant == 15;
}
FD_FN_PURE uchar fd_instr_error_enum_is_duplicate_account_index(fd_instr_error_enum_t const * self) {
  return self->discriminant == 16;
}
FD_FN_PURE uchar fd_instr_error_enum_is_executable_modified(fd_instr_error_enum_t const * self) {
  return self->discriminant == 17;
}
FD_FN_PURE uchar fd_instr_error_enum_is_rent_epoch_modified(fd_instr_error_enum_t const * self) {
  return self->discriminant == 18;
}
FD_FN_PURE uchar fd_instr_error_enum_is_not_enough_account_keys(fd_instr_error_enum_t const * self) {
  return self->discriminant == 19;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_data_size_changed(fd_instr_error_enum_t const * self) {
  return self->discriminant == 20;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_not_executable(fd_instr_error_enum_t const * self) {
  return self->discriminant == 21;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_borrow_failed(fd_instr_error_enum_t const * self) {
  return self->discriminant == 22;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_borrow_outstanding(fd_instr_error_enum_t const * self) {
  return self->discriminant == 23;
}
FD_FN_PURE uchar fd_instr_error_enum_is_duplicate_account_out_of_sync(fd_instr_error_enum_t const * self) {
  return self->discriminant == 24;
}
FD_FN_PURE uchar fd_instr_error_enum_is_custom(fd_instr_error_enum_t const * self) {
  return self->discriminant == 25;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_error(fd_instr_error_enum_t const * self) {
  return self->discriminant == 26;
}
FD_FN_PURE uchar fd_instr_error_enum_is_executable_data_modified(fd_instr_error_enum_t const * self) {
  return self->discriminant == 27;
}
FD_FN_PURE uchar fd_instr_error_enum_is_executable_lamport_change(fd_instr_error_enum_t const * self) {
  return self->discriminant == 28;
}
FD_FN_PURE uchar fd_instr_error_enum_is_executable_account_not_rent_exempt(fd_instr_error_enum_t const * self) {
  return self->discriminant == 29;
}
FD_FN_PURE uchar fd_instr_error_enum_is_unsupported_program_id(fd_instr_error_enum_t const * self) {
  return self->discriminant == 30;
}
FD_FN_PURE uchar fd_instr_error_enum_is_call_depth(fd_instr_error_enum_t const * self) {
  return self->discriminant == 31;
}
FD_FN_PURE uchar fd_instr_error_enum_is_missing_account(fd_instr_error_enum_t const * self) {
  return self->discriminant == 32;
}
FD_FN_PURE uchar fd_instr_error_enum_is_reentrancy_not_allowed(fd_instr_error_enum_t const * self) {
  return self->discriminant == 33;
}
FD_FN_PURE uchar fd_instr_error_enum_is_max_seed_length_exceeded(fd_instr_error_enum_t const * self) {
  return self->discriminant == 34;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_seeds(fd_instr_error_enum_t const * self) {
  return self->discriminant == 35;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_realloc(fd_instr_error_enum_t const * self) {
  return self->discriminant == 36;
}
FD_FN_PURE uchar fd_instr_error_enum_is_computational_budget_exceeded(fd_instr_error_enum_t const * self) {
  return self->discriminant == 37;
}
FD_FN_PURE uchar fd_instr_error_enum_is_privilege_escalation(fd_instr_error_enum_t const * self) {
  return self->discriminant == 38;
}
FD_FN_PURE uchar fd_instr_error_enum_is_program_environment_setup_failure(fd_instr_error_enum_t const * self) {
  return self->discriminant == 39;
}
FD_FN_PURE uchar fd_instr_error_enum_is_program_failed_to_complete(fd_instr_error_enum_t const * self) {
  return self->discriminant == 40;
}
FD_FN_PURE uchar fd_instr_error_enum_is_program_failed_to_compile(fd_instr_error_enum_t const * self) {
  return self->discriminant == 41;
}
FD_FN_PURE uchar fd_instr_error_enum_is_immutable(fd_instr_error_enum_t const * self) {
  return self->discriminant == 42;
}
FD_FN_PURE uchar fd_instr_error_enum_is_incorrect_authority(fd_instr_error_enum_t const * self) {
  return self->discriminant == 43;
}
FD_FN_PURE uchar fd_instr_error_enum_is_borsh_io_error(fd_instr_error_enum_t const * self) {
  return self->discriminant == 44;
}
FD_FN_PURE uchar fd_instr_error_enum_is_account_not_rent_exempt(fd_instr_error_enum_t const * self) {
  return self->discriminant == 45;
}
FD_FN_PURE uchar fd_instr_error_enum_is_invalid_account_owner(fd_instr_error_enum_t const * self) {
  return self->discriminant == 46;
}
FD_FN_PURE uchar fd_instr_error_enum_is_arithmetic_overflow(fd_instr_error_enum_t const * self) {
  return self->discriminant == 47;
}
FD_FN_PURE uchar fd_instr_error_enum_is_unsupported_sysvar(fd_instr_error_enum_t const * self) {
  return self->discriminant == 48;
}
FD_FN_PURE uchar fd_instr_error_enum_is_illegal_owner(fd_instr_error_enum_t const * self) {
  return self->discriminant == 49;
}
FD_FN_PURE uchar fd_instr_error_enum_is_max_accounts_data_allocations_exceeded(fd_instr_error_enum_t const * self) {
  return self->discriminant == 50;
}
FD_FN_PURE uchar fd_instr_error_enum_is_max_accounts_exceeded(fd_instr_error_enum_t const * self) {
  return self->discriminant == 51;
}
FD_FN_PURE uchar fd_instr_error_enum_is_max_instruction_trace_length_exceeded(fd_instr_error_enum_t const * self) {
  return self->discriminant == 52;
}
FD_FN_PURE uchar fd_instr_error_enum_is_builtin_programs_must_consume_compute_units(fd_instr_error_enum_t const * self) {
  return self->discriminant == 53;
}
void fd_instr_error_enum_inner_new( fd_instr_error_enum_inner_t * self, uint discriminant );
int fd_instr_error_enum_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    return FD_BINCODE_SUCCESS;
  }
  case 12: {
    return FD_BINCODE_SUCCESS;
  }
  case 13: {
    return FD_BINCODE_SUCCESS;
  }
  case 14: {
    return FD_BINCODE_SUCCESS;
  }
  case 15: {
    return FD_BINCODE_SUCCESS;
  }
  case 16: {
    return FD_BINCODE_SUCCESS;
  }
  case 17: {
    return FD_BINCODE_SUCCESS;
  }
  case 18: {
    return FD_BINCODE_SUCCESS;
  }
  case 19: {
    return FD_BINCODE_SUCCESS;
  }
  case 20: {
    return FD_BINCODE_SUCCESS;
  }
  case 21: {
    return FD_BINCODE_SUCCESS;
  }
  case 22: {
    return FD_BINCODE_SUCCESS;
  }
  case 23: {
    return FD_BINCODE_SUCCESS;
  }
  case 24: {
    return FD_BINCODE_SUCCESS;
  }
  case 25: {
    err = fd_bincode_uint32_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 26: {
    return FD_BINCODE_SUCCESS;
  }
  case 27: {
    return FD_BINCODE_SUCCESS;
  }
  case 28: {
    return FD_BINCODE_SUCCESS;
  }
  case 29: {
    return FD_BINCODE_SUCCESS;
  }
  case 30: {
    return FD_BINCODE_SUCCESS;
  }
  case 31: {
    return FD_BINCODE_SUCCESS;
  }
  case 32: {
    return FD_BINCODE_SUCCESS;
  }
  case 33: {
    return FD_BINCODE_SUCCESS;
  }
  case 34: {
    return FD_BINCODE_SUCCESS;
  }
  case 35: {
    return FD_BINCODE_SUCCESS;
  }
  case 36: {
    return FD_BINCODE_SUCCESS;
  }
  case 37: {
    return FD_BINCODE_SUCCESS;
  }
  case 38: {
    return FD_BINCODE_SUCCESS;
  }
  case 39: {
    return FD_BINCODE_SUCCESS;
  }
  case 40: {
    return FD_BINCODE_SUCCESS;
  }
  case 41: {
    return FD_BINCODE_SUCCESS;
  }
  case 42: {
    return FD_BINCODE_SUCCESS;
  }
  case 43: {
    return FD_BINCODE_SUCCESS;
  }
  case 44: {
    ulong slen;
    err = fd_bincode_uint64_decode( &slen, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    err = fd_bincode_bytes_decode_footprint( slen, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    *total_sz += slen;
    return FD_BINCODE_SUCCESS;
  }
  case 45: {
    return FD_BINCODE_SUCCESS;
  }
  case 46: {
    return FD_BINCODE_SUCCESS;
  }
  case 47: {
    return FD_BINCODE_SUCCESS;
  }
  case 48: {
    return FD_BINCODE_SUCCESS;
  }
  case 49: {
    return FD_BINCODE_SUCCESS;
  }
  case 50: {
    return FD_BINCODE_SUCCESS;
  }
  case 51: {
    return FD_BINCODE_SUCCESS;
  }
  case 52: {
    return FD_BINCODE_SUCCESS;
  }
  case 53: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_instr_error_enum_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_instr_error_enum_t);
  void const * start_data = ctx->data;
  int err =  fd_instr_error_enum_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_instr_error_enum_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_instr_error_enum_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_instr_error_enum_inner_decode_inner( fd_instr_error_enum_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    fd_bincode_uint32_decode_unsafe( &self->custom, ctx );
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    break;
  }
  case 31: {
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    break;
  }
  case 36: {
    break;
  }
  case 37: {
    break;
  }
  case 38: {
    break;
  }
  case 39: {
    break;
  }
  case 40: {
    break;
  }
  case 41: {
    break;
  }
  case 42: {
    break;
  }
  case 43: {
    break;
  }
  case 44: {
    ulong slen;
    fd_bincode_uint64_decode_unsafe( &slen, ctx );
    self->borsh_io_error = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( (uchar *)self->borsh_io_error, slen, ctx );
    self->borsh_io_error[slen] = '\0';
    *alloc_mem = (uchar *)(*alloc_mem) + slen;
    break;
  }
  case 45: {
    break;
  }
  case 46: {
    break;
  }
  case 47: {
    break;
  }
  case 48: {
    break;
  }
  case 49: {
    break;
  }
  case 50: {
    break;
  }
  case 51: {
    break;
  }
  case 52: {
    break;
  }
  case 53: {
    break;
  }
  }
}
void fd_instr_error_enum_inner_decode_inner_global( fd_instr_error_enum_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    fd_bincode_uint32_decode_unsafe( &self->custom, ctx );
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    break;
  }
  case 31: {
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    break;
  }
  case 36: {
    break;
  }
  case 37: {
    break;
  }
  case 38: {
    break;
  }
  case 39: {
    break;
  }
  case 40: {
    break;
  }
  case 41: {
    break;
  }
  case 42: {
    break;
  }
  case 43: {
    break;
  }
  case 44: {
    ulong slen;
    fd_bincode_uint64_decode_unsafe( &slen, ctx );
    self->borsh_io_error = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( (uchar *)self->borsh_io_error, slen, ctx );
    self->borsh_io_error[slen] = '\0';
    *alloc_mem = (uchar *)(*alloc_mem) + slen;
    break;
  }
  case 45: {
    break;
  }
  case 46: {
    break;
  }
  case 47: {
    break;
  }
  case 48: {
    break;
  }
  case 49: {
    break;
  }
  case 50: {
    break;
  }
  case 51: {
    break;
  }
  case 52: {
    break;
  }
  case 53: {
    break;
  }
  }
}
int fd_instr_error_enum_convert_global_to_local_inner( fd_instr_error_enum_inner_global_t const * mem, fd_instr_error_enum_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    self->custom = mem->custom;
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    break;
  }
  case 31: {
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    break;
  }
  case 36: {
    break;
  }
  case 37: {
    break;
  }
  case 38: {
    break;
  }
  case 39: {
    break;
  }
  case 40: {
    break;
  }
  case 41: {
    break;
  }
  case 42: {
    break;
  }
  case 43: {
    break;
  }
  case 44: {
    strcpy( self->borsh_io_error, mem->borsh_io_error);
    break;
  }
  case 45: {
    break;
  }
  case 46: {
    break;
  }
  case 47: {
    break;
  }
  case 48: {
    break;
  }
  case 49: {
    break;
  }
  case 50: {
    break;
  }
  case 51: {
    break;
  }
  case 52: {
    break;
  }
  case 53: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_instr_error_enum_convert_global_to_local( void const * global_self, fd_instr_error_enum_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_instr_error_enum_global_t const * mem = (fd_instr_error_enum_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_instr_error_enum_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_instr_error_enum_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_instr_error_enum_t * self = (fd_instr_error_enum_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_instr_error_enum_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_instr_error_enum_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_instr_error_enum_t * self = (fd_instr_error_enum_t *)mem;
  fd_instr_error_enum_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_instr_error_enum_t);
  void * * alloc_mem = &alloc_region;
  fd_instr_error_enum_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_instr_error_enum_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_instr_error_enum_t * self = (fd_instr_error_enum_t *)mem;
  fd_instr_error_enum_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_instr_error_enum_t);
  void * * alloc_mem = &alloc_region;
  fd_instr_error_enum_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_instr_error_enum_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_instr_error_enum_global_t * self = (fd_instr_error_enum_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_instr_error_enum_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_instr_error_enum_inner_new( fd_instr_error_enum_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    break;
  }
  case 31: {
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    break;
  }
  case 36: {
    break;
  }
  case 37: {
    break;
  }
  case 38: {
    break;
  }
  case 39: {
    break;
  }
  case 40: {
    break;
  }
  case 41: {
    break;
  }
  case 42: {
    break;
  }
  case 43: {
    break;
  }
  case 44: {
    break;
  }
  case 45: {
    break;
  }
  case 46: {
    break;
  }
  case 47: {
    break;
  }
  case 48: {
    break;
  }
  case 49: {
    break;
  }
  case 50: {
    break;
  }
  case 51: {
    break;
  }
  case 52: {
    break;
  }
  case 53: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_instr_error_enum_new_disc( fd_instr_error_enum_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_instr_error_enum_inner_new( &self->inner, self->discriminant );
}
void fd_instr_error_enum_new( fd_instr_error_enum_t * self ) {
  fd_memset( self, 0, sizeof(fd_instr_error_enum_t) );
  fd_instr_error_enum_new_disc( self, UINT_MAX );
}
void fd_instr_error_enum_inner_destroy( fd_instr_error_enum_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 25: {
    break;
  }
  case 44: {
  self->borsh_io_error = NULL;

    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_instr_error_enum_destroy( fd_instr_error_enum_t * self ) {
  fd_instr_error_enum_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_instr_error_enum_footprint( void ){ return FD_INSTR_ERROR_ENUM_FOOTPRINT; }
ulong fd_instr_error_enum_align( void ){ return FD_INSTR_ERROR_ENUM_ALIGN; }

void fd_instr_error_enum_walk( void * w, fd_instr_error_enum_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_instr_error_enum", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "generic_error", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "invalid_argument", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "invalid_instruction_data", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "invalid_account_data", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "account_data_too_small", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "insufficient_funds", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 6: {
    fun( w, self, "incorrect_program_id", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 7: {
    fun( w, self, "missing_required_signature", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 8: {
    fun( w, self, "account_already_initialized", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 9: {
    fun( w, self, "uninitialized_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 10: {
    fun( w, self, "unbalanced_instruction", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 11: {
    fun( w, self, "modified_program_id", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 12: {
    fun( w, self, "external_account_lamport_spend", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 13: {
    fun( w, self, "external_account_data_modified", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 14: {
    fun( w, self, "readonly_lamport_change", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 15: {
    fun( w, self, "readonly_data_modified", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 16: {
    fun( w, self, "duplicate_account_index", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 17: {
    fun( w, self, "executable_modified", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 18: {
    fun( w, self, "rent_epoch_modified", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 19: {
    fun( w, self, "not_enough_account_keys", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 20: {
    fun( w, self, "account_data_size_changed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 21: {
    fun( w, self, "account_not_executable", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 22: {
    fun( w, self, "account_borrow_failed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 23: {
    fun( w, self, "account_borrow_outstanding", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 24: {
    fun( w, self, "duplicate_account_out_of_sync", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 25: {
    fun( w, self, "custom", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.custom, "custom", FD_FLAMENCO_TYPE_UINT, "uint", level );
    break;
  }
  case 26: {
    fun( w, self, "invalid_error", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 27: {
    fun( w, self, "executable_data_modified", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 28: {
    fun( w, self, "executable_lamport_change", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 29: {
    fun( w, self, "executable_account_not_rent_exempt", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 30: {
    fun( w, self, "unsupported_program_id", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 31: {
    fun( w, self, "call_depth", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 32: {
    fun( w, self, "missing_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 33: {
    fun( w, self, "reentrancy_not_allowed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 34: {
    fun( w, self, "max_seed_length_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 35: {
    fun( w, self, "invalid_seeds", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 36: {
    fun( w, self, "invalid_realloc", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 37: {
    fun( w, self, "computational_budget_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 38: {
    fun( w, self, "privilege_escalation", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 39: {
    fun( w, self, "program_environment_setup_failure", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 40: {
    fun( w, self, "program_failed_to_complete", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 41: {
    fun( w, self, "program_failed_to_compile", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 42: {
    fun( w, self, "immutable", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 43: {
    fun( w, self, "incorrect_authority", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 44: {
    fun( w, self, "borsh_io_error", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, self->inner.borsh_io_error, "borsh_io_error", FD_FLAMENCO_TYPE_CSTR, "char*", level );
    break;
  }
  case 45: {
    fun( w, self, "account_not_rent_exempt", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 46: {
    fun( w, self, "invalid_account_owner", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 47: {
    fun( w, self, "arithmetic_overflow", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 48: {
    fun( w, self, "unsupported_sysvar", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 49: {
    fun( w, self, "illegal_owner", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 50: {
    fun( w, self, "max_accounts_data_allocations_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 51: {
    fun( w, self, "max_accounts_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 52: {
    fun( w, self, "max_instruction_trace_length_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 53: {
    fun( w, self, "builtin_programs_must_consume_compute_units", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_instr_error_enum", level-- );
}
ulong fd_instr_error_enum_size( fd_instr_error_enum_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 25: {
    size += sizeof(uint);
    break;
  }
  case 44: {
    size += sizeof(ulong) + strlen(self->inner.borsh_io_error);
    break;
  }
  }
  return size;
}

int fd_instr_error_enum_inner_encode( fd_instr_error_enum_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 25: {
    err = fd_bincode_uint32_encode( self->custom, ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 44: {
    ulong slen = strlen( (char *) self->borsh_io_error );
    err = fd_bincode_uint64_encode( slen, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_bincode_bytes_encode( (uchar *) self->borsh_io_error, slen, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_instr_error_enum_encode( fd_instr_error_enum_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_instr_error_enum_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_txn_instr_error_encode( fd_txn_instr_error_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint8_encode( (uchar)(self->instr_idx), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_instr_error_enum_encode( &self->error, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_txn_instr_error_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_txn_instr_error_t);
  void const * start_data = ctx->data;
  int err = fd_txn_instr_error_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_txn_instr_error_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_instr_error_enum_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_txn_instr_error_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_instr_error_t * self = (fd_txn_instr_error_t *)mem;
  fd_txn_instr_error_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_txn_instr_error_t);
  void * * alloc_mem = &alloc_region;
  fd_txn_instr_error_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_txn_instr_error_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_instr_error_t * self = (fd_txn_instr_error_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->instr_idx, ctx );
  fd_instr_error_enum_decode_inner( &self->error, alloc_mem, ctx );
}
void * fd_txn_instr_error_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_instr_error_global_t * self = (fd_txn_instr_error_global_t *)mem;
  fd_txn_instr_error_new( (fd_txn_instr_error_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_txn_instr_error_global_t);
  void * * alloc_mem = &alloc_region;
  fd_txn_instr_error_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_txn_instr_error_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_instr_error_global_t * self = (fd_txn_instr_error_global_t *)struct_mem;
  fd_bincode_uint8_decode_unsafe( &self->instr_idx, ctx );
  fd_instr_error_enum_decode_inner_global( &self->error, alloc_mem, ctx );
}
int fd_txn_instr_error_convert_global_to_local( void const * global_self, fd_txn_instr_error_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_txn_instr_error_global_t const * mem = (fd_txn_instr_error_global_t const *)global_self;
  self->instr_idx = mem->instr_idx;
  err = fd_instr_error_enum_convert_global_to_local( &mem->error, &self->error, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_txn_instr_error_new(fd_txn_instr_error_t * self) {
  fd_memset( self, 0, sizeof(fd_txn_instr_error_t) );
  fd_instr_error_enum_new( &self->error );
}
void fd_txn_instr_error_destroy( fd_txn_instr_error_t * self ) {
  fd_instr_error_enum_destroy( &self->error );
}

ulong fd_txn_instr_error_footprint( void ){ return FD_TXN_INSTR_ERROR_FOOTPRINT; }
ulong fd_txn_instr_error_align( void ){ return FD_TXN_INSTR_ERROR_ALIGN; }

void fd_txn_instr_error_walk( void * w, fd_txn_instr_error_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_txn_instr_error", level++ );
  fun( w, &self->instr_idx, "instr_idx", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_instr_error_enum_walk( w, &self->error, fun, "error", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_txn_instr_error", level-- );
}
ulong fd_txn_instr_error_size( fd_txn_instr_error_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  size += fd_instr_error_enum_size( &self->error );
  return size;
}

FD_FN_PURE uchar fd_txn_error_enum_is_account_in_use(fd_txn_error_enum_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_txn_error_enum_is_account_loaded_twice(fd_txn_error_enum_t const * self) {
  return self->discriminant == 1;
}
FD_FN_PURE uchar fd_txn_error_enum_is_account_not_found(fd_txn_error_enum_t const * self) {
  return self->discriminant == 2;
}
FD_FN_PURE uchar fd_txn_error_enum_is_program_account_not_found(fd_txn_error_enum_t const * self) {
  return self->discriminant == 3;
}
FD_FN_PURE uchar fd_txn_error_enum_is_insufficient_funds_for_fee(fd_txn_error_enum_t const * self) {
  return self->discriminant == 4;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_account_for_fee(fd_txn_error_enum_t const * self) {
  return self->discriminant == 5;
}
FD_FN_PURE uchar fd_txn_error_enum_is_already_processed(fd_txn_error_enum_t const * self) {
  return self->discriminant == 6;
}
FD_FN_PURE uchar fd_txn_error_enum_is_blockhash_not_found(fd_txn_error_enum_t const * self) {
  return self->discriminant == 7;
}
FD_FN_PURE uchar fd_txn_error_enum_is_instruction_error(fd_txn_error_enum_t const * self) {
  return self->discriminant == 8;
}
FD_FN_PURE uchar fd_txn_error_enum_is_call_chain_too_deep(fd_txn_error_enum_t const * self) {
  return self->discriminant == 9;
}
FD_FN_PURE uchar fd_txn_error_enum_is_missing_signature_for_fee(fd_txn_error_enum_t const * self) {
  return self->discriminant == 10;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_account_index(fd_txn_error_enum_t const * self) {
  return self->discriminant == 11;
}
FD_FN_PURE uchar fd_txn_error_enum_is_signature_failure(fd_txn_error_enum_t const * self) {
  return self->discriminant == 12;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_program_for_execution(fd_txn_error_enum_t const * self) {
  return self->discriminant == 13;
}
FD_FN_PURE uchar fd_txn_error_enum_is_sanitize_failure(fd_txn_error_enum_t const * self) {
  return self->discriminant == 14;
}
FD_FN_PURE uchar fd_txn_error_enum_is_cluster_maintenance(fd_txn_error_enum_t const * self) {
  return self->discriminant == 15;
}
FD_FN_PURE uchar fd_txn_error_enum_is_account_borrow_outstanding(fd_txn_error_enum_t const * self) {
  return self->discriminant == 16;
}
FD_FN_PURE uchar fd_txn_error_enum_is_would_exceed_max_block_cost_limit(fd_txn_error_enum_t const * self) {
  return self->discriminant == 17;
}
FD_FN_PURE uchar fd_txn_error_enum_is_unsupported_version(fd_txn_error_enum_t const * self) {
  return self->discriminant == 18;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_writable_account(fd_txn_error_enum_t const * self) {
  return self->discriminant == 19;
}
FD_FN_PURE uchar fd_txn_error_enum_is_would_exceed_max_account_cost_limit(fd_txn_error_enum_t const * self) {
  return self->discriminant == 20;
}
FD_FN_PURE uchar fd_txn_error_enum_is_would_exceed_account_data_block_limit(fd_txn_error_enum_t const * self) {
  return self->discriminant == 21;
}
FD_FN_PURE uchar fd_txn_error_enum_is_too_many_account_locks(fd_txn_error_enum_t const * self) {
  return self->discriminant == 22;
}
FD_FN_PURE uchar fd_txn_error_enum_is_address_lookup_table_not_found(fd_txn_error_enum_t const * self) {
  return self->discriminant == 23;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_address_lookup_table_owner(fd_txn_error_enum_t const * self) {
  return self->discriminant == 24;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_address_lookup_table_data(fd_txn_error_enum_t const * self) {
  return self->discriminant == 25;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_address_lookup_table_index(fd_txn_error_enum_t const * self) {
  return self->discriminant == 26;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_rent_paying_account(fd_txn_error_enum_t const * self) {
  return self->discriminant == 27;
}
FD_FN_PURE uchar fd_txn_error_enum_is_would_exceed_max_vote_cost_limit(fd_txn_error_enum_t const * self) {
  return self->discriminant == 28;
}
FD_FN_PURE uchar fd_txn_error_enum_is_would_exceed_account_data_total_limit(fd_txn_error_enum_t const * self) {
  return self->discriminant == 29;
}
FD_FN_PURE uchar fd_txn_error_enum_is_duplicate_instruction(fd_txn_error_enum_t const * self) {
  return self->discriminant == 30;
}
FD_FN_PURE uchar fd_txn_error_enum_is_insufficient_funds_for_rent(fd_txn_error_enum_t const * self) {
  return self->discriminant == 31;
}
FD_FN_PURE uchar fd_txn_error_enum_is_max_loaded_accounts_data_size_exceeded(fd_txn_error_enum_t const * self) {
  return self->discriminant == 32;
}
FD_FN_PURE uchar fd_txn_error_enum_is_invalid_loaded_accounts_data_size_limit(fd_txn_error_enum_t const * self) {
  return self->discriminant == 33;
}
FD_FN_PURE uchar fd_txn_error_enum_is_resanitization_needed(fd_txn_error_enum_t const * self) {
  return self->discriminant == 34;
}
FD_FN_PURE uchar fd_txn_error_enum_is_program_execution_temporarily_restricted(fd_txn_error_enum_t const * self) {
  return self->discriminant == 35;
}
FD_FN_PURE uchar fd_txn_error_enum_is_unbalanced_transaction(fd_txn_error_enum_t const * self) {
  return self->discriminant == 36;
}
void fd_txn_error_enum_inner_new( fd_txn_error_enum_inner_t * self, uint discriminant );
int fd_txn_error_enum_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    return FD_BINCODE_SUCCESS;
  }
  case 2: {
    return FD_BINCODE_SUCCESS;
  }
  case 3: {
    return FD_BINCODE_SUCCESS;
  }
  case 4: {
    return FD_BINCODE_SUCCESS;
  }
  case 5: {
    return FD_BINCODE_SUCCESS;
  }
  case 6: {
    return FD_BINCODE_SUCCESS;
  }
  case 7: {
    return FD_BINCODE_SUCCESS;
  }
  case 8: {
    err = fd_txn_instr_error_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 9: {
    return FD_BINCODE_SUCCESS;
  }
  case 10: {
    return FD_BINCODE_SUCCESS;
  }
  case 11: {
    return FD_BINCODE_SUCCESS;
  }
  case 12: {
    return FD_BINCODE_SUCCESS;
  }
  case 13: {
    return FD_BINCODE_SUCCESS;
  }
  case 14: {
    return FD_BINCODE_SUCCESS;
  }
  case 15: {
    return FD_BINCODE_SUCCESS;
  }
  case 16: {
    return FD_BINCODE_SUCCESS;
  }
  case 17: {
    return FD_BINCODE_SUCCESS;
  }
  case 18: {
    return FD_BINCODE_SUCCESS;
  }
  case 19: {
    return FD_BINCODE_SUCCESS;
  }
  case 20: {
    return FD_BINCODE_SUCCESS;
  }
  case 21: {
    return FD_BINCODE_SUCCESS;
  }
  case 22: {
    return FD_BINCODE_SUCCESS;
  }
  case 23: {
    return FD_BINCODE_SUCCESS;
  }
  case 24: {
    return FD_BINCODE_SUCCESS;
  }
  case 25: {
    return FD_BINCODE_SUCCESS;
  }
  case 26: {
    return FD_BINCODE_SUCCESS;
  }
  case 27: {
    return FD_BINCODE_SUCCESS;
  }
  case 28: {
    return FD_BINCODE_SUCCESS;
  }
  case 29: {
    return FD_BINCODE_SUCCESS;
  }
  case 30: {
    err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 31: {
    err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 32: {
    return FD_BINCODE_SUCCESS;
  }
  case 33: {
    return FD_BINCODE_SUCCESS;
  }
  case 34: {
    return FD_BINCODE_SUCCESS;
  }
  case 35: {
    err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  case 36: {
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_txn_error_enum_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_txn_error_enum_t);
  void const * start_data = ctx->data;
  int err =  fd_txn_error_enum_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_txn_error_enum_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_txn_error_enum_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_txn_error_enum_inner_decode_inner( fd_txn_error_enum_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    fd_txn_instr_error_decode_inner( &self->instruction_error, alloc_mem, ctx );
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    fd_bincode_uint8_decode_unsafe( &self->duplicate_instruction, ctx );
    break;
  }
  case 31: {
    fd_bincode_uint8_decode_unsafe( &self->insufficient_funds_for_rent, ctx );
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    fd_bincode_uint8_decode_unsafe( &self->program_execution_temporarily_restricted, ctx );
    break;
  }
  case 36: {
    break;
  }
  }
}
void fd_txn_error_enum_inner_decode_inner_global( fd_txn_error_enum_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    fd_txn_instr_error_decode_inner_global( &self->instruction_error, alloc_mem, ctx );
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    fd_bincode_uint8_decode_unsafe( &self->duplicate_instruction, ctx );
    break;
  }
  case 31: {
    fd_bincode_uint8_decode_unsafe( &self->insufficient_funds_for_rent, ctx );
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    fd_bincode_uint8_decode_unsafe( &self->program_execution_temporarily_restricted, ctx );
    break;
  }
  case 36: {
    break;
  }
  }
}
int fd_txn_error_enum_convert_global_to_local_inner( fd_txn_error_enum_inner_global_t const * mem, fd_txn_error_enum_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    err = fd_txn_instr_error_convert_global_to_local( &mem->instruction_error, &self->instruction_error, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    self->duplicate_instruction = mem->duplicate_instruction;
    break;
  }
  case 31: {
    self->insufficient_funds_for_rent = mem->insufficient_funds_for_rent;
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    self->program_execution_temporarily_restricted = mem->program_execution_temporarily_restricted;
    break;
  }
  case 36: {
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_txn_error_enum_convert_global_to_local( void const * global_self, fd_txn_error_enum_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_error_enum_global_t const * mem = (fd_txn_error_enum_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_txn_error_enum_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_txn_error_enum_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_error_enum_t * self = (fd_txn_error_enum_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_txn_error_enum_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_txn_error_enum_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_error_enum_t * self = (fd_txn_error_enum_t *)mem;
  fd_txn_error_enum_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_txn_error_enum_t);
  void * * alloc_mem = &alloc_region;
  fd_txn_error_enum_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_txn_error_enum_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_error_enum_t * self = (fd_txn_error_enum_t *)mem;
  fd_txn_error_enum_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_txn_error_enum_t);
  void * * alloc_mem = &alloc_region;
  fd_txn_error_enum_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_txn_error_enum_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_error_enum_global_t * self = (fd_txn_error_enum_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_txn_error_enum_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_txn_error_enum_inner_new( fd_txn_error_enum_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    break;
  }
  case 2: {
    break;
  }
  case 3: {
    break;
  }
  case 4: {
    break;
  }
  case 5: {
    break;
  }
  case 6: {
    break;
  }
  case 7: {
    break;
  }
  case 8: {
    fd_txn_instr_error_new( &self->instruction_error );
    break;
  }
  case 9: {
    break;
  }
  case 10: {
    break;
  }
  case 11: {
    break;
  }
  case 12: {
    break;
  }
  case 13: {
    break;
  }
  case 14: {
    break;
  }
  case 15: {
    break;
  }
  case 16: {
    break;
  }
  case 17: {
    break;
  }
  case 18: {
    break;
  }
  case 19: {
    break;
  }
  case 20: {
    break;
  }
  case 21: {
    break;
  }
  case 22: {
    break;
  }
  case 23: {
    break;
  }
  case 24: {
    break;
  }
  case 25: {
    break;
  }
  case 26: {
    break;
  }
  case 27: {
    break;
  }
  case 28: {
    break;
  }
  case 29: {
    break;
  }
  case 30: {
    break;
  }
  case 31: {
    break;
  }
  case 32: {
    break;
  }
  case 33: {
    break;
  }
  case 34: {
    break;
  }
  case 35: {
    break;
  }
  case 36: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_txn_error_enum_new_disc( fd_txn_error_enum_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_txn_error_enum_inner_new( &self->inner, self->discriminant );
}
void fd_txn_error_enum_new( fd_txn_error_enum_t * self ) {
  fd_memset( self, 0, sizeof(fd_txn_error_enum_t) );
  fd_txn_error_enum_new_disc( self, UINT_MAX );
}
void fd_txn_error_enum_inner_destroy( fd_txn_error_enum_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 8: {
    fd_txn_instr_error_destroy( &self->instruction_error );
    break;
  }
  case 30: {
    break;
  }
  case 31: {
    break;
  }
  case 35: {
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_txn_error_enum_destroy( fd_txn_error_enum_t * self ) {
  fd_txn_error_enum_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_txn_error_enum_footprint( void ){ return FD_TXN_ERROR_ENUM_FOOTPRINT; }
ulong fd_txn_error_enum_align( void ){ return FD_TXN_ERROR_ENUM_ALIGN; }

void fd_txn_error_enum_walk( void * w, fd_txn_error_enum_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_txn_error_enum", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "account_in_use", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "account_loaded_twice", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 2: {
    fun( w, self, "account_not_found", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 3: {
    fun( w, self, "program_account_not_found", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 4: {
    fun( w, self, "insufficient_funds_for_fee", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 5: {
    fun( w, self, "invalid_account_for_fee", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 6: {
    fun( w, self, "already_processed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 7: {
    fun( w, self, "blockhash_not_found", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 8: {
    fun( w, self, "instruction_error", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_txn_instr_error_walk( w, &self->inner.instruction_error, fun, "instruction_error", level );
    break;
  }
  case 9: {
    fun( w, self, "call_chain_too_deep", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 10: {
    fun( w, self, "missing_signature_for_fee", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 11: {
    fun( w, self, "invalid_account_index", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 12: {
    fun( w, self, "signature_failure", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 13: {
    fun( w, self, "invalid_program_for_execution", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 14: {
    fun( w, self, "sanitize_failure", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 15: {
    fun( w, self, "cluster_maintenance", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 16: {
    fun( w, self, "account_borrow_outstanding", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 17: {
    fun( w, self, "would_exceed_max_block_cost_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 18: {
    fun( w, self, "unsupported_version", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 19: {
    fun( w, self, "invalid_writable_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 20: {
    fun( w, self, "would_exceed_max_account_cost_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 21: {
    fun( w, self, "would_exceed_account_data_block_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 22: {
    fun( w, self, "too_many_account_locks", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 23: {
    fun( w, self, "address_lookup_table_not_found", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 24: {
    fun( w, self, "invalid_address_lookup_table_owner", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 25: {
    fun( w, self, "invalid_address_lookup_table_data", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 26: {
    fun( w, self, "invalid_address_lookup_table_index", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 27: {
    fun( w, self, "invalid_rent_paying_account", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 28: {
    fun( w, self, "would_exceed_max_vote_cost_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 29: {
    fun( w, self, "would_exceed_account_data_total_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 30: {
    fun( w, self, "duplicate_instruction", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.duplicate_instruction, "duplicate_instruction", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
    break;
  }
  case 31: {
    fun( w, self, "insufficient_funds_for_rent", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.insufficient_funds_for_rent, "insufficient_funds_for_rent", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
    break;
  }
  case 32: {
    fun( w, self, "max_loaded_accounts_data_size_exceeded", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 33: {
    fun( w, self, "invalid_loaded_accounts_data_size_limit", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 34: {
    fun( w, self, "resanitization_needed", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 35: {
    fun( w, self, "program_execution_temporarily_restricted", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
  fun( w, &self->inner.program_execution_temporarily_restricted, "program_execution_temporarily_restricted", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
    break;
  }
  case 36: {
    fun( w, self, "unbalanced_transaction", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_txn_error_enum", level-- );
}
ulong fd_txn_error_enum_size( fd_txn_error_enum_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 8: {
    size += fd_txn_instr_error_size( &self->inner.instruction_error );
    break;
  }
  case 30: {
    size += sizeof(char);
    break;
  }
  case 31: {
    size += sizeof(char);
    break;
  }
  case 35: {
    size += sizeof(char);
    break;
  }
  }
  return size;
}

int fd_txn_error_enum_inner_encode( fd_txn_error_enum_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 8: {
    err = fd_txn_instr_error_encode( &self->instruction_error, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 30: {
    err = fd_bincode_uint8_encode( (uchar)(self->duplicate_instruction), ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 31: {
    err = fd_bincode_uint8_encode( (uchar)(self->insufficient_funds_for_rent), ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  case 35: {
    err = fd_bincode_uint8_encode( (uchar)(self->program_execution_temporarily_restricted), ctx );
  if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_txn_error_enum_encode( fd_txn_error_enum_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_txn_error_enum_inner_encode( &self->inner, self->discriminant, ctx );
}

FD_FN_PURE uchar fd_txn_result_is_ok(fd_txn_result_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_txn_result_is_error(fd_txn_result_t const * self) {
  return self->discriminant == 1;
}
void fd_txn_result_inner_new( fd_txn_result_inner_t * self, uint discriminant );
int fd_txn_result_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_txn_error_enum_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_txn_result_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_txn_result_t);
  void const * start_data = ctx->data;
  int err =  fd_txn_result_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_txn_result_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_txn_result_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_txn_result_inner_decode_inner( fd_txn_result_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_txn_error_enum_decode_inner( &self->error, alloc_mem, ctx );
    break;
  }
  }
}
void fd_txn_result_inner_decode_inner_global( fd_txn_result_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_txn_error_enum_decode_inner_global( &self->error, alloc_mem, ctx );
    break;
  }
  }
}
int fd_txn_result_convert_global_to_local_inner( fd_txn_result_inner_global_t const * mem, fd_txn_result_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_txn_error_enum_convert_global_to_local( &mem->error, &self->error, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_txn_result_convert_global_to_local( void const * global_self, fd_txn_result_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_result_global_t const * mem = (fd_txn_result_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_txn_result_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_txn_result_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_result_t * self = (fd_txn_result_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_txn_result_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_txn_result_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_result_t * self = (fd_txn_result_t *)mem;
  fd_txn_result_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_txn_result_t);
  void * * alloc_mem = &alloc_region;
  fd_txn_result_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_txn_result_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_result_t * self = (fd_txn_result_t *)mem;
  fd_txn_result_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_txn_result_t);
  void * * alloc_mem = &alloc_region;
  fd_txn_result_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_txn_result_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_txn_result_global_t * self = (fd_txn_result_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_txn_result_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_txn_result_inner_new( fd_txn_result_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_txn_error_enum_new( &self->error );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_txn_result_new_disc( fd_txn_result_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_txn_result_inner_new( &self->inner, self->discriminant );
}
void fd_txn_result_new( fd_txn_result_t * self ) {
  fd_memset( self, 0, sizeof(fd_txn_result_t) );
  fd_txn_result_new_disc( self, UINT_MAX );
}
void fd_txn_result_inner_destroy( fd_txn_result_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_txn_error_enum_destroy( &self->error );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_txn_result_destroy( fd_txn_result_t * self ) {
  fd_txn_result_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_txn_result_footprint( void ){ return FD_TXN_RESULT_FOOTPRINT; }
ulong fd_txn_result_align( void ){ return FD_TXN_RESULT_ALIGN; }

void fd_txn_result_walk( void * w, fd_txn_result_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_txn_result", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "ok", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "error", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_txn_error_enum_walk( w, &self->inner.error, fun, "error", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_txn_result", level-- );
}
ulong fd_txn_result_size( fd_txn_result_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_txn_error_enum_size( &self->inner.error );
    break;
  }
  }
  return size;
}

int fd_txn_result_inner_encode( fd_txn_result_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_txn_error_enum_encode( &self->error, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_txn_result_encode( fd_txn_result_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_txn_result_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_cache_status_encode( fd_cache_status_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_bytes_encode( self->key_slice, 20, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_txn_result_encode( &self->result, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_cache_status_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_cache_status_t);
  void const * start_data = ctx->data;
  int err = fd_cache_status_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_cache_status_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_bytes_decode_footprint( 20, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_txn_result_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_cache_status_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cache_status_t * self = (fd_cache_status_t *)mem;
  fd_cache_status_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_cache_status_t);
  void * * alloc_mem = &alloc_region;
  fd_cache_status_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_cache_status_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cache_status_t * self = (fd_cache_status_t *)struct_mem;
  fd_bincode_bytes_decode_unsafe( self->key_slice, 20, ctx );
  fd_txn_result_decode_inner( &self->result, alloc_mem, ctx );
}
void * fd_cache_status_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cache_status_global_t * self = (fd_cache_status_global_t *)mem;
  fd_cache_status_new( (fd_cache_status_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_cache_status_global_t);
  void * * alloc_mem = &alloc_region;
  fd_cache_status_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_cache_status_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cache_status_global_t * self = (fd_cache_status_global_t *)struct_mem;
  fd_bincode_bytes_decode_unsafe( self->key_slice, 20, ctx );
  fd_txn_result_decode_inner_global( &self->result, alloc_mem, ctx );
}
int fd_cache_status_convert_global_to_local( void const * global_self, fd_cache_status_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_cache_status_global_t const * mem = (fd_cache_status_global_t const *)global_self;
  fd_memcpy( self->key_slice, mem->key_slice, 20 * sizeof(uchar) );
  err = fd_txn_result_convert_global_to_local( &mem->result, &self->result, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_cache_status_new(fd_cache_status_t * self) {
  fd_memset( self, 0, sizeof(fd_cache_status_t) );
  fd_txn_result_new( &self->result );
}
void fd_cache_status_destroy( fd_cache_status_t * self ) {
  fd_txn_result_destroy( &self->result );
}

ulong fd_cache_status_footprint( void ){ return FD_CACHE_STATUS_FOOTPRINT; }
ulong fd_cache_status_align( void ){ return FD_CACHE_STATUS_ALIGN; }

void fd_cache_status_walk( void * w, fd_cache_status_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_cache_status", level++ );
  fun(w, self->key_slice, "key_slice", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fd_txn_result_walk( w, &self->result, fun, "result", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_cache_status", level-- );
}
ulong fd_cache_status_size( fd_cache_status_t const * self ) {
  ulong size = 0;
  size += 20;
  size += fd_txn_result_size( &self->result );
  return size;
}

int fd_status_value_encode( fd_status_value_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->txn_idx, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->statuses_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->statuses_len ) {
    for( ulong i=0; i < self->statuses_len; i++ ) {
      err = fd_cache_status_encode( self->statuses + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_status_value_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_status_value_t);
  void const * start_data = ctx->data;
  int err = fd_status_value_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_status_value_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  ulong statuses_len;
  err = fd_bincode_uint64_decode( &statuses_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( statuses_len ) {
    *total_sz += FD_CACHE_STATUS_ALIGN + FD_CACHE_STATUS_FOOTPRINT*statuses_len;
    for( ulong i=0; i < statuses_len; i++ ) {
      err = fd_cache_status_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_status_value_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_value_t * self = (fd_status_value_t *)mem;
  fd_status_value_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_status_value_t);
  void * * alloc_mem = &alloc_region;
  fd_status_value_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_status_value_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_value_t * self = (fd_status_value_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->txn_idx, ctx );
  fd_bincode_uint64_decode_unsafe( &self->statuses_len, ctx );
  if( self->statuses_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CACHE_STATUS_ALIGN );
    self->statuses = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CACHE_STATUS_FOOTPRINT*self->statuses_len;
    for( ulong i=0; i < self->statuses_len; i++ ) {
      fd_cache_status_new( self->statuses + i );
      fd_cache_status_decode_inner( self->statuses + i, alloc_mem, ctx );
    }
  } else
    self->statuses = NULL;
}
void * fd_status_value_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_value_global_t * self = (fd_status_value_global_t *)mem;
  fd_status_value_new( (fd_status_value_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_status_value_global_t);
  void * * alloc_mem = &alloc_region;
  fd_status_value_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_status_value_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_value_global_t * self = (fd_status_value_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->txn_idx, ctx );
  fd_bincode_uint64_decode_unsafe( &self->statuses_len, ctx );
  if( self->statuses_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_CACHE_STATUS_ALIGN );
    self->statuses_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_CACHE_STATUS_FOOTPRINT*self->statuses_len;
    for( ulong i=0; i < self->statuses_len; i++ ) {
      fd_cache_status_new( (fd_cache_status_t *)(cur_mem + FD_CACHE_STATUS_FOOTPRINT * i) );
      fd_cache_status_decode_inner_global( cur_mem + FD_CACHE_STATUS_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->statuses_gaddr = 0UL;
}
int fd_status_value_convert_global_to_local( void const * global_self, fd_status_value_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_status_value_global_t const * mem = (fd_status_value_global_t const *)global_self;
  self->txn_idx = mem->txn_idx;
  self->statuses_len = mem->statuses_len;
  self->statuses     = fd_wksp_laddr_fast( ctx->wksp, mem->statuses_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_status_value_new(fd_status_value_t * self) {
  fd_memset( self, 0, sizeof(fd_status_value_t) );
}
void fd_status_value_destroy( fd_status_value_t * self ) {
  if( self->statuses ) {
    for( ulong i=0; i < self->statuses_len; i++ )
      fd_cache_status_destroy( self->statuses + i );
    self->statuses = NULL;
  }
}

ulong fd_status_value_footprint( void ){ return FD_STATUS_VALUE_FOOTPRINT; }
ulong fd_status_value_align( void ){ return FD_STATUS_VALUE_ALIGN; }

void fd_status_value_walk( void * w, fd_status_value_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_status_value", level++ );
  fun( w, &self->txn_idx, "txn_idx", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  if( self->statuses_len ) {
    fun( w, NULL, "statuses", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->statuses_len; i++ )
      fd_cache_status_walk(w, self->statuses + i, fun, "cache_status", level );
    fun( w, NULL, "statuses", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_status_value", level-- );
}
ulong fd_status_value_size( fd_status_value_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->statuses_len; i++ )
      size += fd_cache_status_size( self->statuses + i );
  } while(0);
  return size;
}

int fd_status_pair_encode( fd_status_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_hash_encode( &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_status_value_encode( &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_status_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_status_pair_t);
  void const * start_data = ctx->data;
  int err = fd_status_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_status_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_hash_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_status_value_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_status_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_pair_t * self = (fd_status_pair_t *)mem;
  fd_status_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_status_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_status_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_status_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_pair_t * self = (fd_status_pair_t *)struct_mem;
  fd_hash_decode_inner( &self->hash, alloc_mem, ctx );
  fd_status_value_decode_inner( &self->value, alloc_mem, ctx );
}
void * fd_status_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_pair_global_t * self = (fd_status_pair_global_t *)mem;
  fd_status_pair_new( (fd_status_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_status_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_status_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_status_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_status_pair_global_t * self = (fd_status_pair_global_t *)struct_mem;
  fd_hash_decode_inner_global( &self->hash, alloc_mem, ctx );
  fd_status_value_decode_inner_global( &self->value, alloc_mem, ctx );
}
int fd_status_pair_convert_global_to_local( void const * global_self, fd_status_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_status_pair_global_t const * mem = (fd_status_pair_global_t const *)global_self;
  err = fd_hash_convert_global_to_local( &mem->hash, &self->hash, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_status_value_convert_global_to_local( &mem->value, &self->value, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_status_pair_new(fd_status_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_status_pair_t) );
  fd_hash_new( &self->hash );
  fd_status_value_new( &self->value );
}
void fd_status_pair_destroy( fd_status_pair_t * self ) {
  fd_hash_destroy( &self->hash );
  fd_status_value_destroy( &self->value );
}

ulong fd_status_pair_footprint( void ){ return FD_STATUS_PAIR_FOOTPRINT; }
ulong fd_status_pair_align( void ){ return FD_STATUS_PAIR_ALIGN; }

void fd_status_pair_walk( void * w, fd_status_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_status_pair", level++ );
  fd_hash_walk( w, &self->hash, fun, "hash", level );
  fd_status_value_walk( w, &self->value, fun, "value", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_status_pair", level-- );
}
ulong fd_status_pair_size( fd_status_pair_t const * self ) {
  ulong size = 0;
  size += fd_hash_size( &self->hash );
  size += fd_status_value_size( &self->value );
  return size;
}

int fd_slot_delta_encode( fd_slot_delta_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_bool_encode( (uchar)(self->is_root), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->slot_delta_vec_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->slot_delta_vec_len ) {
    for( ulong i=0; i < self->slot_delta_vec_len; i++ ) {
      err = fd_status_pair_encode( self->slot_delta_vec + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_slot_delta_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_slot_delta_t);
  void const * start_data = ctx->data;
  int err = fd_slot_delta_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_slot_delta_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_bool_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  ulong slot_delta_vec_len;
  err = fd_bincode_uint64_decode( &slot_delta_vec_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( slot_delta_vec_len ) {
    *total_sz += FD_STATUS_PAIR_ALIGN + FD_STATUS_PAIR_FOOTPRINT*slot_delta_vec_len;
    for( ulong i=0; i < slot_delta_vec_len; i++ ) {
      err = fd_status_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_slot_delta_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_delta_t * self = (fd_slot_delta_t *)mem;
  fd_slot_delta_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_delta_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_delta_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_delta_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_delta_t * self = (fd_slot_delta_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_bool_decode_unsafe( &self->is_root, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot_delta_vec_len, ctx );
  if( self->slot_delta_vec_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_STATUS_PAIR_ALIGN );
    self->slot_delta_vec = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_STATUS_PAIR_FOOTPRINT*self->slot_delta_vec_len;
    for( ulong i=0; i < self->slot_delta_vec_len; i++ ) {
      fd_status_pair_new( self->slot_delta_vec + i );
      fd_status_pair_decode_inner( self->slot_delta_vec + i, alloc_mem, ctx );
    }
  } else
    self->slot_delta_vec = NULL;
}
void * fd_slot_delta_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_delta_global_t * self = (fd_slot_delta_global_t *)mem;
  fd_slot_delta_new( (fd_slot_delta_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_slot_delta_global_t);
  void * * alloc_mem = &alloc_region;
  fd_slot_delta_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_slot_delta_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_slot_delta_global_t * self = (fd_slot_delta_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot, ctx );
  fd_bincode_bool_decode_unsafe( &self->is_root, ctx );
  fd_bincode_uint64_decode_unsafe( &self->slot_delta_vec_len, ctx );
  if( self->slot_delta_vec_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_STATUS_PAIR_ALIGN );
    self->slot_delta_vec_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_STATUS_PAIR_FOOTPRINT*self->slot_delta_vec_len;
    for( ulong i=0; i < self->slot_delta_vec_len; i++ ) {
      fd_status_pair_new( (fd_status_pair_t *)(cur_mem + FD_STATUS_PAIR_FOOTPRINT * i) );
      fd_status_pair_decode_inner_global( cur_mem + FD_STATUS_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->slot_delta_vec_gaddr = 0UL;
}
int fd_slot_delta_convert_global_to_local( void const * global_self, fd_slot_delta_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_slot_delta_global_t const * mem = (fd_slot_delta_global_t const *)global_self;
  self->slot = mem->slot;
  self->is_root = mem->is_root;
  self->slot_delta_vec_len = mem->slot_delta_vec_len;
  self->slot_delta_vec     = fd_wksp_laddr_fast( ctx->wksp, mem->slot_delta_vec_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_slot_delta_new(fd_slot_delta_t * self) {
  fd_memset( self, 0, sizeof(fd_slot_delta_t) );
}
void fd_slot_delta_destroy( fd_slot_delta_t * self ) {
  if( self->slot_delta_vec ) {
    for( ulong i=0; i < self->slot_delta_vec_len; i++ )
      fd_status_pair_destroy( self->slot_delta_vec + i );
    self->slot_delta_vec = NULL;
  }
}

ulong fd_slot_delta_footprint( void ){ return FD_SLOT_DELTA_FOOTPRINT; }
ulong fd_slot_delta_align( void ){ return FD_SLOT_DELTA_ALIGN; }

void fd_slot_delta_walk( void * w, fd_slot_delta_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_slot_delta", level++ );
  fun( w, &self->slot, "slot", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->is_root, "is_root", FD_FLAMENCO_TYPE_BOOL, "bool", level );
  if( self->slot_delta_vec_len ) {
    fun( w, NULL, "slot_delta_vec", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->slot_delta_vec_len; i++ )
      fd_status_pair_walk(w, self->slot_delta_vec + i, fun, "status_pair", level );
    fun( w, NULL, "slot_delta_vec", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_slot_delta", level-- );
}
ulong fd_slot_delta_size( fd_slot_delta_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(char);
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->slot_delta_vec_len; i++ )
      size += fd_status_pair_size( self->slot_delta_vec + i );
  } while(0);
  return size;
}

int fd_bank_slot_deltas_encode( fd_bank_slot_deltas_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->slot_deltas_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->slot_deltas_len ) {
    for( ulong i=0; i < self->slot_deltas_len; i++ ) {
      err = fd_slot_delta_encode( self->slot_deltas + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_bank_slot_deltas_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_bank_slot_deltas_t);
  void const * start_data = ctx->data;
  int err = fd_bank_slot_deltas_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_bank_slot_deltas_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong slot_deltas_len;
  err = fd_bincode_uint64_decode( &slot_deltas_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( slot_deltas_len ) {
    *total_sz += FD_SLOT_DELTA_ALIGN + FD_SLOT_DELTA_FOOTPRINT*slot_deltas_len;
    for( ulong i=0; i < slot_deltas_len; i++ ) {
      err = fd_slot_delta_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_bank_slot_deltas_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_slot_deltas_t * self = (fd_bank_slot_deltas_t *)mem;
  fd_bank_slot_deltas_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_slot_deltas_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_slot_deltas_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_slot_deltas_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_slot_deltas_t * self = (fd_bank_slot_deltas_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot_deltas_len, ctx );
  if( self->slot_deltas_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_DELTA_ALIGN );
    self->slot_deltas = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_DELTA_FOOTPRINT*self->slot_deltas_len;
    for( ulong i=0; i < self->slot_deltas_len; i++ ) {
      fd_slot_delta_new( self->slot_deltas + i );
      fd_slot_delta_decode_inner( self->slot_deltas + i, alloc_mem, ctx );
    }
  } else
    self->slot_deltas = NULL;
}
void * fd_bank_slot_deltas_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_slot_deltas_global_t * self = (fd_bank_slot_deltas_global_t *)mem;
  fd_bank_slot_deltas_new( (fd_bank_slot_deltas_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_bank_slot_deltas_global_t);
  void * * alloc_mem = &alloc_region;
  fd_bank_slot_deltas_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_bank_slot_deltas_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_bank_slot_deltas_global_t * self = (fd_bank_slot_deltas_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->slot_deltas_len, ctx );
  if( self->slot_deltas_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_SLOT_DELTA_ALIGN );
    self->slot_deltas_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_SLOT_DELTA_FOOTPRINT*self->slot_deltas_len;
    for( ulong i=0; i < self->slot_deltas_len; i++ ) {
      fd_slot_delta_new( (fd_slot_delta_t *)(cur_mem + FD_SLOT_DELTA_FOOTPRINT * i) );
      fd_slot_delta_decode_inner_global( cur_mem + FD_SLOT_DELTA_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->slot_deltas_gaddr = 0UL;
}
int fd_bank_slot_deltas_convert_global_to_local( void const * global_self, fd_bank_slot_deltas_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_bank_slot_deltas_global_t const * mem = (fd_bank_slot_deltas_global_t const *)global_self;
  self->slot_deltas_len = mem->slot_deltas_len;
  self->slot_deltas     = fd_wksp_laddr_fast( ctx->wksp, mem->slot_deltas_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_bank_slot_deltas_new(fd_bank_slot_deltas_t * self) {
  fd_memset( self, 0, sizeof(fd_bank_slot_deltas_t) );
}
void fd_bank_slot_deltas_destroy( fd_bank_slot_deltas_t * self ) {
  if( self->slot_deltas ) {
    for( ulong i=0; i < self->slot_deltas_len; i++ )
      fd_slot_delta_destroy( self->slot_deltas + i );
    self->slot_deltas = NULL;
  }
}

ulong fd_bank_slot_deltas_footprint( void ){ return FD_BANK_SLOT_DELTAS_FOOTPRINT; }
ulong fd_bank_slot_deltas_align( void ){ return FD_BANK_SLOT_DELTAS_ALIGN; }

void fd_bank_slot_deltas_walk( void * w, fd_bank_slot_deltas_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_bank_slot_deltas", level++ );
  if( self->slot_deltas_len ) {
    fun( w, NULL, "slot_deltas", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->slot_deltas_len; i++ )
      fd_slot_delta_walk(w, self->slot_deltas + i, fun, "slot_delta", level );
    fun( w, NULL, "slot_deltas", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_bank_slot_deltas", level-- );
}
ulong fd_bank_slot_deltas_size( fd_bank_slot_deltas_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->slot_deltas_len; i++ )
      size += fd_slot_delta_size( self->slot_deltas + i );
  } while(0);
  return size;
}

int fd_pubkey_rewardinfo_pair_encode( fd_pubkey_rewardinfo_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_reward_info_encode( &self->reward_info, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_pubkey_rewardinfo_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_pubkey_rewardinfo_pair_t);
  void const * start_data = ctx->data;
  int err = fd_pubkey_rewardinfo_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_pubkey_rewardinfo_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_reward_info_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_pubkey_rewardinfo_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_rewardinfo_pair_t * self = (fd_pubkey_rewardinfo_pair_t *)mem;
  fd_pubkey_rewardinfo_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_rewardinfo_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_rewardinfo_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_rewardinfo_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_rewardinfo_pair_t * self = (fd_pubkey_rewardinfo_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->pubkey, alloc_mem, ctx );
  fd_reward_info_decode_inner( &self->reward_info, alloc_mem, ctx );
}
void * fd_pubkey_rewardinfo_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_rewardinfo_pair_global_t * self = (fd_pubkey_rewardinfo_pair_global_t *)mem;
  fd_pubkey_rewardinfo_pair_new( (fd_pubkey_rewardinfo_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_pubkey_rewardinfo_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_pubkey_rewardinfo_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_pubkey_rewardinfo_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_pubkey_rewardinfo_pair_global_t * self = (fd_pubkey_rewardinfo_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->pubkey, alloc_mem, ctx );
  fd_reward_info_decode_inner_global( &self->reward_info, alloc_mem, ctx );
}
int fd_pubkey_rewardinfo_pair_convert_global_to_local( void const * global_self, fd_pubkey_rewardinfo_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_pubkey_rewardinfo_pair_global_t const * mem = (fd_pubkey_rewardinfo_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->pubkey, &self->pubkey, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_reward_info_convert_global_to_local( &mem->reward_info, &self->reward_info, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_pubkey_rewardinfo_pair_new(fd_pubkey_rewardinfo_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_pubkey_rewardinfo_pair_t) );
  fd_pubkey_new( &self->pubkey );
  fd_reward_info_new( &self->reward_info );
}
void fd_pubkey_rewardinfo_pair_destroy( fd_pubkey_rewardinfo_pair_t * self ) {
  fd_pubkey_destroy( &self->pubkey );
  fd_reward_info_destroy( &self->reward_info );
}

ulong fd_pubkey_rewardinfo_pair_footprint( void ){ return FD_PUBKEY_REWARDINFO_PAIR_FOOTPRINT; }
ulong fd_pubkey_rewardinfo_pair_align( void ){ return FD_PUBKEY_REWARDINFO_PAIR_ALIGN; }

void fd_pubkey_rewardinfo_pair_walk( void * w, fd_pubkey_rewardinfo_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_pubkey_rewardinfo_pair", level++ );
  fd_pubkey_walk( w, &self->pubkey, fun, "pubkey", level );
  fd_reward_info_walk( w, &self->reward_info, fun, "reward_info", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_pubkey_rewardinfo_pair", level-- );
}
ulong fd_pubkey_rewardinfo_pair_size( fd_pubkey_rewardinfo_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->pubkey );
  size += fd_reward_info_size( &self->reward_info );
  return size;
}

int fd_optional_account_encode( fd_optional_account_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->account != NULL ) {
    err = fd_bincode_bool_encode( 1, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    err = fd_solana_account_encode( self->account, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  } else {
    err = fd_bincode_bool_encode( 0, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_optional_account_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_optional_account_t);
  void const * start_data = ctx->data;
  int err = fd_optional_account_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_optional_account_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  {
    uchar o;
    err = fd_bincode_bool_decode( &o, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    if( o ) {
    *total_sz += FD_SOLANA_ACCOUNT_ALIGN + FD_SOLANA_ACCOUNT_FOOTPRINT;
      err = fd_solana_account_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  return 0;
}
void * fd_optional_account_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_optional_account_t * self = (fd_optional_account_t *)mem;
  fd_optional_account_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_optional_account_t);
  void * * alloc_mem = &alloc_region;
  fd_optional_account_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_optional_account_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_optional_account_t * self = (fd_optional_account_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_SOLANA_ACCOUNT_ALIGN );
      self->account = *alloc_mem;
      *alloc_mem = (uchar *)*alloc_mem + FD_SOLANA_ACCOUNT_FOOTPRINT;
      fd_solana_account_new( self->account );
      fd_solana_account_decode_inner( self->account, alloc_mem, ctx );
    } else {
      self->account = NULL;
    }
  }
}
void * fd_optional_account_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_optional_account_global_t * self = (fd_optional_account_global_t *)mem;
  fd_optional_account_new( (fd_optional_account_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_optional_account_global_t);
  void * * alloc_mem = &alloc_region;
  fd_optional_account_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_optional_account_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_optional_account_global_t * self = (fd_optional_account_global_t *)struct_mem;
  {
    uchar o;
    fd_bincode_bool_decode_unsafe( &o, ctx );
    if( o ) {
      *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, FD_SOLANA_ACCOUNT_ALIGN );
      self->account_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
      fd_solana_account_new( *alloc_mem );
      *alloc_mem = (uchar *)*alloc_mem + FD_SOLANA_ACCOUNT_FOOTPRINT;
      fd_solana_account_decode_inner_global( fd_wksp_laddr_fast( ctx->wksp, self->account_gaddr ), alloc_mem, ctx );
    } else {
      self->account_gaddr = 0UL;
    }
  }
}
int fd_optional_account_convert_global_to_local( void const * global_self, fd_optional_account_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_optional_account_global_t const * mem = (fd_optional_account_global_t const *)global_self;
  self->account = fd_wksp_laddr_fast( ctx->wksp, mem->account_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_optional_account_new(fd_optional_account_t * self) {
  fd_memset( self, 0, sizeof(fd_optional_account_t) );
}
void fd_optional_account_destroy( fd_optional_account_t * self ) {
  if( self->account ) {
    fd_solana_account_destroy( self->account );
    self->account = NULL;
  }
}

ulong fd_optional_account_footprint( void ){ return FD_OPTIONAL_ACCOUNT_FOOTPRINT; }
ulong fd_optional_account_align( void ){ return FD_OPTIONAL_ACCOUNT_ALIGN; }

void fd_optional_account_walk( void * w, fd_optional_account_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_optional_account", level++ );
  if( !self->account ) {
    fun( w, NULL, "account", FD_FLAMENCO_TYPE_NULL, "solana_account", level );
  } else {
    fd_solana_account_walk( w, self->account, fun, "account", level );
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_optional_account", level-- );
}
ulong fd_optional_account_size( fd_optional_account_t const * self ) {
  ulong size = 0;
  size += sizeof(char);
  if( NULL !=  self->account ) {
    size += fd_solana_account_size( self->account );
  }
  return size;
}

int fd_calculated_stake_points_encode( fd_calculated_stake_points_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint128_encode( self->points, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->new_credits_observed, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint8_encode( (uchar)(self->force_credits_update_with_skipped_reward), ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_calculated_stake_points_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_calculated_stake_points_t);
  void const * start_data = ctx->data;
  int err = fd_calculated_stake_points_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_calculated_stake_points_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint128_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint8_decode_footprint( ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_calculated_stake_points_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_points_t * self = (fd_calculated_stake_points_t *)mem;
  fd_calculated_stake_points_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_calculated_stake_points_t);
  void * * alloc_mem = &alloc_region;
  fd_calculated_stake_points_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_calculated_stake_points_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_points_t * self = (fd_calculated_stake_points_t *)struct_mem;
  fd_bincode_uint128_decode_unsafe( &self->points, ctx );
  fd_bincode_uint64_decode_unsafe( &self->new_credits_observed, ctx );
  fd_bincode_uint8_decode_unsafe( &self->force_credits_update_with_skipped_reward, ctx );
}
void * fd_calculated_stake_points_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_points_global_t * self = (fd_calculated_stake_points_global_t *)mem;
  fd_calculated_stake_points_new( (fd_calculated_stake_points_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_calculated_stake_points_global_t);
  void * * alloc_mem = &alloc_region;
  fd_calculated_stake_points_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_calculated_stake_points_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_points_global_t * self = (fd_calculated_stake_points_global_t *)struct_mem;
  fd_bincode_uint128_decode_unsafe( &self->points, ctx );
  fd_bincode_uint64_decode_unsafe( &self->new_credits_observed, ctx );
  fd_bincode_uint8_decode_unsafe( &self->force_credits_update_with_skipped_reward, ctx );
}
int fd_calculated_stake_points_convert_global_to_local( void const * global_self, fd_calculated_stake_points_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_calculated_stake_points_global_t const * mem = (fd_calculated_stake_points_global_t const *)global_self;
  self->points = mem->points;
  self->new_credits_observed = mem->new_credits_observed;
  self->force_credits_update_with_skipped_reward = mem->force_credits_update_with_skipped_reward;
  return FD_BINCODE_SUCCESS;
}
void fd_calculated_stake_points_new(fd_calculated_stake_points_t * self) {
  fd_memset( self, 0, sizeof(fd_calculated_stake_points_t) );
}
void fd_calculated_stake_points_destroy( fd_calculated_stake_points_t * self ) {
}

ulong fd_calculated_stake_points_footprint( void ){ return FD_CALCULATED_STAKE_POINTS_FOOTPRINT; }
ulong fd_calculated_stake_points_align( void ){ return FD_CALCULATED_STAKE_POINTS_ALIGN; }

void fd_calculated_stake_points_walk( void * w, fd_calculated_stake_points_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_calculated_stake_points", level++ );
  fun( w, &self->points, "points", FD_FLAMENCO_TYPE_UINT128, "uint128", level );
  fun( w, &self->new_credits_observed, "new_credits_observed", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->force_credits_update_with_skipped_reward, "force_credits_update_with_skipped_reward", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_calculated_stake_points", level-- );
}
ulong fd_calculated_stake_points_size( fd_calculated_stake_points_t const * self ) {
  ulong size = 0;
  size += sizeof(uint128);
  size += sizeof(ulong);
  size += sizeof(char);
  return size;
}

int fd_calculated_stake_rewards_encode( fd_calculated_stake_rewards_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->staker_rewards, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->voter_rewards, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->new_credits_observed, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_calculated_stake_rewards_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_calculated_stake_rewards_t);
  void const * start_data = ctx->data;
  int err = fd_calculated_stake_rewards_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_calculated_stake_rewards_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_calculated_stake_rewards_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_rewards_t * self = (fd_calculated_stake_rewards_t *)mem;
  fd_calculated_stake_rewards_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_calculated_stake_rewards_t);
  void * * alloc_mem = &alloc_region;
  fd_calculated_stake_rewards_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_calculated_stake_rewards_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_rewards_t * self = (fd_calculated_stake_rewards_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->staker_rewards, ctx );
  fd_bincode_uint64_decode_unsafe( &self->voter_rewards, ctx );
  fd_bincode_uint64_decode_unsafe( &self->new_credits_observed, ctx );
}
void * fd_calculated_stake_rewards_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_rewards_global_t * self = (fd_calculated_stake_rewards_global_t *)mem;
  fd_calculated_stake_rewards_new( (fd_calculated_stake_rewards_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_calculated_stake_rewards_global_t);
  void * * alloc_mem = &alloc_region;
  fd_calculated_stake_rewards_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_calculated_stake_rewards_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_calculated_stake_rewards_global_t * self = (fd_calculated_stake_rewards_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->staker_rewards, ctx );
  fd_bincode_uint64_decode_unsafe( &self->voter_rewards, ctx );
  fd_bincode_uint64_decode_unsafe( &self->new_credits_observed, ctx );
}
int fd_calculated_stake_rewards_convert_global_to_local( void const * global_self, fd_calculated_stake_rewards_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_calculated_stake_rewards_global_t const * mem = (fd_calculated_stake_rewards_global_t const *)global_self;
  self->staker_rewards = mem->staker_rewards;
  self->voter_rewards = mem->voter_rewards;
  self->new_credits_observed = mem->new_credits_observed;
  return FD_BINCODE_SUCCESS;
}
void fd_calculated_stake_rewards_new(fd_calculated_stake_rewards_t * self) {
  fd_memset( self, 0, sizeof(fd_calculated_stake_rewards_t) );
}
void fd_calculated_stake_rewards_destroy( fd_calculated_stake_rewards_t * self ) {
}

ulong fd_calculated_stake_rewards_footprint( void ){ return FD_CALCULATED_STAKE_REWARDS_FOOTPRINT; }
ulong fd_calculated_stake_rewards_align( void ){ return FD_CALCULATED_STAKE_REWARDS_ALIGN; }

void fd_calculated_stake_rewards_walk( void * w, fd_calculated_stake_rewards_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_calculated_stake_rewards", level++ );
  fun( w, &self->staker_rewards, "staker_rewards", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->voter_rewards, "voter_rewards", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->new_credits_observed, "new_credits_observed", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_calculated_stake_rewards", level-- );
}
ulong fd_calculated_stake_rewards_size( fd_calculated_stake_rewards_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

int fd_duplicate_slot_proof_encode( fd_duplicate_slot_proof_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->shred1_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->shred1_len ) {
    err = fd_bincode_bytes_encode( self->shred1, self->shred1_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->shred2_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->shred2_len ) {
    err = fd_bincode_bytes_encode( self->shred2, self->shred2_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_duplicate_slot_proof_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_duplicate_slot_proof_t);
  void const * start_data = ctx->data;
  int err = fd_duplicate_slot_proof_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_duplicate_slot_proof_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong shred1_len;
  err = fd_bincode_uint64_decode( &shred1_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( shred1_len ) {
    *total_sz += 8UL + shred1_len;
    err = fd_bincode_bytes_decode_footprint( shred1_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  ulong shred2_len;
  err = fd_bincode_uint64_decode( &shred2_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( shred2_len ) {
    *total_sz += 8UL + shred2_len;
    err = fd_bincode_bytes_decode_footprint( shred2_len, ctx );
    if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  }
  return 0;
}
void * fd_duplicate_slot_proof_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_duplicate_slot_proof_t * self = (fd_duplicate_slot_proof_t *)mem;
  fd_duplicate_slot_proof_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_duplicate_slot_proof_t);
  void * * alloc_mem = &alloc_region;
  fd_duplicate_slot_proof_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_duplicate_slot_proof_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_duplicate_slot_proof_t * self = (fd_duplicate_slot_proof_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->shred1_len, ctx );
  if( self->shred1_len ) {
    self->shred1 = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->shred1, self->shred1_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->shred1_len;
  } else
    self->shred1 = NULL;
  fd_bincode_uint64_decode_unsafe( &self->shred2_len, ctx );
  if( self->shred2_len ) {
    self->shred2 = *alloc_mem;
    fd_bincode_bytes_decode_unsafe( self->shred2, self->shred2_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->shred2_len;
  } else
    self->shred2 = NULL;
}
void * fd_duplicate_slot_proof_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_duplicate_slot_proof_global_t * self = (fd_duplicate_slot_proof_global_t *)mem;
  fd_duplicate_slot_proof_new( (fd_duplicate_slot_proof_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_duplicate_slot_proof_global_t);
  void * * alloc_mem = &alloc_region;
  fd_duplicate_slot_proof_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_duplicate_slot_proof_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_duplicate_slot_proof_global_t * self = (fd_duplicate_slot_proof_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->shred1_len, ctx );
  if( self->shred1_len ) {
    self->shred1_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->shred1_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->shred1_len;
  } else
    self->shred1_gaddr = 0UL;
  fd_bincode_uint64_decode_unsafe( &self->shred2_len, ctx );
  if( self->shred2_len ) {
    self->shred2_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    fd_bincode_bytes_decode_unsafe( *alloc_mem, self->shred2_len, ctx );
    *alloc_mem = (uchar *)(*alloc_mem) + self->shred2_len;
  } else
    self->shred2_gaddr = 0UL;
}
int fd_duplicate_slot_proof_convert_global_to_local( void const * global_self, fd_duplicate_slot_proof_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_duplicate_slot_proof_global_t const * mem = (fd_duplicate_slot_proof_global_t const *)global_self;
  self->shred1_len = mem->shred1_len;
  self->shred1     = fd_wksp_laddr_fast( ctx->wksp, mem->shred1_gaddr );
  self->shred2_len = mem->shred2_len;
  self->shred2     = fd_wksp_laddr_fast( ctx->wksp, mem->shred2_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_duplicate_slot_proof_new(fd_duplicate_slot_proof_t * self) {
  fd_memset( self, 0, sizeof(fd_duplicate_slot_proof_t) );
}
void fd_duplicate_slot_proof_destroy( fd_duplicate_slot_proof_t * self ) {
  if( self->shred1 ) {
    self->shred1 = NULL;
  }
  if( self->shred2 ) {
    self->shred2 = NULL;
  }
}

ulong fd_duplicate_slot_proof_footprint( void ){ return FD_DUPLICATE_SLOT_PROOF_FOOTPRINT; }
ulong fd_duplicate_slot_proof_align( void ){ return FD_DUPLICATE_SLOT_PROOF_ALIGN; }

void fd_duplicate_slot_proof_walk( void * w, fd_duplicate_slot_proof_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_duplicate_slot_proof", level++ );
  fun(w, self->shred1, "shred1", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun(w, self->shred2, "shred2", FD_FLAMENCO_TYPE_UCHAR, "uchar", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_duplicate_slot_proof", level-- );
}
ulong fd_duplicate_slot_proof_size( fd_duplicate_slot_proof_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    size += self->shred1_len;
  } while(0);
  do {
    size += sizeof(ulong);
    size += self->shred2_len;
  } while(0);
  return size;
}

int fd_epoch_info_pair_encode( fd_epoch_info_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_encode( &self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_epoch_info_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_epoch_info_pair_t);
  void const * start_data = ctx->data;
  int err = fd_epoch_info_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_epoch_info_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_epoch_info_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_pair_t * self = (fd_epoch_info_pair_t *)mem;
  fd_epoch_info_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_info_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_info_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_info_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_pair_t * self = (fd_epoch_info_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->account, alloc_mem, ctx );
  fd_stake_decode_inner( &self->stake, alloc_mem, ctx );
}
void * fd_epoch_info_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_pair_global_t * self = (fd_epoch_info_pair_global_t *)mem;
  fd_epoch_info_pair_new( (fd_epoch_info_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_info_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_info_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_info_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_pair_global_t * self = (fd_epoch_info_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->account, alloc_mem, ctx );
  fd_stake_decode_inner_global( &self->stake, alloc_mem, ctx );
}
int fd_epoch_info_pair_convert_global_to_local( void const * global_self, fd_epoch_info_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_epoch_info_pair_global_t const * mem = (fd_epoch_info_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->account, &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_stake_convert_global_to_local( &mem->stake, &self->stake, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_epoch_info_pair_new(fd_epoch_info_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_epoch_info_pair_t) );
  fd_pubkey_new( &self->account );
  fd_stake_new( &self->stake );
}
void fd_epoch_info_pair_destroy( fd_epoch_info_pair_t * self ) {
  fd_pubkey_destroy( &self->account );
  fd_stake_destroy( &self->stake );
}

ulong fd_epoch_info_pair_footprint( void ){ return FD_EPOCH_INFO_PAIR_FOOTPRINT; }
ulong fd_epoch_info_pair_align( void ){ return FD_EPOCH_INFO_PAIR_ALIGN; }

void fd_epoch_info_pair_walk( void * w, fd_epoch_info_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_epoch_info_pair", level++ );
  fd_pubkey_walk( w, &self->account, fun, "account", level );
  fd_stake_walk( w, &self->stake, fun, "stake", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_epoch_info_pair", level-- );
}
ulong fd_epoch_info_pair_size( fd_epoch_info_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->account );
  size += fd_stake_size( &self->stake );
  return size;
}

int fd_vote_info_pair_encode( fd_vote_info_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_state_versioned_encode( &self->state, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_vote_info_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_vote_info_pair_t);
  void const * start_data = ctx->data;
  int err = fd_vote_info_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_vote_info_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_state_versioned_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  return 0;
}
void * fd_vote_info_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_info_pair_t * self = (fd_vote_info_pair_t *)mem;
  fd_vote_info_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_info_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_info_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_info_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_info_pair_t * self = (fd_vote_info_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->account, alloc_mem, ctx );
  fd_vote_state_versioned_decode_inner( &self->state, alloc_mem, ctx );
}
void * fd_vote_info_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_info_pair_global_t * self = (fd_vote_info_pair_global_t *)mem;
  fd_vote_info_pair_new( (fd_vote_info_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_vote_info_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_vote_info_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_vote_info_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_vote_info_pair_global_t * self = (fd_vote_info_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->account, alloc_mem, ctx );
  fd_vote_state_versioned_decode_inner_global( &self->state, alloc_mem, ctx );
}
int fd_vote_info_pair_convert_global_to_local( void const * global_self, fd_vote_info_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_vote_info_pair_global_t const * mem = (fd_vote_info_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->account, &self->account, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_vote_state_versioned_convert_global_to_local( &mem->state, &self->state, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
void fd_vote_info_pair_new(fd_vote_info_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_vote_info_pair_t) );
  fd_pubkey_new( &self->account );
  fd_vote_state_versioned_new( &self->state );
}
void fd_vote_info_pair_destroy( fd_vote_info_pair_t * self ) {
  fd_pubkey_destroy( &self->account );
  fd_vote_state_versioned_destroy( &self->state );
}

ulong fd_vote_info_pair_footprint( void ){ return FD_VOTE_INFO_PAIR_FOOTPRINT; }
ulong fd_vote_info_pair_align( void ){ return FD_VOTE_INFO_PAIR_ALIGN; }

void fd_vote_info_pair_walk( void * w, fd_vote_info_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_vote_info_pair", level++ );
  fd_pubkey_walk( w, &self->account, fun, "account", level );
  fd_vote_state_versioned_walk( w, &self->state, fun, "state", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_vote_info_pair", level-- );
}
ulong fd_vote_info_pair_size( fd_vote_info_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->account );
  size += fd_vote_state_versioned_size( &self->state );
  return size;
}

int fd_epoch_info_encode( fd_epoch_info_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->stake_infos_len, ctx );
  if( FD_UNLIKELY(err) ) return err;
  if( self->stake_infos_len ) {
    for( ulong i=0; i < self->stake_infos_len; i++ ) {
      err = fd_epoch_info_pair_encode( self->stake_infos + i, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  }
  if( self->vote_states_root ) {
    ulong vote_states_len = fd_vote_info_pair_t_map_size( self->vote_states_pool, self->vote_states_root );
    err = fd_bincode_uint64_encode( vote_states_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_vote_info_pair_t_mapnode_t * n = fd_vote_info_pair_t_map_minimum( self->vote_states_pool, self->vote_states_root ); n; n = fd_vote_info_pair_t_map_successor( self->vote_states_pool, n ) ) {
      err = fd_vote_info_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong vote_states_len = 0;
    err = fd_bincode_uint64_encode( vote_states_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_encode( self->stake_infos_new_keys_start_idx, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_epoch_info_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_epoch_info_t);
  void const * start_data = ctx->data;
  int err = fd_epoch_info_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_epoch_info_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong stake_infos_len;
  err = fd_bincode_uint64_decode( &stake_infos_len, ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  if( stake_infos_len ) {
    *total_sz += FD_EPOCH_INFO_PAIR_ALIGN + FD_EPOCH_INFO_PAIR_FOOTPRINT*stake_infos_len;
    for( ulong i=0; i < stake_infos_len; i++ ) {
      err = fd_epoch_info_pair_decode_footprint_inner( ctx, total_sz );
      if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
    }
  }
  ulong vote_states_len = 0UL;
  err = fd_bincode_uint64_decode( &vote_states_len, ctx );
  ulong vote_states_cnt = vote_states_len;
  *total_sz += fd_vote_info_pair_t_map_align() + fd_vote_info_pair_t_map_footprint( vote_states_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < vote_states_len; i++ ) {
    err = fd_vote_info_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_epoch_info_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_t * self = (fd_epoch_info_t *)mem;
  fd_epoch_info_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_info_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_info_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_info_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_t * self = (fd_epoch_info_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->stake_infos_len, ctx );
  if( self->stake_infos_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_EPOCH_INFO_PAIR_ALIGN );
    self->stake_infos = *alloc_mem;
    *alloc_mem = (uchar *)(*alloc_mem) + FD_EPOCH_INFO_PAIR_FOOTPRINT*self->stake_infos_len;
    for( ulong i=0; i < self->stake_infos_len; i++ ) {
      fd_epoch_info_pair_new( self->stake_infos + i );
      fd_epoch_info_pair_decode_inner( self->stake_infos + i, alloc_mem, ctx );
    }
  } else
    self->stake_infos = NULL;
  ulong vote_states_len;
  fd_bincode_uint64_decode_unsafe( &vote_states_len, ctx );
  self->vote_states_pool = fd_vote_info_pair_t_map_join_new( alloc_mem, vote_states_len );
  self->vote_states_root = NULL;
  for( ulong i=0; i < vote_states_len; i++ ) {
    fd_vote_info_pair_t_mapnode_t * node = fd_vote_info_pair_t_map_acquire( self->vote_states_pool );
    fd_vote_info_pair_new( &node->elem );
    fd_vote_info_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_vote_info_pair_t_map_insert( self->vote_states_pool, &self->vote_states_root, node );
  }
  fd_bincode_uint64_decode_unsafe( &self->stake_infos_new_keys_start_idx, ctx );
}
void * fd_epoch_info_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_global_t * self = (fd_epoch_info_global_t *)mem;
  fd_epoch_info_new( (fd_epoch_info_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_epoch_info_global_t);
  void * * alloc_mem = &alloc_region;
  fd_epoch_info_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_epoch_info_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_epoch_info_global_t * self = (fd_epoch_info_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->stake_infos_len, ctx );
  if( self->stake_infos_len ) {
    *alloc_mem = (void*)fd_ulong_align_up( (ulong)(*alloc_mem), FD_EPOCH_INFO_PAIR_ALIGN );
    self->stake_infos_gaddr = fd_wksp_gaddr_fast( ctx->wksp, *alloc_mem );
    uchar * cur_mem = (uchar *)(*alloc_mem);
    *alloc_mem = (uchar *)(*alloc_mem) + FD_EPOCH_INFO_PAIR_FOOTPRINT*self->stake_infos_len;
    for( ulong i=0; i < self->stake_infos_len; i++ ) {
      fd_epoch_info_pair_new( (fd_epoch_info_pair_t *)(cur_mem + FD_EPOCH_INFO_PAIR_FOOTPRINT * i) );
      fd_epoch_info_pair_decode_inner_global( cur_mem + FD_EPOCH_INFO_PAIR_FOOTPRINT * i, alloc_mem, ctx );
    }
  } else
    self->stake_infos_gaddr = 0UL;
  ulong vote_states_len;
  fd_bincode_uint64_decode_unsafe( &vote_states_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_vote_info_pair_t_map_align() );
  fd_vote_info_pair_t_mapnode_t * vote_states_pool = fd_vote_info_pair_t_map_join_new( alloc_mem, vote_states_len );
  fd_vote_info_pair_t_mapnode_t * vote_states_root = NULL;
  self->vote_states_root_gaddr = 0UL;
  for( ulong i=0; i < vote_states_len; i++ ) {
    fd_vote_info_pair_t_mapnode_t * node = fd_vote_info_pair_t_map_acquire( vote_states_pool );
    fd_vote_info_pair_new( &node->elem );
    fd_vote_info_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_vote_info_pair_t_map_insert( vote_states_pool, &vote_states_root, node );
  }
  self->vote_states_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, vote_states_pool );
  self->vote_states_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, vote_states_root );
  fd_bincode_uint64_decode_unsafe( &self->stake_infos_new_keys_start_idx, ctx );
}
int fd_epoch_info_convert_global_to_local( void const * global_self, fd_epoch_info_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_epoch_info_global_t const * mem = (fd_epoch_info_global_t const *)global_self;
  self->stake_infos_len = mem->stake_infos_len;
  self->stake_infos     = fd_wksp_laddr_fast( ctx->wksp, mem->stake_infos_gaddr );
  self->vote_states_pool = fd_wksp_laddr_fast( ctx->wksp, mem->vote_states_pool_gaddr );
  self->vote_states_root = fd_wksp_laddr_fast( ctx->wksp, mem->vote_states_root_gaddr );
  self->stake_infos_new_keys_start_idx = mem->stake_infos_new_keys_start_idx;
  return FD_BINCODE_SUCCESS;
}
void fd_epoch_info_new(fd_epoch_info_t * self) {
  fd_memset( self, 0, sizeof(fd_epoch_info_t) );
}
void fd_epoch_info_destroy( fd_epoch_info_t * self ) {
  if( self->stake_infos ) {
    for( ulong i=0; i < self->stake_infos_len; i++ )
      fd_epoch_info_pair_destroy( self->stake_infos + i );
    self->stake_infos = NULL;
  }
  for( fd_vote_info_pair_t_mapnode_t * n = fd_vote_info_pair_t_map_minimum(self->vote_states_pool, self->vote_states_root ); n; n = fd_vote_info_pair_t_map_successor(self->vote_states_pool, n) ) {
    fd_vote_info_pair_destroy( &n->elem );
  }
  self->vote_states_pool = NULL;
  self->vote_states_root = NULL;
}

ulong fd_epoch_info_footprint( void ){ return FD_EPOCH_INFO_FOOTPRINT; }
ulong fd_epoch_info_align( void ){ return FD_EPOCH_INFO_ALIGN; }

void fd_epoch_info_walk( void * w, fd_epoch_info_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_epoch_info", level++ );
  if( self->stake_infos_len ) {
    fun( w, NULL, "stake_infos", FD_FLAMENCO_TYPE_ARR, "array", level++ );
    for( ulong i=0; i < self->stake_infos_len; i++ )
      fd_epoch_info_pair_walk(w, self->stake_infos + i, fun, "epoch_info_pair", level );
    fun( w, NULL, "stake_infos", FD_FLAMENCO_TYPE_ARR_END, "array", level-- );
  }
  if( self->vote_states_root ) {
    for( fd_vote_info_pair_t_mapnode_t * n = fd_vote_info_pair_t_map_minimum(self->vote_states_pool, self->vote_states_root ); n; n = fd_vote_info_pair_t_map_successor( self->vote_states_pool, n ) ) {
      fd_vote_info_pair_walk(w, &n->elem, fun, "vote_states", level );
    }
  }
  fun( w, &self->stake_infos_new_keys_start_idx, "stake_infos_new_keys_start_idx", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_epoch_info", level-- );
}
ulong fd_epoch_info_size( fd_epoch_info_t const * self ) {
  ulong size = 0;
  do {
    size += sizeof(ulong);
    for( ulong i=0; i < self->stake_infos_len; i++ )
      size += fd_epoch_info_pair_size( self->stake_infos + i );
  } while(0);
  if( self->vote_states_root ) {
    size += sizeof(ulong);
    for( fd_vote_info_pair_t_mapnode_t * n = fd_vote_info_pair_t_map_minimum( self->vote_states_pool, self->vote_states_root ); n; n = fd_vote_info_pair_t_map_successor( self->vote_states_pool, n ) ) {
      size += fd_vote_info_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  size += sizeof(ulong);
  return size;
}

int fd_usage_cost_details_encode( fd_usage_cost_details_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->signature_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->write_lock_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->data_bytes_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->programs_execution_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->loaded_accounts_data_size_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->allocated_accounts_data_size, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_usage_cost_details_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_usage_cost_details_t);
  void const * start_data = ctx->data;
  int err = fd_usage_cost_details_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_usage_cost_details_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_usage_cost_details_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_usage_cost_details_t * self = (fd_usage_cost_details_t *)mem;
  fd_usage_cost_details_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_usage_cost_details_t);
  void * * alloc_mem = &alloc_region;
  fd_usage_cost_details_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_usage_cost_details_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_usage_cost_details_t * self = (fd_usage_cost_details_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->signature_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->write_lock_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->data_bytes_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->programs_execution_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->loaded_accounts_data_size_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->allocated_accounts_data_size, ctx );
}
void * fd_usage_cost_details_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_usage_cost_details_global_t * self = (fd_usage_cost_details_global_t *)mem;
  fd_usage_cost_details_new( (fd_usage_cost_details_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_usage_cost_details_global_t);
  void * * alloc_mem = &alloc_region;
  fd_usage_cost_details_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_usage_cost_details_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_usage_cost_details_global_t * self = (fd_usage_cost_details_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->signature_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->write_lock_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->data_bytes_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->programs_execution_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->loaded_accounts_data_size_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->allocated_accounts_data_size, ctx );
}
int fd_usage_cost_details_convert_global_to_local( void const * global_self, fd_usage_cost_details_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_usage_cost_details_global_t const * mem = (fd_usage_cost_details_global_t const *)global_self;
  self->signature_cost = mem->signature_cost;
  self->write_lock_cost = mem->write_lock_cost;
  self->data_bytes_cost = mem->data_bytes_cost;
  self->programs_execution_cost = mem->programs_execution_cost;
  self->loaded_accounts_data_size_cost = mem->loaded_accounts_data_size_cost;
  self->allocated_accounts_data_size = mem->allocated_accounts_data_size;
  return FD_BINCODE_SUCCESS;
}
void fd_usage_cost_details_new(fd_usage_cost_details_t * self) {
  fd_memset( self, 0, sizeof(fd_usage_cost_details_t) );
}
void fd_usage_cost_details_destroy( fd_usage_cost_details_t * self ) {
}

ulong fd_usage_cost_details_footprint( void ){ return FD_USAGE_COST_DETAILS_FOOTPRINT; }
ulong fd_usage_cost_details_align( void ){ return FD_USAGE_COST_DETAILS_ALIGN; }

void fd_usage_cost_details_walk( void * w, fd_usage_cost_details_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_usage_cost_details", level++ );
  fun( w, &self->signature_cost, "signature_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->write_lock_cost, "write_lock_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->data_bytes_cost, "data_bytes_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->programs_execution_cost, "programs_execution_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->loaded_accounts_data_size_cost, "loaded_accounts_data_size_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->allocated_accounts_data_size, "allocated_accounts_data_size", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_usage_cost_details", level-- );
}
ulong fd_usage_cost_details_size( fd_usage_cost_details_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

FD_FN_PURE uchar fd_transaction_cost_is_simple_vote(fd_transaction_cost_t const * self) {
  return self->discriminant == 0;
}
FD_FN_PURE uchar fd_transaction_cost_is_transaction(fd_transaction_cost_t const * self) {
  return self->discriminant == 1;
}
void fd_transaction_cost_inner_new( fd_transaction_cost_inner_t * self, uint discriminant );
int fd_transaction_cost_inner_decode_footprint( uint discriminant, fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  int err;
  switch (discriminant) {
  case 0: {
    return FD_BINCODE_SUCCESS;
  }
  case 1: {
    err = fd_usage_cost_details_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
    return FD_BINCODE_SUCCESS;
  }
  default: return FD_BINCODE_ERR_ENCODING;
  }
}
int fd_transaction_cost_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_transaction_cost_t);
  void const * start_data = ctx->data;
  int err =  fd_transaction_cost_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_transaction_cost_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  uint discriminant = 0;
  int err = fd_bincode_uint32_decode( &discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_transaction_cost_inner_decode_footprint( discriminant, ctx, total_sz );
}
void fd_transaction_cost_inner_decode_inner( fd_transaction_cost_inner_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_usage_cost_details_decode_inner( &self->transaction, alloc_mem, ctx );
    break;
  }
  }
}
void fd_transaction_cost_inner_decode_inner_global( fd_transaction_cost_inner_global_t * self, void * * alloc_mem, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  switch (discriminant) {
  case 0: {
    break;
  }
  case 1: {
    fd_usage_cost_details_decode_inner_global( &self->transaction, alloc_mem, ctx );
    break;
  }
  }
}
int fd_transaction_cost_convert_global_to_local_inner( fd_transaction_cost_inner_global_t const * mem, fd_transaction_cost_inner_t * self, uint discriminant, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    err = fd_usage_cost_details_convert_global_to_local( &mem->transaction, &self->transaction, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_transaction_cost_convert_global_to_local( void const * global_self, fd_transaction_cost_t * self, fd_bincode_decode_ctx_t * ctx ) {
  fd_transaction_cost_global_t const * mem = (fd_transaction_cost_global_t const *)global_self;
  uint discriminant = mem->discriminant;
  self->discriminant = mem->discriminant;
  int err = fd_transaction_cost_convert_global_to_local_inner( &mem->inner, &self->inner, discriminant, ctx );
  return FD_BINCODE_SUCCESS;
}
void fd_transaction_cost_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_transaction_cost_t * self = (fd_transaction_cost_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_transaction_cost_inner_decode_inner( &self->inner, alloc_mem, self->discriminant, ctx );
}
void * fd_transaction_cost_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_transaction_cost_t * self = (fd_transaction_cost_t *)mem;
  fd_transaction_cost_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_transaction_cost_t);
  void * * alloc_mem = &alloc_region;
  fd_transaction_cost_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void * fd_transaction_cost_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_transaction_cost_t * self = (fd_transaction_cost_t *)mem;
  fd_transaction_cost_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_transaction_cost_t);
  void * * alloc_mem = &alloc_region;
  fd_transaction_cost_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_transaction_cost_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_transaction_cost_global_t * self = (fd_transaction_cost_global_t *)struct_mem;
  fd_bincode_uint32_decode_unsafe( &self->discriminant, ctx );
  fd_transaction_cost_inner_decode_inner_global( &self->inner, alloc_mem, self->discriminant, ctx );
}
void fd_transaction_cost_inner_new( fd_transaction_cost_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 0: {
    break;
  }
  case 1: {
    fd_usage_cost_details_new( &self->transaction );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type"));
  }
}
void fd_transaction_cost_new_disc( fd_transaction_cost_t * self, uint discriminant ) {
  self->discriminant = discriminant;
  fd_transaction_cost_inner_new( &self->inner, self->discriminant );
}
void fd_transaction_cost_new( fd_transaction_cost_t * self ) {
  fd_memset( self, 0, sizeof(fd_transaction_cost_t) );
  fd_transaction_cost_new_disc( self, UINT_MAX );
}
void fd_transaction_cost_inner_destroy( fd_transaction_cost_inner_t * self, uint discriminant ) {
  switch( discriminant ) {
  case 1: {
    fd_usage_cost_details_destroy( &self->transaction );
    break;
  }
  default: break; // FD_LOG_ERR(( "unhandled type" ));
  }
}
void fd_transaction_cost_destroy( fd_transaction_cost_t * self ) {
  fd_transaction_cost_inner_destroy( &self->inner, self->discriminant );
}

ulong fd_transaction_cost_footprint( void ){ return FD_TRANSACTION_COST_FOOTPRINT; }
ulong fd_transaction_cost_align( void ){ return FD_TRANSACTION_COST_ALIGN; }

void fd_transaction_cost_walk( void * w, fd_transaction_cost_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun(w, self, name, FD_FLAMENCO_TYPE_ENUM, "fd_transaction_cost", level++);
  switch( self->discriminant ) {
  case 0: {
    fun( w, self, "simple_vote", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    break;
  }
  case 1: {
    fun( w, self, "transaction", FD_FLAMENCO_TYPE_ENUM_DISC, "discriminant", level );
    fd_usage_cost_details_walk( w, &self->inner.transaction, fun, "transaction", level );
    break;
  }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_ENUM_END, "fd_transaction_cost", level-- );
}
ulong fd_transaction_cost_size( fd_transaction_cost_t const * self ) {
  ulong size = 0;
  size += sizeof(uint);
  switch (self->discriminant) {
  case 1: {
    size += fd_usage_cost_details_size( &self->inner.transaction );
    break;
  }
  }
  return size;
}

int fd_transaction_cost_inner_encode( fd_transaction_cost_inner_t const * self, uint discriminant, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  switch (discriminant) {
  case 1: {
    err = fd_usage_cost_details_encode( &self->transaction, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    break;
  }
  }
  return FD_BINCODE_SUCCESS;
}
int fd_transaction_cost_encode( fd_transaction_cost_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err = fd_bincode_uint32_encode( self->discriminant, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return fd_transaction_cost_inner_encode( &self->inner, self->discriminant, ctx );
}

int fd_account_costs_pair_encode( fd_account_costs_pair_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_pubkey_encode( &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_account_costs_pair_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_account_costs_pair_t);
  void const * start_data = ctx->data;
  int err = fd_account_costs_pair_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_account_costs_pair_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_pubkey_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_account_costs_pair_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_pair_t * self = (fd_account_costs_pair_t *)mem;
  fd_account_costs_pair_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_costs_pair_t);
  void * * alloc_mem = &alloc_region;
  fd_account_costs_pair_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_account_costs_pair_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_pair_t * self = (fd_account_costs_pair_t *)struct_mem;
  fd_pubkey_decode_inner( &self->key, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->cost, ctx );
}
void * fd_account_costs_pair_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_pair_global_t * self = (fd_account_costs_pair_global_t *)mem;
  fd_account_costs_pair_new( (fd_account_costs_pair_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_costs_pair_global_t);
  void * * alloc_mem = &alloc_region;
  fd_account_costs_pair_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_account_costs_pair_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_pair_global_t * self = (fd_account_costs_pair_global_t *)struct_mem;
  fd_pubkey_decode_inner_global( &self->key, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->cost, ctx );
}
int fd_account_costs_pair_convert_global_to_local( void const * global_self, fd_account_costs_pair_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_account_costs_pair_global_t const * mem = (fd_account_costs_pair_global_t const *)global_self;
  err = fd_pubkey_convert_global_to_local( &mem->key, &self->key, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->cost = mem->cost;
  return FD_BINCODE_SUCCESS;
}
void fd_account_costs_pair_new(fd_account_costs_pair_t * self) {
  fd_memset( self, 0, sizeof(fd_account_costs_pair_t) );
  fd_pubkey_new( &self->key );
}
void fd_account_costs_pair_destroy( fd_account_costs_pair_t * self ) {
  fd_pubkey_destroy( &self->key );
}

ulong fd_account_costs_pair_footprint( void ){ return FD_ACCOUNT_COSTS_PAIR_FOOTPRINT; }
ulong fd_account_costs_pair_align( void ){ return FD_ACCOUNT_COSTS_PAIR_ALIGN; }

void fd_account_costs_pair_walk( void * w, fd_account_costs_pair_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_account_costs_pair", level++ );
  fd_pubkey_walk( w, &self->key, fun, "key", level );
  fun( w, &self->cost, "cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_account_costs_pair", level-- );
}
ulong fd_account_costs_pair_size( fd_account_costs_pair_t const * self ) {
  ulong size = 0;
  size += fd_pubkey_size( &self->key );
  size += sizeof(ulong);
  return size;
}

int fd_account_costs_encode( fd_account_costs_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  if( self->account_costs_root ) {
    ulong account_costs_len = fd_account_costs_pair_t_map_size( self->account_costs_pool, self->account_costs_root );
    err = fd_bincode_uint64_encode( account_costs_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
    for( fd_account_costs_pair_t_mapnode_t * n = fd_account_costs_pair_t_map_minimum( self->account_costs_pool, self->account_costs_root ); n; n = fd_account_costs_pair_t_map_successor( self->account_costs_pool, n ) ) {
      err = fd_account_costs_pair_encode( &n->elem, ctx );
      if( FD_UNLIKELY( err ) ) return err;
    }
  } else {
    ulong account_costs_len = 0;
    err = fd_bincode_uint64_encode( account_costs_len, ctx );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return FD_BINCODE_SUCCESS;
}
int fd_account_costs_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_account_costs_t);
  void const * start_data = ctx->data;
  int err = fd_account_costs_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_account_costs_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  ulong account_costs_len = 0UL;
  err = fd_bincode_uint64_decode( &account_costs_len, ctx );
  ulong account_costs_cnt = fd_ulong_max( account_costs_len, 4096 );
  *total_sz += fd_account_costs_pair_t_map_align() + fd_account_costs_pair_t_map_footprint( account_costs_cnt );
  if( FD_UNLIKELY( err ) ) return err;
  for( ulong i=0; i < account_costs_len; i++ ) {
    err = fd_account_costs_pair_decode_footprint_inner( ctx, total_sz );
    if( FD_UNLIKELY( err ) ) return err;
  }
  return 0;
}
void * fd_account_costs_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_t * self = (fd_account_costs_t *)mem;
  fd_account_costs_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_costs_t);
  void * * alloc_mem = &alloc_region;
  fd_account_costs_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_account_costs_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_t * self = (fd_account_costs_t *)struct_mem;
  ulong account_costs_len;
  fd_bincode_uint64_decode_unsafe( &account_costs_len, ctx );
  self->account_costs_pool = fd_account_costs_pair_t_map_join_new( alloc_mem, fd_ulong_max( account_costs_len, 4096 ) );
  self->account_costs_root = NULL;
  for( ulong i=0; i < account_costs_len; i++ ) {
    fd_account_costs_pair_t_mapnode_t * node = fd_account_costs_pair_t_map_acquire( self->account_costs_pool );
    fd_account_costs_pair_new( &node->elem );
    fd_account_costs_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_account_costs_pair_t_map_insert( self->account_costs_pool, &self->account_costs_root, node );
  }
}
void * fd_account_costs_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_global_t * self = (fd_account_costs_global_t *)mem;
  fd_account_costs_new( (fd_account_costs_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_account_costs_global_t);
  void * * alloc_mem = &alloc_region;
  fd_account_costs_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_account_costs_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_account_costs_global_t * self = (fd_account_costs_global_t *)struct_mem;
  ulong account_costs_len;
  fd_bincode_uint64_decode_unsafe( &account_costs_len, ctx );
  *alloc_mem = (void*)fd_ulong_align_up( (ulong)*alloc_mem, fd_account_costs_pair_t_map_align() );
  fd_account_costs_pair_t_mapnode_t * account_costs_pool = fd_account_costs_pair_t_map_join_new( alloc_mem, fd_ulong_max( account_costs_len, 4096 ) );
  fd_account_costs_pair_t_mapnode_t * account_costs_root = NULL;
  self->account_costs_root_gaddr = 0UL;
  for( ulong i=0; i < account_costs_len; i++ ) {
    fd_account_costs_pair_t_mapnode_t * node = fd_account_costs_pair_t_map_acquire( account_costs_pool );
    fd_account_costs_pair_new( &node->elem );
    fd_account_costs_pair_decode_inner( &node->elem, alloc_mem, ctx );
    fd_account_costs_pair_t_map_insert( account_costs_pool, &account_costs_root, node );
  }
  self->account_costs_pool_gaddr = fd_wksp_gaddr_fast( ctx->wksp, account_costs_pool );
  self->account_costs_root_gaddr = fd_wksp_gaddr_fast( ctx->wksp, account_costs_root );
}
int fd_account_costs_convert_global_to_local( void const * global_self, fd_account_costs_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_account_costs_global_t const * mem = (fd_account_costs_global_t const *)global_self;
  self->account_costs_pool = fd_wksp_laddr_fast( ctx->wksp, mem->account_costs_pool_gaddr );
  self->account_costs_root = fd_wksp_laddr_fast( ctx->wksp, mem->account_costs_root_gaddr );
  return FD_BINCODE_SUCCESS;
}
void fd_account_costs_new(fd_account_costs_t * self) {
  fd_memset( self, 0, sizeof(fd_account_costs_t) );
}
void fd_account_costs_destroy( fd_account_costs_t * self ) {
  for( fd_account_costs_pair_t_mapnode_t * n = fd_account_costs_pair_t_map_minimum(self->account_costs_pool, self->account_costs_root ); n; n = fd_account_costs_pair_t_map_successor(self->account_costs_pool, n) ) {
    fd_account_costs_pair_destroy( &n->elem );
  }
  self->account_costs_pool = NULL;
  self->account_costs_root = NULL;
}

ulong fd_account_costs_footprint( void ){ return FD_ACCOUNT_COSTS_FOOTPRINT; }
ulong fd_account_costs_align( void ){ return FD_ACCOUNT_COSTS_ALIGN; }

void fd_account_costs_walk( void * w, fd_account_costs_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_account_costs", level++ );
  if( self->account_costs_root ) {
    for( fd_account_costs_pair_t_mapnode_t * n = fd_account_costs_pair_t_map_minimum(self->account_costs_pool, self->account_costs_root ); n; n = fd_account_costs_pair_t_map_successor( self->account_costs_pool, n ) ) {
      fd_account_costs_pair_walk(w, &n->elem, fun, "account_costs", level );
    }
  }
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_account_costs", level-- );
}
ulong fd_account_costs_size( fd_account_costs_t const * self ) {
  ulong size = 0;
  if( self->account_costs_root ) {
    size += sizeof(ulong);
    for( fd_account_costs_pair_t_mapnode_t * n = fd_account_costs_pair_t_map_minimum( self->account_costs_pool, self->account_costs_root ); n; n = fd_account_costs_pair_t_map_successor( self->account_costs_pool, n ) ) {
      size += fd_account_costs_pair_size( &n->elem );
    }
  } else {
    size += sizeof(ulong);
  }
  return size;
}

int fd_cost_tracker_encode( fd_cost_tracker_t const * self, fd_bincode_encode_ctx_t * ctx ) {
  int err;
  err = fd_bincode_uint64_encode( self->account_cost_limit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->block_cost_limit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->vote_cost_limit, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_account_costs_encode( &self->cost_by_writable_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->block_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->vote_cost, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->transaction_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->allocated_accounts_data_size, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->transaction_signature_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->secp256k1_instruction_signature_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->ed25519_instruction_signature_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_encode( self->secp256r1_instruction_signature_count, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  return FD_BINCODE_SUCCESS;
}
int fd_cost_tracker_decode_footprint( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  *total_sz += sizeof(fd_cost_tracker_t);
  void const * start_data = ctx->data;
  int err = fd_cost_tracker_decode_footprint_inner( ctx, total_sz );
  if( ctx->data>ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  ctx->data = start_data;
  return err;
}
int fd_cost_tracker_decode_footprint_inner( fd_bincode_decode_ctx_t * ctx, ulong * total_sz ) {
  if( ctx->data>=ctx->dataend ) { return FD_BINCODE_ERR_OVERFLOW; };
  int err = 0;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_account_costs_decode_footprint_inner( ctx, total_sz );
  if( FD_UNLIKELY( err ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  err = fd_bincode_uint64_decode_footprint( ctx );
  if( FD_UNLIKELY( err!=FD_BINCODE_SUCCESS ) ) return err;
  return 0;
}
void * fd_cost_tracker_decode( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cost_tracker_t * self = (fd_cost_tracker_t *)mem;
  fd_cost_tracker_new( self );
  void * alloc_region = (uchar *)mem + sizeof(fd_cost_tracker_t);
  void * * alloc_mem = &alloc_region;
  fd_cost_tracker_decode_inner( mem, alloc_mem, ctx );
  return self;
}
void fd_cost_tracker_decode_inner( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cost_tracker_t * self = (fd_cost_tracker_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->account_cost_limit, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_cost_limit, ctx );
  fd_bincode_uint64_decode_unsafe( &self->vote_cost_limit, ctx );
  fd_account_costs_decode_inner( &self->cost_by_writable_accounts, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->vote_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->allocated_accounts_data_size, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->secp256k1_instruction_signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ed25519_instruction_signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->secp256r1_instruction_signature_count, ctx );
}
void * fd_cost_tracker_decode_global( void * mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cost_tracker_global_t * self = (fd_cost_tracker_global_t *)mem;
  fd_cost_tracker_new( (fd_cost_tracker_t *)self );
  void * alloc_region = (uchar *)mem + sizeof(fd_cost_tracker_global_t);
  void * * alloc_mem = &alloc_region;
  fd_cost_tracker_decode_inner_global( mem, alloc_mem, ctx );
  return self;
}
void fd_cost_tracker_decode_inner_global( void * struct_mem, void * * alloc_mem, fd_bincode_decode_ctx_t * ctx ) {
  fd_cost_tracker_global_t * self = (fd_cost_tracker_global_t *)struct_mem;
  fd_bincode_uint64_decode_unsafe( &self->account_cost_limit, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_cost_limit, ctx );
  fd_bincode_uint64_decode_unsafe( &self->vote_cost_limit, ctx );
  fd_account_costs_decode_inner_global( &self->cost_by_writable_accounts, alloc_mem, ctx );
  fd_bincode_uint64_decode_unsafe( &self->block_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->vote_cost, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->allocated_accounts_data_size, ctx );
  fd_bincode_uint64_decode_unsafe( &self->transaction_signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->secp256k1_instruction_signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->ed25519_instruction_signature_count, ctx );
  fd_bincode_uint64_decode_unsafe( &self->secp256r1_instruction_signature_count, ctx );
}
int fd_cost_tracker_convert_global_to_local( void const * global_self, fd_cost_tracker_t * self, fd_bincode_decode_ctx_t * ctx ) {
  int err = 0;
  fd_cost_tracker_global_t const * mem = (fd_cost_tracker_global_t const *)global_self;
  self->account_cost_limit = mem->account_cost_limit;
  self->block_cost_limit = mem->block_cost_limit;
  self->vote_cost_limit = mem->vote_cost_limit;
  err = fd_account_costs_convert_global_to_local( &mem->cost_by_writable_accounts, &self->cost_by_writable_accounts, ctx );
  if( FD_UNLIKELY( err ) ) return err;
  self->block_cost = mem->block_cost;
  self->vote_cost = mem->vote_cost;
  self->transaction_count = mem->transaction_count;
  self->allocated_accounts_data_size = mem->allocated_accounts_data_size;
  self->transaction_signature_count = mem->transaction_signature_count;
  self->secp256k1_instruction_signature_count = mem->secp256k1_instruction_signature_count;
  self->ed25519_instruction_signature_count = mem->ed25519_instruction_signature_count;
  self->secp256r1_instruction_signature_count = mem->secp256r1_instruction_signature_count;
  return FD_BINCODE_SUCCESS;
}
void fd_cost_tracker_new(fd_cost_tracker_t * self) {
  fd_memset( self, 0, sizeof(fd_cost_tracker_t) );
  fd_account_costs_new( &self->cost_by_writable_accounts );
}
void fd_cost_tracker_destroy( fd_cost_tracker_t * self ) {
  fd_account_costs_destroy( &self->cost_by_writable_accounts );
}

ulong fd_cost_tracker_footprint( void ){ return FD_COST_TRACKER_FOOTPRINT; }
ulong fd_cost_tracker_align( void ){ return FD_COST_TRACKER_ALIGN; }

void fd_cost_tracker_walk( void * w, fd_cost_tracker_t const * self, fd_types_walk_fn_t fun, const char *name, uint level ) {
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP, "fd_cost_tracker", level++ );
  fun( w, &self->account_cost_limit, "account_cost_limit", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->block_cost_limit, "block_cost_limit", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->vote_cost_limit, "vote_cost_limit", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fd_account_costs_walk( w, &self->cost_by_writable_accounts, fun, "cost_by_writable_accounts", level );
  fun( w, &self->block_cost, "block_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->vote_cost, "vote_cost", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->transaction_count, "transaction_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->allocated_accounts_data_size, "allocated_accounts_data_size", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->transaction_signature_count, "transaction_signature_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->secp256k1_instruction_signature_count, "secp256k1_instruction_signature_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->ed25519_instruction_signature_count, "ed25519_instruction_signature_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, &self->secp256r1_instruction_signature_count, "secp256r1_instruction_signature_count", FD_FLAMENCO_TYPE_ULONG, "ulong", level );
  fun( w, self, name, FD_FLAMENCO_TYPE_MAP_END, "fd_cost_tracker", level-- );
}
ulong fd_cost_tracker_size( fd_cost_tracker_t const * self ) {
  ulong size = 0;
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += fd_account_costs_size( &self->cost_by_writable_accounts );
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  size += sizeof(ulong);
  return size;
}

#define REDBLK_T fd_hash_hash_age_pair_t_mapnode_t
#define REDBLK_NAME fd_hash_hash_age_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_hash_hash_age_pair_t_map_compare( fd_hash_hash_age_pair_t_mapnode_t * left, fd_hash_hash_age_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.key.uc, right->elem.key.uc, sizeof(right->elem.key) );
}
#define REDBLK_T fd_vote_accounts_pair_t_mapnode_t
#define REDBLK_NAME fd_vote_accounts_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_vote_accounts_pair_t_map_compare( fd_vote_accounts_pair_t_mapnode_t * left, fd_vote_accounts_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.key.uc, right->elem.key.uc, sizeof(right->elem.key) );
}
#define REDBLK_T fd_account_keys_pair_t_mapnode_t
#define REDBLK_NAME fd_account_keys_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_account_keys_pair_t_map_compare( fd_account_keys_pair_t_mapnode_t * left, fd_account_keys_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.key.uc, right->elem.key.uc, sizeof(right->elem.key) );
}
#define REDBLK_T fd_stake_weight_t_mapnode_t
#define REDBLK_NAME fd_stake_weight_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_stake_weight_t_map_compare( fd_stake_weight_t_mapnode_t * left, fd_stake_weight_t_mapnode_t * right ) {
  return memcmp( left->elem.key.uc, right->elem.key.uc, sizeof(right->elem.key) );
}
#define REDBLK_T fd_delegation_pair_t_mapnode_t
#define REDBLK_NAME fd_delegation_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_delegation_pair_t_map_compare( fd_delegation_pair_t_mapnode_t * left, fd_delegation_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.account.uc, right->elem.account.uc, sizeof(right->elem.account) );
}
#define REDBLK_T fd_stake_pair_t_mapnode_t
#define REDBLK_NAME fd_stake_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_stake_pair_t_map_compare( fd_stake_pair_t_mapnode_t * left, fd_stake_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.account.uc, right->elem.account.uc, sizeof(right->elem.account) );
}
#define REDBLK_T fd_clock_timestamp_vote_t_mapnode_t
#define REDBLK_NAME fd_clock_timestamp_vote_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_clock_timestamp_vote_t_map_compare( fd_clock_timestamp_vote_t_mapnode_t * left, fd_clock_timestamp_vote_t_mapnode_t * right ) {
  return memcmp( left->elem.pubkey.uc, right->elem.pubkey.uc, sizeof(right->elem.pubkey) );
}
#define REDBLK_T fd_pubkey_node_t_mapnode_t
#define REDBLK_NAME fd_pubkey_node_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_pubkey_node_t_map_compare( fd_pubkey_node_t_mapnode_t * left, fd_pubkey_node_t_mapnode_t * right ) {
  return memcmp( left->elem.pubkey.uc, right->elem.pubkey.uc, sizeof(right->elem.pubkey) );
}
#define REDBLK_T fd_rent_fresh_accounts_partition_t_mapnode_t
#define REDBLK_NAME fd_rent_fresh_accounts_partition_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_rent_fresh_accounts_partition_t_map_compare( fd_rent_fresh_accounts_partition_t_mapnode_t * left, fd_rent_fresh_accounts_partition_t_mapnode_t * right ) {
  return (long)( left->elem.partition - right->elem.partition );
}
#define REDBLK_T fd_vote_info_pair_t_mapnode_t
#define REDBLK_NAME fd_vote_info_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_vote_info_pair_t_map_compare( fd_vote_info_pair_t_mapnode_t * left, fd_vote_info_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.account.uc, right->elem.account.uc, sizeof(right->elem.account) );
}
#define REDBLK_T fd_account_costs_pair_t_mapnode_t
#define REDBLK_NAME fd_account_costs_pair_t_map
#define REDBLK_IMPL_STYLE 2
#include "../../util/tmpl/fd_redblack.c"
long fd_account_costs_pair_t_map_compare( fd_account_costs_pair_t_mapnode_t * left, fd_account_costs_pair_t_mapnode_t * right ) {
  return memcmp( left->elem.key.uc, right->elem.key.uc, sizeof(right->elem.key) );
}
